{
 "JTS AP1P_Close": {
  "prefix": "AP1P_Close",
  "body": [
   "AP1P_Close($$InstrumentHandle);"
  ],
  "description": "\n\nThe close function terminates the software connection to the instrument and de-allocates system resources. It is generally a good programming habit to close the instrument handle when the program is done using the instrument.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThe handle of the instrument returned from the AP1P_Init function\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\nAP1P_Close($handle);\n\n\n\n\n\nSupported Instruments\n\nAudio Precision AP1P\n\n\n\n\n\nAP1P_ConfigureAnalogAmpFreq\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AP1P_GetAnalogAmpFreq": {
  "prefix": "AP1P_GetAnalogAmpFreq",
  "body": [
   "$$genSetting=AP1P_GetAnalogAmpFreq($$AP1P_handle,$$genFunction);"
  ],
  "description": "\n\nReturns the current analog generator amplitude or frequency setting and units.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AP1P_handle\n\nObject\n\nHandle created by the AP1P_Init() function. Used in all subsequent driver calls.\n\n\n\n$genFunction\n\nString\n\nThe desired setting to return. [AMPLITUDE , FREQUENCY]\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$genSetting\n\nString\n\nThe current setting and units for the specified generator function.\n\n\n\n\n\nExamples:\n\n$genAmplitude = AP1P_GetAnalogAmpFreq($handle, \"AMPLITUDE\");\n\n\n\n\n\nSupported Instruments\n\nAudio Precision AP1P\n\n\n\n\n\nAP1P_ConfigureAnalogGenerator\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AP1P_ConfigureAnalogGenerator": {
  "prefix": "AP1P_ConfigureAnalogGenerator",
  "body": [
   "AP1P_ConfigureAnalogGenerator($$AP1P_handle,$$waveType,$$frequency,$$amplitude,$$amplitudeUnits,$$imdHighFreq,$$imdLowFreq);"
  ],
  "description": "\n\nConfigures the analog generator to the specified values and settings.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AP1P_handle\n\nObject\n\nHandle created by the AP1P_Init() function. Used in all subsequent driver calls.\n\n\n\n$waveType\n\nString\n\nSelects the analog generator waveform for output. Accepted string values are: [SINE, SQUARE, IMD]\n\n\n\n$frequency\n\nFloat\n\nThe frequency value to set the analog generator to specified in hertz.\n\n\n\n$amplitude\n\nFloat\n\nThe amplitude value to set the analog generator to, specified in the current units passed in the subsequent argument.\n\n\n\n$amplitudeUnits\n\nString\n\nThe amplitude units of the value sent in $amplitudeValue. Accepted string values are:\n\n[VPK, Vrms, DBV, DBU, DBM]\n\n\n\n$imdHighFreq\n\nInteger\n\nSelects the analog generator IMD high frequency tone for the IMD waveform. [7000, 8000]\n\n\n\n$imdLowFreq\n\nInteger\n\nSelects the analog generator IMD low frequency tone for the IMD waveform. [50, 60, 70, 250]\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n-\n\n-\n\n\n\n\n\nExamples:\n\nAP1P_ConfigureAnalogGenerator($handle, \"SQUARE\", 1000, 2.5, \"Vrms\", 7000, 60);\n\n\n\n\n\nSupported Instruments\n\nAudio Precision AP1P\n\n\n\n\n\nAP1P_ConfigureInput\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AP1P_ConfigureInput": {
  "prefix": "AP1P_ConfigureInput",
  "body": [
   "AP1P_ConfigureInput($$AP1P_handle,$$inputChannel);"
  ],
  "description": "\n\nSelects the Analog Analyzer input channel to be measured, depending on the the measurement function currently selected.\n\n\n\nNote: GAGB and GBGA are valid only when LEVEL, PHASE, or RATIO are selected with AP1P_ConfigureMeasurementFunction.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AP1P_handle\n\nObject\n\nHandle created by the AP1P_Init() function. Used in all subsequent driver calls.\n\n\n\n$inputChannel\n\nString\n\nAnalog Analyzer Input Channel. Accepted strings are: [A,B,GENA,GENB,GAGB,GBGA]\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n-\n\n-\n\n\n\n\n\nExamples:\n\nAP1P_ConfigureInput($handle, \"A\");\n\n\n\n\n\nSupported Instruments\n\nAudio Precision AP1P\n\n\n\n\n\nAP1P_ConfigureMeasurementFunction\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AP1P_ConfigureMeasurementFunction": {
  "prefix": "AP1P_ConfigureMeasurementFunction",
  "body": [
   "AP1P_ConfigureMeasurementFunction($$AP1P_handle,$$measurementFunction);"
  ],
  "description": "\n\nTurns on the specified audio analyzer measurement function for the instrument.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AP1P_handle\n\nObject\n\nHandle created by the AP1P_Init() function. Used in all subsequent driver calls.\n\n\n\n$measurementFunction\n\nString\n\nThe measurement function to set the audio analyzer. Accepted strings are:\n\n[AMPLITUDE, NOISE, THD, SINAD,IMD,WF,ACMAINS, LEVEL, PHASE, RATIO, XTALK, GENLOAD]\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n-\n\n-\n\n\n\n\n\nExamples:\n\nAP1P_ConfigureMeasurementFunction($handle, \"AMPLITUDE\");\n\n\n\n\n\nSupported Instruments\n\nAudio Precision AP1P\n\n\n\n\n\nAP1P_ConfigureNoiseMeasurement\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AP1P_ConfigureNoiseMeasurement": {
  "prefix": "AP1P_ConfigureNoiseMeasurement",
  "body": [
   "AP1P_ConfigureNoiseMeasurement($$AP1P_handle,$$maxAmplitude,$$minAmplitude,$$bpFilter,$$extSweep,$$noiseFilter,$$maxFrequency,$$minFrequency,$$hpFilter,$$lpFilter,$$noiseUnit,$$weightingFilter);"
  ],
  "description": "\n\nConfigures the Noise function of the analog generator to the specified values and settings.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AP1P_handle\n\nObject\n\nHandle created by the AP1P_Init() function. Used in all subsequent driver calls.\n\n\n\n$maxAmplitude\n\nFloat\n\nSets the maximum amplitude level for an amplitude sweep of the analog generator.\n\n\n\n$minAmplitude\n\nFloat\n\nSets the minimum amplitude level for an amplitude sweep of the analog generator.\n\n\n\n$bpFilter\n\nFloat\n\nSelects the center frequency for the tunable bandpass filter.\n\n\n\n$extSweep\n\nString\n\nSelectes the GLIDE or STEP settling in external sweep mode.\n\n\n\n$noiseFilter\n\nString\n\nSelects the filter for the noise function. [SELECTIVE, WTD, UNWTD]\n\n\n\n$maxFrequency\n\nFloat\n\nSelects the upper frequency display range for the sweep and bargraph displays.\n\n\n\n$minFrequency\n\nFloat\n\nSelects the lower frequency display range for the sweep and bargraph displays.\n\n\n\n$hpFilter\n\nString\n\nEnables and disables the high pass filter. [ON, OFF]\n\n\n\n$lpFilter\n\nString\n\nSelects the band pass filter when the unweighted filter is selected. [R22K, Q22K, R30K, R80K, R300K]\n\n\n\n$noiseUnit\n\nString\n\nSelects the measurement units for the noise function. [V, DBV, DBU, DBM, DBG, W, DB]\n\n\n\n$weightingFilter\n\nString\n\nSelects the weighting filter for the noise function when the WTD filter is selected. [AUX1, AUX2, IECA, RMSCCIR, CCIR2K, QPKCCIR, ARMCCIR]\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n-\n\n-\n\n\n\n\n\nExamples:\n\nAP1P_ConfigureNoiseMeasurement($handle,\n\n2.5,0,1000,\"STEP\",\"WTD\",20000,20,\"ON\",\"R22K\",\"V\",\"AUX1\" );\n\n\n\n\n\nSupported Instruments\n\nAudio Precision AP1P\n\n\n\n\n\nAP1P_ConfigureNoiseSweep\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AP1P_ConfigureNoiseSweep": {
  "prefix": "AP1P_ConfigureNoiseSweep",
  "body": [
   "AP1P_ConfigureNoiseSweep($$AP1P_handle,$$sweepSpeed,$$steps,$$sweepType);"
  ],
  "description": "\n\n\n\n\n\nConfigures the sweep settings for the noise function of the audio analyzer.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AP1P_handle\n\nObject\n\nHandle created by the AP1P_Init() function. Used in all subsequent driver calls.\n\n\n\n$sweepSpeed\n\nString\n\nSelects the sweep speed. [FAST, MEDIUM, SLOW]\n\n\n\n$steps\n\nInteger\n\nSelects the number of sweep steps. [-1, 0, 3, 5, 10, 5, 30, 75, 150]\n\n\n\n$sweepType\n\nString\n\nSpecifies either a frequency sweep or an amplitude sweep is to be performed when the sweep begins. [FREQ, AMPL]\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n-\n\n-\n\n\n\n\n\nExamples:\n\nAP1P_ConfigureNoiseSweep($handle, \"MEDIUM\", 5, \"AMPL\");\n\n\n\n\n\nSupported Instruments\n\nAudio Precision AP1P\n\n\n\n\n\nAP1P_ConfigureOutput\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AP1P_ConfigureOutput": {
  "prefix": "AP1P_ConfigureOutput",
  "body": [
   "AP1P_ConfigureOutput($$AP1P_handle,$$outputChannel);"
  ],
  "description": "\n\nSelects the analog generator output channel. Selecting channel A connects the generator to the channel A output and does not effect the status of the B output. Selecting OFF turns both A and B off. Selecting ON turns both A and B on.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AP1P_handle\n\nObject\n\nHandle created by the AP1P_Init() function. Used in all subsequent driver calls.\n\n\n\n$outputChannel\n\nString\n\nAnalog Generator Output Channel. Accepted strings are: [A, B, ON, OFF]\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n-\n\n-\n\n\n\n\n\nExamples:\n\nAP1P_ConfigureOutput($handle, \"A\");\n\n\n\n\n\nSupported Instruments\n\nAudio Precision AP1P\n\n\n\n\n\nAP1P_ConfigureOutputImpedance\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AP1P_ConfigureOutputImpedance": {
  "prefix": "AP1P_ConfigureOutputImpedance",
  "body": [
   "AP1P_ConfigureOutputImpedance($$AP1P_handle,$$outputImpedance);"
  ],
  "description": "\n\n\n\n\n\nSelects the analog generator output impedance in ohms and configuration.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AP1P_handle\n\nObject\n\nHandle created by the AP1P_Init() function. Used in all subsequent driver calls.\n\n\n\n$outputImpedance\n\nString\n\nOutput Impedance and Configuration. Accepted strings are: [U40, U50, B40, B50, B150, B600]\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n-\n\n-\n\n\n\n\n\nExamples:\n\nAP1P_ConfigureOutputImpedance($handle, \"B600\");\n\n\n\n\n\nSupported Instruments\n\nAudio Precision AP1P\n\n\n\n\n\nAP1P_ConfigurePhaseMeasurement\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AP1P_ConfigurePhaseMeasurement": {
  "prefix": "AP1P_ConfigurePhaseMeasurement",
  "body": [
   "AP1P_ConfigurePhaseMeasurement($$AP1P_handle,$$maxAmplitude,$$minAmplitude,$$average,$$external,$$maxFrequency,$$minFrequency,$$levelMeterUnits,$$displayRange);"
  ],
  "description": "\n\nConfigures the Phase function of the analog generator to the specified values and settings.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AP1P_handle\n\nObject\n\nHandle created by the AP1P_Init() function. Used in all subsequent driver calls.\n\n\n\n$maxAmplitude\n\nFloat\n\nSets the maximum amplitude level for an amplitude sweep of the analog generator.\n\n\n\n$minAmplitude\n\nFloat\n\nSets the minimum amplitude level for an amplitude sweep of the analog generator.\n\n\n\n$average\n\nString\n\nSelects the average function for the phase meter. [AVERAGE, NOAVERAGE]\n\n\n\n$external\n\nString\n\nSelectes the GLIDE or STEP settling in external sweep mode.\n\n\n\n$maxFrequency\n\nFloat\n\nSelects the upper frequency display range for the sweep and bargraph displays.\n\n\n\n$minFrequency\n\nFloat\n\nSelects the lower frequency display range for the sweep and bargraph displays.\n\n\n\n$levelMeterUnits\n\nString\n\nSelects the level meter units. OFF turns the level measurement display off. [V, DBV, DBU, DBM, DBR, DBG, W, OFF]\n\n\n\n$displayRange\n\nString\n\nSelects the phase meter display range. [DEG90, DEG180, DEG270]\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n-\n\n-\n\n\n\n\n\nExamples:\n\nAP1P_ConfigurePhaseMeasurement($handle,2.5,0,\"AVERAGE\",\"STEP\",20000,20,\"V\",\"DEG90\");\n\n\n\n\n\nSupported Instruments\n\nAudio Precision AP1P\n\n\n\n\n\nAP1P_ConfigurePhaseSweep\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AP1P_ConfigurePhaseSweep": {
  "prefix": "AP1P_ConfigurePhaseSweep",
  "body": [
   "AP1P_ConfigurePhaseSweep($$AP1P_handle,$$sweepSpeed,$$steps,$$sweepType);"
  ],
  "description": "\n\n\n\n\n\nConfigures the sweep settings for the phase measurement function of the audio analyzer.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AP1P_handle\n\nObject\n\nHandle created by the AP1P_Init() function. Used in all subsequent driver calls.\n\n\n\n$sweepSpeed\n\nString\n\nSelects the sweep speed. [FAST, MEDIUM, SLOW]\n\n\n\n$steps\n\nInteger\n\nSelects the number of sweep steps. [-1, 0, 3, 5, 10, 5, 30, 75, 150]\n\n\n\n$sweepType\n\nString\n\nSpecifies either a frequency sweep or an amplitude sweep is to be performed when the sweep begins. [FREQ, AMPL]\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n-\n\n-\n\n\n\n\n\nExamples:\n\nAP1P_ConfigurePhaseSweep($handle, \"MEDIUM\", 5, \"AMPL\");\n\n\n\n\n\nSupported Instruments\n\nAudio Precision AP1P\n\n\n\n\n\nAP1P_ConfigureTHDMeasurement\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AP1P_ConfigureTHDMeasurement": {
  "prefix": "AP1P_ConfigureTHDMeasurement",
  "body": [
   "AP1P_ConfigureTHDMeasurement($$AP1P_handle,$$maxAmplitude,$$minAmplitude,$$extSweep,$$filter,$$maxFrequency,$$minFrequency,$$hpFilter,$$bpFilter,$$levelUnit,$$weightingFilter,$$notchFrequency,$$notchTune);"
  ],
  "description": "\n\nConfigures the THD function of the analog generator to the specified values and settings.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AP1P_handle\n\nObject\n\nHandle created by the AP1P_Init() function. Used in all subsequent driver calls.\n\n\n\n$maxAmplitude\n\nFloat\n\nSets the maximum amplitude level for an amplitude sweep of the analog generator.\n\n\n\n$minAmplitude\n\nFloat\n\nSets the minimum amplitude level for an amplitude sweep of the analog generator.\n\n\n\n$extSweep\n\nString\n\nSelects the GLIDE or STEP settling in external sweep mode.\n\n\n\n$filter\n\nString\n\nSelects the filter for the noise function. [WTD, UNWTD, AVERAGE]\n\n\n\n$maxFrequency\n\nFloat\n\nSelects the upper frequency display range for the sweep and bargraph displays.\n\n\n\n$minFrequency\n\nFloat\n\nSelects the lower frequency display range for the sweep and bargraph displays.\n\n\n\n$hpFilter\n\nString\n\nEnables and disables the high pass filter. [ON, OFF]\n\n\n\n$bpFilter\n\nString\n\nSelects the band pass filter when the UNWTD filter is selected. [R22K, Q22K, R30K, R80K, R300K]\n\n\n\n$levelUnit\n\nString\n\nSelects the measurement units for the level measurement in the THD function. [PCT,V, DBV, DBU, DBM, DBG, W, DB]\n\n\n\n$weightingFilter\n\nString\n\nSelects the weighting filter for the THD+N function when the WTD filter is selected. [AUX1, AUX2, IECA, RMSCCIR, CCIR2K, QPKCCIR, ARMCCIR]\n\n\n\n$notchFrequency\n\nFloat\n\nSelects the center frequency for the tunable notch filter when $notchTune is set to FIXTUNE.\n\n\n\n$notchTune\n\nString\n\nSelects the notch filter tuning mode for the THD function. [AUTO, GENTRACK, FIXTUNE]\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n-\n\n-\n\n\n\n\n\nExamples:\n\nAP1P_ConfigureTHDMeasurement($handle,\n\n2.5,0,\"STEP\",\"WTD\",20000,20,\"ON\",\"R22K\",\"V\",\"AUX1\",1000,\"AUTO\" );\n\n\n\n\n\nSupported Instruments\n\nAudio Precision AP1P\n\n\n\n\n\nAP1P_ConfigureTHDSweep\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AP1P_ConfigureTHDSweep": {
  "prefix": "AP1P_ConfigureTHDSweep",
  "body": [
   "AP1P_ConfigureTHDSweep($$AP1P_handle,$$sweepSpeed,$$steps,$$sweepType);"
  ],
  "description": "\n\n\n\n\n\nConfigures the sweep settings for the THD measurement function of the audio analyzer.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AP1P_handle\n\nObject\n\nHandle created by the AP1P_Init() function. Used in all subsequent driver calls.\n\n\n\n$sweepSpeed\n\nString\n\nSelects the sweep speed. [FAST, MEDIUM, SLOW]\n\n\n\n$steps\n\nInteger\n\nSelects the number of sweep steps. [-1, 0, 3, 5, 10, 5, 30, 75, 150]\n\n\n\n$sweepType\n\nString\n\nSpecifies either a frequency sweep or an amplitude sweep is to be performed when the sweep begins. [FREQ, AMPL]\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n-\n\n-\n\n\n\n\n\nExamples:\n\nAP1P_ConfigureTHDSweep($handle, \"MEDIUM\", 5, \"AMPL\");\n\n\n\n\n\nSupported Instruments\n\nAudio Precision AP1P\n\n\n\n\n\nAP1P_ConfigureWowAndFlutterMeasurement\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AP1P_ConfigureWowAndFlutterMeasurement": {
  "prefix": "AP1P_ConfigureWowAndFlutterMeasurement",
  "body": [
   "AP1P_ConfigureWowAndFlutterMeasurement($$AP1P_handle,$$wfDetector,$$wfFilter,$$wfLUnit,$$wfMMax,$$wfMMin,$$wfResponse,$$wfFUnit,);"
  ],
  "description": "\n\nConfigures the Wow and Flutter function of the analog generator to the specified values and settings.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AP1P_handle\n\nObject\n\nHandle created by the AP1P_Init() function. Used in all subsequent driver calls.\n\n\n\n$wfDetector\n\nString\n\nSelects the Wow and Flutter Detector. [IEC, NAB, JIS]\n\n\n\n$wfFilter\n\nString\n\nSelects the Wow and Flutter weighted or unweighted filters. [WTD, UNWTD]\n\n\n\n$wfLUnit\n\nString\n\nSelects the measurement units for the level measurement in the Wow and Flutter function. [V, DBV, DBU, DBM, DBR, DBG, W, OFF]\n\n\n\n$wfMMax\n\nFloat\n\nSelects the upper magnitude display range for the bar graph display.\n\n\n\n$wfMMin\n\nFloat\n\nSelects the lower magnitude display range for the bar graph display.\n\n\n\n$wfResponse\n\nString\n\nSelects the measurement response mode for the Wow and Flutter measurements. [PEAK, SIG2]\n\n\n\n$wfFUnit\n\nString\n\nSelects the Wow and Flutter function frequency meter units and reference frequency for frequency deviation measurements. [HZ, DPCT3000, DPCT3150, OFF]\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n-\n\n-\n\n\n\n\n\nExamples:\n\nAP1P_ConfigureWowAndFlutterMeasurement($handle,\"IEC\",\"WTD\",\"V\",2.5,1.5,\"PEAK\",\"HZ\");\n\n\n\n\n\nSupported Instruments\n\nAudio Precision AP1P\n\n\n\n\n\nAP1P_GetMeasurementData\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AP1P_GetMeasurementData": {
  "prefix": "AP1P_GetMeasurementData",
  "body": [
   "($$measurement,$$Units)=AP1P_GetMeasurementData($$AP1P_handle,$$measurementGauge);"
  ],
  "description": "\n\nReturns the next available measurement from specified measurement meter. This meter is dependant on the currently selected analog function.\n\n\n\n\n\nNote: The accepted measurement gauge and correpsonding reading are as follows:\n\n\n\n\n\n\"1\" : Left displayed measurement on the front panel\n\n\"2\" : Center displayed measurement on the front panel\n\n\"3\" : Right displayed measurement on the front panel\n\n\"F\" : The measurement from the analog frequency meter\n\n\"P\" : The measurement from the analog phase meter\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AP1P_handle\n\nObject\n\nHandle created by the AP1P_Init() function. Used in all subsequent driver calls.\n\n\n\n$measurementGauge\n\nString\n\nDesired measurement meter to get the measurement from. Accepted string values above.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$measurement\n\nFloat\n\nThe returned measurement value\n\n\n\n$measurementUnits\n\nString\n\nThe returned measurement units\n\n\n\n\n\nExamples:\n\n($measurement, $Units) = AP1P_GetMeasurementData($handle, \"1\");\n\n\n\n\n\nSupported Instruments\n\nAudio Precision AP1P\n\n\n\n\n\nAP1P_Init\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AP1P_Init": {
  "prefix": "AP1P_Init",
  "body": [
   "$$handle=AP1P_Init($$ResourceName);"
  ],
  "description": "\n\nThis function initializes a session with the instrument and returns the handle to the test script.\n\nNote: This function requires NI-VISA to be installed.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ResourceName\n\nString\n\nThe resource name of the instrument.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$handle\n\nObject\n\nThe handle to the instrument session.\n\n\n\n\n\nExamples:\n\n$handle = AP1P_Init(\"GPIB0::7::Instr\");\n\n\n\n\n\nSupported Instruments\n\nAudio Precision AP1P\n\n\n\n\n\nAP1P_Query\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AP1P_Query": {
  "prefix": "AP1P_Query",
  "body": [
   "$$ReturnString=AP1P_Query($$handle,$$QueryCommand);"
  ],
  "description": "\n\nThis function will send query messages directly to the instrument.\n\nNote: All query messages must end with a \"?\".\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$handle\n\nObject\n\nThe handle of the instrument session that was returned by the AP1P_Init function.\n\n\n\n$QueryCommand\n\nString\n\nThe query to be sent to the instrument.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ReturnString\n\nString\n\nThe data return from the instrument\n\n\n\n\n\nExamples:\n\n$handle = AP1P_Query($handle,\"M1?\");\n\n\n\n\n\nSupported Instruments\n\nAudio Precision AP1P\n\n\n\n\n\nAP1P_Reset\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AP1P_Reset": {
  "prefix": "AP1P_Reset",
  "body": [
   "AP1P_Reset($$AP1P_handle);"
  ],
  "description": "\n\nResets the instrument to the factory default settings.\n\n\n\nNote: This function requires NI-VISA to be installed.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AP1P_handle\n\nObject\n\nHandle created by the AP1P_Init() function. Used in all subsequent driver calls.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n-\n\n-\n\n\n\n\n\nExamples:\n\nAP1P_Reset($handle);\n\n\n\n\n\nSupported Instruments\n\nAudio Precision AP1P\n\n\n\n\n\nAP1P_SetAnalogAmplitude\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AP1P_SetAnalogAmplitude": {
  "prefix": "AP1P_SetAnalogAmplitude",
  "body": [
   "AP1P_SetAnalogAmplitude($$AP1P_handle,$$amplitudeValue,$$amplitudeUnits);"
  ],
  "description": "\n\nSets the analog generator output amplitude in the specified units.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AP1P_handle\n\nObject\n\nHandle created by the AP1P_Init() function. Used in all subsequent driver calls.\n\n\n\n$amplitudeValue\n\nFloat\n\nThe amplitude level to set the analog generator to.\n\n\n\n$amplitudeUnits\n\nString\n\nThe amplitude units of the value sent in $amplitudeValue. Accepted string values are:\n\n[VPK, Vrms, DBV, DBU, DBM]\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n-\n\n-\n\n\n\n\n\nExamples:\n\nAP1P_SetAnalogAmplitude($handle,2.5, \"Vrms\");\n\n\n\n\n\nSupported Instruments\n\nAudio Precision AP1P\n\n\n\n\n\nAP1P_SetAnalogFrequency\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AP1P_SetAnalogFrequency": {
  "prefix": "AP1P_SetAnalogFrequency",
  "body": [
   "AP1P_SetAnalogFrequency($$AP1P_handle,$$frequencyValue);"
  ],
  "description": "\n\nSets the analog generator frequency to the specified value. Default units are Hz.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AP1P_handle\n\nObject\n\nHandle created by the AP1P_Init() function. Used in all subsequent driver calls.\n\n\n\n$frequecyValue\n\nFloat\n\nThe frequency value to set the analog generator to.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n-\n\n-\n\n\n\n\n\nExamples:\n\nAP1P_SetAnalogFrequency($handle,1000);\n\n\n\n\n\nSupported Instruments\n\nAudio Precision AP1P\n\n\n\n\n\nAP1P_Write\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AP1P_Write": {
  "prefix": "AP1P_Write",
  "body": [
   "AP1P_Write($$handle,$$Command);"
  ],
  "description": "\n\n\n\n\n\nThe Write function will send the passed command directly to the instrument. This will allow the test engineer to communicate with the instrument through GPIB commands that may not be available in one of the functions.\n\n\n\n\n\nNote: This function provides no error checking on the passed arguments. The arguments will be sent directly to the instrument.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$handle\n\nObject\n\nThe handle of the instrument returned from the AP1P_Init function\n\n\n\n$Command\n\nstring\n\nThe GPIB command to be sent to the instrument.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\nAP1P_Close($handle, $command);\n\n\n\n\n\nSupported Instruments\n\nAudio Precision AP1P\n\n\n\n\n\nAPX525_Close\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS APX525_Close": {
  "prefix": "APX525_Close",
  "body": [
   "APX525_Close($$InstrumentHandle);"
  ],
  "description": "\n\nThe close function terminates the software connection to the instrument and de-allocates system resources. It is generally a good programming habit to close the instrument handle when the program is done using the instrument.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThe handle of the instrument returned from the APX525_Init function\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\nAPX525_Close($handle);\n\n\n\n\n\nSupported Instruments\n\nAudio Precision APX525\n\n\n\n\n\nAPX525_GetMeasurement_Frequency\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS APX525_GetMeasurement_Frequency": {
  "prefix": "APX525_GetMeasurement_Frequency",
  "body": [
   "($$Ch1_Level,$$Ch2_Level)=APX525_GetMeasurement_Frequency($$InstrumentHandle,$$SignalPathName,$$MeasurementName,$$NoOfChannels);"
  ],
  "description": "\n\nThe GetMeasurement_Frequency function loads the test configuration file for an RMS Level measurement and returns the Ch1 and Ch2 frequency readings .\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThe handle of the instrument returned from the APX525_Init function\n\n\n\n$SignalPathName\n\nString\n\nThe Name of the Signal Path in the config file loaded using the APX525_LoadProjectFile function.\n\n\n\n$MeasurementName\n\nString\n\nThe Name of the Measurement to perform as specified in the config file loaded using the APX525_LoadProjectFile function.\n\n\n\n$NoOfChannels\n\nInteger\n\nThe number of channels to test. It may be 1 or 2. If 1 is specified then the data returned for CH2 is \"NA.\"\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Ch1_Level\n\nString\n\nReturns the level value.\n\n\n\n$Ch2_Level\n\nString\n\nReturns the level value if there are 2 channels being used. Returns \"NA\" if only 1 channel is specified for measurement.\n\n\n\n\n\nExamples:\n\n($Ch1_Level,$Ch2_Level) = APX525_GetMeasurement_Frequency($InstrumentHandle,$SignalPathName,$MeasurementName,$NoOfChannels);\n\n\n\n\n\nSupported Instruments\n\nAudio Precision APX525\n\n\n\n\n\nAPX525_GetMeasurement_RMSLevel\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS APX525_GetMeasurement_RMSLevel": {
  "prefix": "APX525_GetMeasurement_RMSLevel",
  "body": [
   "($$Ch1_Level,$$Ch2_Level)=APX525_GetMeasurement_RMSLevel($$InstrumentHandle,$$SignalPathName,$$MeasurementName,$$NoOfChannels);"
  ],
  "description": "\n\nThe GetMeasurement_RMSevel function loads the test configuration file for an RMS Level measurement and returns the Ch1 and Ch2 level readings .\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThe handle of the instrument returned from the APX525_Init function\n\n\n\n$SignalPathName\n\nString\n\nThe Name of the Signal Path in the config file loaded using the APX525_LoadProjectFile function.\n\n\n\n$MeasurementName\n\nString\n\nThe Name of the Measurement to perform as specified in the config file loaded using the APX525_LoadProjectFile function.\n\n\n\n$NoOfChannels\n\nInteger\n\nThe number of channels to test. It may be 1 or 2. If 1 is specified then the data returned for CH2 is \"NA.\"\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Ch1_Level\n\nString\n\nReturns the level value.\n\n\n\n$Ch2_Level\n\nString\n\nReturns the level value if there are 2 channels being used. Returns \"NA\" if only 1 channel is specified for measurement.\n\n\n\n\n\nExamples:\n\n($Ch1_Level,$Ch2_Level) = APX525_GetMeasurement_RMSLevel($InstrumentHandle,$SignalPathName,$MeasurementName,$NoOfChannels);\n\n\n\n\n\nSupported Instruments\n\nAudio Precision APX525\n\n\n\n\n\nAPX525_GetMeasurement_THD_Plus_N_Level\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS APX525_GetMeasurement_THD_Plus_N_Level": {
  "prefix": "APX525_GetMeasurement_THD_Plus_N_Level",
  "body": [
   "($$Ch1_Level,$$Ch2_Level)=APX525_GetMeasurement_THD_Plus_N_Level($$InstrumentHandle,$$SignalPathName,$$MeasurementName,$$NoOfChannels);"
  ],
  "description": "\n\nThe close function loads the test configuration file for a THD plus noise level measurement and\n\nreturns the Ch1 and Ch2 level readings .\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThe handle of the instrument returned from the APX525_Init function\n\n\n\n$SignalPathName\n\nString\n\nThe Name of the Signal Path in the config file loaded using the APX525_LoadProjectFile function.\n\n\n\n$MeasurementName\n\nString\n\nThe Name of the Measurement to perform as specified in the config file loaded using the APX525_LoadProjectFile function.\n\n\n\n$NoOfChannels\n\nInteger\n\nThe number of channels to test. It may be 1 or 2. If 1 is specified then the data returned for CH2 is \"NA.\"\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Ch1_Level\n\nString\n\nReturns the level value.\n\n\n\n$Ch2_Level\n\nString\n\nReturns the level value if there are 2 channels being used. Returns \"NA\" if only 1 channel is specified for measurement.\n\n\n\n\n\nExamples:\n\n($Ch1_Level,$Ch2_Level) = APX525_GetMeasurement_THD_Plus_N_Level($InstrumentHandle,$SignalPathName,$MeasurementName,$NoOfChannels);\n\n\n\n\n\nSupported Instruments\n\nAudio Precision APX525\n\n\n\n\n\nAPX525_Init\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS APX525_Init": {
  "prefix": "APX525_Init",
  "body": [
   "$$handle=APX525_Init();"
  ],
  "description": "\n\nThis function initializes a session with APX500 software and returns the handle to the test script.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\nNA\n\nNA\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$handle\n\nObject\n\nThe handle to the APX525 instrument session.\n\n\n\n\n\nExamples:\n\n$handle = APX525_Init();\n\n\n\n\n\nSupported Instruments\n\nAudio Precision APX525\n\n\n\n\n\nAPX525_LoadProjectFile\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS APX525_LoadProjectFile": {
  "prefix": "APX525_LoadProjectFile",
  "body": [
   "APX525_LoadProjectFile($$InstrumentHandle,$$ProjectFileNameAndPath);"
  ],
  "description": "\n\nThis function initializes a session with APX500 software and returns the handle to the test script.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThe handle to the APX525 instrument session.\n\n\n\n$ProjectFileNameAndPath\n\nString\n\nPath and filename to the cofig file to be used by the APX500 software.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\nNA\n\nNA\n\n\n\n\n\nExamples:\n\nAPX525_LoadProjectFile($InstrumentHandle,$ProjectFileNameAndPath);\n\n\n\n\n\nSupported Instruments\n\nAudio Precision APX525\n\n\n\n\n\nSNAPI_ScanBarcode\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SNAPI_ScanBarcode": {
  "prefix": "SNAPI_ScanBarcode",
  "body": [
   "$$Barcode=SNAPI_ScanBarcode($$Device,$$Timeout,$$MaxLength);"
  ],
  "description": "\n\nThis function requires the installation of the Motorola SNAPI driver on the system.\n\nThis function scans a barcode of given length within the given time limit.\n\n\n\n\n\nResult:\n\n$Barcode = SNAPI_ScanBarcode($Device,$Timeout,$MaxLength);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Device\n\ninteger\n\nThe device number of the scanner. (usually 0)\n\n\n\n$Timeout\n\ninteger\n\nThe timeout value in seconds. (1-10)\n\n\n\n$MaxLength\n\ninteger\n\nThe maximum length of the barcode to be scanned.\n\nResults will be clipped to this value when they are too long.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Barcode\n\nString\n\nThe scanned barcode. (empty if no barcode was found)\n\n\n\n\n\nExample:\n\n$Barcode = SNAPI_ScanBarcode(0,2,16);\n\n\n\n\n\nExtended Example:\n\n// Parameters\n\n$DeviceNr = 0; // Device number\n\n$ScanTimeout = 2; // Timeout in seconds\n\n$MaxBarcodeLength = 16; // Maximum length\n\n\n\n\n\n// Open serial device to PRN\n\n$Barcode = SNAPI_ScanBarcode($DeviceNr,$ScanTimeout,$MaxBarcodeLength);\n\nUpdateStatus($Barcode);\n\n$Len = StringLength($Barcode);\n\nUpdateStatus($Len);\n\nEnd;\n\n\n\n\n\nCableEye_Destroy\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS CableEye_Destroy": {
  "prefix": "CableEye_Destroy",
  "body": [
   "CableEye_Destroy($$CableEyeHandle);"
  ],
  "description": "\n\nCloses session, releasing all hardware and software resources.\n\n\n\n\n\nNote: Using these functions requires registering the CableEye API using the 'CableEyeAPI.license' file in the Jabil Test directory. Start the main CableEye program by dragging the license file on top of the CableEye shortcut icon. You should get a pop-up confirming that the license was installed.\n\n\n\n\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$CableEyeHandle\n\nObject\n\nHandle to CableEye fixture and databases returned by the CableEye_Init() function.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n--\n\n\n\n\n\nExample:\n\nCableEye_Destroy($CableEyeHandle);\n\n\n\n\n\nCableEye_Init\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS CableEye_Init": {
  "prefix": "CableEye_Init",
  "body": [
   "$$CableEyeHandle=CableEye_Init($$baseDirectory);"
  ],
  "description": "\n\nOpens a session and returns a handle to the CableEye tester hardware.\n\n\n\n\n\nNote: Using these functions requires registering the CableEye API using the 'CableEyeAPI.license' file in the Jabil Test directory. Start the main CableEye program by dragging the license file on top of the CableEye shortcut icon. You should get a pop-up confirming that the license was installed.\n\n\n\n\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$baseDirectory\n\nString\n\nDirectory containing the CableEye.ini file. Use a blank directory (\"\") if the CableEye software was installed to the default directory.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$CableEyeHandle\n\nObject\n\nHandle to CableEye fixture and databases.\n\n\n\n\n\nExample:\n\n$baseDirectory = \"C:\\\\Documents and Settings\\\\All Users\\\\Application Data\\\\CAMI\\\\CableEyeV5\";\n\n$CableEyeHandle = CableEye_Init($baseDirectory );\n\n\n\n\n\nCableEye_Learn\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS CableEye_Learn": {
  "prefix": "CableEye_Learn",
  "body": [
   "CableEye_Learn($$CableEyeHandle);"
  ],
  "description": "\n\nLoads the match data with the current fixture configuration, using the currently set fixture mapping.\n\n\n\n\n\nNote: Using these functions requires registering the CableEye API using the 'CableEyeAPI.license' file in the Jabil Test directory. Start the main CableEye program by dragging the license file on top of the CableEye shortcut icon. You should get a pop-up confirming that the license was installed.\n\n\n\n\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$CableEyeHandle\n\nObject\n\nHandle to CableEye fixture and databases returned by the CableEye_Init() function.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n--\n\n\n\n\n\nExample:\n\nCableEye_Learn($CableEyeHandle);\n\n\n\n\n\nCableEye_LoadMap\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS CableEye_LoadMap": {
  "prefix": "CableEye_LoadMap",
  "body": [
   "CableEye_LoadMap($$CableEyeHandle,$$customMapFile);"
  ],
  "description": "\n\nLoads the match data's fixture mapping. A custom mapping can be loaded from the database, or the built-in default or consecutive header numbering schemes. This mapping is ignored if the match file has a default fixture mapping associated with it and overrideDefaultMap is set to false in the CableEye_LoadMatch() function.\n\n\n\n\n\nNote: Using these functions requires registering the CableEye API using the 'CableEyeAPI.license' file in the Jabil Test directory. Start the main CableEye program by dragging the license file on top of the CableEye shortcut icon. You should get a pop-up confirming that the license was installed.\n\n\n\n\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$CableEyeHandle\n\nObject\n\nHandle to CableEye fixture and databases returned by the CableEye_Init() function.\n\n\n\n$customMapFile\n\nString\n\nCustom fixture mapping filename. If no custom mapping exists for the selected cable type (match data), there are two other mapping modes that can be used:\n\n\n\n\n\n\u00b7 \"DEFAULT\" for CB Board layouts. Warning: because multiple CB connector pins map to the same data point, this mode can cause ambiguous mapping errors when running the test!\n\n\u00b7 \"HEADERS\" for generic connector headers with consecutive numbering\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n--\n\n\n\n\n\nExample:\n\n$mappingFile = \"Test Map\";\n\nCableEye_LoadMap($CableEyeHandle, $mappingFile);\n\n\n\n\n\nCableEye_LoadMatch\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS CableEye_LoadMatch": {
  "prefix": "CableEye_LoadMatch",
  "body": [
   "CableEye_LoadMatch($$CableEyeHandle,$$matchDataFile,$$overrideDefaultMap);"
  ],
  "description": "\n\nLoads the match data file. If overrideDefaultMap is true, a custom fixture mapping file can be specified using the CableEye_LoadMap() function. If the match data does not have a custom fixture mapping associated with it, you must call the CableEye_LoadMap() function with the \"HEADERS\" or \"DEFAULT\" option.\n\n\n\n\n\nNote: Using these functions requires registering the CableEye API using the 'CableEyeAPI.license' file in the Jabil Test directory. Start the main CableEye program by dragging the license file on top of the CableEye shortcut icon. You should get a pop-up confirming that the license was installed.\n\n\n\n\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$CableEyeHandle\n\nObject\n\nHandle to CableEye fixture and databases returned by the CableEye_Init() function.\n\n\n\n$matchDataFile\n\nString\n\nName of the match data filename.\n\n\n\n$overrideDefaultMap\n\nBoolean\n\nControls whether the match file's default fixture mapping should be replaced (with a custom map or generic connector headers).\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n--\n\n\n\n\n\nExample:\n\n$matchFile = \"Test Cable 4\";\n\nCableEye_LoadMatch($CableEyeHandle, $matchFile, true);\n\n\n\n\n\nCableEye_Run\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS CableEye_Run": {
  "prefix": "CableEye_Run",
  "body": [
   "($$testPass,$$failureList)=CableEye_Run($$CableEyeHandle);"
  ],
  "description": "\n\nRuns the test, comparing the current setup to the match data. If any failures are found, they are returned as a list of non-conforming connections.\n\n\n\n\n\nNote: Using these functions requires registering the CableEye API using the 'CableEyeAPI.license' file in the Jabil Test directory. Start the main CableEye program by dragging the license file on top of the CableEye shortcut icon. You should get a pop-up confirming that the license was installed.\n\n\n\n\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$CableEyeHandle\n\nObject\n\nHandle to CableEye fixture and databases returned by the CableEye_Init() function.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$testPass\n\nBoolean\n\nTrue if the Test data and Match data are a match (all wiring the same, all values within tolerance).\n\n\n\n$failureList\n\nString\n\nA list of nonconforming connections, in the format:\n\n<FROM> - <TO> = <FAULT> (<TYPE>[ - <VALUE>])\n\n\n\n\n\nExample:\n\n($testPass, $failureList) = CableEye_Run($CableEyeHandle);\n\nRecordMeasurementPassFail(\"Cable Test\",$failureList,\" \",true,$testPass);\n\n\n\n\n\nCableEye_ShowDifference\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS CableEye_ShowDifference": {
  "prefix": "CableEye_ShowDifference",
  "body": [
   "CableEye_ShowDifference($$CableEyeHandle);"
  ],
  "description": "\n\nRuns the test, comparing the current setup to the match data. If any non-conforming connections are found, they are displayed in a cable diagram with a table of failures. The script pauses until the form is closed.\n\n\n\n\n\nNote: this function requires the cell setting 'Cell Threading Mode' to be set to (STA Mode).\n\n\n\n\n\nNote: Using these functions requires registering the CableEye API using the 'CableEyeAPI.license' file in the Jabil Test directory. Start the main CableEye program by dragging the license file on top of the CableEye shortcut icon. You should get a pop-up confirming that the license was installed.\n\n\n\n\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$CableEyeHandle\n\nObject\n\nHandle to CableEye fixture and databases returned by the CableEye_Init() function.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n--\n\n\n\n\n\nExample:\n\nCableEye_ShowDifference($CableEyeHandle);\n\n\n\n\n\nCableEye_Close\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS CableEye_Close": {
  "prefix": "CableEye_Close",
  "body": [
   "CableEye_Close($$Handle);"
  ],
  "description": "\n\nThis function is used to support the CableEye cable test platform developed by CAMI Research. It supports both M2 and M3 model cable test platforms.\n\nCloses connection to the CableEye fixture.\n\nNote: These functions have been replaced by the CableEye API functions.\n\nExample:\n\nCableEye_Close($Handle);\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nThe handle to the CableEye hardware to be released.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nCableEye_LoadFiles\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS CableEye_LoadFiles": {
  "prefix": "CableEye_LoadFiles",
  "body": [
   "CableEye_LoadFiles($$Handle,$$CableName,$$MapFile);"
  ],
  "description": "\n\nThis function is used to support the CableEye cable test platform developed by CAMI Research. It supports both M2 and M3 model cable test platforms.\n\nThis function is used to load the test data and map file to be used for Cable Testing on the CableEye product from CAMI research. In the event that the Cable Name can't be found in the CableEye database, or the custom pin map file can't be found, a failure is returned to the test executive interpreter. For more information on creating cable models, and custom pin map definitions, please see the CableEye user's manual.\n\nNote: These functions have been replaced by the CableEye API functions.\n\nExample:\n\nCableEye_LoadFiles($Handle,\"TestCable\",\"MapDef\");\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nThe handle to the CableEye hardware to be released.\n\n\n\n$CableName\n\nString\n\nThe Cable file from the CableEye database to be used for comparison.\n\n\n\n$MapFile\n\nString\n\nThe name of the custom map file (not including .map file extension or directory path)\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nCableEye.Open\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS CableEye_Open": {
  "prefix": "CableEye_Open",
  "body": [
   "$$handle=CableEye_Open($$WorkingDirectory,$$ComPort,$$DwellTime,$$ModelType);"
  ],
  "description": "\n\nThis function is used to support the CableEye cable test platform developed by CAMI Research. It supports both M2 and M3 model cable test platforms.\n\nThis function is used to initialize the CableEye cable tester made by CAMI research. After executing the CableEye.Open function, the handle returned must be disposed with the CableEye.Close function. In the event that the CableEye hardware can't be accessed, a failure is returned to the test script interpreter.\n\nNote: These functions have been replaced by the CableEye API functions.\n\nExample:\n\n$handle = CableEye_Open(\"c:\\\\program files\\\\cableeye\\\\software\",1,200,\"M3);\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$WorkingDirectory\n\nString\n\nThe working directory of the CableEye software. This directory must contain the sub-directories which contain the custom MAP and cable definition files.\n\n\n\n$ComPort\n\nInteger\n\nThe number of the COM port on which the CableEye fixture is connected.\n\n\n\n$DwellTime\n\nInteger\n\nThe dwell time in microseconds in which to wait before detecting a test pattern after it has been asserted.\n\n\n\n$ModelType\n\nString\n\nThe model type of Cable Eye to open. Allowable values are \"M2\" or \"M3\".\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$handle\n\nObject\n\nReturns a handle to the initialized CableEye hardware\n\n\n\n\n\nCableEye.RunTest\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS CableEye_RunTest": {
  "prefix": "CableEye_RunTest",
  "body": [
   "CableEye_RunTest($$Session);"
  ],
  "description": "\n\nThis function is used to support the CableEye cable test platform developed by CAMI Research. It supports both M2 and M3 model cable test platforms.\n\nThis function is used to initiate the test sequence on the CableEye Tester. In the event that the cable matches the cable data loaded, a passing result is generated. Otherwise a failure is returned to the test executive, along with a list of all the shorts,opens, and resistive mismatch failures found in the cable.\n\nBefore this function can be run, the CableEye tester first needs to be initialized and setup using the CableEye.Open and CableEye.LoadFiles functions. After running the CableEye test, the resources should be freed using the CableEye.Close function.\n\nNote: These functions have been replaced by the CableEye API functions.\n\nExample:\n\nCableEye_RunTest($Session)\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Session\n\nObject\n\nA handle to a current CableEye fixture which was creating using the CableEye.Open function.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nCableEye_SetThresholds\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS CableEye.SetThresholds": {
  "prefix": "CableEye.SetThresholds",
  "body": [
   "$$handle=CableEye.SetThresholds($$Session,$$LowerLimit,$$UpperLimit,$$LowerTolerance,$$UpperTolerance);"
  ],
  "description": "\n\nThis function is used to support the CableEye cable test platform developed by CAMI Research. It supports both M2 and M3 model cable test platforms.\n\nThis function is used to set the thresholds consistuting a short vs. open for the CableEye platform. Both single-threshold or dual-threshold setups are supported. If a single threshold is used, set the $UpperLimit argument to 0. For more information about resistance thresholds, see the CableEye user's manual.\n\nNote: These functions have been replaced by the CableEye API functions.\n\nExample:\n\nCableEye_SetThresholds($Session,2,0,1,1);\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Session\n\nObject\n\nA handle to a current CableEye fixture which was creating using the CableEye.Open function.\n\n\n\n$LowerLimit\n\nFloat\n\nResistance threshold below which connections are considered wires (or, in single-threshold mode, below which a connection is detected)\n\n\n\n$UpperLimit\n\nFloat\n\nResistance threshold above which connections are considered opens. Set to 0 to use single-threshold mode.\n\n\n\n$LowerTolerance\n\nFloat\n\nFor resistance measurements, the lower bound on the difference between the measured resistance value of a resistive connection and the expected value expressed as a percent of the expected value.\n\n\n\n$UpperTolerance\n\nFloat\n\nFor resistance measurements, the upper bound on the difference between the measured resistance value of a resistive connection and the expected value, expressed as percent of the expected value.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nCA210_Close\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS CA210_Close": {
  "prefix": "CA210_Close",
  "body": [
   "CA210_Close($$InstrumentHandle);"
  ],
  "description": "\n\nThis function supports the CA-210 Color Analzyer manufactered by Konica Minolta. It supports a single instrument connected via USB. In order to use this function, the USB driver must be installed along with the SDK library.\n\nThis function closes and releases the CA210 Color Analyzer\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nAn instance of the CA210 Instrument handle to close\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nCA210_Measure_FlickerFMA\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS $CA210_MeasureFlickerFMA": {
  "prefix": "$CA210_MeasureFlickerFMA",
  "body": [
   "$$flickerMeasure=$$CA210_MeasureFlickerFMA($$InstrumentHandle);"
  ],
  "description": "\n\nThis function supports the CA-210 Color Analzyer manufactered by Konica Minolta. It supports a single instrument connected via USB. In order to use this function, the USB driver must be installed along with the SDK library.\n\nPerforms a measurement and returns the result of the FMA flicker measurement.\n\nSee the Konika-Minolta Display Color Analyzer User's Manual For More Detailed Information.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nAn instance of the CA210 Instrument handle\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$flickerMeasure\n\nFloat\n\nThe FMA flicker measurement\n\n\n\n\n\nCA210_Measure_FlickerJEITA\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS $CA210_Measure_FlickerJEITA": {
  "prefix": "$CA210_Measure_FlickerJEITA",
  "body": [
   "$$flickerMeasure=$$CA210_Measure_FlickerJEITA($$InstrumentHandle);"
  ],
  "description": "\n\nThis function supports the CA-210 Color Analzyer manufactered by Konica Minolta. It supports a single instrument connected via USB. In order to use this function, the USB driver must be installed along with the SDK library.\n\nPerforms a measurement and returns the result of the JEITA flicker measurement.\n\nSee the Konika-Minolta Display Color Analyzer User's Manual For More Detailed Information.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nAn instance of the CA210 Instrument handle\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$flickerMeasure\n\nFloat\n\nThe JEITA flicker measurement\n\n\n\n\n\nCA210_Measure_LV\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS $CA210.Measure_LV": {
  "prefix": "$CA210.Measure_LV",
  "body": [
   "$$Lv=$$CA210.Measure_LV($$InstrumentHandle);"
  ],
  "description": "\n\nThis function supports the CA-210 Color Analzyer manufactered by Konica Minolta. It supports a single instrument connected via USB. In order to use this function, the USB driver must be installed along with the SDK library.\n\nPerforms a brightness measurement and results the results in (cd/m2) Lv units.\n\nSee the Konika-Minolta Display Color Analyzer User's Manual For More Detailed Information.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nAn instance of the CA210 Instrument handle\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Lv\n\nFloat\n\nThe measurement returned in (Lv) (cd/m2) units\n\n\n\n\n\nCA210_Measure_LVFL\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS $CA210_Measure_LVFL": {
  "prefix": "$CA210_Measure_LVFL",
  "body": [
   "$$LvfL=$$CA210_Measure_LVFL($$InstrumentHandle);"
  ],
  "description": "\n\nThis function supports the CA-210 Color Analzyer manufactered by Konica Minolta. It supports a single instrument connected via USB. In order to use this function, the USB driver must be installed along with the SDK library.\n\nPerforms a brightness measurement and results the results in fL units.\n\nSee the Konika-Minolta Display Color Analyzer User's Manual For More Detailed Information.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nAn instance of the CA210 Instrument handle\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$LvfL\n\nFloat\n\nThe measurement returned in fL units\n\n\n\n\n\nCA210_Measure_SXSY\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS $CA210_Measure_SXSY": {
  "prefix": "$CA210_Measure_SXSY",
  "body": [
   "($$sx,sy)=$$CA210_Measure_SXSY($$InstrumentHandle);"
  ],
  "description": "\n\nThis function supports the CA-210 Color Analzyer manufactered by Konica Minolta. It supports a single instrument connected via USB. In order to use this function, the USB driver must be installed along with the SDK library.\n\nPerforms a measurement, and returns the results in the xy color space.\n\nSee the Konika-Minolta Display Color Analyzer User's Manual For More Detailed Information.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nAn instance of the CA210 Instrument handle\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$sx\n\nFloat\n\nThe x value of the measurement in the xy color space\n\n\n\n$sy\n\nFloat\n\nThe yvalue of the measurement in the xy color space\n\n\n\n\n\nCA210_Measure_TDUV\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS $CA210_MeasureTDUV": {
  "prefix": "$CA210_MeasureTDUV",
  "body": [
   "($$T,$$Duv)=$$CA210_MeasureTDUV($$InstrumentHandle);"
  ],
  "description": "\n\nThis function supports the CA-210 Color Analzyer manufactered by Konica Minolta. It supports a single instrument connected via USB. In order to use this function, the USB driver must be installed along with the SDK library.\n\nPerforms a measurement and returns the correlated color temperature and the difference from black-body locus, as represented in the uv color space.\n\nSee the Konika-Minolta Display Color Analyzer User's Manual For More Detailed Information.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nAn instance of the CA210 Instrument handle\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$T\n\nFloat\n\nCorrelated color temperature, in uv color space\n\n\n\n$Duv\n\nFloat\n\nDifference from black-body locus, in uv color space\n\n\n\n\n\nCA210_Measure_XYZ\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS $CA210_Measure_XYZ": {
  "prefix": "$CA210_Measure_XYZ",
  "body": [
   "($$X,$$Y,$$Z)=$$CA210_Measure_XYZ($$InstrumentHandle);"
  ],
  "description": "\n\nThis function supports the CA-210 Color Analzyer manufactered by Konica Minolta. It supports a single instrument connected via USB. In order to use this function, the USB driver must be installed along with the SDK library.\n\nPerforms a measurement and returns the result in the XYZ color space.\n\nSee the Konika-Minolta Display Color Analyzer User's Manual For More Detailed Information.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nAn instance of the CA210 Instrument handle\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$X\n\nFloat\n\nThe X value of measurement result in XYZ color space\n\n\n\n$Y\n\nFloat\n\nThe Y value of measurement result in XYZ color space\n\n\n\n$Z\n\nFloat\n\nThe Z value of measurement result in XYZ color space\n\n\n\n\n\nCA210_Open\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS CA210_Open": {
  "prefix": "CA210_Open",
  "body": [
   "$$Instrument=CA210_Open();"
  ],
  "description": "\n\nThis function supports the CA-210 Color Analzyer manufactered by Konica Minolta. It supports a single instrument connected via USB. In order to use this function, the USB driver must be installed along with the SDK library.\n\nThis function opens the CA210 color analyzer for use.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Instrument\n\nObject\n\nAn instance of the CA210 Instrument handle\n\n\n\n\n\nCA210_SetAnalogRange\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS CA210_SetAnalogRange": {
  "prefix": "CA210_SetAnalogRange",
  "body": [
   "CA210_SetAnalogRange($$InstrumentHandle,$$Range1,$$Range2);"
  ],
  "description": "\n\nThis function supports the CA-210 Color Analzyer manufactered by Konica Minolta. It supports a single instrument connected via USB. In order to use this function, the USB driver must be installed along with the SDK library.\n\nThis function sets the analog range of the CA-200 unit's analog display.\n\nSee the Konika-Minolta Display Color Analyzer User's Manual For More Detailed Information.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nAn instance of the CA210 Instrument handle\n\n\n\n$Range1\n\nFloat\n\nAllowable values are (0.1 .. 99.0)\n\n\n\n$Range2\n\nFloat\n\nAllowable values are (0.1 .. 99.0)\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nCA210_SetAveragingMode\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS CA210_SetAveragingMode": {
  "prefix": "CA210_SetAveragingMode",
  "body": [
   "CA210_SetAveragingMode($$InstrumentHandle,$$AveragingMode);"
  ],
  "description": "\n\nThis function supports the CA-210 Color Analzyer manufactered by Konica Minolta. It supports a single instrument connected via USB. In order to use this function, the USB driver must be installed along with the SDK library.\n\nThis function sets the averaging mode on the CA-210 Instrument.\n\nSee the Konika-Minolta Display Color Analyzer User's Manual For More Detailed Information.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nAn instance of the CA210 Instrument handle\n\n\n\n$SyncMode\n\nString\n\nThe synchronization mode to use. Valid values are:\n\n\u00b7 \"SLOW\"\n\n\u00b7 \"FAST\"\n\n\u00b7 \"AUTO\"\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nCA210_SetFMAAnalogRange\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS CA210_SetFMAAnalogRange": {
  "prefix": "CA210_SetFMAAnalogRange",
  "body": [
   "CA210_SetFMAAnalogRange($$InstrumentHandle,$$Range);"
  ],
  "description": "\n\nThis function supports the CA-210 Color Analzyer manufactered by Konica Minolta. It supports a single instrument connected via USB. In order to use this function, the USB driver must be installed along with the SDK library.\n\nSets the analog display range used by the CA-210 for flicker measurement.\n\nSee the Konika-Minolta Display Color Analyzer User's Manual For More Detailed Information.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nAn instance of the CA210 Instrument handle\n\n\n\n$Range\n\nFloat\n\nAllowable values are (0.1 .. 99.0)\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nCA210_SetSyncMode\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS CA210_SetSyncMode": {
  "prefix": "CA210_SetSyncMode",
  "body": [
   "CA210_SetSyncMode($$InstrumentHandle,$$SyncMode);"
  ],
  "description": "\n\nThis function supports the CA-210 Color Analzyer manufactered by Konica Minolta. It supports a single instrument connected via USB. In order to use this function, the USB driver must be installed along with the SDK library.\n\nThis function sets the Synchronization mode on the CA-210 Instrument.\n\nSee the Konika-Minolta Display Color Analyzer User's Manual For More Detailed Information.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nAn instance of the CA210 Instrument handle\n\n\n\n$SyncMode\n\nString\n\nThe synchronization mode to use. Valid values are:\n\n\u00b7 \"NTSC\"\n\n\u00b7 \"PAL\"\n\n\u00b7 \"EXT\"\n\n\u00b7 \"UNIV\"\n\n\u00b7 \"INT\"\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nCA210_StandardCal\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS CA210_StandardCal": {
  "prefix": "CA210_StandardCal",
  "body": [
   "CA210_StandardCal($$InstrumentHandle,$$CalMode);"
  ],
  "description": "\n\nThis function supports the CA-210 Color Analzyer manufactered by Konica Minolta. It supports a single instrument connected via USB. In order to use this function, the USB driver must be installed along with the SDK library.\n\nThis function performs a Standard Calibration on the CA-210 Instrument. Either a 6500K calibration or 9300K calibration may be selected.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nAn instance of the CA210 Instrument handle\n\n\n\n$CalMode\n\nString\n\nThe calibration standard to use. Valid values are:\n\n\u00b7 \"6500K\"\n\n\u00b7 \"9300K\"\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nCA210_ZeroCal\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS CA210_ZeroCal": {
  "prefix": "CA210_ZeroCal",
  "body": [
   "CA210_ZeroCal($$InstrumentHandle);"
  ],
  "description": "\n\nThis function supports the CA-210 Color Analzyer manufactered by Konica Minolta. It supports a single instrument connected via USB. In order to use this function, the USB driver must be installed along with the SDK library.\n\nThis function performs a Zero Cal on the CA-210 Instrument. In order for a successful zero calibration operation, the device should have the lens cap in place, and the probe should be set to the Zero Cal position.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nAn instance of the CA210 Instrument handle\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nPCIE1752_Close\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS PCIE1752_Close": {
  "prefix": "PCIE1752_Close",
  "body": [
   "PCIE1752_Close($$pcieHandle);"
  ],
  "description": "\n\nThis function will close communication with the PCIE-1752 DO card.\n\n\n\nRemarks\n\nCommunication must already have been opened with the PCIE1752_Connect function.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$pcieHandle\n\nObject\n\nThe handle to an existing PCIE-1752 connection.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n\n\n\n\n// Connect to board ID 0.\n\n$boardNum = 0;\n\n$pcieHandle = PCIE1752_Connect($boardNum);\n\n\n\n// Now we close the communication.\n\nPCIE1752_Close($pcieHandle);\n\n\n\n\n\nPCIE1752_Connect\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS PCIE1752_Connect": {
  "prefix": "PCIE1752_Connect",
  "body": [
   "$$pcieHandle=PCIE1752_Connect($$deviceNumber);"
  ],
  "description": "\n\nThis function will open communication with the PCIE-1752 DO card.\n\n\n\nRemarks\n\nIf the board can not be found, an error will be generated and the script will be failed.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$deviceNumber\n\nInteger\n\nThe ID number of the DO card to connect to.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$pcieHandle\n\nObject\n\nA handle to the open communication that can be used with other PCIE-1752 functions.\n\n\n\n\n\nExample:\n\n\n\n\n\n// Connect to board ID 0.\n\n$boardNum = 0;\n\n$pcieHandle = PCIE1752_Connect($boardNum);\n\n\n\n\n\nPCIE1752_GetBoardInfo\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS PCIE1752_GetBoardInfo": {
  "prefix": "PCIE1752_GetBoardInfo",
  "body": [
   "($$boardVersion,$$boardID,$$driverVersion,$$portCount,$$location,$$boardDesc)=PCIE1752_GetBoardInfo($$pcieHandle);"
  ],
  "description": "\n\nThis function will return information about the PCIE-1752 DO card.\n\n\n\nRemarks\n\nCommunication must already have been opened with the PCIE1752_Connect function.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$pcieHandle\n\nObject\n\nThe handle to an existing PCIE-1752 connection.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$boardVersion\n\nString\n\nA string containing the version of the board.\n\n\n\n$boardID\n\nString\n\nA string containing the ID of the board.\n\n\n\n$driverVersion\n\nString\n\nA string containing the version of the software driver.\n\n\n\n$portCount\n\nInteger\n\nThe number of ports on the board.\n\n\n\n$location\n\nString\n\nA string containing the location of the board inside the computer.\n\n\n\n$boardDesc\n\nString\n\nA string containing the description of the board.\n\n\n\n\n\nExample:\n\n\n\n\n\n// Connect to board ID 0.\n\n$boardNum = 0;\n\n$pcieHandle = PCIE1752_Connect($boardNum);\n\n\n\n// Get the information about the board.\n\n($boardVer, $boardID, $driverVer, $portCount, $location, $boardDesc) = PCIE1752_GetBoardInfo($pcieHandle);\n\n\n\n// Output the information about the board.\n\n$outStr = \"\\r\\nBoard Version:\\t\" + $boardVer;\n\n$outStr = $outStr + \"\\r\\nBoard ID:\\t\\t\" + $boardID;\n\n$outStr = $outStr + \"\\r\\nDriver Version:\\t\" + $driverVer;\n\n$outStr = $outStr + \"\\r\\nNumber of Ports:\\t\" + $portCount;\n\n$outStr = $outStr + \"\\r\\nBoard Location:\\t\" + $location;\n\n$outStr = $outStr + \"\\r\\nBoard Description:\\t\" + $boardDesc;\n\nUpdateStatus($outStr);\n\n\n\n\n\nPCIE1752_ReadBit\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS PCIE1752_ReadBit": {
  "prefix": "PCIE1752_ReadBit",
  "body": [
   "$$bitState=PCIE1752_ReadBit($$pcieHandle,$$portNumber,$$lineNumber);"
  ],
  "description": "\n\nThis function will return the state of the specified output line.\n\n\n\nRemarks\n\nCommunication must already have been opened with the PCIE1752_Connect function.\n\nPort numbers and Line numbers start at 0. A board with 8 ports will have them numbered 0 to 7.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$pcieHandle\n\nObject\n\nThe handle to an existing PCIE-1752 connection.\n\n\n\n$portNumber\n\nInteger\n\nThe port number to get the data from.\n\n\n\n$lineNumber\n\nInteger\n\nThe line number to get the data from.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$bitState\n\nInteger\n\nThe state of the output line. 0 = low, 1 = high.\n\n\n\n\n\nExample:\n\n\n\n\n\n// Connect to board ID 0.\n\n$boardNum = 0;\n\n$pcieHandle = PCIE1752_Connect($boardNum);\n\n\n\n// Get the state of line 2 on port 1.\n\n$portNum = 1;\n\n$lineNum = 2;\n\n$lineState = PCIE1752_ReadBit($pcieHandle, $portNum, lineNum);\n\n\n\n\n\nPCIE1752_ReadPort\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS PCIE1752_ReadPort": {
  "prefix": "PCIE1752_ReadPort",
  "body": [
   "$$portState=PCIE1752_ReadPort($$pcieHandle,$$portNumber);"
  ],
  "description": "\n\nThis function will return the state of the specified port.\n\n\n\nRemarks\n\nCommunication must already have been opened with the PCIE1752_Connect function.\n\nPort numbers start at 0. A board with 8 ports will have them numbered 0 to 7.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$pcieHandle\n\nObject\n\nThe handle to an existing PCIE-1752 connection.\n\n\n\n$portNumber\n\nInteger\n\nThe port number to get the data from.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$portState\n\nInteger\n\nThe state of the output port.\n\n\n\n\n\nExample:\n\n\n\n\n\n// Connect to board ID 0.\n\n$boardNum = 0;\n\n$pcieHandle = PCIE1752_Connect($boardNum);\n\n\n\n// Get the state of port 1.\n\n$portNum = 1;\n\n$lineState = PCIE1752_ReadPort($pcieHandle, $portNum);\n\n\n\n\n\nPCIE1752_ResetBoard\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS PCIE1752_ResetBoard": {
  "prefix": "PCIE1752_ResetBoard",
  "body": [
   "PCIE1752_ResetBoard($$pcieHandle,$$resetState);"
  ],
  "description": "\n\nThis function will reset the board.\n\n\n\nRemarks\n\nCommunication must already have been opened with the PCIE1752_Connect function.\n\nThe board will be reset to its power-on state.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$pcieHandle\n\nObject\n\nThe handle to an existing PCIE-1752 connection.\n\n\n\n$resetState\n\nInteger\n\nThe reset state for the board.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n\n\n\n\n// Connect to board ID 0.\n\n$boardNum = 0;\n\n$pcieHandle = PCIE1752_Connect($boardNum);\n\n\n\n// Reset the board.\n\n$resetState = 0;\n\nPCIE1752_ResetBoard($pcieHandle, $resetState);\n\n\n\n\n\nPCIE1752_WriteBit\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS PCIE1752_WriteBit": {
  "prefix": "PCIE1752_WriteBit",
  "body": [
   "PCIE1752_WriteBit($$pcieHandle,$$portNumber,$$lineNumber,$$lineData);"
  ],
  "description": "\n\nThis function will set the state of one output line on a specified port.\n\n\n\nRemarks\n\nCommunication must already have been opened with the PCIE1752_Connect function.\n\nPort numbers and Line numbers start at 0. A board with 8 ports will have them numbered 0 to 7.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$pcieHandle\n\nObject\n\nThe handle to an existing PCIE-1752 connection.\n\n\n\n$portNumber\n\nInteger\n\nThe port number to set a line state on.\n\n\n\n$lineNumber\n\nInteger\n\nThe line number to set the state of.\n\n\n\n$lineData\n\nInteger\n\nThe state to set the line to. 0 = low, all positive integers = high.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n\n\n\n\n// Connect to board ID 0.\n\n$boardNum = 0;\n\n$pcieHandle = PCIE1752_Connect($boardNum);\n\n\n\n// Set line 2 on port 1 high.\n\n$portNum = 1;\n\n$lineNum = 2;\n\n$lineState = 255;\n\nPCIE1752_WriteBit($pcieHandle, $portNum, lineNum, $lineState);\n\n\n\n\n\nPCIE1752_WritePort\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS PCIE1752_WritePort": {
  "prefix": "PCIE1752_WritePort",
  "body": [
   "PCIE1752_WritePort($$pcieHandle,$$portNumber,$$portData);"
  ],
  "description": "\n\nThis function will set the state of all of the output lines on one port.\n\n\n\nRemarks\n\nCommunication must already have been opened with the PCIE1752_Connect function.\n\nPort numbers start at 0. A board with 8 ports will have them numbered 0 to 7.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$pcieHandle\n\nObject\n\nThe handle to an existing PCIE-1752 connection.\n\n\n\n$portNumber\n\nInteger\n\nThe port number to set the outputs of.\n\n\n\n$portData\n\nInteger\n\nThe state to set the port to. Each bit represents one line. 0 = low, 1 = high.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n\n\n\n\n// Connect to board ID 0.\n\n$boardNum = 0;\n\n$pcieHandle = PCIE1752_Connect($boardNum);\n\n\n\n// Set port 1 to a pattern of 0011 0011. (0x33 = 0d51).\n\n$portNum = 1;\n\n$portState = 51;\n\nPCIE1752_WritePort($pcieHandle, $portNum, $portState);\n\n\n\n\n\nPMD_AnalogConfigure\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS PMD_AnalogConfigure": {
  "prefix": "PMD_AnalogConfigure",
  "body": [
   "PMD_AnalogConfigure($$DeviceID,$$AnalogMode);"
  ],
  "description": "\n\nThis function supports the PMD-1208LS Personal Measurement Device From Measurement Computing Corporation\n\nThis function configures the Analog Input section of the PMD-1208LS device for either Single Ended or Differential operation. In Single-Ended mode, 8 Analog input ports are available. In Differential Mode, 4 Analog Input devices are available.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$deviceNumber\n\nInteger\n\nThe Board ID of the PMD-1208LS device\n\n\n\n$AnalogMode\n\nString\n\nConfigures the Analog input mode, allowable values are:\n\n\u00b7 \"SingleEnded\"\n\n\u00b7 \"Differential\"\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nPMD_AnalogMeasure\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS PMD_AnalogMeasure": {
  "prefix": "PMD_AnalogMeasure",
  "body": [
   "$$measurement=PMD_AnalogMeasure($$DeviceID,$$Channel,$$Range);"
  ],
  "description": "\n\nThis function supports the PMD-1208LS Personal Measurement Device From Measurement Computing Corporation\n\nThis function acquires an analog measurement from the D/A Convertor of the PMD-1208LS device. The raw value of the DA converter is automatically converted to a voltage measurement based on the range value supplied to the function. In the event of a successful measurement the function returns a PASS result. In the event that a hardware problem occurs, a FAIL result is returned to the executive.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$deviceNumber\n\nInteger\n\nThe Board ID of the PMD-1208LS device\n\n\n\n$Channel\n\nInteger\n\nThe channel to for an analog measurement. For single ended measurements, 0-7 are valid values. For differential measurements 0-3 are valid values.\n\n\n\n$Range\n\nString\n\nThe measurement range for the D/A converter. For single-ended configuration, the only valid range is \"Bip10Volts\". For differential measurements, the valid values are:\n\n\u00b7 \"Bip20Volts\" = +/- 20 Volts\n\n\u00b7 \"Bip10Volts\" = +/- 10 Volts\n\n\u00b7 \"Bip5Volts\" = +/- 5 Volts\n\n\u00b7 \"Bip4Volts\" = +/- 4 Volts\n\n\u00b7 \"Bip2Pt5Volts\" = +/- 2.5 Volts\n\n\u00b7 \"Bip2Volts\" = +/- 2 Volts\n\n\u00b7 \"Bip1Pt25Volts\" = +/- 1.25 Volts\n\n\u00b7 \"Bip2Volts\" = +/- 2 Volts\n\n\u00b7 \"Bip1Pt25Volts\" = +/- 1.25 Volts\n\n\u00b7 \"Bip1Volts' = +/- 1 Volts\n\n\u00b7 \"BipPt625Volts\" = +/- 0.625 Volts\n\n\u00b7 \"BipPt5Volts\" = +/- 0.5 Volts\n\n\u00b7 \"BipPt25Volts\" = +/- 0.25 Volts\n\n\u00b7 \"BipPt2Volts\" = +/- 0.20 Volts\n\n\u00b7 \"BipPt1Volts\" = +/- 0.10 Volts\n\n\u00b7 \"BipPt05Volts\" = +/- 0.05 Volts\n\n\u00b7 \"BipPt01Volts\" = +/- 0.01 Volts\n\n\u00b7 \"BipPt005Volts\" = +/- 0.005 Volts\n\n\u00b7 \"Bip1Pt67Volts\" = +/- 1.67 Volts\n\n\u00b7 \"Uni10Volts\" = 0 - 10 Volts\n\n\u00b7 \"Uni5Volts\" = 0 - 5 Volts\n\n\u00b7 \"Uni2Pt5Volts\" = 0 - 2.5 Volts\n\n\u00b7 \"Uni1Volts\" = 0 - 1 Volts\n\n\u00b7 \"UniPt5Volts\" = 0 - 0.5 Volts\n\n\u00b7 \"UniPt25Volts\" = 0 - 0.25 Volts\n\n\u00b7 \"UniPt2Volts\" = 0 - 0.2 Volts\n\n\u00b7 \"UniPt1Volts\" = 0 - 0.1 Volts\n\n\u00b7 \"UniPt01Volts\" = 0 - 0.01 Volts\n\n\u00b7 \"UniPt02Volts\" = 0 - 0.02 Volts\n\n\u00b7 \"UniPt05Volts\" = 0 - 0.05 Volts\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$measurement\n\nFloat\n\nThe measurement in Volts computed by taking the raw output of the A/D convertor and comparing to the measurement range specified in the function call.\n\n\n\n\n\nPMD_AnalogOut\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS PMD_AnalogOut": {
  "prefix": "PMD_AnalogOut",
  "body": [
   "PMD_AnalogOut($$DeviceID,$$Channel,$$Range,$$DACValue);"
  ],
  "description": "\n\nThis function supports the PMD-1208LS Personal Measurement Device From Measurement Computing Corporation\n\nThis function writes an analog voltage to the D/A Convertor of the PMD-1208LS device. The $Range specifies the scaling for the A/D convertor (for the PMD-1208LS the A/D convertor only supports \"Uni5Volts\"). The $DACValue is an integer value between 0-1023 that specifies the value written to the A/D register.\n\nExample:\n\nPMD_AnalogOut(1,1,\"Uni5Volts\",1023); // Sets Channel 1 of Unit 1 to 5 volts\n\nPMD_AnalogOut(1,1,\"Uni5Volts\",0); // Sets Channel 1 of Unit 1 to 0 volts\n\nPMD_AnalogOut(1,1,\"Uni5Volts\",512); // Sets Channel 1 of Unit 1 to 2.5 volts\n\nIn the event of that the DAC value is set successfully the function returns a PASS result. In the event that a hardware problem occurs, a FAIL result is returned to the executive.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$deviceNumber\n\nInteger\n\nThe Board ID of the PMD-1208LS device\n\n\n\n$Channel\n\nInteger\n\nThe channel to for an analog measurement. For single ended measurements, 0-7 are valid values. For differential measurements 0-3 are valid values.\n\n\n\n$Range\n\nString\n\nThe measurement range for the D/A converter. For single-ended configuration, the only valid range is \"Bip10Volts\". For differential measurements, the valid values are:\n\n\u00b7 \"Bip20Volts\" = +/- 20 Volts\n\n\u00b7 \"Bip10Volts\" = +/- 10 Volts\n\n\u00b7 \"Bip5Volts\" = +/- 5 Volts\n\n\u00b7 \"Bip4Volts\" = +/- 4 Volts\n\n\u00b7 \"Bip2Pt5Volts\" = +/- 2.5 Volts\n\n\u00b7 \"Bip2Volts\" = +/- 2 Volts\n\n\u00b7 \"Bip1Pt25Volts\" = +/- 1.25 Volts\n\n\u00b7 \"Bip2Volts\" = +/- 2 Volts\n\n\u00b7 \"Bip1Pt25Volts\" = +/- 1.25 Volts\n\n\u00b7 \"Bip1Volts' = +/- 1 Volts\n\n\u00b7 \"BipPt625Volts\" = +/- 0.625 Volts\n\n\u00b7 \"BipPt5Volts\" = +/- 0.5 Volts\n\n\u00b7 \"BipPt25Volts\" = +/- 0.25 Volts\n\n\u00b7 \"BipPt2Volts\" = +/- 0.20 Volts\n\n\u00b7 \"BipPt1Volts\" = +/- 0.10 Volts\n\n\u00b7 \"BipPt05Volts\" = +/- 0.05 Volts\n\n\u00b7 \"BipPt01Volts\" = +/- 0.01 Volts\n\n\u00b7 \"BipPt005Volts\" = +/- 0.005 Volts\n\n\u00b7 \"Bip1Pt67Volts\" = +/- 1.67 Volts\n\n\u00b7 \"Uni10Volts\" = 0 - 10 Volts\n\n\u00b7 \"Uni5Volts\" = 0 - 5 Volts\n\n\u00b7 \"Uni2Pt5Volts\" = 0 - 2.5 Volts\n\n\u00b7 \"Uni1Volts\" = 0 - 1 Volts\n\n\u00b7 \"UniPt5Volts\" = 0 - 0.5 Volts\n\n\u00b7 \"UniPt25Volts\" = 0 - 0.25 Volts\n\n\u00b7 \"UniPt2Volts\" = 0 - 0.2 Volts\n\n\u00b7 \"UniPt1Volts\" = 0 - 0.1 Volts\n\n\u00b7 \"UniPt01Volts\" = 0 - 0.01 Volts\n\n\u00b7 \"UniPt02Volts\" = 0 - 0.02 Volts\n\n\u00b7 \"UniPt05Volts\" = 0 - 0.05 Volts\n\n\n\n$DACValue\n\nInteger\n\nThe integer value to set the D/A output register. Valid values are 0-1023\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nPMD_ConfigDigitalPort\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS PMD_ConfigDigitalPort": {
  "prefix": "PMD_ConfigDigitalPort",
  "body": [
   "PMD_ConfigDigitalPort($$DeviceID,$$Port,$$Direction);"
  ],
  "description": "\n\nThis function supports the PMD-1208LS Personal Measurement Device From Measurement Computing Corporation\n\nThis function configures the specified DIO port direction for the PMD-1208LS measurement device. In the event of a successful configuration, a PASS result is returned. Otherwise a FAIL result is generated.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$deviceNumber\n\nInteger\n\nThe Board ID of the PMD-1208LS device\n\n\n\n$Port\n\nInteger\n\nThe DIO Port to Configure\n\n\n\n$Direction\n\nString\n\nThe direction of the DIO port. Allowable Values are:\n\n\u00b7 \"INPUT\"\n\n\u00b7 \"OUTPUT\"\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nPMD_DIOBitRead\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS PMD_DIOBitRead": {
  "prefix": "PMD_DIOBitRead",
  "body": [
   "$$value=PMD_DIOBitRead($$DeviceID,$$Port,$$BitNumber);"
  ],
  "description": "\n\nThis function supports the PMD-1208LS Personal Measurement Device From Measurement Computing Corporation\n\nThis function reads the present value of a particular bit on the DIO Port from the PMD-1208LS device.\n\nBefore reading a value from the DIO port bit, it first must be configured as an INPUT port using the PMD_DIOConfigDigitalPort function. In the event that a value is successfully read from the device a PASS result is generated. Otherwise a FAIL result is returned to the executive.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$deviceNumber\n\nInteger\n\nThe Board ID of the PMD-1208LS device\n\n\n\n$Port\n\nInteger\n\nThe DIO Port to Write\n\n\n\n$BitNumber\n\nInteger\n\nThe particular bit of a port to read (valid values are 0-7)\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$value\n\nInteger\n\nThe integer value of the DIO Port Bit requested. Return values are 0 or 1.\n\n\n\n\n\nPMD_DIOBitWrite\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS PMD_DIOBitWrite": {
  "prefix": "PMD_DIOBitWrite",
  "body": [
   "PMD_DIOBitWrite($$DeviceID,$$Port,$$BitNumber,$$value);"
  ],
  "description": "\n\nThis function supports the PMD-1208LS Personal Measurement Device From Measurement Computing Corporation\n\nThis function writes the supplied value to the specified DIO Port and Bit Number. Before writing a value to the DIO port, it first must be configured as an OUTPUT port using the PMD_DIOConfigDigitalPort function. In the event that a value is successfully written to the device a PASS result is generated. Otherwise a FAIL result is returned to the executive.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$deviceNumber\n\nInteger\n\nThe Board ID of the PMD-1208LS device\n\n\n\n$Port\n\nInteger\n\nThe DIO Port to Write\n\n\n\n$BitNumber\n\nInteger\n\nThe Bit Number of the DIO Port to Write. Valid Values are 0-7.\n\n\n\n$value\n\nInteger\n\nA integer value indicating the value to write to the port and bit number. Valid values are 0 or 1.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nPMD_DIOPortRead\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS PMD_DIOPortRead": {
  "prefix": "PMD_DIOPortRead",
  "body": [
   "$$value=PMD_DIOPortRead($$DeviceID,$$Port);"
  ],
  "description": "\n\nThis function supports the PMD-1208LS Personal Measurement Device From Measurement Computing Corporation\n\nThis function reads the present value of a DIO Port from the PMD-1208LS device.\n\nBefore reading a value from the DIO port, it first must be configured as an INPUT port using the PMD_DIOConfigDigitalPort function. In the event that a value is successfully read from the device a PASS result is generated. Otherwise a FAIL result is returned to the executive.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$deviceNumber\n\nInteger\n\nThe Board ID of the PMD-1208LS device\n\n\n\n$Port\n\nInteger\n\nThe DIO Port to Write\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$value\n\nInteger\n\nThe integer value of the DIO Port. Return values are 0-255.\n\n\n\n\n\nPMD_DIOPortWrite\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS PMD_DIOPortWrite": {
  "prefix": "PMD_DIOPortWrite",
  "body": [
   "PMD_DIOPortWrite($$DeviceID,$$Port,$$value);"
  ],
  "description": "\n\nThis function supports the PMD-1208LS Personal Measurement Device From Measurement Computing Corporation\n\nThis function writes the supplied value to the specified DIO Port. Before writing a value to the DIO port, it first must be configured as an OUTPUT port using the PMD_DIOConfigDigitalPort function. In the event that a value is successfully written to the device a PASS result is generated. Otherwise a FAIL result is returned to the executive.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$deviceNumber\n\nInteger\n\nThe Board ID of the PMD-1208LS device\n\n\n\n$Port\n\nInteger\n\nThe DIO Port to Write\n\n\n\n$value\n\nString\n\nA hexidecimal string indicating the value to write to the port. Valid values are \"00\" to \"FF\"\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nPMD_FlashLED\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS PMD_FlashLED": {
  "prefix": "PMD_FlashLED",
  "body": [
   "PMD_FlashLED($$DeviceID);"
  ],
  "description": "\n\nThis function supports the PMD-1208LS Personal Measurement Device From Measurement Computing Corporation\n\nThis function flashes the LED of the PMD Device. This can be useful for determining which device is hooked up to a particular USB port when multiple devices are used. In the event of successful communication with the device, a PASS result is returned. In the event of unsuccessful communication, a FAIL result is returned.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$deviceNumber\n\nInteger\n\nThe Board ID of the PMD-1208LS device\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nMCC DIO-96 Port Mapping\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS MC_AnalogMeasure": {
  "prefix": "MC_AnalogMeasure",
  "body": [
   "$$measurement=MC_AnalogMeasure($$DeviceID,$$Channel,$$Range,$$BitQuantity);"
  ],
  "description": "\n\nThis function supports all Data Acquisition Devices From Measurement Computing Corporation\n\nThis function acquires an analog measurement from the D/A Convertor of the DAQ device. The raw value of the DA converter is automatically converted to a voltage measurement based on the range value supplied to the function. In the event of a successful measurement the function returns a PASS result. In the event that a hardware problem occurs, a FAIL result is returned to the executive.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$deviceNumber\n\nInteger\n\nThe Board ID of the DAQ device\n\n\n\n$Channel\n\nInteger\n\nThe channel to for an analog measurement.\n\n\n\n$Range\n\nString\n\nThe measurement range for the D/A converter. For single-ended configuration, the only valid range is \"Bip10Volts\". For differential measurements, the valid values are:\n\n\u00b7 \"Bip20Volts\" = +/- 20 Volts\n\n\u00b7 \"Bip10Volts\" = +/- 10 Volts\n\n\u00b7 \"Bip5Volts\" = +/- 5 Volts\n\n\u00b7 \"Bip4Volts\" = +/- 4 Volts\n\n\u00b7 \"Bip2Pt5Volts\" = +/- 2.5 Volts\n\n\u00b7 \"Bip2Volts\" = +/- 2 Volts\n\n\u00b7 \"Bip1Pt25Volts\" = +/- 1.25 Volts\n\n\u00b7 \"Bip2Volts\" = +/- 2 Volts\n\n\u00b7 \"Bip1Pt25Volts\" = +/- 1.25 Volts\n\n\u00b7 \"Bip1Volts' = +/- 1 Volts\n\n\u00b7 \"BipPt625Volts\" = +/- 0.625 Volts\n\n\u00b7 \"BipPt5Volts\" = +/- 0.5 Volts\n\n\u00b7 \"BipPt25Volts\" = +/- 0.25 Volts\n\n\u00b7 \"BipPt2Volts\" = +/- 0.20 Volts\n\n\u00b7 \"BipPt1Volts\" = +/- 0.10 Volts\n\n\u00b7 \"BipPt05Volts\" = +/- 0.05 Volts\n\n\u00b7 \"BipPt01Volts\" = +/- 0.01 Volts\n\n\u00b7 \"BipPt005Volts\" = +/- 0.005 Volts\n\n\u00b7 \"Bip1Pt67Volts\" = +/- 1.67 Volts\n\n\u00b7 \"Uni10Volts\" = 0 - 10 Volts\n\n\u00b7 \"Uni5Volts\" = 0 - 5 Volts\n\n\u00b7 \"Uni2Pt5Volts\" = 0 - 2.5 Volts\n\n\u00b7 \"Uni1Volts\" = 0 - 1 Volts\n\n\u00b7 \"UniPt5Volts\" = 0 - 0.5 Volts\n\n\u00b7 \"UniPt25Volts\" = 0 - 0.25 Volts\n\n\u00b7 \"UniPt2Volts\" = 0 - 0.2 Volts\n\n\u00b7 \"UniPt1Volts\" = 0 - 0.1 Volts\n\n\u00b7 \"UniPt01Volts\" = 0 - 0.01 Volts\n\n\u00b7 \"UniPt02Volts\" = 0 - 0.02 Volts\n\n\u00b7 \"UniPt05Volts\" = 0 - 0.05 Volts\n\n\n\n$BitQuantity\n\nInteger\n\nThe Number of bits according to your board (8,12,14 or 16).\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$measurement\n\nFloat\n\nThe measurement in Volts computed by taking the raw output of the A/D convertor and comparing to the measurement range specified in the function call.\n\n\n\n\n\nMC_AnalogOut\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS MC_AnalogOut": {
  "prefix": "MC_AnalogOut",
  "body": [
   "MC_AnalogOut($$DeviceID,$$Channel,$$Range,$$DACValue);"
  ],
  "description": "\n\nThis function supports all Data Acquisition Devices From Measurement Computing Corporation\n\nThis function writes an analog voltage to the D/A Convertor of the DAQ device. The $Range specifies the scaling for the A/D convertor. The $DACValue is an integer value between 0-1023 that specifies the value written to the A/D register.\n\nExample:\n\nMC_AnalogOut(1,1,\"Uni5Volts\",1023); // Sets Channel 1 of Unit 1 to 5 volts\n\nMC_AnalogOut(1,1,\"Uni5Volts\",0); // Sets Channel 1 of Unit 1 to 0 volts\n\nMC_AnalogOut(1,1,\"Uni5Volts\",512); // Sets Channel 1 of Unit 1 to 2.5 volts\n\nIn the event of that the DAC value is set successfully the function returns a PASS result. In the event that a hardware problem occurs, a FAIL result is returned to the executive.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$deviceNumber\n\nInteger\n\nThe Board ID of the DAQ device\n\n\n\n$Channel\n\nInteger\n\nThe channel to for an analog measurement.\n\n\n\n$Range\n\nString\n\nThe measurement range for the D/A converter. For single-ended configuration, the only valid range is \"Bip10Volts\". For differential measurements, the valid values are:\n\n\u00b7 \"Bip20Volts\" = +/- 20 Volts\n\n\u00b7 \"Bip10Volts\" = +/- 10 Volts\n\n\u00b7 \"Bip5Volts\" = +/- 5 Volts\n\n\u00b7 \"Bip4Volts\" = +/- 4 Volts\n\n\u00b7 \"Bip2Pt5Volts\" = +/- 2.5 Volts\n\n\u00b7 \"Bip2Volts\" = +/- 2 Volts\n\n\u00b7 \"Bip1Pt25Volts\" = +/- 1.25 Volts\n\n\u00b7 \"Bip2Volts\" = +/- 2 Volts\n\n\u00b7 \"Bip1Pt25Volts\" = +/- 1.25 Volts\n\n\u00b7 \"Bip1Volts' = +/- 1 Volts\n\n\u00b7 \"BipPt625Volts\" = +/- 0.625 Volts\n\n\u00b7 \"BipPt5Volts\" = +/- 0.5 Volts\n\n\u00b7 \"BipPt25Volts\" = +/- 0.25 Volts\n\n\u00b7 \"BipPt2Volts\" = +/- 0.20 Volts\n\n\u00b7 \"BipPt1Volts\" = +/- 0.10 Volts\n\n\u00b7 \"BipPt05Volts\" = +/- 0.05 Volts\n\n\u00b7 \"BipPt01Volts\" = +/- 0.01 Volts\n\n\u00b7 \"BipPt005Volts\" = +/- 0.005 Volts\n\n\u00b7 \"Bip1Pt67Volts\" = +/- 1.67 Volts\n\n\u00b7 \"Uni10Volts\" = 0 - 10 Volts\n\n\u00b7 \"Uni5Volts\" = 0 - 5 Volts\n\n\u00b7 \"Uni2Pt5Volts\" = 0 - 2.5 Volts\n\n\u00b7 \"Uni1Volts\" = 0 - 1 Volts\n\n\u00b7 \"UniPt5Volts\" = 0 - 0.5 Volts\n\n\u00b7 \"UniPt25Volts\" = 0 - 0.25 Volts\n\n\u00b7 \"UniPt2Volts\" = 0 - 0.2 Volts\n\n\u00b7 \"UniPt1Volts\" = 0 - 0.1 Volts\n\n\u00b7 \"UniPt01Volts\" = 0 - 0.01 Volts\n\n\u00b7 \"UniPt02Volts\" = 0 - 0.02 Volts\n\n\u00b7 \"UniPt05Volts\" = 0 - 0.05 Volts\n\n\n\n$DACValue\n\nInteger\n\nThe integer value to set the D/A output register. Valid values are 0-1023\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nMC_AnalogOutDC\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS MC_AnalogOutDC": {
  "prefix": "MC_AnalogOutDC",
  "body": [
   "MC_AnalogOutDC($$DeviceID,$$Channel,$$Range,$$DCValue);"
  ],
  "description": "\n\nThis function writes an analog voltage to the D/A Convertor of the DAQ device. The $Range specifies the scaling for the A/D convertor. The $DCValue is the wanted DC output.\n\nExample:\n\nMC_AnalogOutDC(1,1,\"Bip10Volts\",\"5,2\"); // Sets Channel 1 of Unit 1 to 5,2 volts\n\nMC_AnalogOutDC(1,1,\"Bip10Volts\",\"0\"); // Sets Channel 1 of Unit 1 to 0 volts\n\nMC_AnalogOutDC(1,1,\"Bip10Volts\",\"-3\"); // Sets Channel 1 of Unit 1 to -3 volts\n\nIn the event of that the DAC value is set successfully the function returns a PASS result. In the event that a hardware problem occurs, a FAIL result is returned to the executive.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$deviceNumber\n\nInteger\n\nThe Board ID of the DAQ device\n\n\n\n$Channel\n\nInteger\n\nThe channel to for an analog measurement.\n\n\n\n$Range\n\nString\n\nThe measurement range for the D/A converter. For single-ended configuration, the only valid range is \"Bip10Volts\". For differential measurements, the valid values are:\n\n\u00b7 \"Bip20Volts\" = +/- 20 Volts\n\n\u00b7 \"Bip10Volts\" = +/- 10 Volts\n\n\u00b7 \"Bip5Volts\" = +/- 5 Volts\n\n\u00b7 \"Bip4Volts\" = +/- 4 Volts\n\n\u00b7 \"Bip2Pt5Volts\" = +/- 2.5 Volts\n\n\u00b7 \"Bip2Volts\" = +/- 2 Volts\n\n\u00b7 \"Bip1Pt25Volts\" = +/- 1.25 Volts\n\n\u00b7 \"Bip2Volts\" = +/- 2 Volts\n\n\u00b7 \"Bip1Pt25Volts\" = +/- 1.25 Volts\n\n\u00b7 \"Bip1Volts' = +/- 1 Volts\n\n\u00b7 \"BipPt625Volts\" = +/- 0.625 Volts\n\n\u00b7 \"BipPt5Volts\" = +/- 0.5 Volts\n\n\u00b7 \"BipPt25Volts\" = +/- 0.25 Volts\n\n\u00b7 \"BipPt2Volts\" = +/- 0.20 Volts\n\n\u00b7 \"BipPt1Volts\" = +/- 0.10 Volts\n\n\u00b7 \"BipPt05Volts\" = +/- 0.05 Volts\n\n\u00b7 \"BipPt01Volts\" = +/- 0.01 Volts\n\n\u00b7 \"BipPt005Volts\" = +/- 0.005 Volts\n\n\u00b7 \"Bip1Pt67Volts\" = +/- 1.67 Volts\n\n\u00b7 \"Uni10Volts\" = 0 - 10 Volts\n\n\u00b7 \"Uni5Volts\" = 0 - 5 Volts\n\n\u00b7 \"Uni2Pt5Volts\" = 0 - 2.5 Volts\n\n\u00b7 \"Uni1Volts\" = 0 - 1 Volts\n\n\u00b7 \"UniPt5Volts\" = 0 - 0.5 Volts\n\n\u00b7 \"UniPt25Volts\" = 0 - 0.25 Volts\n\n\u00b7 \"UniPt2Volts\" = 0 - 0.2 Volts\n\n\u00b7 \"UniPt1Volts\" = 0 - 0.1 Volts\n\n\u00b7 \"UniPt01Volts\" = 0 - 0.01 Volts\n\n\u00b7 \"UniPt02Volts\" = 0 - 0.02 Volts\n\n\u00b7 \"UniPt05Volts\" = 0 - 0.05 Volts\n\n\n\n$DCValue\n\nString\n\nThe value to set the D/A output.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nMC_AnalogScanInput\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS MC_AnalogScanInput": {
  "prefix": "MC_AnalogScanInput",
  "body": [
   "($$RMS,$$ACRMS,$$TT,$$Mean)=MC_AnalogScanInput($$DeviceID,$$Channel,$$Range,$$qntBit,$$scanrate,$$nbrpoints);"
  ],
  "description": "\n\nThis function takes a number of samples from a channel, and calculates the RMS,ACRMS,PTP and Mean value. This function can be used on DC measurements and on sine wave signals.\n\nRemark:\n\nThis function has been written for and tested with a PCI DAS6031 board.\n\nIt should work with other boards within the same family\n\nExample:\n\n($RMS,$ACRMS,$TT,$Mean) = MC_AnalogScanInput(1,7,\"Bip10Volts\",16,320,600);\n\nIn the event of that the scan was successfully the function returns a PASS result and all of the calculated values. In the event that a hardware problem occurs, a FAIL result is returned to the executive.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$DeviceID\n\nInteger\n\nThe Board ID of the DAQ device\n\n\n\n$Channel\n\nInteger\n\nThe channel to for an analog measurement.\n\n\n\n$Range\n\nString\n\nThe measurement range for the D/A converter. For single-ended configuration, the only valid range is \"Bip10Volts\". For differential measurements, the valid values are:\n\n\u00b7 \"Bip20Volts\" = +/- 20 Volts\n\n\u00b7 \"Bip10Volts\" = +/- 10 Volts\n\n\u00b7 \"Bip5Volts\" = +/- 5 Volts\n\n\u00b7 \"Bip4Volts\" = +/- 4 Volts\n\n\u00b7 \"Bip2Pt5Volts\" = +/- 2.5 Volts\n\n\u00b7 \"Bip2Volts\" = +/- 2 Volts\n\n\u00b7 \"Bip1Pt25Volts\" = +/- 1.25 Volts\n\n\u00b7 \"Bip2Volts\" = +/- 2 Volts\n\n\u00b7 \"Bip1Pt25Volts\" = +/- 1.25 Volts\n\n\u00b7 \"Bip1Volts' = +/- 1 Volts\n\n\u00b7 \"BipPt625Volts\" = +/- 0.625 Volts\n\n\u00b7 \"BipPt5Volts\" = +/- 0.5 Volts\n\n\u00b7 \"BipPt25Volts\" = +/- 0.25 Volts\n\n\u00b7 \"BipPt2Volts\" = +/- 0.20 Volts\n\n\u00b7 \"BipPt1Volts\" = +/- 0.10 Volts\n\n\u00b7 \"BipPt05Volts\" = +/- 0.05 Volts\n\n\u00b7 \"BipPt01Volts\" = +/- 0.01 Volts\n\n\u00b7 \"BipPt005Volts\" = +/- 0.005 Volts\n\n\u00b7 \"Bip1Pt67Volts\" = +/- 1.67 Volts\n\n\u00b7 \"Uni10Volts\" = 0 - 10 Volts\n\n\u00b7 \"Uni5Volts\" = 0 - 5 Volts\n\n\u00b7 \"Uni2Pt5Volts\" = 0 - 2.5 Volts\n\n\u00b7 \"Uni1Volts\" = 0 - 1 Volts\n\n\u00b7 \"UniPt5Volts\" = 0 - 0.5 Volts\n\n\u00b7 \"UniPt25Volts\" = 0 - 0.25 Volts\n\n\u00b7 \"UniPt2Volts\" = 0 - 0.2 Volts\n\n\u00b7 \"UniPt1Volts\" = 0 - 0.1 Volts\n\n\u00b7 \"UniPt01Volts\" = 0 - 0.01 Volts\n\n\u00b7 \"UniPt02Volts\" = 0 - 0.02 Volts\n\n\u00b7 \"UniPt05Volts\" = 0 - 0.05 Volts\n\n\n\n$qntBit\n\nInteger\n\nThe number of bits of the board:8,11,12 and 16 allowed.\n\n\n\n$scanrate\n\nInteger\n\nThe rate of the samples to take.Refer to board specs\n\n\n\n$nbrpoints\n\nInteger\n\nHow many samples should be taken on the channel.Refer to board specs\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$RMS\n\nFloat\n\nRMS over the samples taken\n\n\n\n$ACRMS\n\nFloat\n\nACRMS over the samples taken\n\n\n\n$TT\n\nFloat\n\nTop Top value over the samples taken\n\n\n\n$Mean\n\nFloat\n\nAverage value over the samples taken\n\n\n\n\n\nMC_ConfigDigitalBit\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS MC_ConfigDigitalBit": {
  "prefix": "MC_ConfigDigitalBit",
  "body": [
   "MC_ConfigDigitalBit($$DeviceID,$$Port,$$Bit,$$Direction);"
  ],
  "description": "\n\nPlease See the linked spreadsheet which explains the Measurement computing DIO port mapping: MCC DIO-96 Port Mapping.\n\nIn case you use a PCI multi IO A/D D/A with an AuxPort: example PCI-DAS6031, then you can simple select the Port to be 0\n\nThis function is NOT supported by 8255 type DIO ports. Refer to the board-specific information for details.\n\nThis function configures the specified DIO bit direction for Measurement Computing Data Acquisition devices. Only works for ports with individually configurable bits; see MC_ConfigDigitalPort for 8255 type DIO ports. In the event of a successful configuration, a PASS result is returned. Otherwise a FAIL result is generated.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$DeviceID\n\nInteger\n\nThe Board ID of the Measurement Computing Device\n\n\n\n$Port\n\nInteger\n\nThe DIO Port to Configure\n\n\n\n$Bit\n\nInteger\n\nThe DIO Bit to Configure\n\n\n\n$Direction\n\nString\n\nThe direction of the DIO port; Allowable values are:\n\n\u00b7 \"INPUT\"\n\n\u00b7 \"OUTPUT\"\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nMC_ConfigDigitalBitBool\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS MC_ConfigDigitalBitBool": {
  "prefix": "MC_ConfigDigitalBitBool",
  "body": [
   "$$success=MC_ConfigDigitalBitBool($$deviceNumber,$$portNumber,$$bitNumber,$$direction);"
  ],
  "description": "\n\nThis function will configure the specified bit on the DIO port direction for a Measurement Computing Data Acquisition device.\n\n\n\n\n\nRemarks:\n\nThis function will not fail a test step. Instead it will return pass/fail through the $success boolean.\n\nPlease see MCC DIO-96 Port Mapping for the port mapping.\n\nThis function is not supported by 8255 type DIO ports. Refer to the board-specific information for details.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$deviceNumber\n\nInteger\n\nThe Board ID of the Measurement Computing device.\n\n\n\n$portNumber\n\nInteger\n\nThe DIO port to configure.\n\n\n\n$bitNumber\n\nInteger\n\nThe number of the bit on the DIO port to configure.\n\n\n\n$direction\n\nString\n\nThe direction of the DIO port. Valid entries are:\n\n\u00b7 INPUT\n\n\u00b7 OUTPUT\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$success\n\nBoolean\n\nTrue if the configuration was successful and False otherwise.\n\n\n\n\n\nExample:\n\n// Configure a bit for output\n\n$deviceNumber = 7;\n\n$portNumber = 0;\n\n$bitNumber = 3;\n\n$direction = \"OUTPUT\";\n\n\n\n\n\n$success = MC_ConfigDigitalBitBool($deviceNumber, $portNumber, $bitNumber, $direction);\n\n\n\n\n\nMC_ConfigDigitalPort\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS MC_ConfigDigitalPort": {
  "prefix": "MC_ConfigDigitalPort",
  "body": [
   "MC_ConfigDigitalPort($$DeviceID,$$Port,$$Direction);"
  ],
  "description": "\n\nPlease See the linked spreadsheet which explains the Measurement computing DIO port mapping: MCDIOMapping.xls\n\nIn case you use a PCI multi IO A/D D/A with an AuxPort: example PCI-DAS6031, then you can simple select the Port to be 0\n\nThis function supports all Data Acquisition Products From Measurement Computing Corporation\n\nThis function configures the specified DIO port direction for Measurement Computing Data Acquisition device. In the event of a successful configuration, a PASS result is returned. Otherwise a FAIL result is generated.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$deviceNumber\n\nInteger\n\nThe Board ID of the Measurement Computing Device\n\n\n\n$Port\n\nInteger\n\nThe DIO Port to Configure\n\n\n\n$Direction\n\nString\n\nThe direction of the DIO port. Allowable Values are:\n\n\"INPUT\"\n\n\"OUTPUT\"\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nMC_ConfigDigitalPortBool\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS MC_ConfigDigitalPortBool": {
  "prefix": "MC_ConfigDigitalPortBool",
  "body": [
   "$$success=MC_ConfigDigitalPortBool($$deviceNumber,$$portNumber,$$direction);"
  ],
  "description": "\n\nThis function will configure the specified DIO port direction for a Measurement Computing Data Acquisition device.\n\n\n\n\n\nRemarks:\n\nThis function will not fail a test step. Instead it will return pass/fail through the $success boolean.\n\nPlease see MCC DIO-96 Port Mapping for the port mapping.\n\nIf you have a PCI multi IO A/D D/A with an AuxPort (like the PCI-DAS6031), you can only select Port 0.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$deviceNumber\n\nInteger\n\nThe Board ID of the Measurement Computing device.\n\n\n\n$portNumber\n\nInteger\n\nThe DIO port to configure.\n\n\n\n$direction\n\nString\n\nThe direction of the DIO port. Valid entries are:\n\n\u00b7 INPUT\n\n\u00b7 OUTPUT\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$success\n\nBoolean\n\nTrue if the configuration was successful and False otherwise.\n\n\n\n\n\nExample:\n\n// Configure a port for output\n\n$deviceNumber = 7;\n\n$portNumber = 0;\n\n$direction = \"OUTPUT\";\n\n\n\n\n\n$success = MC_ConfigDigitalPortBool($deviceNumber, $portNumber, $direction);\n\n\n\n\n\nMC_DIOBitRead\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS MC_DIOBitRead": {
  "prefix": "MC_DIOBitRead",
  "body": [
   "$$value=MC_DIOBitRead($$DeviceID,$$Port,$$BitNumber);"
  ],
  "description": "\n\nThis function supports all Data Acquisition cards From Measurement Computing Corporation\n\nPlease See the linked spreadsheet which explains the Measurement computing DIO port mapping: MCDIOMapping.xls\n\n\n\nThis function reads the present value of a particular bit on the DIO Port from the DAQ device.\n\nBefore reading a value from the DIO port bit, it first must be configured as an INPUT port using the MC_ConfigDigitalBit function. In the event that a value is successfully read from the device a PASS result is generated. Otherwise a FAIL result is returned to the executive.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$deviceNumber\n\nInteger\n\nThe Board ID of the DAQ device\n\n\n\n$Port\n\nInteger\n\nThe DIO Port to Write\n\n\n\n$BitNumber\n\nInteger\n\nThe particular bit of a port to read (valid values are 0-7)\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$value\n\nInteger\n\nThe integer value of the DIO Port Bit requested. Return values are 0 or 1.\n\n\n\n\n\nMC_DIOBitReadBool\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS MC_DIOBitReadBool": {
  "prefix": "MC_DIOBitReadBool",
  "body": [
   "($$value,$$success)=MC_DIOBitReadBool($$deviceNumber,$$portNumber,$$bitNumber);"
  ],
  "description": "\n\nThis function will read the present value of one bit on the DIO port of the specified DAQ device.\n\n\n\n\n\nRemarks:\n\nThis function will not fail a test step. Instead it will return pass/fail through the $success boolean.\n\nPlease see MCC DIO-96 Port Mapping for the port mapping.\n\nBefore reading the bit must be configured for input using MC_ConfigDigitalBit or MC_ConfigDigitalBitBool.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$deviceNumber\n\nInteger\n\nThe Board ID of the Measurement Computing device.\n\n\n\n$portNumber\n\nInteger\n\nThe DIO port to read from.\n\n\n\n$bitNumber\n\nInteger\n\nThe number of the bit on the DIO port to read from.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$value\n\nInteger\n\nThe integer value representing the bit value. 0 = low and 1 = high.\n\n\n\n$success\n\nBoolean\n\nTrue if the reading was successful and False otherwise.\n\n\n\n\n\nExample:\n\n// Configure a bit for input.\n\n$deviceNumber = 7;\n\n$portNumber = 0;\n\n$bitNumber = 3;\n\n$direction = \"INPUT\";\n\n\n\n\n\n$success = MC_ConfigDigitalBitBool($deviceNumber, $portNumber, $bitNumber, $direction);\n\n\n\n\n\n// Read the bit.\n\n($value, $success) = MC_DIOBitReadBool($deviceNumber, $portNumber, $bitNumber);\n\n\n\n\n\nMC_DIOBitWrite\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS MC_DIOBitWrite": {
  "prefix": "MC_DIOBitWrite",
  "body": [
   "MC_DIOBitWrite($$DeviceID,$$Port,$$BitNumber,$$value);"
  ],
  "description": "\n\nThis function supports all DAQ Devices From Measurement Computing Corporation\n\nPlease See the linked spreadsheet which explains the Measurement computing DIO port mapping: MCDIOMapping.xls\n\nThis function writes the supplied value to the specified DIO Port and Bit Number. Before writing a value to the DIO port, it first must be configured as an OUTPUT port using the MC_ConfigDigitalBit function. In the event that a value is successfully written to the device a PASS result is generated. Otherwise a FAIL result is returned to the executive.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$deviceNumber\n\nInteger\n\nThe Board ID of the DAQ device\n\n\n\n$Port\n\nInteger\n\nThe DIO Port to Write\n\n\n\n$BitNumber\n\nInteger\n\nThe Bit Number of the DIO Port to Write. Valid Values are 0-7.\n\n\n\n$value\n\nInteger\n\nA integer value indicating the value to write to the port and bit number. Valid values are 0 or 1.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nMC_DIOBitWriteBool\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS MC_DIOBitWriteBool": {
  "prefix": "MC_DIOBitWriteBool",
  "body": [
   "$$success=MC_DIOBitWriteBool($$deviceNumber,$$portNumber,$$bitNumber,$$value);"
  ],
  "description": "\n\nThis function will write a value to one bit on the DIO port of the specified DAQ device.\n\n\n\n\n\nRemarks:\n\nThis function will not fail a test step. Instead it will return pass/fail through the $success boolean.\n\nPlease see MCC DIO-96 Port Mapping for the port mapping.\n\nBefore writing the bit must be configured for output using MC_ConfigDigitalBit or MC_ConfigDigitalBitBool.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$deviceNumber\n\nInteger\n\nThe Board ID of the Measurement Computing device.\n\n\n\n$portNumber\n\nInteger\n\nThe DIO port to write to.\n\n\n\n$bitNumber\n\nInteger\n\nThe number of the bit on the DIO port to write to.\n\n\n\n$value\n\nInteger\n\nThe value representing the state to set the bit to. 0 to set the bit low and 1 to set the bit high.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$success\n\nBoolean\n\nTrue if the writing was successful and False otherwise.\n\n\n\n\n\nExample:\n\n// Configure a bit for output.\n\n$deviceNumber = 7;\n\n$portNumber = 0;\n\n$bitNumber = 3;\n\n$direction = \"OUTPUT\";\n\n\n\n\n\n$success = MC_ConfigDigitalBitBool($deviceNumber, $portNumber, $bitNumber, $direction);\n\n\n\n\n\n// Write the bit.\n\n$value = 1;\n\n$success = MC_DIOBitWriteBool($deviceNumber, $portNumber, $bitNumber, $value);\n\n\n\n\n\nMC_DIOPortRead\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS MC_DIOPortRead": {
  "prefix": "MC_DIOPortRead",
  "body": [
   "$$value=MC_DIOPortRead($$DeviceID,$$Port);"
  ],
  "description": "\n\nThis function supports all Data Acqusition Devices From Measurement Computing Corporation.\n\nPlease See the linked spreadsheet which explains the Measurement computing DIO port mapping: MCDIOMapping.xls\n\nThis function reads the present value of a DIO Port from the device.\n\nBefore reading a value from the DIO port, it first must be configured as an INPUT port using the MC_ConfigDigitalPort function. In the event that a value is successfully read from the device a PASS result is generated. Otherwise a FAIL result is returned to the executive.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$deviceNumber\n\nInteger\n\nThe Board ID of the DAQ device\n\n\n\n$Port\n\nInteger\n\nThe DIO Port to Write\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$value\n\nInteger\n\nThe integer value of the DIO Port. Return values are 0-255.\n\n\n\n\n\nMC_DIOPortReadBool\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS MC_DIOPotReadBool": {
  "prefix": "MC_DIOPotReadBool",
  "body": [
   "($$value,$$success)=MC_DIOPotReadBool($$deviceNumber,$$portNumber);"
  ],
  "description": "\n\nThis function will read the present value of one eight bit port of the specified DAQ device.\n\n\n\n\n\nRemarks:\n\nThis function will not fail a test step. Instead it will return pass/fail through the $success boolean.\n\nPlease see MCC DIO-96 Port Mapping for the port mapping.\n\nBefore reading the port must be configured for input using MC_ConfigDigitalPort or MC_ConfigDigitalPortBool.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$deviceNumber\n\nInteger\n\nThe Board ID of the Measurement Computing device.\n\n\n\n$portNumber\n\nInteger\n\nThe DIO port to read from.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$value\n\nInteger\n\nThe integer value of the DIO port. Returns values between 0 and 255.\n\n\n\n$success\n\nBoolean\n\nTrue if the reading was successful and False otherwise.\n\n\n\n\n\nExample:\n\n// Configure a port for input.\n\n$deviceNumber = 7;\n\n$portNumber = 0;\n\n$direction = \"INPUT\";\n\n\n\n\n\n$success = MC_ConfigDigitalPortBool($deviceNumber, $portNumber, $direction);\n\n\n\n\n\n// Read the bit.\n\n($value, $success) = MC_DIOPortReadBool($deviceNumber, $portNumber);\n\n\n\n\n\nMC_DIOPortWrite\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS MC_DIOPortWrite": {
  "prefix": "MC_DIOPortWrite",
  "body": [
   "MC_DIOPortWrite($$DeviceID,$$Port,$$value);"
  ],
  "description": "\n\nThis function supports all Data Acquisition Devices From Measurement Computing Corporation\n\nPlease See the linked spreadsheet which explains the Measurement computing DIO port mapping: MCDIOMapping.xls\n\nIn case you use a PCI multi IO A/D D/A with an AuxPort: example PCI-DAS6031, then you can simple select the Port to be 0\n\nThis function writes the supplied value to the specified DIO Port. Before writing a value to the DIO port, it first must be configured as an OUTPUT port using the MC_ConfigDigitalPort function. In the event that a value is successfully written to the device a PASS result is generated. Otherwise a FAIL result is returned to the executive.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$deviceNumber\n\nInteger\n\nThe Board ID of the DAQ device\n\n\n\n$Port\n\nInteger\n\nThe DIO Port to Write\n\n\n\n$value\n\nString\n\nA hexidecimal string indicating the value to write to the port. Valid values are \"00\" to \"FF\"\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nMC_DIOPortWriteBool\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS MC_DIOPortWriteBool": {
  "prefix": "MC_DIOPortWriteBool",
  "body": [
   "$$success=MC_DIOPortWriteBool($$deviceNumber,$$portNumber,$$value);"
  ],
  "description": "\n\nThis function will write a value to one port on the specified DAQ device.\n\n\n\n\n\nRemarks:\n\nThis function will not fail a test step. Instead it will return pass/fail through the $success boolean.\n\nPlease see MCC DIO-96 Port Mapping for the port mapping.\n\nBefore writing the port must be configured for output using MC_ConfigDigitalPort or MC_ConfigDigitalPortBool.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$deviceNumber\n\nInteger\n\nThe Board ID of the Measurement Computing device.\n\n\n\n$portNumber\n\nInteger\n\nThe DIO port to write to.\n\n\n\n$value\n\nInteger\n\nThe value to set the port to. Valid values are between 0 and 255.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$success\n\nBoolean\n\nTrue if the writing was successful and False otherwise.\n\n\n\n\n\nExample:\n\n// Configure a port for output.\n\n$deviceNumber = 7;\n\n$portNumber = 0;\n\n$direction = \"OUTPUT\";\n\n\n\n\n\n$success = MC_ConfigDigitalPortBool($deviceNumber, $portNumber, $direction);\n\n\n\n\n\n// Write to the port.\n\n$value = 67;\n\n$success = MC_DIOPortWriteBool($deviceNumber, $portNumber, $value);\n\n\n\n\n\nMC_Diff_or_Single\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS MC_Diff_or_Single": {
  "prefix": "MC_Diff_or_Single",
  "body": [
   "MC_Diff_or_Single($$DeviceID,$$ChnQnt);"
  ],
  "description": "\n\nSets the number of A/D channels on the board Check board specific info for valid numbers Note that this settings affects the single-ended/differential input mode of boards for which this setting is programmable.\n\nIn the event of a successful configuration, a PASS result is returned. Otherwise a FAIL result is generated.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$DeviceID\n\nInteger\n\nThe Board ID of the Measurement Computing Device\n\n\n\n$ChnQnt\n\nInteger\n\nThe number of A/D channels on the board to set\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nNIDSA_ConfigSource\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NIDSA_ConfigSource": {
  "prefix": "NIDSA_ConfigSource",
  "body": [
   "NIDSA_ConfigSource($$DeviceID,$$Frequency,$$Amplitude);"
  ],
  "description": "\n\nThis function will configure a sine output from the DSA card.\n\nRemark:\n\nThis function has been written for and tested with a NI 4551 DSA board.\n\nIt should work with other boards within the same family\n\nExample:\n\nNIDSA_ConfigSource(1, 920.0, 0.500);\n\n\n\n\n\nIn the event of that the scan was successfully the function returns a PASS result and all of the calculated values. In the event that a hardware problem occurs, a FAIL result is returned to the executive.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$DeviceID\n\nInteger\n\nThe Board ID of the DAQ device\n\n\n\n$Frequency\n\nDouble\n\nThe output frequency.\n\n\n\n$Amplitude\n\nDouble\n\nThe output amplitude in volts peak to peak.\n\n\n\n\n\nNIDSA_Init\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NIDSA_Init": {
  "prefix": "NIDSA_Init",
  "body": [
   "NIDSA_Init($$DeviceID);"
  ],
  "description": "\n\nThis function initializes the DSA card.\n\nRemark:\n\nThis function has been written for and tested with a NI 4551 DSA board.\n\nIt should work with other boards within the same family\n\nExample:\n\nNIDSA_Init(1);\n\nIn the event of that the scan was successfully the function returns a PASS result and all of the calculated values. In the event that a hardware problem occurs, a FAIL result is returned to the executive.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$DeviceID\n\nInteger\n\nThe Board ID of the DAQ device\n\n\n\n\n\nNIDSA_MeasTHD\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NIDSA_MeasTHD": {
  "prefix": "NIDSA_MeasTHD",
  "body": [
   "$$Power=NIDSA_MeasTHD($$DeviceID,$$Channel,$$DbUnits);"
  ],
  "description": "\n\nThis function measures the Total Harmonic Distortion and returns the Fundamental frequency power level.\n\nRemark:\n\nThis function has been written for and tested with a NI 4551 DSA board.\n\nIt should work with other boards within the same family\n\nExample:\n\n$Power = NIDSA_MeasTHD(1, 0, 1);\n\nIn the event of that the scan was successfully the function returns a PASS result and all of the calculated values. In the event that a hardware problem occurs, a FAIL result is returned to the executive.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$DeviceID\n\nInteger\n\nThe Board ID of the DAQ device\n\n\n\n$Channel\n\nInteger\n\nThe channel to for an analog measurement.\n\n\n\n$DbUnits\n\nInteger\n\nWill power be measured in dB unit, 1 will set dB units on.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Power\n\nFloat\n\nThe measured power of the fundamental frequency\n\n\n\n\n\nNI_DAQmx_CounterReadFreq\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_DAQmx_CounterReadFreq": {
  "prefix": "NI_DAQmx_CounterReadFreq",
  "body": [
   "$$Results=NI_DAQmx_CounterReadFreq($$CounterDeviceName,$$Edge,$$MinRange,$$MaxRange,$$Time,$$Qnt,$$TaskName);"
  ],
  "description": "\n\nThis function requires NI-DAQmx 9.4 or later to be installed on the system.\n\nThis function measures a TTL signal (sine, square,saw ) and calculates its frequency. This function is used to measure higher frequencies using the internal timebase.\n\nRemarks:\n\nThis function is tested with NI-PCI-6221, and NI-PCI-6625 This function checks if the user has used a correct parameter for $CounterDeviceName.\n\nMethod used: \"Measure High frequencies with two counters . This method is mainly used for higher frequencies using two counter method. In this method, you route a pulse of known duration to the gate of a counter. This is internally generated with a second counter.\" You should only apply the signal to be measured onto the Source input of your selected counter.\n\nDue to the chosen measurement method you should always take at least 2 measurements and ignore always the first one .\n\nResult: Function Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$CounterDeviceName\n\nString\n\nThe NI DAQmx Device Name + CounterChannel you want to use.\n\n\n\n$Edge\n\nint\n\n0=Falling 1 = Rising. Unknown results in falling\n\n\n\n$MinRange\n\nString\n\nThe minimum expected value.\n\n\n\n$MaxRange\n\nString\n\nThe maximum expected value.\n\n\n\n$Time\n\nString\n\nThe Time the measurement may take, the higher the more accuracy.\n\n\n\n\n\n$Qnt\n\nint\n\nThe number of readings to return\n\n\n\n$TaskName\n\nString\n\nThe name of the measurement task to be performed. Each NIDAQmx task that occurs in parallel should have a unique name. Jabil Test automatically appends the cell number to the supplied task name in the script to guarantee uniqueness when a test script is executed on multiple threads.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Result\n\nArray\n\nThe measurements in Hz.\n\n\n\n\n\nExamples:\n\n$HelloTest = NI_DAQmx_CounterReadFreq(\"Dev2/ctr0\",1,\"10000\",\"20000\",\"0.5\",2,\"TaskName\");\n\nMeasure: on counter 0 of device 2, Rising edge detection,10Khz min, 20Khz max, 0.5 seconds time, 2 values returned.\n\nYou can now use the following function to retreive your measurements\n\n$Testme = ArrayGetValue($HelloTest,0,1); This will take the second element out of the array and return it\n\n\n\n\n\nNI_DAQmx_CounterReadFreqPFIx\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_DAQmx_CounterReadFreqPFIx": {
  "prefix": "NI_DAQmx_CounterReadFreqPFIx",
  "body": [
   "$$ResultsArray=NI_DAQmx_CounterReadFreqPFIx($$CounterDeviceName,$$Edge,$$MinRange,$$MaxRange,$$Time,$$Qnt,$$PFIx,$$TaskName);"
  ],
  "description": "\n\nThis function measures a TTL signal and calculates its frequency. This function is used to measure higher frequencies using the internal timebase.\n\n\n\nRemarks:\n\nThis function requires NI-DAQmx 9.4 or later to be installed on the system.\n\nThis function is tested with NI-PXI-6723. This function checks if the user has used a correct parameter for $CounterDeviceName.\n\nMethod used: \"Measure High frequencies with two counters. This method is mainly used for higher frequencies using two counter method. In this method, you route a pulse of known duration to the gate of a counter. This is internally generated with a second counter.\" You should only apply the signal to be measured onto the Source input of your selected counter.\n\nDue to the chosen measurement method you should always take at least 2 measurements and ignore the first one.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$CounterDeviceName\n\nString\n\nThe NI-DAQmx Device Name including the name of the counter that will be used for pulse generation.\n\n\n\n$Edge\n\nInteger\n\nThe Edge the counter will trigger on.\n\n0 = Falling (generates unknown results)\n\n1 = Rising\n\n\n\n$MinRange\n\nString\n\nThe minimum expected value based on the DAQmx channel setting. Eg. if the device reads -10V to +10V, $MinRange = -10 (if there is no scaling applied to the channel), regardless of the what the measured signal levels are.\n\n\n\n$MaxRange\n\nString\n\nThe maximum expected value based on the DAQmx device setting.\n\n\n\n$Time\n\nString\n\nThe time the measurement may take, the higher - the more accuracy.\n\n\n\n$Qnt\n\nInteger\n\nThe number of readings to return.\n\n\n\n$PFIx\n\nString\n\nThe Counter channel used for the measurement.\n\n\n\n$TaskName\n\nString\n\nThe name of the measurement task to be performed. Each NIDAQmx task that occurs in parallel should have a unique name. Jabil Test automatically appends the cell number to the supplied task name in the script to guarantee uniqueness when a test script is executed on multiple threads.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Result\n\nArray\n\nThe measurements in Hz.\n\n\n\n\n\nExample:\n\n$CounterDeviceName = \"PXI1Slot9/ctr0\";\n\n$Edge = 1; //rising edge\n\n$MinRange = \"0\";\n\n$MaxRange = \"1000.0\"; // Channel is scaled to 0 to 1000.\n\n$Time = \"5\"; // 5 seconds\n\n$Qnt = 2; // return 1 reading\n\n$PFIx = \"PFI0\";\n\n\n\n\n\n$ResultsArray = NI_DAQmx_CounterReadFreqPFIx($CounterDeviceName, $Edge, $MinRange, $MaxRange, $Time, $Qnt, $PFIx, \"MyTask\");\n\n\n\n\n\n$Frequency = Array1DGetValue($ResultsArray, 1); // Ignore first reading\n\n\n\n\n\nNI_DAQmx_CounterReadPulseWidth\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_DAQmx_CounterReadPulseWidth": {
  "prefix": "NI_DAQmx_CounterReadPulseWidth",
  "body": [
   "$$Result=NI_DAQmx_CounterReadPulseWidth($$CounterName,$$Edge,$$MinRange,$$MaxRange,$$NumMeasure,$$TaskName);"
  ],
  "description": "\n\nThis function requires NI-DAQmx 9.4 or later to be installed on the system.\n\n\n\nThis function measures a TTL signal (sine, square,saw ) and returns the pulse width.\n\n\n\n\n\nRemarks:\n\n\u00b7 This function was tested with: NI-6225 simulated DAQ.\n\n\n\n\n\n\u00b7 This function will return an number of measurements in an array. The first measurements may not be accurate and should be discarded.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$CounterName\n\nString\n\nThe name of the counter on the DAQ card. Example: Dev2/ctr0\n\n\n\n$Edge\n\nString\n\nThe edge of the waveform to start measurements from.\n\nValue: Rising, Falling\n\n\n\n$MinRange\n\nString\n\nThe minimum expected value.\n\n\n\n$MaxRange\n\nString\n\nThe maximum expected value.\n\n\n\n$NumMeasure\n\nInteger\n\nThe number of measurements to return.\n\n\n\n$TaskName\n\nString\n\nThe name of the measurement task to be performed. Each NI-DAQmx task that occurs in parallel should have a unique name. Jabil Test automatically appends the cell number to the supplied task name in the script to guarantee uniqueness when a test script is executed on multiple threads.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Result\n\nArray\n\nThe configured number of measurements in seconds.\n\n\n\n\n\nExample:\n\n// Build array to hold 3 results returned.\n\n$Results = Array1DCreate(\"FLOAT\", 3);\n\n$CounterName = \"Dev1/ctr0\";\n\n$Edge = \"Rising\";\n\n$MinRange = \"0.002\";\n\n$MaxRange = \"0.020\";\n\n$NumMeasure = 3;\n\n$TaskName = \"PTrainWidth\";\n\n\n\n\n\n$Results = NI_DAQmx_CounterReadPulseWidth($CounterName, $Edge, $MinRange, $MaxRange, $NumMeasure, $TaskName);\n\n\n\n\n\nNI_DAQmx_DeleteTask\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_DAQmx_DeleteTask": {
  "prefix": "NI_DAQmx_DeleteTask",
  "body": [
   "NI_DAQmx_DeleteTask($$TaskName);"
  ],
  "description": "\n\n\n\n\n\nThis function will delete a currently executing task across any NIDAQmx compatible DAQ device on the local system. If the requested task doesn't exist, the function will generate a failure. It's possible to retrieve a list of all currently executing tasks using the NI_DAQmx_ShowAllTasks script command.\n\n\n\n\n\nThis function requires NI-DAQmx 9.4 or later to be installed on the system.\n\n\n\n\n\nSpecial Notes:\n\nThe majority of tasks created by single use functions such as NI_DAQmx_MeasureVoltageAC and similiar functions automatically dispose of the task after execution has completed.\n\n\n\n\n\nAlso, take note that Jabil Test automatically appends the cell number at the end of any created NIDAQmx tasks to ensure that task names are unique across test cells so that the script developer doesn't need to address this concern when developing multi-cell tests.\n\nFor instance, if a task name such as 'DoSomething' is created, on cell 1 the task would be named 'DoSomething1', and on cell 2 it would be named 'DoSomething2', etc.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$TaskName\n\nString\n\nThe name of the NIDAQmx task to delete.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\nNI_DAQmx_DeleteTask(\"MyTask1\");\n\n\n\n\n\nNI_DAQmx_GenerateSinusWave\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_DAQmx_GenerateSinusWave": {
  "prefix": "NI_DAQmx_GenerateSinusWave",
  "body": [
   "NI_DAQmx_GenerateSinusWave($$deviceName,$$analogOutputChannel,$$minimumRange,$$maximumRange,$$frequency,$$cyclesPerBuffer,$$samplesPerBuffer,$$amplitude);"
  ],
  "description": "\n\nThis function generates a sinusoidal wave on the selected analog output $analogOutputChannel of device $deviceName with the user defined settings. You only can generate a sinusoidal wave on 1 analog output at a time.\n\nYou can execute this function several times after each other, but when you use another output, the sinusoidal wave on the previous output will disappear.\n\n\n\nRemarks:\n\nThis function requires NI-DAQmx 9.4 or later to be installed on the system.\n\nThis function was tested with NI-PCI-6221.\n\nThis function requires a DAQ device with internal memory and processing. Devices known to not work are the USB-6008 and USB-6009.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$deviceName\n\nString\n\nThe NI-DAQmx device name you want to use. You can find this in the Measurement and Automation Explorer (MAX).\n\n\n\n$analogOutputChannel\n\nString\n\nThe analog output channel of the device where you want to have the sine wave.\n\n\n\n$minimumRange\n\nFloat\n\nThe minimum value in volts that you expect to generate.\n\n\n\n$maximumRange\n\nFloat\n\nThe maximum value of the generated sine wave.\n\n\n\n$frequency\n\nFloat\n\nThe frequency of the generated sine wave.\n\n\n\n$cyclesPerBuffer\n\nFloat\n\nThe number of cycles per sample.\n\n\n\n$samplesPerBuffer\n\nFloat\n\nThe number of samples to generate.\n\n\n\n$amplitude\n\nFloat\n\nThe peak to peak value of the generated sine wave.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n\n\n\n\n// This example generates a sine wave of 2Vpkpk and a frequency of 1250Hz on Dev1/Ao0.\n\n$device = \"Dev1\";\n\n$aoChan = \"ao0\";\n\n$minRange = -10.0;\n\n$maxRange = 10.0;\n\n$freq = 1250.0;\n\n$cycles = 5.0;\n\n$samples = 1000.0;\n\n$amplitude = 2.0;\n\nNI_DAQmx_GenerateSinusWave($device, $aoChan, $minRange, $maxRange, $freq, $cycles, $samples, $amplitude);\n\n\n\n\n\nNI_DAQmx_GenerateSinusWaveWithOffset\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_DAQmx_GenerateSinusWaveWithOffset": {
  "prefix": "NI_DAQmx_GenerateSinusWaveWithOffset",
  "body": [
   "NI_DAQmx_GenerateSinusWaveWithOffset($$deviceName,$$analogOutputChannel,$$minimumRange,$$maximumRange,$$frequency,$$cyclesPerBuffer,$$samplesPerBuffer,$$amplitude,$$dcOffset);"
  ],
  "description": "\n\nThis function generates a sinusoidal wave on the selected analog output $analogOutputChannel of device $deviceName with the user defined settings.\n\n\n\n\n\nRemarks:\n\nThis function requires NI-DAQmx 9.4 or later to be installed on the system.\n\nYou only can generate a sinusoidal wave on 1 analog output at a time. You can execute this function several times after each other, but when you use another output, the sinusoidal wave on the previous output will disappear.\n\nThis function was tested with NI-PXI-6723.\n\nThis function requires a DAQ device with internal memory and processing. Devices known to not work are the USB-6008 and USB-6009.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$deviceName\n\nString\n\nThe NI-DAQmx device name you want to use. You can find this in the Measurement and Automation Explorer (MAX).\n\n\n\n$analogOutputChannel\n\nString\n\nThe analog output channel of the device on which to generate the sine wave.\n\n\n\n$minimumRange\n\nFloat\n\nThe minimum output value based on the DAQmx channel setting. Eg. if the device outputs 0V to +10V, $MinimumRange = 0 (if there is no scaling applied to the channel), regardless of the what the amplitude and offset levels are.\n\n\n\n$maximumRange\n\nFloat\n\nThe maximum output value based on the DAQmx device setting.\n\n\n\n$frequency\n\nFloat\n\nThe frequency of the generated sine wave.\n\n\n\n$cyclesPerBuffer\n\nFloat\n\nThe number of cycles per sample.\n\n\n\n$samplesPerBuffer\n\nFloat\n\nThe number of samples to generate.\n\n\n\n$amplitude\n\nFloat\n\nThe peak-to-peak amplitude of the sine wave.\n\n\n\n$dcOffset\n\nFloat\n\nThe DC offset value of the generated sine wave.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n\n\n\n\n// This example generates a sine wave with a frequency of 5000Hz on PXI1, Slot 13, ao0.\n\n$device = \"PXI1Slot13\";\n\n$aoChan = \"ao0\";\n\n$minRange = -10.0;\n\n$maxRange = 10.0; // Channel scaled to -10 to +10.\n\n$freq = 5000.0; // 5 kHz.\n\n$cycles = 5.0; // 5 cycles per buffer.\n\n$samples = 10.0;\n\n$amplit = 4.5;\n\n$dcOffset = 0.0;\n\nNI_DAQmx_GenerateSinusWaveWithOffset($device, $aoChan, $minRange, $maxRange, $freq, $cycles, $samples, $amplit, $dcOffset);\n\n\n\n\n\nNI_DAQmx_GenerateSquareWaveWithOffset\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_DAQmx_GenerateSquareWaveWithOffset": {
  "prefix": "NI_DAQmx_GenerateSquareWaveWithOffset",
  "body": [
   "NI_DAQmx_GenerateSquareWaveWithOffset($$deviceName,$$analogOutputChannel,$$minimumRange,$$maximumRange,$$frequency,$$cyclesPerBuffer,$$samplesPerBuffer,$$amplitude,$$dcOffset);"
  ],
  "description": "\n\nThis function generates a square wave on the selected analog output $analogOutputChannel of device $deviceName with the user defined settings.\n\n\n\n\n\nRemarks:\n\nThis function requires NI-DAQmx 9.4 or later to be installed on the system.\n\nYou only can generate a square wave on 1 analog output at a time. You can execute this function several times after each other, but when you use another output, the square wave on the previous output will disappear.\n\nThis function was tested with NI-PXI-6723.\n\nThis function requires a DAQ device with internal memory and processing. Devices known to not work are the USB-6008 and USB-6009.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$deviceName\n\nString\n\nThe NI-DAQmx device name you want to use. You can find this in the Measurement and Automation Explorer (MAX).\n\n\n\n$analogOutputChannel\n\nString\n\nThe analog output channel of the device on which to generate the square wave.\n\n\n\n$minimumRange\n\nFloat\n\nThe minimum output value based on the DAQmx channel setting. Eg. if the device outputs 0V to +10V, $MinimumRange = 0 (if there is no scaling applied to the channel), regardless of the what the amplitude and offset levels are.\n\n\n\n$maximumRange\n\nFloat\n\nThe maximum output value based on the DAQmx device setting.\n\n\n\n$frequency\n\nFloat\n\nThe frequency of the generated square wave.\n\n\n\n$cyclesPerBuffer\n\nFloat\n\nThe number of cycles per sample.\n\n\n\n$samplesPerBuffer\n\nFloat\n\nThe number of samples to generate.\n\n\n\n$amplitude\n\nFloat\n\nThe peak-to-peak amplitude of the generated square wave.\n\n\n\n$dcOffset\n\nFloat\n\nThe DC offset value of the generated square wave.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n\n\n\n\n// This example generates a square wave with a frequency of 5000Hz on PXI1, Slot 13, ao0.\n\n$device = \"PXI1Slot13\";\n\n$aoChan = \"ao0\";\n\n$minRange = -10.0;\n\n$maxRange = 10.0; // Channel scaled to -10 to +10.\n\n$freq = 5000.0; // 5 kHz.\n\n$cycles = 5.0; // 5 cycles per buffer.\n\n$samples = 10.0;\n\n$amplit = 4.5;\n\n$dcOffset = 0.0;\n\nNI_DAQmx_GenerateSquareWaveWithOffset($device, $aoChan, $minRange, $maxRange, $freq, $cycles, $samples, $smplit, $dcOffset);\n\n\n\n\n\nNI_DAQmx_Generate_Dig_Pulse_Train\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_DAQmx_Generate_Dig_Pulse_Train": {
  "prefix": "NI_DAQmx_Generate_Dig_Pulse_Train",
  "body": [
   "NI_DAQmx_Generate_Dig_Pulse_Train($$DeviceName,$$Counter,$$Frequency,$$DutyCycle,$$IdleState,$$FirstPulseDelay);"
  ],
  "description": "\n\nThis function requires NI-DAQmx 9.4 or later to be installed on the system.\n\nThis function generates a digital pulse train on the counter output $Counter of device $DeviceName with a frequency $Frequency and duty cycle $DutyCycle. $IdleState specifies the resting state of the output terminal.\n\n\n\n\n\nRemarks:\n\n\n\nThis function is tested with NI-PCI-6221 and NI-PCI-MIO-16E-4\n\nThis function checks if the user has used a correct parameter for $DeviceName\n\nThis function checks if the user has used a correct parameter for $Channel\n\nThis function checks if the user has used a correct parameter for $InputConfig\n\n\n\n\n\nResult:\n\nNI_DAQmx_Generate_Dig_Pulse_Train($DeviceName, $Counter, $Frequency, $DutyCycle, $IdleState, $FirstPulseDelay);\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$DeviceName\n\nString\n\nThe NI DAQmx device name you want to use.\n\n\n\n$Counter\n\nString\n\nThe NI DAQmx counter channel where the pulse train will appear.\n\n\n\n$Frequency\n\nFloat\n\nThe frequency of the pulse to generate.\n\n\n\n$DutyCycle\n\nFloat\n\nThe width of the pulse divided by period. NI-DAQmx uses this ratio, combined with frequency, to determine both pulse width and the interval between pulses.\n\n\n\n$IdleState\n\nInteger\n\nThe resting state of the output terminal.\n\n\n\n$FirstPulseDelay\n\nFloat\n\nThe amount of time in seconds to wait before generating the first pulse.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\nNI_DAQmx_Generate_Dig_Pulse_Train(\"Dev2\", \"ctr0\", 100.0, 0.45, 0, 0.0);\n\nThis example generates a digital pulse train on \"Dev2/ctr0\" with a frequency of 100 Hz and duty cycle of 45%. The idle state is low and the initial delay 0 sec.\n\n\n\n\n\nNI_DAQmx_Initialize\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_DAQmx_Initialize": {
  "prefix": "NI_DAQmx_Initialize",
  "body": [
   "NI_DAQmx_Initialize();"
  ],
  "description": "\n\nThis function requires NI-DAQmx 9.4 or later to be installed on the system.\n\nThis function initialize all NI-DAQmx devices present in the system .\n\nRemarks:\n\nThis function is tested with NI-PCI-6221 and NI-PCI-MIO-16E-4\n\nThe initializing takes some time.\n\nResult:\n\nNI_DAQmx_Initialize();\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nNI_DAQmx_MeasureCurrentDC\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_DAQmx_MeasureCurrentDC": {
  "prefix": "NI_DAQmx_MeasureCurrentDC",
  "body": [
   "$$current=NI_DAQmx_MeasureCurrentDC($$device,$$channel,$$minRange,$$maxRange,$$samples,$$sampleRate,$$configuration,$$taskName);"
  ],
  "description": "\n\nThis function returns an average current from one channel of a DAQmx system.\n\n\n\nRemarks:\n\nThis function requires NI_DAQmx 9.0+ to be loaded on the computer.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$device\n\nString\n\nThe name of the device to read the current from (as shown in NI-MAX).\n\n\n\n$channel\n\nString\n\nThe name of the channel to read the current from (as shown in NI-MAX).\n\n\n\n$minRange\n\nFloat\n\nThe lowest value expected in the measured current.\n\n\n\n$maxRange\n\nFloat\n\nThe highest value expected in the measured current.\n\n\n\n$samples\n\nInteger\n\nThe number of samples to average together.\n\n\n\n$sampleRate\n\nInteger\n\nThe sampling rate in samples per second.\n\n\n\n$configuration\n\nString\n\nThe type of input signal source and the configuration of the measurement system.\n\nValid entries are:\n\n\u00b7 RSE\n\n\u00b7 NRSE\n\n\u00b7 Differential\n\n\u00b7 PseudoDifferential\n\n\n\n$taskName\n\nString\n\nThe name of the task to create in NI-DAQmx. Each NI-DAQmx task that occurs in parallel should have a unique name. Jabil Test will append the test cell number to the end of the task name to ensure unique task names for scripts that are run in multiple test cells.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$current\n\nFloat\n\nThe average current that was measured on the specified channel.\n\n\n\n\n\nExample:\n\n// Set up some variables.\n\n$device = \"cDAQ1Mod1\";\n\n$chan = \"ai0\";\n\n$minR = 0;\n\n$maxR = 5;\n\n$samples = 100;\n\n$sampleRate = 1000;\n\n$config = \"Differential\";\n\n$task = \"ReadCurr\";\n\n\n\n\n\n$curr = NI_DAQmx_MeasureCurrentDC($device, $chan, $minR, $maxR, $samples, $sampleRate, $config, $task);\n\n\n\n\n\n$outStr = \"Average Current = \" + $curr;\n\nUpdateStatus($outStr);\n\n\n\n\n\nNI_DAQmx_MeasureVoltageAC\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_DAQmx_MeasureVoltageAC": {
  "prefix": "NI_DAQmx_MeasureVoltageAC",
  "body": [
   "($$avg,$$min,$$max,$$rms,$$ACrms,$$PTP)=NI_DAQmx_MeasureVoltageAC($$DeviceName,$$Channel,$$MinRange,$$MaxRange,$$Samples,$$Rate,$$InputConfig,$$TaskName);"
  ],
  "description": "\n\nThis function requires NI-DAQmx 9.4 or later to be installed on the system.\n\nThis function measures the AC voltage on $DeviceName/$Channel with the configuration $InputConfig between a range of $MinRange and $MaxRange. .\n\nRemarks:\n\nThis function is tested with NI-PCI-6221\n\nResult:\n\n($avg,$min,$max,$rms,$ACrms,$PTP) = NI_DAQmx_MeasureVoltageAC($DeviceName, $Channel, $MinRange, $MaxRange, $Samples, $Rate, $InputConfig,$TaskName);\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$DeviceName\n\nString\n\nThe NI DAQmx device name you want to use.\n\n\n\n$Channel\n\nString\n\nThe NI DAQmx device channel where you want to measure the voltage. (MAX explorer)\n\n\n\n$MinRange\n\nDouble\n\nThe minimum value expected from the measurement.\n\n\n\n$MaxRange\n\nDouble\n\nThe maximum value expected from the measurement.\n\n\n\n$Samples\n\nInteger\n\nThe number of samples to acquire.\n\n\n\n$Rate\n\nInteger\n\nThe sampling rate in samples per second.\n\n\n\n$InputConfig\n\nString\n\nThe type of input signal source and the configuration of the measurement system.\n\nPossible values:\n\nRSE\n\nNRSE\n\nDifferential\n\nPseudoDifferential\n\n\n\n$TaskName\n\nString\n\nThe name of the measurement task to be performed. Each NIDAQmx task that occurs in parallel should have a unique name. Jabil Test automatically appends the cell number to the supplied task name in the script to guarantee uniqueness when a test script is executed on multiple threads.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$avg\n\nfloat\n\nThe average of all samples.\n\n\n\n$min\n\nfloat\n\nThe minimum measured value.\n\n\n\n$max\n\nfloat\n\nThe maximum measured value.\n\n\n\n$rms\n\nfloat\n\nThe measured RMS value.\n\n\n\n$ACrms\n\nfloat\n\nThe measured ACrms value.\n\n\n\n$PTP\n\nfloat\n\nThe measured peak to peak value.\n\n\n\n\n\nExamples:\n\n($avg,$min,$max,$rms,$ACrms,$PTP) = NI_DAQmx_MeasureVoltageAC(\"Dev1\", \"ai1\", 0.0, 2.5, 2000, 1000, \"RSE\",\"TaskName\");\n\nNumericLimitTest($min, \"-1.100\", \"-0.950\");\n\nNumericLimitTest($max, \"0.950\", \"1.100\");\n\nNumericLimitTest($rms, \"0.700\", \"0.715\");\n\nNumericLimitTest($ACrms, \"0.700\", \"0.715\");\n\nNumericLimitTest($avg, \"-0.1\", \"0.1\");\n\nNumericLimitTest($PTP, \"1.95\", \"2.05\");\n\n\n\n\n\nNI_DAQmx_MeasureVoltageDC\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_DAQmx_MeasureVoltageDC": {
  "prefix": "NI_DAQmx_MeasureVoltageDC",
  "body": [
   "$$dc=NI_DAQmx_MeasureVoltageDC($$DeviceName,$$Channel,$$MinRange,$$MaxRange,$$Samples,$$Rate,$$InputConfig,$$TaskName);"
  ],
  "description": "\n\nThis function requires NI-DAQmx 9.4 or later to be installed on the system.\n\nThis function measures the DC voltage on $DeviceName/$Channel with the configuration $InputConfig between a range of $MinRange and $MaxRange. .\n\nRemarks:\n\nThis function is tested with NI-PCI-6221\n\nResult:\n\n$dc = NI_DAQmx_MeasureVoltageDC($DeviceName, $Channel, $MinRange, $MaxRange, $Samples, $Rate, $InputConfig,$TaskName);\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$DeviceName\n\nString\n\nThe NI DAQmx device name you want to use.\n\n\n\n$Channel\n\nString\n\nThe NI DAQmx device channel where you want to measure the voltage. (MAX explorer)\n\n\n\n$MinRange\n\nDouble\n\nThe minimum value expected from the measurement.\n\n\n\n$MaxRange\n\nDouble\n\nThe maximum value expected from the measurement.\n\n\n\n$Samples\n\nInteger\n\nThe number of samples to acquire.\n\n\n\n$Rate\n\nInteger\n\nThe sampling rate in samples per second.\n\n\n\n$InputConfig\n\nString\n\nThe type of input signal source and the configuration of the measurement system.\n\nPossible values:\n\nRSE\n\nNRSE\n\nDifferential\n\nPseudoDifferential\n\n\n\n$TaskName\n\nString\n\nThe name of the measurement task to be performed. Each NIDAQmx task that occurs in parallel should have a unique name. Jabil Test automatically appends the cell number to the supplied task name in the script to guarantee uniqueness when a test script is executed on multiple threads.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$dc\n\nfloat\n\nThe resulting value is returned as a float.\n\n\n\n\n\nExamples:\n\n$dc = NIDAQmx_MeasureVoltageDC(\"Dev1\", \"ai0\", 4.95, 5.05, 1000, 10000, \"RSE\",\"TaskName\");\n\nNumericLimitTest($dc, \"4.95\", \"5.05\");\n\n\n\n\n\nNI_DAQmx_Measure_Chan_Current\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_DAQmx_Measure_Chan_Current": {
  "prefix": "NI_DAQmx_Measure_Chan_Current",
  "body": [
   "$$current=NI_DAQmx_Measure_Chan_Current($$device,$$channel,$$minRange,$$maxRange,$$configuration,$$taskName);"
  ],
  "description": "\n\nThis function returns the current on one channel of a DAQmx system.\n\n\n\nRemarks:\n\nThis function requires NI_DAQmx 9.0+ to be loaded on the computer.\n\nThis function takes a single reading and not all NI-DAQmx instruments can perform this. If your instrument returns an error while using this try the function NI_DAQmx_MeasureCurrent_DC.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$device\n\nString\n\nThe name of the device to read the current from (as shown in NI-MAX).\n\n\n\n$channel\n\nString\n\nThe name of the channel to read the current from (as shown in NI-MAX).\n\n\n\n$minRange\n\nFloat\n\nThe lowest value expected in the measured current.\n\n\n\n$maxRange\n\nFloat\n\nThe highest value expected in the measured current.\n\n\n\n$configuration\n\nString\n\nThe type of input signal source and the configuration of the measurement system.\n\nValid entries are:\n\n\u00b7 RSE\n\n\u00b7 NRSE\n\n\u00b7 Differential\n\n\u00b7 PseudoDifferential\n\n\n\n$taskName\n\nString\n\nThe name of the task to create in NI-DAQmx. Each NI-DAQmx task that occurs in parallel should have a unique name. Jabil Test will append the test cell number to the end of the task name to ensure unique task names for scripts that are run in multiple test cells.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$current\n\nFloat\n\nThe current that was measured in the specified channel.\n\n\n\n\n\nExample:\n\n// Set up some variables.\n\n$device = \"cDAQ1Mod1\";\n\n$chan = \"ai0\";\n\n$minR = 0;\n\n$maxR = 5;\n\n$config = \"Differential\";\n\n$task = \"ReadCurr\";\n\n\n\n\n\n$curr = NI_DAQmx_Measure_Chan_Current($device, $chan, $minR, $maxR, $config, $task);\n\n\n\n\n\n$outStr = \"Measured Current = \" + $curr;\n\nUpdateStatus($outStr);\n\n\n\n\n\nNI_DAQmx_Measure_Chan_Voltage\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_DAQmx_Measure_Chan_Voltage": {
  "prefix": "NI_DAQmx_Measure_Chan_Voltage",
  "body": [
   "$$measurement=NI_DAQmx_Measure_Chan_Voltage($$DeviceName,$$Channel,$$MinRange,$$MaxRange,$$InputConfig,$$TaskName);"
  ],
  "description": "\n\nThis function requires NI-DAQmx 9.4 or later to be installed on the system.\n\nThis function measures the voltage on $DeviceName/$Channel with the configuration $InputConfig between a range of $MinRange and $MaxRange .\n\nRemarks:\n\nThis function is tested with NI-PCI-6221 and NI-PCI-MIO-16E-4\n\nThis function checks if the user has used a correct parameter for $DeviceName\n\nThis function checks if the user has used a correct parameter for $Channel\n\nThis function checks if the user has used a correct parameter for $InputConfig\n\nResult:\n\n$measurement = NI_DAQmx_Measure_Chan_Voltage($DeviceName, $Channel, $MinRange, $MaxRange, $InputConfig,$TaskName);\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$DeviceName\n\nString\n\nThe NI DAQmx device name you want to use.\n\n\n\n$Channel\n\nString\n\nThe NI DAQmx device channel where you want to measure the voltage.\n\n\n\n$MinRange\n\nDouble\n\nThe minimum value expected from the measurement.\n\n\n\n$MaxRange\n\nDouble\n\nThe maximum value expected from the measurement.\n\n\n\n$InputConfig\n\nString\n\nThe type of input signal source and the configuration of the measurement system.\n\nPossible values:\n\nReferenced Single-Ended\n\nNon-Referenced Single-Ended\n\nDifferential\n\nPseudoDifferential\n\n\n\n$TaskName\n\nString\n\nThe name of the measurement task to be performed. Each NIDAQmx task that occurs in parallel should have a unique name. Jabil Test automatically appends the cell number to the supplied task name in the script to guarantee uniqueness when a test script is executed on multiple threads.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$measurement\n\nfloat\n\nThe resulting value is returned as a float.\n\n\n\n\n\nExamples:\n\n$measurement = NI_DAQmx_Measure_Chan_Voltage(\"Dev2\", \"ai0\", 6.0, 7.0,\"Referenced Single-Ended\",\"MyTask1\");\n\nThis example measures a referenced single-ended voltage on Dev2/ai0 between a range of 6 and 7. The resulting value was 6.12V\n\n$measurement = NI_DAQmx_Measure_Chan_Voltage(\"Dev2\", \"ai5\", 4.85,5.15,\"Referenced Single-Ended\",\"MyTask1\");\n\nThis example measures a referenced single-ended voltage on Dev2/ai5 between a range of 4.85 and 5.15. The resulting value was 5.02V\n\n\n\n\n\nNI_DAQmx_Measure_Chan_VoltageMulti\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_DAQmx_Measure_ChanVoltageMulti": {
  "prefix": "NI_DAQmx_Measure_ChanVoltageMulti",
  "body": [
   "$$measurementArray=NI_DAQmx_Measure_ChanVoltageMulti($$DeviceName,$$Channel,$$MinRange,$$MaxRange,$$InputConfig,$$NumberOfSamples,$$SampleRate,$$TaskName);"
  ],
  "description": "\n\nThis function requires NI-DAQmx 9.4 or later to be installed on the system.\n\nThis function takes a number of samples of the voltage on $DeviceName/$Channel with the configuration $InputConfig between a range of $MinRange and $MaxRange at a given sample rate. The samples are returned as an object which contains an array of doubles.\n\nRemarks:\n\nThis function is tested with NI-PCI-6221 and NI-PCI-MIO-16E-4\n\nThis function checks if the user has used a correct parameter for $DeviceName\n\nThis function checks if the user has used a correct parameter for $Channel\n\nThis function checks if the user has used a correct parameter for $InputConfig\n\nResult:\n\n$measurement = NI_DAQmx_Measure_ChanVoltageMulti($DeviceName, $Channel, $MinRange, $MaxRange, $InputConfig,$NumberOfSamples,$SampleRate,$TaskName);\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$DeviceName\n\nString\n\nThe NI DAQmx device name you want to use.\n\n\n\n$Channel\n\nString\n\nThe NI DAQmx device channel where you want to measure the voltage.\n\n\n\n$MinRange\n\nDouble\n\nThe minimum value expected from the measurement.\n\n\n\n$MaxRange\n\nDouble\n\nThe maximum value expected from the measurement.\n\n\n\n$InputConfig\n\nString\n\nThe type of input signal source and the configuration of the measurement system.\n\nPossible values:\n\nReferenced Single-Ended\n\nNon-Referenced Single-Ended\n\nDifferential\n\nPseudoDifferential\n\n\n\n$NumberOfSamples\n\nInteger\n\nThe number of samples to take\n\n\n\n$SampleRate\n\nInteger\n\nThe rate at which to sample measured in Hertz\n\n\n\n$TaskName\n\nString\n\nThe name of the measurement task to be performed. Each NIDAQmx task that occurs in parallel should have a unique name. Jabil Test automatically appends the cell number to the supplied task name in the script to guarantee uniqueness when a test script is executed on multiple threads.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$measurementArray\n\nArray\n\nA single-dimensional array of type double containing all the measurements\n\n\n\n\n\nNI_DAQmx_MultiDACWaves\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_DAQmx_MultiDACWaves": {
  "prefix": "NI_DAQmx_MultiDACWaves",
  "body": [
   "NI_DAQmx_MultiDACWaves($$DeviceNameRanges,$$Channels,$$MinRanges,$$MaxRanges,$$Freqs,$$Waves,$$Cycles,$$Amplitudes,$$OffSets);"
  ],
  "description": "\n\nThis function requires NI-DAQmx 9.4 or later to be installed on the system.\n\nThis function generates on the selected DACs a selected waveform Square,Sine, Triangle. The frequence can be selected, also the Voltage and the Offset. It is multi channel.\n\n\n\n\n\nRemarks:\n\nThis function is tested with NI-PCI-6221.\n\n\n\n\n\nThis function checks if the user has used a correct parameter for:\n\n- $DeviceNameRanges.\n\n- $Channels.\n\n- $Waves\n\n- $Channels\n\n- $Amplitudes in reference to $MaxRanges and $MinRanges\n\n- $OffSets in reference to $Amplitudes and $MaxRanges,$MinRanges\n\n\n\n\n\nFor multichannel:\n\n\n\nAt this moment for $MinRanges,$MaxRanges and $Freqs, only the first value is taken into account. So every channel will operate on the same frequence and ranges.\n\nIn order for this \"Task\" to be still available over more steps, the object stays alive until you use the NI_DAQmx_StopMultiDACWaves script function.\n\nSee this helpfile for more details about how to stop the generation.\n\n\n\n\n\nResult:\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$DeviceNameRanges\n\nString\n\nThe NI DAQmx device name Device Name + ChannelRange you want to use.\n\n\n\n$Channels\n\nString\n\nThe NI DAQmx device channels where you want to generate the voltages.\n\n\n\n$MinRanges\n\nString\n\nThe minimum Range values.\n\n\n\n$MaxRanges\n\nString\n\nThe maximum Range values.\n\n\n\n$Freqs\n\nString\n\nThe base frequences for this function.\n\n\n\n\n\n$Waves\n\nString\n\nThe wave types to generate\n\nPossible values:\n\nSine\n\nSquare\n\nTriangle\n\n\n\n$Cycles\n\nString\n\nThe number of Cycles to generate, in fact total frequence equals $Cycles "
 }
,
 "JTS NI_DAQmx_OneCounterReadFreqPFIx": {
  "prefix": "NI_DAQmx_OneCounterReadFreqPFIx",
  "body": [
   "$$ResultsArray=NI_DAQmx_OneCounterReadFreqPFIx($$CounterDeviceName,$$Edge,$$MinRange,$$MaxRange,$$Time,$$Qnt,$$PFIx,$$TaskName);"
  ],
  "description": "\n\nThis function measures a TTL signal and calculates its frequency. This function is used to measure higher frequencies using the internal timebase.\n\n\n\nRemarks:\n\nThis function requires NI-DAQmx 9.4 or later to be installed on the system.\n\nThis function is tested with NI-PXI-6723. This function checks if the user has used a correct parameter for $CounterDeviceName.\n\nMethod used: \"Measure low frequencies with one counter.\"\n\nDue to the chosen measurement method you should always take at least 3 measurements and ignore the first 2.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$CounterDeviceName\n\nString\n\nThe NI-DAQmx Device Name including the name of the counter that will be used for pulse generation.\n\n\n\n$Edge\n\nInteger\n\nThe Edge the counter will trigger on.\n\n0 = Falling (generates unknown results)\n\n1 = Rising\n\n\n\n$MinRange\n\nString\n\nThe minimum expected value based on the DAQmx channel setting. Eg. if the device reads -10V to +10V, $MinRange = -10 (if there is no scaling applied to the channel), regardless of the what the measured signal levels are.\n\n\n\n$MaxRange\n\nString\n\nThe maximum expected value based on the DAQmx device setting.\n\n\n\n$Time\n\nString\n\nThe time the measurement may take, the higher - the more accuracy.\n\n\n\n$Qnt\n\nInteger\n\nThe number of readings to return.\n\n\n\n$PFIx\n\nString\n\nThe Counter channel used for the measurement.\n\n\n\n$TaskName\n\nString\n\nThe name of the measurement task to be performed. Each NIDAQmx task that occurs in parallel should have a unique name. Jabil Test automatically appends the cell number to the supplied task name in the script to guarantee uniqueness when a test script is executed on multiple threads.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Result\n\nArray\n\nThe measurements in Hz.\n\n\n\n\n\nExample:\n\n$CounterDeviceName = \"PXI1Slot9/ctr0\";\n\n$Edge = 1; //rising edge\n\n$MinRange = \"0\";\n\n$MaxRange = \"1000.0\"; // Channel is scaled to 0 to 1000.\n\n$Time = \"5\"; // 5 seconds\n\n$Qnt = 3; // return 1 reading\n\n$PFIx = \"PFI0\";\n\n\n\n\n\n$ResultsArray = NI_DAQmx_OneCounterReadFreqPFIx($CounterDeviceName, $Edge, $MinRange, $MaxRange, $Time, $Qnt, $PFIx, \"MyTask\");\n\n\n\n\n\n$Frequency = Array1DGetValue($ResultsArray, 2); // Ignore first readings\n\n\n\n\n\nNI_DAQmx_ReadDIOPort\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_DAQmx_ReadDIOPort": {
  "prefix": "NI_DAQmx_ReadDIOPort",
  "body": [
   "$$Value=NI_DAQmx_ReadDIOPort($$DeviceName,$$PortName,$$TaskName);"
  ],
  "description": "\n\n\n\n\n\nThis function reads the value on a specified digital input port on a NIDAQmx compatible DAQ device.\n\n\n\n\n\nThis function requires NI-DAQmx 9.4 or later to be installed on the system.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Device\n\nString\n\nThe NIDAQmx device name you want to use.\n\n\n\n$Channel\n\nString\n\nThe specified channel on the NIDAQmx device. If this channel does not exist, or is not able to be used as a digital output resource, the function will fail.\n\n\n\n$TaskName\n\nString\n\nThe name of the measurement task to be performed. Each NIDAQmx task that occurs in parallel should have a unique name. Jabil Test automatically appends the cell number to the supplied task name in the script to guarantee uniqueness when a test script is executed on multiple threads.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Value\n\nInteger\n\nThe digital port value read from the input port on the NIDAQmx compatible DAQ device.\n\n\n\n\n\nExamples:\n\n$Value = NI_DAQmx_ReadDIOPort(\"dev1\",\"port0\",\"MyTask\");\n\n\n\n\n\nNI_DAQmx_Read_Dig_Port_Line\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_DAQmx_Read_Dig_Port_Line": {
  "prefix": "NI_DAQmx_Read_Dig_Port_Line",
  "body": [
   "$$measurement=NI_DAQmx_Read_Dig_Port_Line($$DeviceName,$$Port,$$Line,$$TaskName);"
  ],
  "description": "\n\nThis function requires NI-DAQmx 9.4 or later to be installed on the system.\n\nThis function reads a $value (high or low) from a NI DAQmx $DeviceName/$Port/$Line. .\n\nRemarks:\n\nThis function is tested with NI-PCI-6221 and NI-PCI-MIO-16E-4\n\nThis function checks if the user has used a correct parameter for $DeviceName\n\nThis function checks if the user has used a correct parameter for $Port\n\nThis function checks if the user has used a correct parameter for $Line\n\nResult:\n\n$measurement = NI_DAQmx_Read_Dig_Port_Line($DeviceName, $Port, $Line,$TaskName);\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$DeviceName\n\nString\n\nThe NI DAQmx device name you want to use.\n\n\n\n$Port\n\nString\n\nThe NI DAQmx device port you want to use.\n\n\n\n$Line\n\nString\n\nThe NI DAQmx device line you want to use.\n\n\n\n$TaskName\n\nString\n\nThe name of the measurement task to be performed. Each NIDAQmx task that occurs in parallel should have a unique name. Jabil Test automatically appends the cell number to the supplied task name in the script to guarantee uniqueness when a test script is executed on multiple threads.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$measurement\n\nInteger\n\nThe status of the DIO line. (high or low)\n\n\n\n\n\nExamples:\n\n$measurement = NI_DAQmx_Read_Dig_Port_Line(\"Dev2\",\"port0\",\"line5\",\"MyTask\");\n\nThis example reads the \"Dev2/port0/line5\" high.\n\n\n\n\n\nNI_DAQmx_ResetDevice\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_DAQmx_ResetDevice": {
  "prefix": "NI_DAQmx_ResetDevice",
  "body": [
   "NI_DAQmx_ResetDevice($$DeviceName);"
  ],
  "description": "\n\n\n\n\n\nThis function will reset the specified NIDAQmx device on the system, which ends all tasks executing on that particular device.\n\n\n\n\n\nIf the specified device is not found in the system, or can't be reset, the function generates a failing test result.\n\n\n\n\n\nNote:\n\nThe name of each NIDAQmx device can be retrieved by using the NI-MAX Explorer application provided by National Instruments.\n\n\n\n\n\nThis function requires NI-DAQmx 9.4 or later to be installed on the system.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$DeviceName\n\nString\n\nThe name of the NIDAQmx Device that the user wishes to reset, and re-initialize.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\nNI_DAQmx_ResetDevice(\"Dev1\");\n\nNI_DAQmx_ResetDevice(\"Dev2\");\n\n\n\n\n\nNI_DAQmx_SetCurrentDC\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_DAQmx_SetCurrentDC": {
  "prefix": "NI_DAQmx_SetCurrentDC",
  "body": [
   "NI_DAQmx_SetCurrentDC($$deviceName,$$channelName,$$current,$$minimumCurrent,$$maximumCurrent,$$taskName);"
  ],
  "description": "\n\nThis function sets an output current on the specified channel of the specified device.\n\n\n\nRemarks:\n\nThis function requires that NI-DAQmx 9.4 or later be installed on the system.\n\nThis NI-DAQmx device must be capable of current output.\n\nThe minimum and maximum current settings are used to determine the range selected by the instrument. The output current must be between the minumum and maximum currents.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$deviceName\n\nString\n\nThe name of the NI-DAQmx device to output from.\n\n\n\n$channelName\n\nString\n\nThe name of the channel to output from.\n\n\n\n$current\n\nFloat\n\nThe output current in Amps.\n\n\n\n$minimumCurrent\n\nFloat\n\nThe smallest current you expect (low end of current range).\n\n\n\n$maximumCurrent\n\nFloat\n\nThe largest current you expect (high end of current range).\n\n\n\n$taskName\n\nString\n\nThe name of the NI-DAQmx Task to create for this function.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n\n\n\n\n// Set up a 100mA current.\n\n$devName = \"Dev1\";\n\n$chanName = \"line0\";\n\n$current = 0.1;\n\n$minA = 0;\n\n$maxA = 1;\n\n$taskName = \"CurrentOutTask\";\n\n\n\nNI_DAQmx_SetCurrentDC($devName, $chanName, $current, $minA, $maxA, $taskName);\n\n\n\n\n\nNI_DAQmx_SetVoltageDC\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_DAQmx_SetVoltageDC": {
  "prefix": "NI_DAQmx_SetVoltageDC",
  "body": [
   "NI_DAQmx_SetVoltageDC($$DeviceName,$$Channel,$$Voltage,$$MinimumExpectedVoltage,$$MaximumExpectedVoltage,$$TaskName);"
  ],
  "description": "\n\nThis function requires NI-DAQmx 9.4 or later to be installed on the system.\n\nThis function sets the DC voltage on $DeviceName/$Channel.\n\nRemarks:\n\nThis function is tested with NI-PCI-6025 and NI-DAQ USB 6008\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$DeviceName\n\nString\n\nThe NI DAQmx device name you want to use.\n\n\n\n$Channel\n\nString\n\nThe NI DAQmx device channel where you want to measure the voltage. (MAX explorer)\n\n\n\n$Voltage\n\nFloat\n\nThe desired voltage for the analog output channel.\n\n\n\n$MinimumExpectedVoltage\n\nFloat\n\nThe minimum expected voltage for the output channel.\n\n\n\n$MaximumExpectedVoltage\n\nFloat\n\nThe maximum expected voltage for the output channel.\n\n\n\n$TaskName\n\nString\n\nThe name of the measurement task to be performed. Each NIDAQmx task that occurs in parallel should have a unique name. Jabil Test automatically appends the cell number to the supplied task name in the script to guarantee uniqueness when a test script is executed on multiple threads.\n\n\n\n\n\nReturn Parameters\n\n\n\nNone\n\n\n\n\n\nNI_DAQmx_ShowAllTasks\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_DAQmx_ShowAllTasks": {
  "prefix": "NI_DAQmx_ShowAllTasks",
  "body": [
   "$$TaskList=NI_DAQmx_ShowAllTasks();"
  ],
  "description": "\n\n\n\n\n\nThis function lists all the persistent tasks that are currently executing on the local system across all NIDAQmx devices.\n\nThe list of devices is written to the debug window, and returned as a semi-colon delimited string.\n\n\n\n\n\nThis function requires NI-DAQmx 9.4 or later to be installed on the system.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$TaskList\n\nString\n\nA semi-colon delimited list of all the currently executing persistent tasks on the local system.\n\n\n\n\n\nExamples:\n\n$Tasks = NI_DAQmx_ShowAllTasks();\n\n\n\n\n\nNI_DAQmx_StopMultiDACWaves\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_DAQmx_StopMultiDACWaves": {
  "prefix": "NI_DAQmx_StopMultiDACWaves",
  "body": [
   "NI_DAQmx_StopMultiDACWaves($$DeviceName,$$AnalogOutputChannel);"
  ],
  "description": "\n\nThis function requires NI-DAQmx 9.4 or later to be installed on the system. This function stops the generation of waves on all the analog output with the user defined settings.\n\nRemarks:\n\nThis function is tested with NI-PCI-6221.\n\nBefore stopping the generation, you need at least to set the outputs to zero, especially the DC part of it, otherwise you receive a fluctuated DC offset at the outputs.\n\nYou must use the NI_DAQmx_MultiDACWaves to do so.\n\nResult:\n\nNI_DAQmx_StopMultiDACWaves($DeviceName, $AnalogOutputChannel);\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$DeviceName\n\nString\n\nThe NI DAQmx device name you want to use. You find this name in MAX explorer.\n\n\n\n$AnalogOutputChannel\n\nString\n\nThe 1st analog output channel used by the NI_DAQmx_MultiDACWaves\n\nThe others will stop accordingly.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n\n\nExample:\n\nNI_DAQmx_StopMultiDACWaves(\"Dev1\", \"ao0\");\n\nThis example stops generating on all channels Dev1.\n\nNI_DAQmx_StopMultiDACWaves(\"Dev1\", \"ao1\");\n\nThis example also stops generating on all channels Dev1.\n\n\n\n\n\nNI_DAQmx_StopSinusWave\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_DAQmx_StopSinusWave": {
  "prefix": "NI_DAQmx_StopSinusWave",
  "body": [
   "NI_DAQmx_StopSinusWave($$DeviceName,$$AnalogOutputChannel);"
  ],
  "description": "\n\nThis function requires NI-DAQmx 9.4 or later to be installed on the system.\n\nThis function stops the generation of a sinusoidal wave on the analog output with the user defined settings.\n\nRemarks:\n\nThis function is tested with NI-PCI-6221.\n\nResult:\n\nNI_DAQmx_StopSinusWave($DeviceName, $AnalogOutputChannel);\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$DeviceName\n\nString\n\nThe NI DAQmx device name you want to use. You find this name in MAX explorer.\n\n\n\n$AnalogOutputChannel\n\nString\n\nThe analog output channel of the device where you want to have the sinusoidal wave.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n\n\nExample:\n\n// This example stops generating a sinus wave on Dev1/Ao0.\n\nNI_DAQmx_StopSinusWave(\"Dev1\", \"ao0\");\n\n\n\n\n\n// This example stops generating a sinus wave on Dev1/Ao1.\n\nNI_DAQmx_StopSinusWave(\"Dev1\", \"ao1\");\n\n\n\n\n\nNI_DAQmx_StopSinusWaveWithOffset\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_DAQmx_StopSinusWaveWithOffset": {
  "prefix": "NI_DAQmx_StopSinusWaveWithOffset",
  "body": [
   "NI_DAQmx_StopSinusWaveWithOffset($$DeviceName,$$AnalogOutputChannel);"
  ],
  "description": "\n\nThis function stops the generation of a sinusoidal wave on the specified analog output.\n\n\n\n\n\nRemarks:\n\nThis function requires NI-DAQmx 9.4 or later to be installed on the system.\n\nThis function is tested with NI-PXI-6723. This function checks if the user has used a correct parameter for $CounterDeviceName.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$DeviceName\n\nString\n\nThe NI-DAQmx Device Name for the wave. Find the name in Measurement and Automation Explorer.\n\n\n\n$AnalogOutputChannel\n\nString\n\nThe analog output channel on which to stop the generation of a sinusoidal wave.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n$DeviceName = \"PXI1Slot13\";\n\n$AnalogOutputChannel = \"ao0\";\n\n\n\n\n\nNI_DAQmx_StopSinusWaveWithOffset($DeviceName, $AnalogOutputChannel);\n\n\n\n\n\nNI_DAQmx_StopSquareWaveWithOffset\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_DAQmx_StopSquareWaveWithOffset": {
  "prefix": "NI_DAQmx_StopSquareWaveWithOffset",
  "body": [
   "NI_DAQmx_StopSquareWaveWithOffset($$DeviceName,$$AnalogOutputChannel);"
  ],
  "description": "\n\nThis function stops the generation of a square wave on the specified analog output.\n\n\n\nRemarks:\n\nThis function requires NI-DAQmx 9.4 or later to be installed on the system.\n\nThis function is tested with NI-PXI-6723. This function checks if the user has used a correct parameter for $CounterDeviceName.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$DeviceName\n\nString\n\nThe NI-DAQmx Device Name for the wave. Find the name in Measurement and Automation Explorer.\n\n\n\n$AnalogOutputChannel\n\nString\n\nThe analog output channel on which to stop the generation of a square wave.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n$DeviceName = \"PXI1Slot13\";\n\n$AnalogOutputChannel = \"ao0\";\n\n\n\n\n\nNI_DAQmx_StopSquareWaveWithOffset($DeviceName, $AnalogOutputChannel);\n\n\n\n\n\nNI_DAQmx_Stop_Dig_Pulse_Train\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_DAQmx_Stop_Dig_Pulse_Train": {
  "prefix": "NI_DAQmx_Stop_Dig_Pulse_Train",
  "body": [
   "NI_DAQmx_Stop_Dig_Pulse_Train($$DeviceName,$$Counter);"
  ],
  "description": "\n\nThis function requires NI-DAQmx 9.4 or later to be installed on the system.\n\nThis function stops a digital pulse train on the counter output $Counter of device $DeviceName .\n\nRemarks:\n\nThis function is tested with NI-PCI-6221 and NI-PCI-MIO-16E-4\n\nThis function checks if the user has used a correct parameter for $DeviceName\n\nThis function checks if the user has used a correct parameter for $Channel\n\nThis function checks if the user has used a correct parameter for $InputConfig\n\nResult:\n\nNI_DAQmx_Stop_Dig_Pulse_Train($DeviceName, $Counter);\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$DeviceName\n\nString\n\nThe NI DAQmx device name you want to use.\n\n\n\n$Counter\n\nString\n\nThe NI DAQmx counter channel where the pulse train will appear.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\nNI_DAQmx_Stop_Dig_Pulse_Train(\"Dev2\", \"ctr0\");\n\nThis example stops the digital pulse train on \"Dev2/ctr0\".\n\n\n\n\n\nNI_DAQmx_WriteDIOPort\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_DAQmx_WriteDIOPort": {
  "prefix": "NI_DAQmx_WriteDIOPort",
  "body": [
   "NI_DAQmx_WriteDIOPort($$DeviceName,$$ChannelName,$$ChannelValue,$$TaskName);"
  ],
  "description": "\n\n\n\n\n\nThis function writes a specified static 8-bit value to a Digital Output channel on a NIDAQmx compatible DAQ device.\n\n\n\n\n\nThis function requires NI-DAQmx 9.4 or later to be installed on the system.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Device\n\nString\n\nThe NIDAQmx device name you want to use.\n\n\n\n$Channel\n\nString\n\nThe specified channel on the NIDAQmx device. If this channel does not exist, or is not able to be used as a digital output resource, the function will fail.\n\n\n\n$ChannelValue\n\nString\n\nA hexadecimal string indicating the desired 8-bit value to write to the specified port.\n\n\n\n$TaskName\n\nString\n\nThe name of the measurement task to be performed. Each NIDAQmx task that occurs in parallel should have a unique name. Jabil Test automatically appends the cell number to the supplied task name in the script to guarantee uniqueness when a test script is executed on multiple threads.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\nNI_DAQmx_WriteDIOPort(\"Dev0\",\"Port0\",\"FF\",\"MyTask\");\n\n\n\n\n\nNI_DAQmx_Write_Dig_Port_Line\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_DAQmx_Write_Dig_Port_Line": {
  "prefix": "NI_DAQmx_Write_Dig_Port_Line",
  "body": [
   "NI_DAQmx_Write_Dig_Port_Line($$deviceName,$$portName,$$lineName,$$value,$$taskName);"
  ],
  "description": "\n\nThis function writes a value to the specified line on the specified NI-DAQmx device and port.\n\n\n\n\n\nRemarks:\n\nThis function requires NI-DAQmx 16.1 or later.\n\n\n\nThis function checks that the device, port and line exist.\n\n\n\nFor $value any of these will evaluate to True (everything else will evaluate to False: \"1\", \"True\", \"Yes\", \"High\", \"T\", \"Y\".\n\n\n\nThis function was tested with an NI-USB-6008.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$deviceName\n\nString\n\nThe NI-DAQmx device name to use.\n\n\n\n$portName\n\nString\n\nThe port on the NI-DAQmx device to use.\n\n\n\n$lineName\n\nString\n\nThe line on the port of the NI-DAQmx device to use.\n\n\n\n$value\n\nString\n\nThe value to write to the line.\n\n\n\n$taskName\n\nString\n\nThe name of the measurement task to be performed. Each NIDAQmx task that occurs in parallel should have a unique name. Jabil Test automatically appends the cell number to the supplied task name in the script to guarantee uniqueness when a test script is executed in multiple test cells.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n\n\n\n\n// Output a high on Port0, Line 2 of Dev1.\n\n$device = \"Dev1\";\n\n$port = \"port0\";\n\n$line = \"line2\";\n\n$value = 1;\n\n$task = \"VoltOut\";\n\n\n\nNI_DAQmx_Write_Dig_Port_Line($device, $port, $line, $value, $task);\n\n\n\n\n\nDIO_ConfigPort\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS DIO_ConfigPort": {
  "prefix": "DIO_ConfigPort",
  "body": [
   "DIO_ConfigPort($$deviceNumber,$$portNumber,$$mode,$$direction);"
  ],
  "description": "\n\nThis is a direct mapping of the NIDAQ function DIO_ConfigPort, therefore it's compatible with any digital input output device which supports the NIDAQ interface created by National Instruments.\n\nThis function configures a digital input or output port on a NIDAQ compatible device for further operations.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$deviceNumber\n\nInteger\n\nThe number assigned to your device in the Measurement and Automation explorer utility by National Instruments.\n\n\n\n$portNumber\n\nInteger\n\nThe number of the port to configure. The valid range of ports is dependant on the particular digital control device that you are using in your test solution.\n\n\n\n$mode\n\nString\n\nThe operational mode of the port. Note: Not all devices support all modes, you'll need to refer to the documentation for your DIO device.\n\nSupported Values:\n\n\"LATCHED\"\n\n\"UNLATCHED\"\n\n\n\n$direction\n\nString\n\nThe operational direction of the port. Note: Not all devices support all modes, you'll need to refer to the documentation for your DIO device.\n\nSupported Values:\n\n\"INPUT\"\n\n\"OUTPUT\"\n\n\"BIDIRECTIONAL\".\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nDIO_ReadPort\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS DIO_ReadPort": {
  "prefix": "DIO_ReadPort",
  "body": [
   "$$returnValue=DIO_ReadPort($$deviceNumber,$$portNumber);"
  ],
  "description": "\n\nThis is a direct mapping of the NIDAQ function DIO_ReadPort, therefore it's compatible with any digital input output device which supports the NIDAQ interface created by National Instruments.\n\nThis function returns a hexidecimal string representing an 8 bit value fromthe device and port specified in the function parameters.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$deviceNumber\n\nInteger\n\nThe number assigned to your device in the Measurement and Automation explorer utility by National Instruments.\n\n\n\n$portNumber\n\nInteger\n\nThe number of the port to configure. The valid range of ports is dependant on the particular digital control device that you are using in your test solution.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$returnValue\n\nString\n\nA string representing the hexidecimal value of the pattern read from the port and device specified in the function parameters.\n\n\n\n\n\nDIO_WriteLine\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS DIO_WriteLine": {
  "prefix": "DIO_WriteLine",
  "body": [
   "DIO_WriteLine($$Device,$$Port,$$Line,$$Value);"
  ],
  "description": "\n\n\n\n\n\nThis function writes a single line of a given port with the supplied bit value of 0 or 1. This function uses the traditional NIDAQ library.\n\n\n\n\n\nThe given port must be configured as an output port before invoking this function.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Device\n\nInteger\n\nThe ID Number of the NIDAQ device\n\n\n\n$Port\n\nInteger\n\nThe port number on the device to be written to\n\n\n\n$Line\n\nInteger\n\nThe line on the given port to be written to\n\n\n\n$Value\n\nInteger\n\nThe value to write to the supplied port, allowed values are 0 or 1.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\nDIO_WriteLine(1,4,3,1);\n\n\n\n\n\nDIO_WritePort\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS DIO_WritePort": {
  "prefix": "DIO_WritePort",
  "body": [
   "DIO_WritePort($$deviceNumber,$$portNumber,$$PatternValue);"
  ],
  "description": "\n\nThis is a direct mapping of the NIDAQ function DIO_WritePort, therefore it's compatible with any digital input output device which supports the NIDAQ interface created by National Instruments.\n\nThis function writes an 8 bit value to the device and port specified in the function parameters.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$deviceNumber\n\nInteger\n\nThe number assigned to your device in the Measurement and Automation explorer utility by National Instruments.\n\n\n\n$portNumber\n\nInteger\n\nThe number of the port to configure. The valid range of ports is dependant on the particular digital control device that you are using in your test solution.\n\n\n\n$PatternValue\n\nString\n\nA String representing a hexidecimal number to write to the port and device specified. Valid values are 0x00 to 0xff. Note: The '0x' notation is entirely optional, and not required for the function to work properly.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nDIO_WritePortWithMask\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS DIO_WritePortWithMask": {
  "prefix": "DIO_WritePortWithMask",
  "body": [
   "DIO_WritePortWithMask($$Device,$$Port,$$WritePattern,$$MaskPattern);"
  ],
  "description": "\n\n\n\n\n\nThis function writes an 8 bit value to the device and port specified. The 8-bit value to be written is logically \"ANDED\" with the 8-bit value supplied in the mask pattern, and only the unmasked bits are written. The remaining port lines which are masked will be unaffected.\n\n\n\n\n\nThe given port must be configured as an output port before invoking this function.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Device\n\nInteger\n\nThe ID Number of the NIDAQ device\n\n\n\n$Port\n\nInteger\n\nThe port number on the device to be written to\n\n\n\n$WritePattern\n\nString\n\nThe 8-bit value to be written to the port expressed as a hexadecimal string.\n\n\n\n$MaskPattern\n\nString\n\nThe 8-bit value to be applied as a mask to the 8-bit write pattern value. The mask bits on the output port will be unaffected by the write operation.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\nDIO_WritePortWithMask(1,2,\"AA\",\"0F\");\n\n\n\n\n\nOmega_DAQ_Close\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Omega_DAQ_Close": {
  "prefix": "Omega_DAQ_Close",
  "body": [
   "Omega_DAQ_Close($$DeviceHandle);"
  ],
  "description": "\n\nThe close function terminates the connection to the Omega OMB-DAQ-54 device. Once the specified device has been closed, no subsequent communication with the device can be performed. In order to re-establish communications with a closed device, the device must be re-opened with the Omega_DAQ_Init function.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$DeviceHandle\n\nObject\n\nThe handle of the device returned from the Omega_DAQ_Init function\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\nOmega_DAQ_Close($handle);\n\n\n\n\n\nOmega_DAQ_GetChannelTemperature\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Omega_DAQ_GetChannelTemperature": {
  "prefix": "Omega_DAQ_GetChannelTemperature",
  "body": [
   "$$Temperature=Omega_DAQ_GetChannelTemperature($$DeviceHandle,$$Channel,$$Degree,$$Thermocouple,$$ADCSetting);"
  ],
  "description": "\n\nThis function scans the specified device channel and returns the Voltage to Temperature conversion result based on the degree and thermocouple parameters.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$DeviceHandle\n\nObject\n\nThe handle of the device returned from the Omega_DAQ_Init function\n\n\n\n$Channel\n\nInteger\n\nThe device channel to scan\n\n\n\n$Degree\n\nString\n\nTemperature Degree Unit [C,F]\n\n\n\n$Thermocouple\n\nString\n\nThermocouple Type [J,K,T,N,N14,N28,S,R,B,CJC]\n\n\n\n$ADCSetting\n\nString\n\nThe setting for the analog-digital converter for the specified channel number. Supported values are:\n\n\u00b7 \"SELOW\" = Single Ended Low\n\n\u00b7 \"SEHIGH\" = Single Ended High\n\n\u00b7 \"DIFF\" = Differential\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Temperature\n\nFloat\n\nThe resultant voltage to temperature conversion\n\n\n\n\n\nExamples:\n\n$temp = Omega_DAQ_GetChannelTemperature($handle,3,\"F\",\"T\",\"DIFF\");\n\n\n\n\n\nOmega_DAQ_GetChannelVoltage\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Omega_DAQ_GetChannelVoltage": {
  "prefix": "Omega_DAQ_GetChannelVoltage",
  "body": [
   "$$Voltage=Omega_DAQ_GetChannelVoltage($$DeviceHandle,$$Channel,$$Gain,$$ADCSetting);"
  ],
  "description": "\n\nThis function scans the specified device channel and returns the Voltage to Temperature conversion result based on the degree and thermocouple parameters.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$DeviceHandle\n\nObject\n\nThe handle of the device returned from the Omega_DAQ_Init function\n\n\n\n$Channel\n\nInteger\n\nThe device channel to scan\n\n\n\n$Gain\n\nString\n\nThe channel's gain setting [DIV5,X1,X2,X4,X8,X16,X32,X64,X128]\n\n\n\n$ADCSetting\n\nString\n\nThe setting for the analog-digital converter for the specified channel number. Supported values are:\n\n\u00b7 \"SELOW\" = Single Ended Low\n\n\u00b7 \"SEHIGH\" = Single Ended High\n\n\u00b7 \"DIFF\" = Differential\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Voltage\n\nFloat\n\nThe channel voltage reading\n\n\n\n\n\nExamples:\n\n$voltage = Omega_DAQ_GetChannelVoltage($handle,1,\"X1\",\"DIFF\");\n\n\n\n\n\nOmega_DAQ_GetDeviceCount\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Omega_DAQ_GetDeviceCount": {
  "prefix": "Omega_DAQ_GetDeviceCount",
  "body": [
   "$$Count=Omega_DAQ_GetDeviceCount();"
  ],
  "description": "\n\nThis function returns the number of currently configured devices.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Count\n\nInteger\n\nThe number of devices\n\n\n\n\n\nExamples:\n\n$count = Omega_DAQ_GetDeviceCount();\n\n\n\n\n\nOmega_DAQ_GetDeviceStatus\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Omega_DAQ_GetDeviceStatus": {
  "prefix": "Omega_DAQ_GetDeviceStatus",
  "body": [
   "$$Status=Omega_DAQ_GetDeviceStatus($$DeviceHandle);"
  ],
  "description": "\n\nThis function determines if a device is online and returns and true/false status.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$DeviceHandle\n\nObject\n\nThe handle of the device returned from the Omega_DAQ_Init function\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Status\n\nBoolean\n\nStatus of device [True,False]\n\n\n\n\n\nExamples:\n\n$Status = Omega_DAQ_GetDeviceStatus($handle);\n\n\n\n\n\nOmega_DAQ_Init\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Omega_DAQ_Init": {
  "prefix": "Omega_DAQ_Init",
  "body": [
   "$$DeviceHandle=Omega_DAQ_Init($$DeviceName);"
  ],
  "description": "\n\nThis function will initiate a session for the device name specified by the $DeviceName parameter by opening the device, initializing it, and preparing it for further operation. The device name specified must reference a currently configured device.\n\n\n\n\n\nNote: It is generally a good programming habit to close the instrument handle when the program is done using the instrument. This can be done with the Omega_DAQ_Init function.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$DeviceName\n\nString\n\nName of the Omega device to be initialized.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$DeviceHandle\n\nObject\n\nThe handle of the device\n\n\n\n\n\nExamples:\n\n$DeviceHandle = Omega_DAQ_Init(\"PDAQ\");\n\n\n\n\n\nOpto22_Close\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Opto22_Close": {
  "prefix": "Opto22_Close",
  "body": [
   "Opto22_Close($$Handle);"
  ],
  "description": "\n\nThis function requires the OptoMMP2.dll file to be installed in the Jabil Test folder.\n\n\n\nThis function closes and releases the instrument driver session. It also deallocates any memory resources the driver uses.\n\n\n\n\n\nRemarks:\n\n\u00b7 After closing, communications must be re-initialized before any more commands can be sent.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nThe handle of the instrument returned from the initialization function.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\nOpto22_Close($Handle);\n\n\n\n\n\nOpto22_Init\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Opto22_Init": {
  "prefix": "Opto22_Init",
  "body": [
   "$$Handle=Opto22_Init($$HostName,$$HostPort,$$ConnectionType,$$TimeOut,$$PowerUpClear);"
  ],
  "description": "\n\nThis function requires the OptoMMP2.dll file to be installed in the Jabil Test folder.\n\n\n\nThis function opens communication to the instrument.\n\n\n\n\n\nRemarks:\n\n\u00b7 This library was tested on a SNAP-B3000-ENET PAC.\n\n\u00b7 All Opto22 SNAP PAC's can be controlled with this library with the exception of the SNAP Ultimate I/O models.\n\n\u00b7 This function must be called for each PAC that is to be communicated with.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$HostName\n\nString\n\nThe name of the host PAC to connect to or the IP address of the PAC in dot format.\n\n\n\n$HostPort\n\nInteger\n\nThe ethernet port on the PAC to connect to. Default is 2001.\n\n\n\n$ConnectionType\n\nString\n\nThe ethernet protocol to use when talking to the PAC.\n\nValues: TCP, UDP\n\n\n\n$TimeOut\n\nInteger\n\nThe number of milliseconds to wait for communication from the PAC before returning a time out error.\n\nMinimum value for UDP: 100\n\nMinimum value for TCP: 1000\n\n\n\n$PowerUpClear\n\nBoolean\n\nWhether to reset a PAC that is a \"Brain\" unit. Ignored if not a \"Brain\" PAC.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nReturns a session handle that is used to identify the device in all subsequent function calls.\n\n\n\n\n\nExample:\n\n$Handle = Opto22_Init(\"192.168.10.11\", 2001, \"TCP\", 3000, False);\n\n\n\n\n\nOpto22_ReadAnalog\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Opto22_ReadAnalogl": {
  "prefix": "Opto22_ReadAnalogl",
  "body": [
   "$$Value=Opto22_ReadAnalogl($$Handle,$$MemoryIndex);"
  ],
  "description": "\n\nThis function requires the OptoMMP2.dll file to be installed in the Jabil Test folder.\n\n\n\nThis function reads a single analog channel value from the instrument.\n\n\n\n\n\nRemarks:\n\n\u00b7 The analog values are stored in the instrument memory after the digital values. The first analog value is stored at memory location: <number of digital channels> (due to the memory starting at location 0. If there are 64 digital channels (numbered 0 to 63), the first analog would be 64.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nThe handle of the instrument returned from the initialization function.\n\n\n\n$MemoryIndex\n\nInteger\n\nThe memory location to read from.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Value\n\nFloat\n\nThe analog value read from the specified memory location.\n\n\n\n\n\nExample:\n\n$Value = Opto22_ReadAnalog($Handle, 64);\n\n\n\n\n\nOpto22_ReadDigital\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Opto22_ReadDigital": {
  "prefix": "Opto22_ReadDigital",
  "body": [
   "$$State=Opto22_ReadDigital($$Handle,$$MemoryIndex);"
  ],
  "description": "\n\nThis function requires the OptoMMP2.dll file to be installed in the Jabil Test folder.\n\n\n\nThis function reads a single digital line state from the instrument.\n\n\n\n\n\nRemarks:\n\n\u00b7 There are a maximum of 64 digital lines on a SNAP PAC - numbered 0 to 63.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nThe handle of the instrument returned from the initialization function.\n\n\n\n$MemoryIndex\n\nInteger\n\nThe memory location to read from.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$State\n\nBoolean\n\nThe boolean state read from the specified digital line.\n\n\n\n\n\nExample:\n\n$State = Opto22_ReadDigital($Handle, 3);\n\n\n\n\n\nOpto22_ReadDigitals\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Opto22_ReadDigitals": {
  "prefix": "Opto22_ReadDigitals",
  "body": [
   "$$States[]=Opto22_ReadDigitals($$Handle,$$StartIndex);"
  ],
  "description": "\n\nThis function requires the OptoMMP2.dll file to be installed in the Jabil Test folder.\n\n\n\nThis function reads 64 digital line states from the instrument.\n\n\n\n\n\nRemarks:\n\n\u00b7 Always returns 64 digital states. Even if the PAC does not have 64 digital lines.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nThe handle of the instrument returned from the initialization function.\n\n\n\n$StartIndex\n\nInteger\n\nThe memory location to start reading from.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$States\n\nArray\n\nThe array of boolean values returned by the PAC.\n\n\n\n\n\nExample:\n\n$States = Array1DCreate(\"BOOLEAN\", 64);\n\n$States = Opto22_ReadDigitals($Handle, 0);\n\n\n\n\n\nOpto22_WriteAnalog\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Opto22_WriteAnalog": {
  "prefix": "Opto22_WriteAnalog",
  "body": [
   "Opto22_WriteAnalog($$Handle,$$Value,$$MemoryIndex);"
  ],
  "description": "\n\nThis function requires the OptoMMP2.dll file to be installed in the Jabil Test folder.\n\n\n\nThis function writes a single analog value to the instrument.\n\n\n\n\n\nRemarks:\n\n\u00b7 The analog values are stored in the instrument memory after the digital values. The first analog value is stored at memory location: <number of digital channels> (due to the memory starting at location 0. If there are 64 digital channels (numbered 0 to 63), the first analog would be 64.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nThe handle of the instrument returned from the initialization function.\n\n\n\n$Value\n\nFloat\n\nThe analog value to write to the memory location.\n\n\n\n$MemoryIndex\n\nInteger\n\nThe memory location to write to.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\nOpto22_WriteAnalog($Handle, 4.53, 64);\n\n\n\n\n\nOpto22_WriteDigital\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Opto22_WriteDigital": {
  "prefix": "Opto22_WriteDigital",
  "body": [
   "Opto22_WriteDigital($$Handle,$$State,$$MemoryIndex);"
  ],
  "description": "\n\nThis function requires the OptoMMP2.dll file to be installed in the Jabil Test folder.\n\n\n\nThis function writes a single digital line state to the instrument.\n\n\n\n\n\nRemarks:\n\n\u00b7 There are a maximum of 64 digital lines on a SNAP PAC - numbered 0 to 63.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nThe handle of the instrument returned from the initialization function.\n\n\n\n$State\n\nBoolean\n\nThe state to write to the digital line.\n\n\n\n$MemoryIndex\n\nInteger\n\nThe memory location to write to.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\nOpto22_WriteDigital($Handle, false, 3);\n\n\n\n\n\nOpto22_WriteDigitals\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Opto22_WriteDigitals": {
  "prefix": "Opto22_WriteDigitals",
  "body": [
   "Opto22_WriteDigitals($$Handle,$$States,$$StartIndex);"
  ],
  "description": "\n\nThis function requires the OptoMMP2.dll file to be installed in the Jabil Test folder.\n\n\n\nThis function writes a number of digital line states to the instrument.\n\n\n\n\n\nRemarks:\n\n\u00b7 The number of digital states entered need not be 64.\n\n\u00b7 The number of digital states written to the PAC is 64. This could cause the write to overwrite memory locations beyond the DIO locations.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nThe handle of the instrument returned from the initialization function.\n\n\n\n$States\n\nArray\n\nThe array of boolean values to write to the PAC.\n\n\n\n$StartIndex\n\nInteger\n\nThe memory location to start writing to.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n$States = Array1DCreate(\"BOOLEAN\", 4);\n\nArray1DSetValue($States, 2, True);\n\nOpto22_WriteDigitals($Handle, $States, 0);\n\n\n\n\n\nAG34401A_Close\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG34401A_Close": {
  "prefix": "AG34401A_Close",
  "body": [
   "AG34401A_Close($$agHandle);"
  ],
  "description": "\n\nThis function closes communication to the instrument and recovers resources used.\n\n\n\n\n\nRemarks:\n\nThis function uses the Agilent IVI instrument drivers for the AG34401A instrument. You also need to load the Agilent COM components.\n\nCommunication must previously have been opened using the AG34401A_Init or AG34401A_InitWithOptions function.\n\nThis function does not reset the instrument or change any existing settings.\n\nA fail is generated if this function is unable to close the communication channel.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$agHandle\n\nObject\n\nHandle to previously opened instrument communication channel.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n\n\n\n\n// Open and close communication.\n\n$resource = \"GPIB0::11::INSTR\";\n\n\n\n$agHandle = AG34401A_Init($resource);\n\n\n\nAG34401A_Close($agHandle);\n\n\n\n\n\nAG34401A_Init\n\nPrevious Top Next\n\n\n\n"
 },
 "JTS AG34401A_MeasureDCCurrent": {
  "prefix": "AG34401A_MeasureDCCurrent",
  "body": [
   "$$measurement=AG34401A_MeasureDCCurrent($$agHandle,$$timeout,$$range,$$resolution);"
  ],
  "description": "\n\nThis function performs a DC current measurement and returns the result.\n\n\n\n\n\nRemarks:\n\nThis function uses the Agilent IVI instrument drivers for the AG34401A instrument. You also need to load the Agilent COM components.\n\nCommunication must previously have been opened using the AG34401A_Init or AG34401A_InitWithOptions function.\n\nA fail is generated if the instrument is unable to make a measurement or times out.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$agHandle\n\nObject\n\nHandle to previously opened instrument communication channel.\n\n\n\n$timeout\n\nInteger\n\nNumber of milliseconds to wait for a measurement before returning a fail result.\n\n\n\n$range\n\nFloat\n\nThe range for the measurement.\n\n\n\n$resolution\n\nFloat\n\nThe resolution for the measurement.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$measurement\n\nFloat\n\nThe DC current measurement.\n\n\n\n\n\nExample:\n\n\n\n// Open communication.\n\n$resource = \"GPIB0::11::INSTR\";\n\n\n\n$agHandle = AG34401A_Init($resource);\n\n\n\n// Make a DC Current measurement.\n\n$timeout = 1000;\n\n$range = 1;\n\n$resol = 0.0001;\n\n\n\n$measure = AG34401A_MeasureDCCurrent($agHandle, $timeout, $range, $resol);\n\n\n\n\n\nAG34401A_MeasureDCVolt\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG34401A_MeasureDCVolt": {
  "prefix": "AG34401A_MeasureDCVolt",
  "body": [
   "$$measurement=AG34401A_MeasureDCVolt($$agHandle,$$timeout,$$range,$$resolution);"
  ],
  "description": "\n\nThis function performs a DC voltage measurement and returns the result.\n\n\n\n\n\nRemarks:\n\nThis function uses the Agilent IVI instrument drivers for the AG34401A instrument. You also need to load the Agilent COM components.\n\nCommunication must previously have been opened using the AG34401A_Init or AG34401A_InitWithOptions function.\n\nA fail is generated if the instrument is unable to make a measurement or times out.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$agHandle\n\nObject\n\nHandle to previously opened instrument communication channel.\n\n\n\n$timeout\n\nInteger\n\nNumber of milliseconds to wait for a measurement before returning a fail result.\n\n\n\n$range\n\nFloat\n\nThe range for the measurement.\n\n\n\n$resolution\n\nFloat\n\nThe resolution for the measurement.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$measurement\n\nFloat\n\nThe DC Voltage measurement.\n\n\n\n\n\nExample:\n\n\n\n// Open communication.\n\n$resource = \"GPIB0::11::INSTR\";\n\n\n\n$agHandle = AG34401A_Init($resource);\n\n\n\n// Make a DC Voltage measurement.\n\n$timeout = 1000;\n\n$range = 5;\n\n$resol = 0.001;\n\n\n\n$measure = AG34401A_MeasureDCVolt($agHandle, $timeout, $range, $resol);\n\n\n\n\n\nAG34401A_MeasureResistance\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG34401A_MeasureResistance": {
  "prefix": "AG34401A_MeasureResistance",
  "body": [
   "$$measurement=AG34401A_MeasureResistance($$agHandle,$$timeout,$$range,$$resolution);"
  ],
  "description": "\n\nThis function performs a resistance measurement and returns the result.\n\n\n\n\n\nRemarks:\n\nThis function uses the Agilent IVI instrument drivers for the AG34401A instrument. You also need to load the Agilent COM components.\n\nCommunication must previously have been opened using the AG34401A_Init or AG34401A_InitWithOptions function.\n\nA fail is generated if the instrument is unable to make a measurement or times out.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$agHandle\n\nObject\n\nHandle to previously opened instrument communication channel.\n\n\n\n$timeout\n\nInteger\n\nNumber of milliseconds to wait for a measurement before returning a fail result.\n\n\n\n$range\n\nFloat\n\nThe range for the measurement.\n\n\n\n$resolution\n\nFloat\n\nThe resolution for the measurement.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$measurement\n\nFloat\n\nThe resistance measurement.\n\n\n\n\n\nExample:\n\n\n\n// Open communication.\n\n$resource = \"GPIB0::11::INSTR\";\n\n\n\n$agHandle = AG34401A_Init($resource);\n\n\n\n// Make a Resistance measurement.\n\n$timeout = 1000;\n\n$range = 1000;\n\n$resol = 0.1;\n\n\n\n$measure = AG34401A_MeasureResistance($agHandle, $timeout, $range, $resol);\n\n\n\n\n\nAG34401A_SetDisplay\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG34401A_SetDisplay": {
  "prefix": "AG34401A_SetDisplay",
  "body": [
   "AG34401A_SetDisplay($$agHandle,$$text);"
  ],
  "description": "\n\nThis function sets the display text on the instrument.\n\n\n\n\n\nRemarks:\n\nThis function uses the Agilent IVI instrument drivers for the AG34401A instrument. You also need to load the Agilent COM components.\n\nCommunication must previously have been opened using the AG34401A_Init or AG34401A_InitWithOptions function.\n\nA fail is generated if the instrument is unable to set the display text.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$agHandle\n\nObject\n\nHandle to previously opened instrument communication channel.\n\n\n\n$text\n\nString\n\nThe text to be displayed on the instrument (13 characters maximum).\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n\n\n// Open communication.\n\n$resource = \"GPIB0::11::INSTR\";\n\n\n\n$agHandle = AG34401A_Init($resource);\n\n\n\n// Display some text.\n\n$text = \"MEASURING\";\n\n\n\nAG34401A_SetDisplay($agHandle, $text);\n\n\n\n\n\nAG34410A_Close\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG34410A_Close": {
  "prefix": "AG34410A_Close",
  "body": [
   "AG34410A_Close($$Handle);"
  ],
  "description": "\n\nThis function closes the communication with the instrument and releases resources used by the instrument.\n\n\n\n\n\nRequirements:\n\n\u00b7 This function uses the Agilent IVI-COM driver which must be installed before using these functions.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nThe communcations handle of the instrument returned by the AG34410A_Init function.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n\n\n\n\nAG34410A_Close($Handle);\n\n\n\n\n\nAG34410A_ConfigureDCCurrentRange\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG34410A_ConfigureDCCurrentRange": {
  "prefix": "AG34410A_ConfigureDCCurrentRange",
  "body": [
   "AG34410A_ConfigureDCCurrentRange($$Handle,$$Range,$$Resolution);"
  ],
  "description": "\n\nThis function initializes the range and resolution setting of the AG34410A multimeter. This function can be used to reset the instruments current range setting to eliminate problems that can occur with the current meter causing a voltage drop in a circuit due to it's internal burden voltage.\n\n\n\n\n\nRequirements:\n\n\u00b7 This function uses the Agilent IVI-COM driver which must be installed before using these functions.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nThe communcations handle of the instrument returned by the AG34410A_Init function.\n\n\n\n$Range\n\nFloat\n\nThe specified range for the instrument reading.\n\n\n\n$Resolution\n\nString\n\nThe specified resolution for the instrument.\n\n\n\n\n\nAllowable values are:\n\n\u00b7 \"LEAST\" = Fastest, Least Accurate\n\n\u00b7 \"DEFAULT\" = Default Setting\n\n\u00b7 \"BEST\" = Slowest, Most Accurate\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n\n\n\n\nAG34410A_ConfigureDCCurrentRange($Handle,0.00001,\"BEST\");\n\n// Configures the instrument for 100 uAmp range.\n\n\n\n\n\nAG34410A_Init\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG34410A_Init": {
  "prefix": "AG34410A_Init",
  "body": [
   "$$Handle=AG34410A_Init($$InstrumentID);"
  ],
  "description": "\n\nThis function opens, and initializes the Agilent 34410A digital multimeter and prepares it for further operations.\n\n\n\n\n\nRequirements:\n\n\u00b7 This function uses the Agilent IVI-COM driver which must be installed before using these functions.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentID\n\nString\n\nThe GPIB address of the Instrument, for example \"GPIB0::3::Instr\".\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nA communications handle for the instrument to pass to subsequent function calls.\n\n\n\n\n\nExample:\n\n\n\n\n\n$AG34410A = AG34410A_Init(\"GPIB0::3::INSTR\");\n\n\n\n\n\nAG34410A_MeasureACCurrent\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG34410A_MeasureACCurrent": {
  "prefix": "AG34410A_MeasureACCurrent",
  "body": [
   "$$Measurement=AG34410A_MeasureACCurrent($$Handle,$$Range,$$Resolution);"
  ],
  "description": "\n\nThis function performs a AC Current measurement on the Agilent 34410A using the supplied Range and Resolution settings.\n\n\n\n\n\nRequirements:\n\n\u00b7 This function uses the Agilent IVI-COM driver which must be installed before using these functions.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nThe communcations handle of the instrument returned by the AG34410A_Init function.\n\n\n\n$Range\n\nFloat\n\nThe specified range for the instrument reading. If the sampled value is outside of the range specified, the instrument will autorange automatically. This means that the measurement will take longer to acquire, but will still be an accurate parametric measurement.\n\n\n\n$Resolution\n\nString\n\nThe specified resolution for the measurement. This parameter specifies the desired accuracy of the measurement to acquire. The more accurate the measurement, the longer the measurement will require.\n\nAllowable values are:\n\n\u00b7 \"LEAST\" = Fastest, Least Accurate\n\n\u00b7 \"DEFAULT\" = Default Setting\n\n\u00b7 \"BEST\" = Slowest, Most Accurate\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Measurement\n\nFloat\n\nThe acquired measurement value.\n\n\n\n\n\nExample:\n\n\n\n\n\n$Measurement = AG34410A_MeasureACCurrent($Handle,1,\"BEST\");\n\n\n\n\n\nAG34410A_MeasureACVolt\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG34410A_MeasureACVolt": {
  "prefix": "AG34410A_MeasureACVolt",
  "body": [
   "$$Measurement=AG34410A_MeasureACVolt($$Handle,$$Range,$$Resolution);"
  ],
  "description": "\n\nThis function performs a AC Voltage measurement on the Agilent 34410A using the supplied Range and Resolution settings.\n\n\n\n\n\nRequirements:\n\n\u00b7 This function uses the Agilent IVI-COM driver which must be installed before using these functions.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nThe communcations handle of the instrument returned by the AG34410A_Init function.\n\n\n\n$Range\n\nFloat\n\nThe specified range for the instrument reading. If the sampled value is outside of the range specified, the instrument will autorange automatically. This means that the measurement will take longer to acquire, but will still be an accurate parametric measurement.\n\n\n\n$Resolution\n\nString\n\nThe specified resolution for the measurement. This parameter specifies the desired accuracy of the measurement to acquire. The more accurate the measurement, the longer the measurement will require.\n\nAllowable values are:\n\n\u00b7 \"LEAST\" = Fastest, Least Accurate\n\n\u00b7 \"DEFAULT\" = Default Setting\n\n\u00b7 \"BEST\" = Slowest, Most Accurate\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Measurement\n\nFloat\n\nThe acquired measurement value.\n\n\n\n\n\nExample:\n\n\n\n\n\n$Measurement = AG34410A_MeasureACVolt($Handle,1,\"BEST\");\n\n\n\n\n\nAG34410A_MeasureDCCurrent\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG34410A_MeasureDCCurrent": {
  "prefix": "AG34410A_MeasureDCCurrent",
  "body": [
   "$$Measurement=AG34410A_MeasureDCCurrent($$Handle,$$Range,$$Resolution);"
  ],
  "description": "\n\nThis function performs a DC Current measurement on the Agilent 34410A using the supplied Range and Resolution settings.\n\n\n\n\n\nRequirements:\n\n\u00b7 This function uses the Agilent IVI-COM driver which must be installed before using these functions.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nThe communcations handle of the instrument returned by the AG34410A_Init function.\n\n\n\n$Range\n\nFloat\n\nThe specified range for the instrument reading. If the sampled value is outside of the range specified, the instrument will autorange automatically. This means that the measurement will take longer to acquire, but will still be an accurate parametric measurement.\n\n\n\n$Resolution\n\nString\n\nThe specified resolution for the measurement. This parameter specifies the desired accuracy of the measurement to acquire. The more accurate the measurement, the longer the measurement will require.\n\nAllowable values are:\n\n\u00b7 \"LEAST\" = Fastest, Least Accurate\n\n\u00b7 \"DEFAULT\" = Default Setting\n\n\u00b7 \"BEST\" = Slowest, Most Accurate\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Measurement\n\nFloat\n\nThe acquired measurement value.\n\n\n\n\n\nExample:\n\n\n\n\n\n$Measurement = AG34410A_MeasureDCCurrent($Handle,1,\"BEST\");\n\n\n\n\n\nAG34410A_MeasureDCVolt\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG34410A_MeasureDCVolt": {
  "prefix": "AG34410A_MeasureDCVolt",
  "body": [
   "$$Measurement=AG34410A_MeasureDCVolt($$Handle,$$Range,$$Resolution);"
  ],
  "description": "\n\nThis function performs a DC Voltage measurement on the Agilent 34410A using the supplied Range and Resolution settings.\n\n\n\n\n\nRequirements:\n\n\u00b7 This function uses the Agilent IVI-COM driver which must be installed before using these functions.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nThe communcations handle of the instrument returned by the AG34410A_Init function.\n\n\n\n$Range\n\nFloat\n\nThe specified range for the instrument reading. If the sampled value is outside of the range specified, the instrument will autorange automatically. This means that the measurement will take longer to acquire, but will still be an accurate parametric measurement.\n\n\n\n$Resolution\n\nString\n\nThe specified resolution for the measurement. This parameter specifies the desired accuracy of the measurement to acquire. The more accurate the measurement, the longer the measurement will require.\n\nAllowable values are:\n\n\u00b7 \"LEAST\" = Fastest, Least Accurate\n\n\u00b7 \"DEFAULT\" = Default Setting\n\n\u00b7 \"BEST\" = Slowest, Most Accurate\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Measurement\n\nFloat\n\nThe acquired measurement value.\n\n\n\n\n\nExample:\n\n\n\n\n\n$Measurement = AG34410A_MeasureDCVolt($Handle,1,\"BEST\");\n\n\n\n\n\nAG34410A_MeasureResistance\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG34410A_MeasureResistance": {
  "prefix": "AG34410A_MeasureResistance",
  "body": [
   "$$Measurement=AG34410A_MeasureResistance($$Handle,$$Range,$$Resolution);"
  ],
  "description": "\n\nThis function performs a resistance measurement on the Agilent 34410A using the supplied Range and Resolution settings.\n\n\n\n\n\nRequirements:\n\n\u00b7 This function uses the Agilent IVI-COM driver which must be installed before using these functions.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nThe communcations handle of the instrument returned by the AG34410A_Init function.\n\n\n\n$Range\n\nFloat\n\nThe specified range for the instrument reading. If the sampled value is outside of the range specified, the instrument will autorange automatically. This means that the measurement will take longer to acquire, but will still be an accurate parametric measurement.\n\n\n\n$Resolution\n\nString\n\nThe specified resolution for the measurement. This parameter specifies the desired accuracy of the measurement to acquire. The more accurate the measurement, the longer the measurement will require.\n\nAllowable values are:\n\n\u00b7 \"LEAST\" = Fastest, Least Accurate\n\n\u00b7 \"DEFAULT\" = Default Setting\n\n\u00b7 \"BEST\" = Slowest, Most Accurate\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Measurement\n\nFloat\n\nThe acquired measurement value.\n\n\n\n\n\nExample:\n\n\n\n\n\n$Measurement = AG34410A_MeasureResistance($Handle,1,\"BEST\");\n\n\n\n\n\nAG34410A_SetTimeout\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG34410A_SetTimeout": {
  "prefix": "AG34410A_SetTimeout",
  "body": [
   "AG34410A_SetTimeout($$Handle,$$Timeout);"
  ],
  "description": "\n\nThis function sets the timeout value for all measurement functions.\n\n\n\n\n\nRemarks:\n\nThis function uses the Agilent 34410A IVI-COM driver which must be installed before using these functions.\n\nIf a measurement can't be completed within the timeout allotted, the function will generate a failure.\n\nThe default timeout of the instrument is 2 seconds.\n\nThe $Timeout parameter is specified in milliseconds.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nThe communcations handle of the instrument returned by the AG34410A_Init function.\n\n\n\n$Timeout\n\nInteger\n\nThe timeout setting of the instrument specified in milliseconds.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n\n\n\n\n// Connect to the instrument.\n\n$visa = \"GPIB0::10::INSTR\";\n\n$handle = AG34410A_Init($visa);\n\n\n\n// Set the timeout value to 10 seconds.\n\n$timeout = 10000;\n\n\n\nAG34410A_SetTimeout($handle, $timeout);\n\n\n\n\n\nAG34970A_Close\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG34970A_Close": {
  "prefix": "AG34970A_Close",
  "body": [
   "AG34970A_Close($$AgInstance);"
  ],
  "description": "\n\nThis function uses the Agilent IVI Instrument drivers. In order to use the AG34970A functions in JabilTest, you need to have the Agilent COM components installed.\n\nThis function closes the AG34970A and recovers used resources. It does not reset the unit or change it's existing settings. This function returns a passing result if the instrument was closed successfully, otherwise a failure is generated by the script function.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AgInstance\n\nObject\n\nThe COM Object representing the instance of the AG34970A to be closed. Closing the instrument releases all resources.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nAG34970A_CloseChannelList\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG34970A_CloseChannelList": {
  "prefix": "AG34970A_CloseChannelList",
  "body": [
   "AG34970A_CloseChannelList($$AgInstance,$$ChannelList);"
  ],
  "description": "\n\nThis function uses the Agilent IVI Instrument drivers. In order to use the AG34970 functions in JabilTest, you need to have the Agilent COM components installed.\n\nThis function closes the channel connections specified in the list on the measurement mainframe.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AgInstance\n\nObject\n\nA COM Object representing an instance of the AG34970A.\n\n\n\n$ChannelList\n\nString\n\nList of channels to close separated by commas.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nAG34970A_CloseExclusiveChannel\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG34970A_CloseExclusiveChannel": {
  "prefix": "AG34970A_CloseExclusiveChannel",
  "body": [
   "AG34970A_CloseExclusiveChannel($$AgInstance,$$ChannelNumber);"
  ],
  "description": "\n\nThis function uses the Agilent IVI Instrument drivers. In order to use the AG34970 functions in JabilTest, you need to have the Agilent COM components installed.\n\nThis function closes one channel connection on the measurement mainframe.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AgInstance\n\nObject\n\nA COM Object representing an instance of the AG34970A.\n\n\n\n$ChannelNumber\n\nInteger\n\nThe channel to close.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nAG34970A_ConfigureACVolt\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG34970A_ConfigureACVolt": {
  "prefix": "AG34970A_ConfigureACVolt",
  "body": [
   "AG34970A_ConfigureACVolt($$AgInstance,$$ChannelNumber,$$Range,$$Resolution);"
  ],
  "description": "\n\nThis function uses the Agilent IVI Instrument drivers. In order to use the AG34970 functions in JabilTest, you need to have the Agilent COM components installed.\n\nThis function configures the AC voltage measurement subsystem for the specified channel, however it does not begin the actual acquisition process. In order to perform a measurement after the channel has been configured, use the AG34970A_Read function.\n\nIn the case of instrument communication failure, or an invalid channel specified, a failure is generated by the function.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AgInstance\n\nObject\n\nA COM Object representing an instance of the AG34970A.\n\n\n\n$ChannelNumber\n\nInteger\n\nThe channel to configure for an AC voltage measurement.\n\n\n\n$Range\n\nFloat\n\nThe Range for the measurement channel.\n\n\n\n$Resolution\n\nFloat\n\nThe resolution for the measurement channel.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nAG34970A_ConfigureDCVolt\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG34970A_ConfigureDCVolt": {
  "prefix": "AG34970A_ConfigureDCVolt",
  "body": [
   "AG34970A_ConfigureDCVolt($$AgInstance,$$ChannelNumber,$$Range,$$Resolution);"
  ],
  "description": "\n\nThis function uses the Agilent IVI Instrument drivers. In order to use the AG34970 functions in JabilTest, you need to have the Agilent COM components installed.\n\nThis function configures the DC voltage measurement subsystem for the specified channel, however it does not begin the actual acquisition process. In order to perform a measurement after the channel has been configured, use the AG34970A_Read function.\n\nIn the case of instrument communication failure, or an invalid channel specified, a failure is generated by the function.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AgInstance\n\nObject\n\nA COM Object representing an instance of the AG34970A.\n\n\n\n$ChannelNumber\n\nInteger\n\nThe channel to configure for a DC voltage measurement.\n\n\n\n$Range\n\nFloat\n\nThe Range for the measurement channel.\n\n\n\n$Resolution\n\nFloat\n\nThe resolution for the measurement channel.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nAG34970A_ConfigureResistance\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG34970A_ConfigureResistance": {
  "prefix": "AG34970A_ConfigureResistance",
  "body": [
   "AG34970A_ConfigureResistance($$AgInstance,$$ChannelNumber,$$Range,$$Resolution);"
  ],
  "description": "\n\nThis function uses the Agilent IVI Instrument drivers. In order to use the AG34970 functions in JabilTest, you need to have the Agilent COM components installed.\n\nThis function configures the resistance measurement subsystem for the specified channel, however it does not begin the actual acquisition process. In order to perform a measurement after the channel has been configured, use the AG34970A_Read function.\n\nIn the case of instrument communication failure, or an invalid channel specified, a failure is generated by the function.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AgInstance\n\nObject\n\nA COM Object representing an instance of the AG34970A.\n\n\n\n$ChannelNumber\n\nInteger\n\nThe channel to configure for a resistance measurement.\n\n\n\n$Range\n\nFloat\n\nThe Range for the measurement channel.\n\n\n\n$Resolution\n\nFloat\n\nThe resolution for the measurement channel.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n// Set up channel 214 with a 100K range and 1% resolution.\n\nAG34970A_ConfigureResistance($AgInstance, 214, 100E+3, 1000);\n\n\n\n\n\nAG34970A_DACGetVoltage\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG34970A_DACGetVoltage": {
  "prefix": "AG34970A_DACGetVoltage",
  "body": [
   "$$voltLevel=AG34970A_DACGetVoltage($$AgInstance,$$ChannelNumber);"
  ],
  "description": "\n\nThis function uses the Agilent IVI Instrument drivers. In order to use the AG34970 functions in JabilTest, you need to have the Agilent COM components installed.\n\n\n\n\n\nThis function returns the voltage level from the specified DAC channel.\n\n\n\n\n\nRemarks:\n\n\u00b7 Not all modules for an Agilent 34970A mainframe have DAC channels.\n\n\u00b7 Only channels 04 and 05 are usable for DAC voltages.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AgInstance\n\nObject\n\nA COM Object representing an instance of the AG34970A.\n\n\n\n$ChannelNumber\n\nInteger\n\nThe number of the channel to set the output line of. This follows standard Agilent 34970A numbering convention (ie. 1st module channels start at 1xx, 2nd module at 2xx, etc).\n\nOnly channel x04 and x05 are DAC channels.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$voltLevel\n\nFloat\n\nThe voltage the DAC channel is set to.\n\nValues: -12.00 to +12.00 in 1mV steps.\n\n\n\n\n\nExample:\n\n\n\n\n\n$AgInstance = AG34970A_Init(\"GPIB0::9::Instr\");\n\n\n\n\n\n// Read volts on channel 204.\n\n$voltLevel = AG34970A_DACGetVoltage($AgInstance, 204);\n\n\n\n\n\nAG34970A_DACSetVoltage\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG34970A_DACSetVoltage": {
  "prefix": "AG34970A_DACSetVoltage",
  "body": [
   "AG34970A_DACSetVoltage($$AgInstance,$$ChannelNumber,$$voltLevel);"
  ],
  "description": "\n\nThis function uses the Agilent IVI Instrument drivers. In order to use the AG34970 functions in JabilTest, you need to have the Agilent COM components installed.\n\n\n\n\n\nThis function sets a specified DAC channel to a specified voltage level.\n\n\n\n\n\nRemarks:\n\n\u00b7 Not all modules for an Agilent 34970A mainframe have DAC channels.\n\n\u00b7 Only channels 04 and 05 are usable for DAC voltage output.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AgInstance\n\nObject\n\nA COM Object representing an instance of the AG34970A.\n\n\n\n$ChannelNumber\n\nInteger\n\nThe number of the channel to set the output line of. This follows standard Agilent 34970A numbering convention (ie. 1st module channels start at 1xx, 2nd module at 2xx, etc).\n\nOnly channel x04 and x05 are DAC channels.\n\n\n\n$voltLevel\n\nFloat\n\nThe voltage to set the DAC channel to.\n\nValues: -12.00 to +12.00 in 1mV steps.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone.\n\n\n\n\n\nExample:\n\n\n\n\n\n$AgInstance = AG34970A_Init(\"GPIB0::9::Instr\");\n\n\n\n\n\n// Output 5 volts on channel 204.\n\nAG34970A_DACSetVoltage($AgInstance, 204, 5);\n\n\n\n\n\nAG34970_DigitalInputLine\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG34970A_DigitalInputLine": {
  "prefix": "AG34970A_DigitalInputLine",
  "body": [
   "$$lineIn=AG34970A_DigitalInputLine($$AgInstance,$$ChannelNumber,$$LineNumber);"
  ],
  "description": "\n\nThis function uses the Agilent IVI Instrument drivers. In order to use the AG34970 functions in JabilTest, you need to have the Agilent COM components installed.\n\n\n\n\n\nThis function reads a digital input line from a specified port (one line on the port) from a digital output module in the Agilent 34970A Mainframe.\n\n\n\n\n\nRemarks:\n\n\u00b7 Only the specified line from the port is returned.\n\n\u00b7 If the port can do input and output, it will be switched to input - any output value will be lost.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AgInstance\n\nObject\n\nA COM Object representing an instance of the AG34970A.\n\n\n\n$ChannelNumber\n\nInteger\n\nThe number of the channel to read the input line from. This follows standard Agilent 34970A numbering convention (ie. 1st module channels start at 1xx, 2nd module at 2xx, etc).\n\n\n\n$LineNumber\n\nInteger\n\nThe Line of the channel to read.\n\nValue: 0 to 7.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$lineIn\n\nBoolean\n\nThe value returned from the specified line.\n\n\n\n\n\nExample:\n\n\n\n\n\n$AgInstance = AG34970A_Init(\"GPIB0::9::Instr\");\n\n// Read line 1 on port 201.\n\n$lineIn = AG34970A_DigitalInputLine($AgInstance, 201, 1);\n\n// Read line 5 on port 201.\n\n$lineIn = AG34970A_DigitalInputLine($AgInstance, 201, 5);\n\n\n\n\n\nAG34970A_DigitalInputPort\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG34970A_DigitalInputPort": {
  "prefix": "AG34970A_DigitalInputPort",
  "body": [
   "$$portIn=AG34970A_DigitalInputPort($$AgInstance,$$ChannelNumber);"
  ],
  "description": "\n\nThis function uses the Agilent IVI Instrument drivers. In order to use the AG34970 functions in JabilTest, you need to have the Agilent COM components installed.\n\n\n\n\n\nThis function reads a digital input port (8 lines or 1 byte) from a digital input module in the Agilent 34970A Mainframe.\n\n\n\n\n\nRemarks:\n\n\u00b7 All lines in the port are read at once.\n\n\u00b7 If the port can do input and output, it will be switched to input - any output value will be lost.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AgInstance\n\nObject\n\nA COM Object representing an instance of the AG34970A.\n\n\n\n$ChannelNumber\n\nInteger\n\nThe number of the channel to read the input port of. This follows standard Agilent 34970A numbering convention (ie. 1st module channels start at 1xx, 2nd module at 2xx, etc).\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$portIn\n\nInteger\n\nThe value read from the specified port.\n\n\n\n\n\nExample:\n\n\n\n\n\n$AgInstance = AG34970A_Init(\"GPIB0::9::Instr\");\n\n// Read port from channel 302.\n\n$portIn = AG34970A_DigitalInputPort($AgInstance, 302);\n\n\n\n\n\nAG34970A_DigitalOutputLine\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG34970A_DigitalOutputLine": {
  "prefix": "AG34970A_DigitalOutputLine",
  "body": [
   "AG34970A_DigitalOutputLine($$AgInstance,$$ChannelNumber,$$LineNumber,$$Value);"
  ],
  "description": "\n\nThis function uses the Agilent IVI Instrument drivers. In order to use the AG34970 functions in JabilTest, you need to have the Agilent COM components installed.\n\n\n\n\n\nThis function sets a digital output line on a specified port (one line without changing the other lines on the port) on a digital output module in the Agilent 34970A Mainframe to a specified value.\n\n\n\n\n\nRemarks:\n\n\u00b7 Only the specified line in the port is set. The other lines will not be changed.\n\n\u00b7 The line value is not case sensitive.\n\n\u00b7 If the port can do input and output, it will be switched to output.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AgInstance\n\nObject\n\nA COM Object representing an instance of the AG34970A.\n\n\n\n$ChannelNumber\n\nInteger\n\nThe number of the channel to set the output line of. This follows standard Agilent 34970A numbering convention (ie. 1st module channels start at 1xx, 2nd module at 2xx, etc).\n\n\n\n$LineNumber\n\nInteger\n\nThe Line of the channel to set.\n\nValue: 0 to 7.\n\n\n\n$Value\n\nString\n\nThe value to set the line to.\n\nValues: 0, 1, \"On\", \"Off\", \"True\", \"False\"\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone.\n\n\n\n\n\nExample:\n\n\n\n\n\n$AgInstance = AG34970A_Init(\"GPIB0::9::Instr\");\n\n// Turn on line 1 on port 201.\n\nAg34970A_DigitalOutputLine($AgInstance, 201, 1, \"On\");\n\n// Turn off line 5 on port 201.\n\nAG34970A_DigitalOutputLine($AgInstance, 201, 5, 0);\n\n\n\n\n\nAG34970A_DigitalOutputPort\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG34970A_DigitalOutputPort": {
  "prefix": "AG34970A_DigitalOutputPort",
  "body": [
   "AG34970A_DigitalOutputPort($$AgInstance,$$ChannelNumber,$$ByteOut);"
  ],
  "description": "\n\nThis function uses the Agilent IVI Instrument drivers. In order to use the AG34970 functions in JabilTest, you need to have the Agilent COM components installed.\n\n\n\n\n\nThis function sets a digital output port (8 lines or 1 byte) on a digital output module in the Agilent 34970A Mainframe to a specified value.\n\n\n\n\n\nRemarks:\n\n\u00b7 All lines in the port are set at once. Any existing output values will be overwritten.\n\n\u00b7 If the port can do input and output, it will be switched to output.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AgInstance\n\nObject\n\nA COM Object representing an instance of the AG34970A.\n\n\n\n$ChannelNumber\n\nInteger\n\nThe number of the channel to set the output port of. This follows standard Agilent 34970A numbering convention (ie. 1st module channels start at 1xx, 2nd module at 2xx, etc).\n\n\n\n$ByteOut\n\nInteger\n\nThe value to set the specified port to.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone.\n\n\n\n\n\nExample:\n\n\n\n\n\n$AgInstance = AG34970A_Init(\"GPIB0::9::Instr\");\n\n// Turn on lines 0, 1, 4 and 6 (01010011).\n\nAG34970A_DigitalOutputPort($AgInstance, 302, 83);\n\n\n\n\n\nAG34970A_Init\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG34970A_Init": {
  "prefix": "AG34970A_Init",
  "body": [
   "$$agHandle=AG34970A_Init($$resourceString);"
  ],
  "description": "\n\nThis function opens communications to the Agilent 34970A. It does not reset the unit or change any of its existing settings. I grabs an instance of the COM component to use in further test script operations. This function returns a pass result if the instrument communication was successfully opened, a fail result otherwise.\n\n\n\n\n\nRemarks:\n\nThis function uses the Agilent IVI instrument drivers. You need to have the Agilent COM components installed (included in the Agilent IO Suite).\n\nThis function will initialize communications with Agilent 34970A and 34972A instruments.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$resourceString\n\nString\n\nA VISA resource string identifying the instrument. Example: \"GPIB0::9::INSTR\".\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$agHandle\n\nObject\n\nA handle to this instance of the AG34970A driver that can be passed to other AG34970A script functions.\n\n\n\n\n\nExample:\n\n\n\n\n\n// Get column 2 from a 2 dimensional array.\n\n$resourceString = \"GPIB0::9::INSTR\";\n\n$agHandle = AG34970A_Init($resourceString);\n\n\n\n\n\nAG34970A_MeasureACCurrent\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG34970A_MeasureACCurrent": {
  "prefix": "AG34970A_MeasureACCurrent",
  "body": [
   "$$Measurement=AG34970A_MeasureACCurrent($$AgInstance,$$ChannelNumber,$$Range,$$Resolution);"
  ],
  "description": "\n\nThis function uses the Agilent IVI Instrument drivers. In order to use the AG34970 functions in JabilTest, you need to have the Agilent COM components installed.\n\nThis function takes one AC Current measurement on the specified channel and returns the measurement. In the case of instrument communication failure, or an invalid channel specified, a failure is generated by the function.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AgInstance\n\nObject\n\nA COM Object representing an instance of the AG34970A.\n\n\n\n$ChannelNumber\n\nInteger\n\nThe channel on which to take the measurement.\n\n\n\n$Range\n\nFloat\n\nThe Range for the measurement channel.\n\n\n\n$Resolution\n\nFloat\n\nThe resolution for the measurement channel.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Measurement\n\nFloat\n\nThe AC Current measurement from the specified channel.\n\n\n\n\n\nAG34970A_MeasureACVolt\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG34970A_MeasureACVolt": {
  "prefix": "AG34970A_MeasureACVolt",
  "body": [
   "$$Measurement=AG34970A_MeasureACVolt($$AgInstance,$$ChannelNumber,$$Range,$$Resolution);"
  ],
  "description": "\n\nThis function uses the Agilent IVI Instrument drivers. In order to use the AG34970 functions in JabilTest, you need to have the Agilent COM components installed.\n\nThis function takes one AC voltage measurement on the specified channel and returns the measurement. In the case of instrument communication failure, or an invalid channel specified, a failure is generated by the function.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AgInstance\n\nObject\n\nA COM Object representing an instance of the AG34970A.\n\n\n\n$ChannelNumber\n\nInteger\n\nThe channel on which to take the measurement.\n\n\n\n$Range\n\nFloat\n\nThe Range for the measurement channel.\n\n\n\n$Resolution\n\nFloat\n\nThe resolution for the measurement channel.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Measurement\n\nFloat\n\nThe AC Voltage measurement from the specified channel.\n\n\n\n\n\nAG34970A_MeasureDCCurrent\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG34970A_MeasureDCCurrent": {
  "prefix": "AG34970A_MeasureDCCurrent",
  "body": [
   "$$Measurement=AG34970A_MeasureDCCurrent($$AgInstance,$$ChannelNumber,$$Range,$$Resolution);"
  ],
  "description": "\n\nThis function uses the Agilent IVI Instrument drivers. In order to use the AG34970 functions in JabilTest, you need to have the Agilent COM components installed.\n\nThis function takes one DC Current measurement on the specified channel and returns the measurement. In the case of instrument communication failure, or an invalid channel specified, a failure is generated by the function.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AgInstance\n\nObject\n\nA COM Object representing an instance of the AG34970A.\n\n\n\n$ChannelNumber\n\nInteger\n\nThe channel on which to take the measurement.\n\n\n\n$Range\n\nFloat\n\nThe Range for the measurement channel.\n\n\n\n$Resolution\n\nFloat\n\nThe resolution for the measurement channel.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Measurement\n\nFloat\n\nThe DC Current measurement from the specified channel.\n\n\n\n\n\nAG34970A_MeasureDCVolt\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG34970A_MeasureDCVolt": {
  "prefix": "AG34970A_MeasureDCVolt",
  "body": [
   "$$Measurement=AG34970A_MeasureDCVolt($$AgInstance,$$ChannelNumber,$$Range,$$Resolution);"
  ],
  "description": "\n\nThis function uses the Agilent IVI Instrument drivers. In order to use the AG34970 functions in JabilTest, you need to have the Agilent COM components installed.\n\nThis function takes one DC voltage measurement on the specified channel and returns the measurement. In the case of instrument communication failure, or an invalid channel specified, a failure is generated by the function.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AgInstance\n\nObject\n\nA COM Object representing an instance of the AG34970A.\n\n\n\n$ChannelNumber\n\nInteger\n\nThe channel on which to take the measurement.\n\n\n\n$Range\n\nFloat\n\nThe Range for the measurement channel.\n\n\n\n$Resolution\n\nFloat\n\nThe resolution for the measurement channel.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Measurement\n\nFloat\n\nThe DC Voltage measurement from the specified channel.\n\n\n\n\n\nAG34970A_MeasureFrequency\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG34970A_MeasureFrequency": {
  "prefix": "AG34970A_MeasureFrequency",
  "body": [
   "$$Measurement=AG34970A_MeasureFrequency($$AgInstance,$$ChannelNumber,$$Range,$$Resolution);"
  ],
  "description": "\n\nThis function uses the Agilent IVI Instrument drivers. In order to use the AG34970 functions in JabilTest, you need to have the Agilent COM components installed.\n\nThis function takes one Frequency measurement on the specified channel and returns the measurement. In the case of instrument communication failure, or an invalid channel specified, a failure is generated by the function.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AgInstance\n\nObject\n\nA COM Object representing an instance of the AG34970A.\n\n\n\n$ChannelNumber\n\nInteger\n\nThe channel on which to take the measurement.\n\n\n\n$Range\n\nFloat\n\nThe Range for the measurement channel.\n\n\n\n$Resolution\n\nFloat\n\nThe resolution for the measurement channel.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Measurement\n\nFloat\n\nThe Frequency measurement from the specified channel.\n\n\n\n\n\nAG34970A_MeasurePeriod\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG34970A_MeasurePeriod": {
  "prefix": "AG34970A_MeasurePeriod",
  "body": [
   "$$Measurement=AG34970A_MeasurePeriod($$AgInstance,$$ChannelNumber,$$Range,$$Resolution);"
  ],
  "description": "\n\nThis function uses the Agilent IVI Instrument drivers. In order to use the AG34970 functions in JabilTest, you need to have the Agilent COM components installed.\n\nThis function takes one Period measurement on the specified channel and returns the measurement. In the case of instrument communication failure, or an invalid channel specified, a failure is generated by the function.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AgInstance\n\nObject\n\nA COM Object representing an instance of the AG34970A.\n\n\n\n$ChannelNumber\n\nInteger\n\nThe channel on which to take the measurement.\n\n\n\n$Range\n\nFloat\n\nThe Range for the measurement channel.\n\n\n\n$Resolution\n\nFloat\n\nThe resolution for the measurement channel.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Measurement\n\nFloat\n\nThe Period measurement from the specified channel.\n\n\n\n\n\nAG34970A_MeasureResistance\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG34970A_MeasureResistance": {
  "prefix": "AG34970A_MeasureResistance",
  "body": [
   "$$Measurement=AG34970A_MeasureResistance($$AgInstance,$$ChannelNumber,$$Range,$$Resolution);"
  ],
  "description": "\n\nThis function uses the Agilent IVI Instrument drivers. In order to use the AG34970 functions in JabilTest, you need to have the Agilent COM components installed.\n\nThis function takes one two-wire Resistance measurement on the specified channel and returns the measurement. In the case of instrument communication failure, or an invalid channel specified, a failure is generated by the function.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AgInstance\n\nObject\n\nA COM Object representing an instance of the AG34970A.\n\n\n\n$ChannelNumber\n\nInteger\n\nThe channel on which to take the measurement.\n\n\n\n$Range\n\nFloat\n\nThe Range for the measurement channel.\n\n\n\n$Resolution\n\nFloat\n\nThe resolution for the measurement channel.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Measurement\n\nFloat\n\nThe two-wire resistance measurement from the specified channel.\n\n\n\n\n\nAG34970A_MeasureTemperature\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG34970A_MeasureTemperature": {
  "prefix": "AG34970A_MeasureTemperature",
  "body": [
   "$$Measurement=AG34970A_MeasureTemperature($$AgInstance,$$ChannelNumber,$$ThermocoupleType,$$Resolution);"
  ],
  "description": "\n\nThis function uses the Agilent IVI Instrument drivers. In order to use the AG34970 functions in JabilTest, you need to have the Agilent COM components installed.\n\nThis function takes one temperature measurement on the specified channel and returns the measurement. In the case of instrument communication failure, or an invalid channel specified, a failure is generated by the function.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AgInstance\n\nObject\n\nA COM Object representing an instance of the AG34970A.\n\n\n\n$ChannelNumber\n\nInteger\n\nThe channel on which to take the measurement.\n\n\n\n$ThermocoupleType\n\nString\n\nSpecifies the type of thermocouple installed on the measurement channel. Allowable values are:\n\n\u00b7 \"BTYPE\"\n\n\u00b7 \"ETYPE\"\n\n\u00b7 \"JTYPE\"\n\n\u00b7 \"KTYPE\"\n\n\u00b7 \"NTYPE\"\n\n\u00b7 \"RTYPE\"\n\n\u00b7 \"STYPE\"\n\n\u00b7 \"TTYPE\"\n\n\n\n$Resolution\n\nFloat\n\nThe resolution for the measurement channel.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Measurement\n\nFloat\n\nReturns the Temperature Measurement in Degrees Celsius\n\n\n\n\n\nExample:\n\nAG34970A_MeasureTemperature($Handle,101,\"RTYPE\",0.1);\n\n\n\n\n\nAG34970A_OpenChannelList\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG34970A_OpenChannelList": {
  "prefix": "AG34970A_OpenChannelList",
  "body": [
   "AG34970A_OpenChannelList($$AgInstance,$$channelList);"
  ],
  "description": "\n\nThis function will open the specified channels on a multiplexer or switch module in the Agilent 34970A.\n\n\n\n\n\nRemarks:\n\nThis function uses the Agilent IVI instrument drivers. You need to have the Agilent COM components installed (included in the Agilent IO Suite).\n\nThe list of channels to open is a comma separated list of channels and ranges. Ranges are specified using a colon (:). For example to open channels 101 to 105, the range would be 101:105.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AgInstance\n\nObject\n\nA COM object representing an instance of the AG34970A that was opened with the AG34970A_Init function.\n\n\n\n$channelList\n\nString\n\nComma separated list of channels and ranges of channels to open.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nnone\n\n\n\n\n\nExample:\n\n// Initialize communication with the 34970A.\n\n$resourceStr = \"GPIB0::9:INSTR\";\n\n\n\n\n\n$AgInst = AG34970A_Init($resourceStr);\n\n\n\n\n\n// Open channels 101 to 105 and 202 and 205 to 208.\n\n$chanList = \"101:105,202,205:208\";\n\n\n\n\n\nAG34970A_OpenChannelList($AgInst, $chanList);\n\n\n\n\n\nAG34970A_Read\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG34970A_Read": {
  "prefix": "AG34970A_Read",
  "body": [
   "$$Measurement=AG34970A_Read($$AgInstance);"
  ],
  "description": "\n\nThis function uses the Agilent IVI Instrument drivers. In order to use the AG34970A functions in JabilTest, you need to have the Agilent COM components installed.\n\nThis function performs the 'Read' command on the Agilent 34970A which initiates a scan, and a fetch of the currently configured measurement.\n\nBefore using the 'Read' function, you must first configure the measurement type, channel, and settings for the desired measurement using one of the 'AG34970A_ConfigureXXX' functions.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AgInstance\n\nObject\n\nA COM Object representing an instance of the AG34970A.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Measurement\n\nFloat\n\nThe measurement returned from the instrument.\n\n\n\n\n\nAG34970A_ScanAbort\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG34970A_ScanAbort": {
  "prefix": "AG34970A_ScanAbort",
  "body": [
   "AG34970A_ScanAbort($$AgInstance);"
  ],
  "description": "\n\nThis function uses the Agilent IVI Instrument drivers. In order to use the AG34970A functions in JabilTest, you need to have the Agilent COM components installed.\n\nThis function aborts a scan command on the Agilent 34970A. This command should be issued prior to changing any scan settings.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AgInstance\n\nObject\n\nA COM Object representing an instance of the AG34970A.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n-\n\n\n\n\n\nExample:\n\n$VoltMeter = AG34970A_Init($VoltMeterResourceString);\n\nAG34970A_ScanAbort($VoltMeter);\n\nAG34970A_ConfigureDCVolt($VoltMeter,101,1.0,4.5);\n\nAG34970A_ConfigureDCVolt($VoltMeter,102,1.0,4.5);\n\nAG34970A_ConfigureDCVolt($VoltMeter,103,1.0,4.5);\n\nAG34970A_ConfigureDCVolt($VoltMeter,104,1.0,4.5);\n\nAG34970A_ScanSetup($VoltMeter,\"101,102,103,104\",\"Timer\",1.0,10000);\n\nAG34970A_ScanInitiate($VoltMeter);\n\n// Delay ......\n\nAG34970A_ScanAbort($VoltMeter);\n\n$MeasurementDataTable = AG34970A_ScanFetch($VoltMeter);\n\nDataTable_ShowInWindow($MeasurementDataTable);\n\nAG34970A_Close($VoltMeter);\n\n\n\n\n\nAG34970A_ScanFetch\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG34970A_ScanFetch": {
  "prefix": "AG34970A_ScanFetch",
  "body": [
   "$$DataTable=AG34970A_ScanFetch($$AgInstance);"
  ],
  "description": "\n\nThis function uses the Agilent IVI Instrument drivers. In order to use the AG34970A functions in JabilTest, you need to have the Agilent COM components installed.\n\nThis function returns the measurement results from a scan command on the Agilent 34970A.\n\nNote: This function does not destroy the measurement memory within the instrument. The measurement memory will remain until a new scan has started. This function can be called during a scan. You can store up to 50,000 readings in non-volatile memory during a scan. From the instrument front panel, you can view the last 100 readings. If memory overflows (the MEM annunciator on the instrument will turn on), a status register bit is set and new readings will overwrite the first readings stored (the most recent readings are always preserved).\n\nEach time you start a new scan, the instrument clears all readings (including alarm data) stored in reading memory from the previous scan. Therefore, the contents of memory are always from the most recent scan.\n\nThe instrument also clears all readings in memory after a reset.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AgInstance\n\nObject\n\nA COM Object representing an instance of the AG34970A.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$DataTable\n\nObject\n\nA DataTable containing the measurement results, measurement type, channel number, elapsed time and alarms.\n\n\n\n\n\nExample:\n\n$VoltMeter = AG34970A_Init($VoltMeterResourceString);\n\nAG34970A_ScanAbort($VoltMeter);\n\nAG34970A_ConfigureDCVolt($VoltMeter,101,1.0,4.5);\n\nAG34970A_ConfigureDCVolt($VoltMeter,102,1.0,4.5);\n\nAG34970A_ConfigureDCVolt($VoltMeter,103,1.0,4.5);\n\nAG34970A_ConfigureDCVolt($VoltMeter,104,1.0,4.5);\n\nAG34970A_ScanSetup($VoltMeter,\"101,102,103,104\",\"Timer\",1.0,10000);\n\nAG34970A_ScanInitiate($VoltMeter);\n\n// Delay ......\n\nAG34970A_ScanAbort($VoltMeter);\n\n$MeasurementDataTable = AG34970A_ScanFetch($VoltMeter);\n\nDataTable_ShowInWindow($MeasurementDataTable);\n\nAG34970A_Close($VoltMeter);\n\n\n\n\n\nAG34970A_ScanInitiate\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG34970A_ScanInitiate": {
  "prefix": "AG34970A_ScanInitiate",
  "body": [
   "AG34970A_ScanInitiate($$AgInstance);"
  ],
  "description": "\n\nThis function uses the Agilent IVI Instrument drivers. In order to use the AG34970A functions in JabilTest, you need to have the Agilent COM components installed.\n\nThis function starts the previously configured scan.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AgInstance\n\nObject\n\nA COM Object representing an instance of the AG34970A.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n-\n\n\n\n\n\nExample:\n\n$VoltMeter = AG34970A_Init($VoltMeterResourceString);\n\nAG34970A_ScanAbort($VoltMeter);\n\nAG34970A_ConfigureDCVolt($VoltMeter,101,1.0,4.5);\n\nAG34970A_ConfigureDCVolt($VoltMeter,102,1.0,4.5);\n\nAG34970A_ConfigureDCVolt($VoltMeter,103,1.0,4.5);\n\nAG34970A_ConfigureDCVolt($VoltMeter,104,1.0,4.5);\n\nAG34970A_ScanSetup($VoltMeter,\"101,102,103,104\",\"Timer\",1.0,10000);\n\nAG34970A_ScanInitiate($VoltMeter);\n\n// Delay ......\n\nAG34970A_ScanAbort($VoltMeter);\n\n$MeasurementDataTable = AG34970A_ScanFetch($VoltMeter);\n\nDataTable_ShowInWindow($MeasurementDataTable);\n\nAG34970A_Close($VoltMeter);\n\n\n\n\n\nAG34970A_ScanSetup\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG34970A_ScanSetup": {
  "prefix": "AG34970A_ScanSetup",
  "body": [
   "AG34970A_ScanSetup($$AgInstance,$$ScanList,$$ScanType,$$TimerDelay,$$SweepCount);"
  ],
  "description": "\n\nThis function uses the Agilent IVI Instrument drivers. In order to use the AG34970A functions in JabilTest, you need to have the Agilent COM components installed.\n\nThis function configures the scan parameters.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AgInstance\n\nObject\n\nA COM Object representing an instance of the AG34970A.\n\n\n\n$ScanList\n\nString\n\nList of channels to scan separated by commas.\n\n\n\n$ScanType\n\nString\n\n\"Immediate\" or \"Timer\" are the only allowed values. Immediate repeats the configured sweep immediately and Timer configures a sweep that will repeat based on the $TimerDelay value.\n\n\n\n$TimerDelay\n\nDouble\n\nIf $ScanType = \"Timer\", this value is the delay between sweeps. It has a range of (0 - 359999) in seconds.\n\n\n\n$SweepCount\n\nInteger\n\nA sweep is a complete measurement cycle through the provided $ScanList. The $SweepCount indicates how many sweeps of the scan list. It has a range of (0 - 50000). 50000 represents the number of measurements the instrument's memory can hold.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n-\n\n\n\n\n\nExample:\n\n$VoltMeter = AG34970A_Init($VoltMeterResourceString);\n\nAG34970A_ScanAbort($VoltMeter);\n\nAG34970A_ConfigureDCVolt($VoltMeter,101,1.0,4.5);\n\nAG34970A_ConfigureDCVolt($VoltMeter,102,1.0,4.5);\n\nAG34970A_ConfigureDCVolt($VoltMeter,103,1.0,4.5);\n\nAG34970A_ConfigureDCVolt($VoltMeter,104,1.0,4.5);\n\nAG34970A_ScanSetup($VoltMeter,\"101,102,103,104\",\"Timer\",1.0,10000);\n\nAG34970A_ScanInitiate($VoltMeter);\n\n// Delay ......\n\nAG34970A_ScanAbort($VoltMeter);\n\n$MeasurementDataTable = AG34970A_ScanFetch($VoltMeter);\n\nDataTable_ShowInWindow($MeasurementDataTable);\n\nAG34970A_Close($VoltMeter);\n\n\n\n\n\nAG34980A_Close\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG34980A_CloseChannel": {
  "prefix": "AG34980A_CloseChannel",
  "body": [
   "AG34980A_CloseChannel($$InstrumentHandle,$$ChannelList);"
  ],
  "description": "\n\n\n\n\n\nThis function closes the channels specified in the $ChannelList argument.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThe handle of the instrument returned from the AG34980A_Init function\n\n\n\n$ChannelList\n\nString\n\nThe channel list to close.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nSupported Instruments\n\nAgilent 34980A Measurement mainframe, and all current modules.\n\n\n\n\n\nAG34980A_CloseExclusiveChannel\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG34980A_CloseExclusiveChannel": {
  "prefix": "AG34980A_CloseExclusiveChannel",
  "body": [
   "AG34980A_CloseExclusiveChannel($$AgInstance,$$ChannelList);"
  ],
  "description": "\n\nThis function opens all channels on the specified module and closes the channels in the channel list.\n\n\n\nRemarks:\n\nThis function uses the Agilent IVI Instrument drivers. In order to use the AG34980A functions, you need to have the Agilent COM components installed.\n\nCommunication to the instrument must previously have been opened with the AG34980A_Init function.\n\nIn the case of instrument communication failure, or an invalid channel specified, a failure is generated by the function.\n\nThis function works with the following modules:\n\n34921A through 34925A Multiplexer Modules\n\n34931A through 34933A Matrix Modules\n\n34937A and 34938A GP Switch Modules\n\n34941A and 34942A RF Multiplexer Modules\n\n34945A Microwave Switch Driver\n\n34946A and 34947A Microwave Switch Modules\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$agInstance\n\nObject\n\nThe handle representing the instance of the AG34980A that was previously opened using AG34980A_Init.\n\n\n\n$channelList\n\nString\n\nThe list of channels to close.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n\n\n\n\n$resource = \"GPIB0::11::INSTR\"; // The VISA resource string.\n\n$agHandle = AG34980A_Init($resource);\n\n\n\n$channelNum = 3006;\n\nAG34980A_CloseExclusiveChannel($agHandle, $channelNum);\n\n\n\n\n\nAG34980A_ConfigureCurrentAC\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG34980A_ConfigureCurrentAC": {
  "prefix": "AG34980A_ConfigureCurrentAC",
  "body": [
   "AG34980A_ConfigureCurrentAC($$agInstance,$$channelNumber,$$range,$$resolution);"
  ],
  "description": "\n\nThis function prepares the AC Current measurement on the specified channel but does not take a measurement. This function can be used to adjust the burden voltage of the current channel before taking a measurement.\n\n\n\nRemarks:\n\nThis function uses the Agilent IVI Instrument drivers. In order to use the AG34980A functions, you need to have the Agilent COM components installed.\n\n\n\nCommunication to the instrument must previously have been opened with the AG34980A_Init function.\n\n\n\nIn the case of instrument communication failure, or an invalid channel specified, a failure is generated by the function.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$agInstance\n\nObject\n\nThe handle representing the instance of the AG34980A that was previously opened using AG34980A_Init.\n\n\n\n$channelNumber\n\nInteger\n\nThe channel on which to take the measurement.\n\n\n\n$range\n\nFloat\n\nThe measurement range. Set to a negative number for auto-ranging.\n\n\n\n$resolution\n\nString\n\nA text string indicating the measurement resolution. Supported strings are: \"BEST\"\n\n\"DEFAULT\"\n\n\"LEAST\"\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n\n\n\n\n$resource = \"GPIB0::11::INSTR\"; // The VISA resource string.\n\n$agHandle = AG34980A_Init($resource);\n\n\n\n$channelNum = 3006;\n\n$range = 5.0;\n\n$resolution = \"BEST\";\n\n\n\nAG34980A_ConfigureCurrentAC($agHandle, $channelNum, $range, $resolution);\n\n\n\n\n\nAG34980A_ConfigureCurrentDC\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG34980A_ConfigureCurrentDC": {
  "prefix": "AG34980A_ConfigureCurrentDC",
  "body": [
   "AG34980A_ConfigureCurrentDC($$agInstance,$$channelNumber,$$range,$$resolution);"
  ],
  "description": "\n\nThis function prepares the DC Current measurement on the specified channel but does not take a measurement. This function can be used to adjust the burden voltage of the current channel before taking a measurement.\n\n\n\nRemarks:\n\nThis function uses the Agilent IVI Instrument drivers. In order to use the AG34980A functions, you need to have the Agilent COM components installed.\n\n\n\nCommunication to the instrument must previously have been opened with the AG34980A_Init function.\n\n\n\nIn the case of instrument communication failure, or an invalid channel specified, a failure is generated by the function.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$agInstance\n\nObject\n\nThe handle representing the instance of the AG34980A that was previously opened using AG34980A_Init.\n\n\n\n$channelNumber\n\nInteger\n\nThe channel on which to take the measurement.\n\n\n\n$range\n\nFloat\n\nThe measurement range. Set to a negative number for auto-ranging.\n\n\n\n$resolution\n\nString\n\nA text string indicating the measurement resolution. Supported strings are: \"BEST\"\n\n\"DEFAULT\"\n\n\"LEAST\"\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n\n\n\n\n$resource = \"GPIB0::11::INSTR\"; // The VISA resource string.\n\n$agHandle = AG34980A_Init($resource);\n\n\n\n$channelNum = 3006;\n\n$range = 5.0;\n\n$resolution = \"BEST\";\n\n\n\nAG34980A_ConfigureCurrentDC($agHandle, $channelNum, $range, $resolution);\n\n\n\n\n\nAG34980A_Init\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG34980A_Close": {
  "prefix": "AG34980A_Close",
  "body": [
   "$$agInstance=AG34980A_Close($$resourceString);"
  ],
  "description": "\n\nThis function initializes the AG34980A for operation. It does not reset the unit or change it's existing settings. It simply grabs an instance of the COM component to use in further test script operations.\n\n\n\n\n\nRemarks:\n\nThis function uses the Agilent IVI Instrument drivers. In order to use the AG34980A functions, you need to have the Agilent COM components installed.\n\nThis function returns a passing result if the instrument can be initialized successfully, otherwise a failure is generated by the script function.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$resourceString\n\nString\n\nThe resource string identifying the instrument.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$agInstance\n\nObject\n\nThe handle representing the instance of the AG34980A for use in other script functions.\n\n\n\n\n\nExample:\n\n\n\n\n\n$resource = \"GPIB0::11::INSTR\"; // The VISA resource string.\n\n$agHandle = AG34980A_Init($resource);\n\n\n\n\n\nAG34980A_MeasureCurrentAC\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG34980A_MeasureCurrentAC": {
  "prefix": "AG34980A_MeasureCurrentAC",
  "body": [
   "$$measurement=AG34980A_MeasureCurrentAC($$agInstance,$$channelNumber,$$range,$$resolution);"
  ],
  "description": "\n\nThis function takes an AC Current measurement on the specified channel and returns the measurement.\n\n\n\n\n\nRemarks:\n\nThis function uses the Agilent IVI Instrument drivers. In order to use the AG34980A functions, you need to have the Agilent COM components installed.\n\nCommunication to the instrument must previously have been opened with the AG34980A_Init function.\n\nIn the case of instrument communication failure, or an invalid channel specified, a failure is generated by the function.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$agInstance\n\nObject\n\nThe handle representing the instance of the AG34980A to obtain the measurement from.\n\n\n\n$channelNumber\n\nInteger\n\nThe channel on which to take the measurement.\n\n\n\n$range\n\nFloat\n\nThe measurement range. Set to a negative number for auto-ranging.\n\n\n\n$resolution\n\nString\n\nA text string indicating the measurement resolution. Supported strings are:\n\n\u00b7 \"BEST\"\n\n\u00b7 \"DEFAULT\"\n\n\u00b7 \"LEAST\"\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$measurement\n\nFloat\n\nThe AC Current measured on the specified channel.\n\n\n\n\n\nExample:\n\n\n\n\n\n$resource = \"GPIB0::11::INSTR\"; // The VISA resource string.\n\n$agHandle = AG34980A_Init($resource);\n\n\n\n\n\n$channelNum = 3005;\n\n$range = 5.0;\n\n$resolution = \"BEST\";\n\n\n\n\n\n$measure = AG34980A_MeasureCurrentAC($agHandle, $channelNum, $range, $resolution);\n\n\n\n\n\nAG34980A_MeasureCurrentDC\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG34980A_MeasureCurrentDC": {
  "prefix": "AG34980A_MeasureCurrentDC",
  "body": [
   "$$measurement=AG34980A_MeasureCurrentDC($$agInstance,$$channelNumber,$$range,$$resolution);"
  ],
  "description": "\n\nThis function takes a DC Current measurement on the specified channel and returns the measurement.\n\n\n\n\n\nRemarks:\n\nThis function uses the Agilent IVI Instrument drivers. In order to use the AG34980A functions, you need to have the Agilent COM components installed.\n\nCommunication to the instrument must previously have been opened with the AG34980A_Init function.\n\nIn the case of instrument communication failure, or an invalid channel specified, a failure is generated by the function.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$agInstance\n\nObject\n\nThe handle representing the instance of the AG34980A to obtain the measurement from.\n\n\n\n$channelNumber\n\nInteger\n\nThe channel on which to take the measurement.\n\n\n\n$range\n\nFloat\n\nThe measurement range. Set to a negative number for auto-ranging.\n\n\n\n$resolution\n\nString\n\nA text string indicating the measurement resolution. Supported strings are:\n\n\u00b7 \"BEST\"\n\n\u00b7 \"DEFAULT\"\n\n\u00b7 \"LEAST\"\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$measurement\n\nFloat\n\nThe DC Current measured on the specified channel.\n\n\n\n\n\nExample:\n\n\n\n\n\n$resource = \"GPIB0::11::INSTR\"; // The VISA resource string.\n\n$agHandle = AG34980A_Init($resource);\n\n\n\n\n\n$channelNum = 3005;\n\n$range = 5.0;\n\n$resolution = \"BEST\";\n\n\n\n\n\n$measure = AG34980A_MeasureCurrentDC($agHandle, $channelNum, $range, $resolution);\n\n\n\n\n\nAG34980A_MeasureFrequency\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG34980A_MeasureFrequency": {
  "prefix": "AG34980A_MeasureFrequency",
  "body": [
   "$$measurement=AG34980A_MeasureFrequency($$agInstance,$$channelNumber,$$range,$$resolution);"
  ],
  "description": "\n\nThis function takes a Frequency measurement on the specified channel and returns the measurement.\n\n\n\n\n\nRemarks:\n\nThis function uses the Agilent IVI Instrument drivers. In order to use the AG34980A functions, you need to have the Agilent COM components installed.\n\nCommunication to the instrument must previously have been opened with the AG34980A_Init function.\n\nIn the case of instrument communication failure, or an invalid channel specified, a failure is generated by the function.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$agInstance\n\nObject\n\nThe handle representing the instance of the AG34980A to obtain the measurement from.\n\n\n\n$channelNumber\n\nInteger\n\nThe channel on which to take the measurement.\n\n\n\n$range\n\nFloat\n\nThe measurement range. Set to a negative number for auto-ranging.\n\n\n\n$resolution\n\nString\n\nA text string indicating the measurement resolution. Supported strings are:\n\n\u00b7 \"BEST\"\n\n\u00b7 \"DEFAULT\"\n\n\u00b7 \"LEAST\"\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$measurement\n\nFloat\n\nThe Frequency measured on the specified channel.\n\n\n\n\n\nExample:\n\n\n\n\n\n$resource = \"GPIB0::11::INSTR\"; // The VISA resource string.\n\n$agHandle = AG34980A_Init($resource);\n\n\n\n\n\n$channelNum = 3005;\n\n$range = 5.0;\n\n$resolution = \"BEST\";\n\n\n\n\n\n$measure = AG34980A_MeasureFrequency($agHandle, $channelNum, $range, $resolution);\n\n\n\n\n\nAG34980A_MeasurePeriod\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG34980A_MeasureResistance": {
  "prefix": "AG34980A_MeasureResistance",
  "body": [
   "$$measurement=AG34980A_MeasureResistance($$agInstance,$$channelNumber,$$range,$$resolution);"
  ],
  "description": "\n\nThis function takes a two-wire resistance measurement on the specified channel and returns the measurement.\n\n\n\nRemarks:\n\nThis function uses the Agilent IVI Instrument drivers. In order to use the AG34980A functions, you need to have the Agilent COM components installed.\n\n\n\nCommunication to the instrument must previously have been opened with the AG34980A_Init function.\n\n\n\nIn the case of instrument communication failure, or an invalid channel specified, a failure is generated by the function.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$agInstance\n\nObject\n\nThe handle representing the instance of the AG34980A that was previously opened using AG34980A_Init.\n\n\n\n$channelNumber\n\nInteger\n\nThe channel on which to take the measurement.\n\n\n\n$range\n\nFloat\n\nThe measurement range. Set to a negative number for auto-ranging.\n\n\n\n$resolution\n\nString\n\nA text string indicating the measurement resolution. Supported strings are: \"BEST\"\n\n\"DEFAULT\"\n\n\"LEAST\"\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$measurement\n\nFloat\n\nThe two-wire resistance measured on the specified channel.\n\n\n\n\n\nExample:\n\n\n\n\n\n$resource = \"GPIB0::11::INSTR\"; // The VISA resource string.\n\n$agHandle = AG34980A_Init($resource);\n\n\n\n$channelNum = 3006;\n\n$range = 5.0;\n\n$resolution = \"BEST\";\n\n\n\n$measure = AG34980A_MeasureResistance($agHandle, $channelNum, $range, $resolution);\n\n\n\n\n\nAG34980A_MeasureTemperature\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG34980A_MeasureTemperature": {
  "prefix": "AG34980A_MeasureTemperature",
  "body": [
   "$$measurement=AG34980A_MeasureTemperature($$agInstance,$$channelNumber,$$sensorType,$$resolution);"
  ],
  "description": "\n\nThis function takes a temperature measurement on the specified channel with an attached temperature sensor and returns the measurement.\n\n\n\n\n\nRemarks:\n\nThis function uses the Agilent IVI Instrument drivers. In order to use the AG34980A functions, you need to have the Agilent COM components installed.\n\nCommunication to the instrument must previously have been opened with the AG34980A_Init function.\n\nIn the case of instrument communication failure, or an invalid channel specified, a failure is generated by the function.\n\nThe temperature sensor can be any of the supported thermistors or thermocouples.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$agInstance\n\nObject\n\nThe handle representing the instance of the AG34980A to obtain the measurement from.\n\n\n\n$channelNumber\n\nInteger\n\nThe channel on which to take the measurement.\n\n\n\n$sensorType\n\nString\n\nA string indicating the sensor type used on the channel.\n\nAllowable thermistor values are:\n\n\u00b7 \"10000\"\n\n\u00b7 \"5000\"\n\n\u00b7 \"2252\"\n\nAllowable thermocouple types are:\n\n\"B\",\"E\",\"J\",\"K\",\"N\",\"R\",\"S\", and \"T\"\n\n\n\n$resolution\n\nString\n\nA text string indicating the measurement resolution. Supported strings are:\n\n\u00b7 \"BEST\"\n\n\u00b7 \"DEFAULT\"\n\n\u00b7 \"LEAST\"\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$measurement\n\nFloat\n\nThe DC Current measured on the specified channel.\n\n\n\n\n\nExample:\n\n\n\n\n\n$resource = \"GPIB0::11::INSTR\"; // The VISA resource string.\n\n$agHandle = AG34980A_Init($resource);\n\n\n\n\n\n$channelNum = 3005;\n\n$sensorType = \"K\"; // K type thermocouple.\n\n$resolution = \"BEST\";\n\n\n\n\n\n$measure = AG34980A_MeasureTemperature($agHandle, $channelNum, $sensorType, $resolution);\n\n\n\n\n\nAG34980A_MeasureVoltageAC\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG34980A_MeasureVoltageAC": {
  "prefix": "AG34980A_MeasureVoltageAC",
  "body": [
   "$$measurement=AG34980A_MeasureVoltageAC($$agInstance,$$channelNumber,$$range,$$resolution);"
  ],
  "description": "\n\nThis function takes an AC Voltage measurement on the specified channel and returns the measurement.\n\n\n\n\n\nRemarks:\n\nThis function uses the Agilent IVI Instrument drivers. In order to use the AG34980A functions, you need to have the Agilent COM components installed.\n\nCommunication to the instrument must previously have been opened with the AG34980A_Init function.\n\nIn the case of instrument communication failure, or an invalid channel specified, a failure is generated by the function.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$agInstance\n\nObject\n\nThe handle representing the instance of the AG34980A to obtain the measurement from.\n\n\n\n$channelNumber\n\nInteger\n\nThe channel on which to take the measurement.\n\n\n\n$range\n\nFloat\n\nThe measurement range. Set to a negative number for auto-ranging.\n\n\n\n$resolution\n\nString\n\nA text string indicating the measurement resolution. Supported strings are:\n\n\u00b7 \"BEST\"\n\n\u00b7 \"DEFAULT\"\n\n\u00b7 \"LEAST\"\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$measurement\n\nFloat\n\nThe AC Voltage measured on the specified channel.\n\n\n\n\n\nExample:\n\n\n\n\n\n$resource = \"GPIB0::11::INSTR\"; // The VISA resource string.\n\n$agHandle = AG34980A_Init($resource);\n\n\n\n\n\n$channelNum = 3005;\n\n$range = 5.0;\n\n$resolution = \"BEST\";\n\n\n\n\n\n$measure = AG34980A_MeasureVoltageAC($agHandle, $channelNum, $range, $resolution);\n\n\n\n\n\nAG34980A_MeasureVoltageDC\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG34980A_MeasureVoltageDC": {
  "prefix": "AG34980A_MeasureVoltageDC",
  "body": [
   "$$measurement=AG34980A_MeasureVoltageDC($$agInstance,$$channelNumber,$$range,$$resolution);"
  ],
  "description": "\n\nThis function takes a DC Voltage measurement on the specified channel and returns the measurement.\n\n\n\n\n\nRemarks:\n\nThis function uses the Agilent IVI Instrument drivers. In order to use the AG34980A functions, you need to have the Agilent COM components installed.\n\nCommunication to the instrument must previously have been opened with the AG34980A_Init function.\n\nIn the case of instrument communication failure, or an invalid channel specified, a failure is generated by the function.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$agInstance\n\nObject\n\nThe handle representing the instance of the AG34980A to obtain the measurement from.\n\n\n\n$channelNumber\n\nInteger\n\nThe channel on which to take the measurement.\n\n\n\n$range\n\nFloat\n\nThe measurement range. Set to a negative number for auto-ranging.\n\n\n\n$resolution\n\nString\n\nA text string indicating the measurement resolution. Supported strings are:\n\n\u00b7 \"BEST\"\n\n\u00b7 \"DEFAULT\"\n\n\u00b7 \"LEAST\"\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$measurement\n\nFloat\n\nThe DC Voltage measured on the specified channel.\n\n\n\n\n\nExample:\n\n\n\n\n\n$resource = \"GPIB0::11::INSTR\"; // The VISA resource string.\n\n$agHandle = AG34980A_Init($resource);\n\n\n\n\n\n$channelNum = 3005;\n\n$range = 5.0;\n\n$resolution = \"BEST\";\n\n\n\n\n\n$measure = AG34980A_MeasureVoltageDC($agHandle, $channelNum, $range, $resolution);\n\n\n\n\n\nAG34980A_OpenAllChannels\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG34980A_OpenAllChannels": {
  "prefix": "AG34980A_OpenAllChannels",
  "body": [
   "AG34980A_OpenAllChannels($$agInstance,$$slotNumber);"
  ],
  "description": "\n\nThis function opens the channel connections on the interface module in the specified slot.\n\n\n\n\n\nRemarks:\n\nThis function uses the Agilent IVI Instrument drivers. In order to use the AG34980A functions, you need to have the Agilent COM components installed.\n\nCommunication to the instrument must previously have been opened with the AG34980A_Init function.\n\nIn the case of instrument communication failure, or an invalid slot specified, a failure is generated by the function.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$agInstance\n\nObject\n\nThe handle representing the instance of the AG34980A to open the channels on.\n\n\n\n$slotNumber\n\nInteger\n\nThe slot number to open the connections on.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n\n\n\n\n$resource = \"GPIB0::11::INSTR\"; // The VISA resource string.\n\n$agHandle = AG34980A_Init($resource);\n\n\n\n\n\n$slotNum = 3;\n\n\n\n\n\n$measure = AG34980A_OpenAllChannels($agHandle, $slotNum);\n\n\n\n\n\nAG34980A_OpenChannel\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG34980A_OpenChannel": {
  "prefix": "AG34980A_OpenChannel",
  "body": [
   "AG34980A_OpenChannel($$agInstance,$$channelList);"
  ],
  "description": "\n\nThis function opens the channel connections specified in the list on the measurement mainframe.\n\n\n\n\n\nRemarks:\n\nThis function uses the Agilent IVI Instrument drivers. In order to use the AG34980A functions, you need to have the Agilent COM components installed.\n\nCommunication to the instrument must previously have been opened with the AG34980A_Init function.\n\nIn the case of instrument communication failure, or an invalid channel specified, a failure is generated by the function.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$agInstance\n\nObject\n\nThe handle representing the instance of the AG34980A to open the channels on.\n\n\n\n$channelList\n\nInteger\n\nComma separated list of channels to open.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n\n\n\n\n$resource = \"GPIB0::11::INSTR\"; // The VISA resource string.\n\n$agHandle = AG34980A_Init($resource);\n\n\n\n\n\n$chanList = \"1003, 6021, 4011\";\n\n\n\n\n\n$measure = AG34980A_OpenChannel($agHandle, $chanList);\n\n\n\n\n\nAG34980A_Reset\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG34980A_Reset": {
  "prefix": "AG34980A_Reset",
  "body": [
   "AG34980A_Reset($$InstrumentHandle);"
  ],
  "description": "\n\n\n\n\n\nThis function performs a global reset of the AG34980A, and returns all modules to their default power-on condition.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThe handle of the instrument returned from the AG34980A_Init function\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\nAG34980A_Reset($InstrumentHandle);\n\n\n\n\n\nSupported Instruments\n\nAgilent 34980A Measurement mainframe, and all current modules.\n\n\n\n\n\nAG34980A_ScanVoltageAC\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG34980A_ScanVoltageAC": {
  "prefix": "AG34980A_ScanVoltageAC",
  "body": [
   "$$Measurements=AG34980A_ScanVoltageAC($$InstrumentHandle,$$Channel,$$Range,$$Resolution,$$MeasurementCount,$$TimeBetweenSamples,$$TimeoutMS);"
  ],
  "description": "\n\nThis function uses the Agilent IVI Instrument drivers. In order to use the AG34980 functions in JabilTest, you need to have the Agilent COM components installed.\n\nThis function configures and initiates an AC Voltage scan on a specified channel. This function can be used in place of the Measure commands when you need to take a large number of samples at a very high sample rate. If the $TimeoutMS value is exceeded before the acquisition can be completed, the function generates a failure.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThe handle of the instrument returned from the AG34980A_Init function\n\n\n\n$Channel\n\nString\n\nThe channel number to scan\n\n\n\n$Range\n\nFloat\n\nThe range for the measurement. Set to a negative number for auto-ranging.\n\n\n\n$Resolution\n\nString\n\nThe measurement resolution specified as:\n\n\u00b7 BEST\n\n\u00b7 DEFAULT\n\n\u00b7 LEAST\n\n\n\n$MeasurementCount\n\nInteger\n\nThe number of sweeps of the channel to perform (number of measurements to complete)\n\n\n\n$TimeBetweenSamples\n\nFloat\n\nThe time in seconds between the measurement samples.\n\n\n\n$TimeoutMS\n\nInteger\n\nThe timeout for the total operation to complete. If the acquisition and triggering exceed the timeout limit, the function generates a failure.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$MeasurementArray\n\nArray\n\nReturns a 2D measurement array containing the measurement samples.\n\n\n\n\n\nSupported Instruments\n\nAgilent 34980A Measurement mainframe, and all current modules.\n\n\n\n\n\nExample:\n\n\n\n\n\n// This example takes 1000 measurements as fast as possible on Channel 1015\n\n$MyMeasurements = AG34980A_ScanVoltageAC($It,1015,0.01,\"LEAST\",1000,0,10000);\n\n\n\n\n\n// List the measurements...\n\n$Length = ArrayGetLength($MyMeasurements);\n\n$Count = 0;\n\nLabel Loop1:\n\n\n\n\n\n$Val = ArrayGetValue($MyMeasurements,0,$Count);\n\nUpdateStatus($Val);\n\n$Count = $Count+1;\n\nif ($Count<$Length)\n\n{\n\ngoto Loop1;\n\n}\n\nEnd;\n\n\n\n\n\nAG34980A_ScanVoltageDC\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG34980A_ScanVoltageDC": {
  "prefix": "AG34980A_ScanVoltageDC",
  "body": [
   "$$Measurements=AG34980A_ScanVoltageDC($$InstrumentHandle,$$Channel,$$Range,$$Resolution,$$MeasurementCount,$$TimeBetweenSamples,$$TimeoutMS);"
  ],
  "description": "\n\nThis function uses the Agilent IVI Instrument drivers. In order to use the AG34980 functions in JabilTest, you need to have the Agilent COM components installed.\n\nThis function configures and initiates an DC Voltage scan on a specified channel. This function can be used in place of the Measure commands when you need to take a large number of samples at a very high sample rate. If the $TimeoutMS value is exceeded before the acquisition can be completed, the function generates a failure.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThe handle of the instrument returned from the AG34980A_Init function\n\n\n\n$Channel\n\nString\n\nThe channel number to scan\n\n\n\n$Range\n\nFloat\n\nThe range for the measurement. Set to a negative number for auto-ranging.\n\n\n\n$Resolution\n\nString\n\nThe measurement resolution specified as:\n\n\u00b7 BEST\n\n\u00b7 DEFAULT\n\n\u00b7 LEAST\n\n\n\n$MeasurementCount\n\nInteger\n\nThe number of sweeps of the channel to perform (number of measurements to complete)\n\n\n\n$TimeBetweenSamples\n\nFloat\n\nThe time in seconds between the measurement samples.\n\n\n\n$TimeoutMS\n\nInteger\n\nThe timeout for the total operation to complete. If the acquisition and triggering exceed the timeout limit, the function generates a failure.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$MeasurementArray\n\nArray\n\nReturns a 2D measurement array containing the measurement samples.\n\n\n\n\n\nSupported Instruments\n\nAgilent 34980A Measurement mainframe, and all current modules.\n\n\n\n\n\nExample:\n\n\n\n\n\n// This example takes 1000 measurements as fast as possible on Channel 1015\n\n$MyMeasurements = AG34980A_ScanVoltageDC($It,1015,0.01,\"LEAST\",1000,0,10000);\n\n\n\n\n\n// List the measurements...\n\n$Length = ArrayGetLength($MyMeasurements);\n\n$Count = 0;\n\nLabel Loop1:\n\n\n\n\n\n$Val = ArrayGetValue($MyMeasurements,0,$Count);\n\nUpdateStatus($Val);\n\n$Count = $Count+1;\n\nif ($Count<$Length)\n\n{\n\ngoto Loop1;\n\n}\n\nEnd;\n\n\n\n\n\nAG34980A_SelfTest\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG34980A_SelfTest": {
  "prefix": "AG34980A_SelfTest",
  "body": [
   "AG34980A_SelfTest($$InstrumentHandle);"
  ],
  "description": "\n\n\n\n\n\nThis function performs a self test on the Agilent 34980A Measurement mainframe. This function passes if the self test is successful. In the event of a failure, a measurement result is returned containing the failure message.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThe handle of the instrument returned from the AG34980A_Init function\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\nAG34980A_SelfTest($InstrumentHandle);\n\n\n\n\n\nSupported Instruments\n\nAgilent 34980A Measurement mainframe, and all current modules.\n\n\n\n\n\nAG34980A_SendCommand\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG34980A_SendCommand": {
  "prefix": "AG34980A_SendCommand",
  "body": [
   "$$ReturnString=AG34980A_SendCommand($$InstrumentHandle$$SCPICommand,$$ExpectResult);"
  ],
  "description": "\n\n\n\n\n\nThis function is used to pass raw SCPI commands to the instrument in the event that some functionality isn't exposed by the function library. The $ExpectResult boolean argument will cause the function to perform a GPIB read after the command and place the string into the $ReturnString argument. If $ExpectResult is set to \"FALSE\", the function will always return an empty string.\n\n\n\n\n\nExample:\n\n$ReturnString = AG34980A_SendCommand($AG34980A,\"DMM:MEAS:RES?\",\"TRUE\");\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThe handle of the instrument returned from the AG34980A_Init function\n\n\n\n$SCPICommand\n\nString\n\nThe SCPI command or query to send to the instrument.\n\n\n\n$ExpectResult\n\nBoolean\n\nIf this result is set to 'TRUE' then the function will query the instrument and return the result to the script.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ReturnString\n\nString\n\nThe contents of the GPIB buffer returned from the instrument.\n\n\n\n\n\nSupported Instruments\n\nAgilent 34980A Measurement mainframe, and all current modules.\n\n\n\n\n\nAG34980A_SetDisplayText\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG34980A_SetDisplayText": {
  "prefix": "AG34980A_SetDisplayText",
  "body": [
   "AG34980A_SetDisplayText($$agInstance,$$displayText);"
  ],
  "description": "\n\nThis function displays the specified text on the display of the instrument. The display text is limited to 13 characters.\n\n\n\n\n\nRemarks:\n\nThis function uses the Agilent IVI Instrument drivers. In order to use the AG34980A functions, you need to have the Agilent COM components installed.\n\nCommunication to the instrument must previously have been opened with the AG34980A_Init function.\n\nIn the case of instrument communication failure, a failure is generated by the function.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$agInstance\n\nObject\n\nThe handle representing the instance of the AG34980A to set the text on.\n\n\n\n$displayText\n\nString\n\nThe text to be displayed on the instrument's front panel display.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n\n\n\n\n$resource = \"GPIB0::11::INSTR\"; // The VISA resource string.\n\n$agHandle = AG34980A_Init($resource);\n\n\n\n\n\n$dispTxt = \"Measuring...\";\n\n\n\n\n\n$measure = AG34980A_SetDisplayText($agHandle, $dispTxt);\n\n\n\n\n\nAG34980A_SetTimeout\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG34980A_SetTimeout": {
  "prefix": "AG34980A_SetTimeout",
  "body": [
   "AG34980A_SetTimeout($$InstrumentHandle,$$TimeoutMS);"
  ],
  "description": "\n\n\n\n\n\nThis function sets the measurement timeout limit on the Agilent 34980A.\n\n\n\n\n\nIt may be necessary to adjust the measurement timeout when taking high precision measurements to prevent I/O errors from ocurring during measurement functions. (Current Measurement functions often require adjusting the instrument timeout).\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThe handle of the instrument returned from the AG34980A_Init function\n\n\n\n$TimeoutMS\n\nInteger\n\nThe timeout duration specified in Milliseconds\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\nAG34980A_SelfTest($InstrumentHandle);\n\n\n\n\n\nSupported Instruments\n\nAgilent 34980A Measurement mainframe, and all current modules.\n\n\n\n\n\nE1412A_Close\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS E1412A_Close": {
  "prefix": "E1412A_Close",
  "body": [
   "E1412A_Close($$Handle);"
  ],
  "description": "\n\nThis function controls the HP E1412A Multimeter. In order to use this function the VXI pnp driver for the instrument must be installed on the system running Jabil Test. The latest version of this driver can be downloaded from Agilent.\n\nThis function closes the Multimeter Unit, and releases the handle and resources for the instrument.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nA handle to the HP E1412A instrument\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nE1412A_Init\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS E1412A_Init": {
  "prefix": "E1412A_Init",
  "body": [
   "$$Handle=E1412A_Init($$ResourceString,$$Reset);"
  ],
  "description": "\n\nThis function controls the HP 1412A Multimeter. In order to use this function the VXI pnp driver for the instrument must be installed on the system running Jabil Test. The latest version of this driver can be downloaded from Agilent.\n\nThis function initializes the Multimeter, and returns a handle to the instrument. If the $Reset argument is set to TRUE, the instrument is reset to it's default configuration.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ResourceString\n\nString\n\nThe Resource string of the instrument, for instance \"GPIB0::9::3::INSTR\"\n\n\n\n$Reset\n\nBoolean\n\nSpecifies whether or not to reset the instrument upon initialization.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nA handle to the instrument\n\n\n\n\n\nE1412A_MeasCurrentAC\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS E1412A_MeasCurrentAC": {
  "prefix": "E1412A_MeasCurrentAC",
  "body": [
   "$$Current_AC=E1412A_MeasCurrentAC($$Handle);"
  ],
  "description": "\n\nThis function controls the HP E1412A Multimeter. In order to use this function the VXI pnp driver for the instrument must be installed on the system running Jabil Test. The latest version of this driver can be downloaded from Agilent.\n\nThis function returns the AC current measurement at the E1412A Multimeter.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nA handle to the E1412A created with the E1412A_Init function.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Current_AC\n\nFloat\n\nThe AC current measured in Amps.\n\n\n\n\n\nE1412A_MeasureCurrentDC\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS E1412A_MeasCurrentDC": {
  "prefix": "E1412A_MeasCurrentDC",
  "body": [
   "$$Current_DC=E1412A_MeasCurrentDC($$Handle);"
  ],
  "description": "\n\nThis function controls the HP E1412A Multimeter. In order to use this function the VXI pnp driver for the instrument must be installed on the system running Jabil Test. The latest version of this driver can be downloaded from Agilent.\n\n\n\nThis function returns the DC current measurement at the E1412A Multimeter.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nA handle to the E1412A created with the E1412A_Init function.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Current_DC\n\nFloat\n\nThe DC current measured in Amps.\n\n\n\n\n\nE1412A_MeasFrequency\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS E1412A_MeasureFrequency": {
  "prefix": "E1412A_MeasureFrequency",
  "body": [
   "$$Frequency=E1412A_MeasureFrequency($$Handle);"
  ],
  "description": "\n\nThis function controls the HP E1412A Multimeter. In order to use this function the VXI pnp driver for the instrument must be installed on the system running Jabil Test. The latest version of this driver can be downloaded from Agilent.\n\nThis function returns the Frequency measurement at the E1412A Multimeter.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nA handle to the E1412A created with the E1412A_Init function.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Frequency\n\nFloat\n\nThe frequency measured in Hertz\n\n\n\n\n\nE1412A_MeasPeriod\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS E1412A_MeasPeriod": {
  "prefix": "E1412A_MeasPeriod",
  "body": [
   "$$Period=E1412A_MeasPeriod($$Handle);"
  ],
  "description": "\n\nThis function controls the HP E1412A Multimeter. In order to use this function the VXI pnp driver for the instrument must be installed on the system running Jabil Test. The latest version of this driver can be downloaded from Agilent.\n\nThis function returns the Period measurement at the E1412A Multimeter.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nA handle to the E1412A created with the E1412A_Init function.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Period\n\nFloat\n\nThe Period measured in seconds\n\n\n\n\n\nE1412A_MeasResistance\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS E1412A_MeasResistance": {
  "prefix": "E1412A_MeasResistance",
  "body": [
   "$$Resistance=E1412A_MeasResistance($$Handle);"
  ],
  "description": "\n\nThis function controls the HP E1412A Multimeter. In order to use this function the VXI pnp driver for the instrument must be installed on the system running Jabil Test. The latest version of this driver can be downloaded from Agilent.\n\nThis function returns the resistance measurement of the resitors connected to the E1412A Multimeter.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nA handle to the E1412A created with the E1412A_Init function.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Resistance\n\nFloat\n\nThe resistance measured in Ohms.\n\n\n\n\n\nE1412A_MeasVoltageAC\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS E1412A_MeasVoltageAC": {
  "prefix": "E1412A_MeasVoltageAC",
  "body": [
   "$$Voltage_AC=E1412A_MeasVoltageAC($$Handle);"
  ],
  "description": "\n\nThis function controls the HP E1412A Multimeter. In order to use this function the VXI pnp driver for the instrument must be installed on the system running Jabil Test. The latest version of this driver can be downloaded from Agilent.\n\nThis function returns the AC voltage measurement at the E1412A Multimeter.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nA handle to the E1412A created with the E1412A_Init function.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Voltage_AC\n\nFloat\n\nThe AC voltage measured in Volts.\n\n\n\n\n\nE1412A_MeasVoltageDC\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS E1412A_MeasVoltageDC": {
  "prefix": "E1412A_MeasVoltageDC",
  "body": [
   "$$Voltage_DC=E1412A_MeasVoltageDC($$Handle);"
  ],
  "description": "\n\nThis function controls the HP E1412A Multimeter. In order to use this function the VXI pnp driver for the instrument must be installed on the system running Jabil Test. The latest version of this driver can be downloaded from Agilent.\n\n\n\nThis function returns the DC voltage measurement at the E1412A Multimeter.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nA handle to the E1412A created with the E1412A_Init function.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Voltage_DC\n\nFloat\n\nThe DC voltage measured in Volts.\n\n\n\n\n\nAG3606_Close\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG3606_Close": {
  "prefix": "AG3606_Close",
  "body": [
   "AG3606_Close($$AgHandle);"
  ],
  "description": "\n\nThis function closes a connection to an Agilent U3606x device that was opened using the AG3606_Init function.\n\n\n\n\n\nRemarks:\n\nThe Agilent library for this instrument must be installed on the test computer. The version used for building and testing this function library is version 1.1.7 for 64 bit operating systems.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AgHandle\n\nObject\n\nA handle to a device opened with AG3606_Init.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AgHandle\n\nObject\n\nA handle to the connection for use in other functions.\n\n\n\n\n\nExample:\n\n// Get a handle to the device, do an ID query and reset.\n\n$resName = \"GPIB0::5::INSTR\";\n\n$idQuery = true;\n\n$reset = true;\n\n$options = \"\";\n\n$AgHandle = AG3606_Init($resName, $idQuery, $reset, $options);\n\n\n\n\n\n// Take measurement and work with instrument here.\n\n\n\n\n\nAG3606_Close($AgHandle);\n\n\n\n\n\nAG3606_Init\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG3606_Init": {
  "prefix": "AG3606_Init",
  "body": [
   "$$AgHandle=AG3606_Init($$resourceName,$$idQuery,$$resetDevice,$$options);"
  ],
  "description": "\n\nThis function opens a connection to an Agilent U3606x device (either U3606A or U3606B) and returns an handle to the connection that can be used with other functions.\n\n\n\n\n\nRemarks:\n\nThe Agilent library for this instrument must be installed on the test computer. The version used for building and testing this function library is version 1.1.7 for 64 bit operating systems.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$resourceName\n\nString\n\nA VISA style resource descriptor string for this device. Example: \"GPIB0::5::INSTR\".\n\n\n\n$idQuery\n\nBoolean\n\nWhether to perform an ID Query on the device.\n\n\n\n$resetDevice\n\nBoolean\n\nWhether to perform a reset on the device once the connection is established.\n\n\n\n$options\n\nString\n\nOptions parameters to pass to the device. See the device documentation for examples. Use an empty string, if none are needed.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AgHandle\n\nObject\n\nA handle to the connection for use in other functions.\n\n\n\n\n\nExample:\n\n// Get a handle to the device, do an ID query and reset.\n\n$resName = \"GPIB0::5::INSTR\";\n\n$idQuery = true;\n\n$reset = true;\n\n$options = \"\";\n\n$AgHandle = AG3606_Init($resName, $idQuery, $reset, $options);\n\n\n\n\n\nAG3606_MeasureAcCurrent\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG3606_MeasureAcCurrent": {
  "prefix": "AG3606_MeasureAcCurrent",
  "body": [
   "$$measurement=AG3606_MeasureAcCurrent($$AgHandle,$$range,$$resolution);"
  ],
  "description": "\n\nThis function resets all AC current measurement parameters and trigger parameters to their default values, configures the instrument for AC current measurements and immediately triggers a measurement. A single reading is returned.\n\n\n\n\n\nRemarks:\n\nThe Agilent library for this instrument must be installed on the test computer. The version used for building and testing this function library is version 1.1.7 for 64 bit operating systems.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AgHandle\n\nObject\n\nA handle to a device opened with AG3606_Init.\n\n\n\n$range\n\nFloat\n\nThe current range for the measurement. Valid ranges are (enter the number only):\n\n\u00b7 0.01 A (minimum)\n\n\u00b7 0.1 A\n\n\u00b7 1 A\n\n\u00b7 3 A (maximum)\n\n\u00b7 Use 0 for AUTO\n\n\n\n$resolution\n\nString\n\nThe resolution for the measurements. Valid resolutions are:\n\n\u00b7 BEST\n\n\u00b7 LEAST\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$measurement\n\nFloat\n\nThe measurement read from the instrument.\n\n\n\n\n\nExample:\n\n// Get a handle to the device, do an ID query and reset.\n\n$resName = \"GPIB0::5::INSTR\";\n\n$idQuery = true;\n\n$reset = true;\n\n$options = \"\";\n\n$AgHandle = AG3606_Init($resName, $idQuery, $reset, $options);\n\n\n\n\n\n// Measure in the 100mA range with the Least resolution.\n\n$range = 100;\n\n$resol = \"LEAST\";\n\n\n\n\n\n$measure = AG3606_MeasureAcCurrent($AgHandle, $range, $resol);\n\n\n\n\n\nAG3606_MeasureAcVoltage\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG3606_MeasureAcVoltage": {
  "prefix": "AG3606_MeasureAcVoltage",
  "body": [
   "$$measurement=AG3606_MeasureAcVoltage($$AgHandle,$$range,$$resolution);"
  ],
  "description": "\n\nThis function resets all AC current measurement parameters and trigger parameters to their default values, configures the instrument for AC voltage measurements and immediately triggers a measurement. A single reading is returned.\n\n\n\n\n\nRemarks:\n\nThe Agilent library for this instrument must be installed on the test computer. The version used for building and testing this function library is version 1.1.7 for 64 bit operating systems.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AgHandle\n\nObject\n\nA handle to a device opened with AG3606_Init.\n\n\n\n$range\n\nFloat\n\nThe voltage range for the measurement. Valid ranges are (enter the number only):\n\n\u00b7 0.1 V (minimum)\n\n\u00b7 1 V\n\n\u00b7 10 V\n\n\u00b7 100 V\n\n\u00b7 750 V (maximum)\n\n\u00b7 Use 0 for AUTO\n\n\n\n$resolution\n\nString\n\nThe resolution for the measurements. Valid resolutions are:\n\n\u00b7 BEST\n\n\u00b7 LEAST\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$measurement\n\nFloat\n\nThe measurement read from the instrument.\n\n\n\n\n\nExample:\n\n// Get a handle to the device, do an ID query and reset.\n\n$resName = \"GPIB0::5::INSTR\";\n\n$idQuery = true;\n\n$reset = true;\n\n$options = \"\";\n\n$AgHandle = AG3606_Init($resName, $idQuery, $reset, $options);\n\n\n\n\n\n// Measure in the 10V range with the Least resolution.\n\n$range = 10;\n\n$resol = \"LEAST\";\n\n\n\n\n\n$measure = AG3606_MeasureAcVoltage($AgHandle, $range, $resol);\n\n\n\n\n\nAG3606_MeasureCapacitance\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG3606_MeasureCapacitance": {
  "prefix": "AG3606_MeasureCapacitance",
  "body": [
   "$$measurement=AG3606_MeasureCapacitance($$AgHandle,$$range,$$resolution);"
  ],
  "description": "\n\nThis function resets all capacitance measurement parameters and trigger parameters to their default values, configures the instrument for capacitance measurements and immediately triggers a measurement. A single reading is returned.\n\n\n\n\n\nRemarks:\n\nThe Agilent library for this instrument must be installed on the test computer. The version used for building and testing this function library is version 1.1.7 for 64 bit operating systems.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AgHandle\n\nObject\n\nA handle to a device opened with AG3606_Init.\n\n\n\n$range\n\nFloat\n\nThe capacitance range for the measurement. Valid ranges are (enter the number only):\n\n\u00b7 0.000000001 F ( 1nF = minimum)\n\n\u00b7 0.00000001 F (10 nF)\n\n\u00b7 0.0000001 F (100 nF)\n\n\u00b7 0.000001 F (1 uF)\n\n\u00b7 0.00001 F (10 uF)\n\n\u00b7 0.0001 F (100 uF)\n\n\u00b7 0.001 F (1 mF)\n\n\u00b7 0.01 F (10 mF = maximum)\n\n\u00b7 Use 0 for AUTO\n\n\n\n$resolution\n\nString\n\nThe resolution for the measurements. Valid resolutions are:\n\n\u00b7 BEST\n\n\u00b7 LEAST\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$measurement\n\nFloat\n\nThe measurement read from the instrument.\n\n\n\n\n\nExample:\n\n// Get a handle to the device, do an ID query and reset.\n\n$resName = \"GPIB0::5::INSTR\";\n\n$idQuery = true;\n\n$reset = true;\n\n$options = \"\";\n\n$AgHandle = AG3606_Init($resName, $idQuery, $reset, $options);\n\n\n\n\n\n// Measure in the 1mF range with the Least resolution.\n\n$range = 0.001;\n\n$resol = \"LEAST\";\n\n\n\n\n\n$measure = AG3606_MeasureCapacitance($AgHandle, $range, $resol);\n\n\n\n\n\nAG3606_MeasureContinuity\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG3606_MeasureContinuity": {
  "prefix": "AG3606_MeasureContinuity",
  "body": [
   "$$measurement=AG3606_MeasureContinuity($$AgHandle,$$range,$$resolution);"
  ],
  "description": "\n\nThis function resets all continuity measurement parameters and trigger parameters to their default values, configures the instrument for continuity tests and immediately triggers a test. Continuity is a special type of fixed-range 2-wire resistance measurement. A single reading is returned.\n\n\n\n\n\nRemarks:\n\nThe Agilent library for this instrument must be installed on the test computer. The version used for building and testing this function library is version 1.1.7 for 64 bit operating systems.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AgHandle\n\nObject\n\nA handle to a device opened with AG3606_Init.\n\n\n\n$range\n\nFloat\n\nThe resistance range for the test. Valid ranges are (enter the number only):\n\n\u00b7 100 \u03a9 (minimum)\n\n\u00b7 1000 \u03a9 (1 k\u03a9)\n\n\u00b7 10000 \u03a9 (10 k\u03a9)\n\n\u00b7 100000 \u03a9 (100 k\u03a9)\n\n\u00b7 1000000 \u03a9 (1 M\u03a9)\n\n\u00b7 10000000 \u03a9 (10 M\u03a9)\n\n\u00b7 100000000 \u03a9 (100 M\u03a9 = maximum)\n\n\u00b7 Use 0 for AUTO\n\n\n\n$resolution\n\nString\n\nThe resolution for the measurements. Valid resolutions are:\n\n\u00b7 BEST\n\n\u00b7 LEAST\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$measurement\n\nFloat\n\nThe measurement read from the instrument.\n\n\n\n\n\nExample:\n\n// Get a handle to the device, do an ID query and reset.\n\n$resName = \"GPIB0::5::INSTR\";\n\n$idQuery = true;\n\n$reset = true;\n\n$options = \"\";\n\n$AgHandle = AG3606_Init($resName, $idQuery, $reset, $options);\n\n\n\n\n\n// Measure in the 1 k\u03a9 range with the Least resolution.\n\n$range = 1000;\n\n$resol = \"LEAST\";\n\n\n\n\n\n$measure = AG3606_MeasureContinuity($AgHandle, $range, $resol);\n\n\n\n\n\nAG3606_MeasureDcCurrent\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG3606_MeasureDcCurrent": {
  "prefix": "AG3606_MeasureDcCurrent",
  "body": [
   "$$measurement=AG3606_MeasureDcCurrent($$AgHandle,$$range,$$resolution);"
  ],
  "description": "\n\nThis function resets all DC current measurement parameters and trigger parameters to their default values, configures the instrument for DC current measurements and immediately triggers a measurement. A single reading is returned.\n\n\n\n\n\nRemarks:\n\nThe Agilent library for this instrument must be installed on the test computer. The version used for building and testing this function library is version 1.1.7 for 64 bit operating systems.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AgHandle\n\nObject\n\nA handle to a device opened with AG3606_Init.\n\n\n\n$range\n\nFloat\n\nThe current range for the measurement. Valid ranges are (enter the number only):\n\n\u00b7 0.01 A (minimum)\n\n\u00b7 0.1 A\n\n\u00b7 1 A\n\n\u00b7 3 A (maximum)\n\n\u00b7 Use 0 for AUTO\n\n\n\n$resolution\n\nString\n\nThe resolution for the measurements. Valid resolutions are:\n\n\u00b7 BEST\n\n\u00b7 LEAST\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$measurement\n\nFloat\n\nThe measurement read from the instrument.\n\n\n\n\n\nExample:\n\n// Get a handle to the device, do an ID query and reset.\n\n$resName = \"GPIB0::5::INSTR\";\n\n$idQuery = true;\n\n$reset = true;\n\n$options = \"\";\n\n$AgHandle = AG3606_Init($resName, $idQuery, $reset, $options);\n\n\n\n\n\n// Measure in the 100mA range with the Least resolution.\n\n$range = 0.100;\n\n$resol = \"LEAST\";\n\n\n\n\n\n$measure = AG3606_MeasureDcCurrent($AgHandle, $range, $resol);\n\n\n\n\n\nAG3606_MeasureDcVoltage\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG3606_MeasureDcVoltage": {
  "prefix": "AG3606_MeasureDcVoltage",
  "body": [
   "$$measurement=AG3606_MeasureDcVoltage($$AgHandle,$$range,$$resolution);"
  ],
  "description": "\n\nThis function resets all DC current measurement parameters and trigger parameters to their default values, configures the instrument for DC voltage measurements and immediately triggers a measurement. A single reading is returned.\n\n\n\n\n\nRemarks:\n\nThe Agilent library for this instrument must be installed on the test computer. The version used for building and testing this function library is version 1.1.7 for 64 bit operating systems.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AgHandle\n\nObject\n\nA handle to a device opened with AG3606_Init.\n\n\n\n$range\n\nFloat\n\nThe voltage range for the measurement. Valid ranges are (enter the number only):\n\n\u00b7 0.1 V (minimum)\n\n\u00b7 1 V\n\n\u00b7 10 V\n\n\u00b7 100 V\n\n\u00b7 750 V (maximum)\n\n\u00b7 Use 0 for AUTO\n\n\n\n$resolution\n\nString\n\nThe resolution for the measurements. Valid resolutions are:\n\n\u00b7 BEST\n\n\u00b7 LEAST\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$measurement\n\nFloat\n\nThe measurement read from the instrument.\n\n\n\n\n\nExample:\n\n// Get a handle to the device, do an ID query and reset.\n\n$resName = \"GPIB0::5::INSTR\";\n\n$idQuery = true;\n\n$reset = true;\n\n$options = \"\";\n\n$AgHandle = AG3606_Init($resName, $idQuery, $reset, $options);\n\n\n\n\n\n// Measure in the 10V range with the Least resolution.\n\n$range = 10;\n\n$resol = \"LEAST\";\n\n\n\n\n\n$measure = AG3606_MeasureDcVoltage($AgHandle, $range, $resol);\n\n\n\n\n\nAG3606_MeasureDutyCycleCurrent\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG3606_MeasureDutyCycleCurrent": {
  "prefix": "AG3606_MeasureDutyCycleCurrent",
  "body": [
   "$$measurement=AG3606_MeasureDutyCycleCurrent($$AgHandle,$$range,$$resolution);"
  ],
  "description": "\n\nThis function resets all duty cycle measurement parameters and trigger parameters to their default values, configures the instrument for duty cycle measurements and immediately triggers a measurement. A single reading is returned.\n\n\n\n\n\nRemarks:\n\nThe Agilent library for this instrument must be installed on the test computer. The version used for building and testing this function library is version 1.1.7 for 64 bit operating systems.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AgHandle\n\nObject\n\nA handle to a device opened with AG3606_Init.\n\n\n\n$range\n\nFloat\n\nThe current range for the measurement. Valid ranges are (enter the number only):\n\n\u00b7 0.01 A (minimum)\n\n\u00b7 0.1 A\n\n\u00b7 1 A\n\n\u00b7 3 A (maximum)\n\n\u00b7 Use 0 for AUTO\n\n\n\n$resolution\n\nString\n\nThe resolution for the measurements. Valid resolutions are:\n\n\u00b7 BEST\n\n\u00b7 LEAST\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$measurement\n\nFloat\n\nThe measurement read from the instrument.\n\n\n\n\n\nExample:\n\n// Get a handle to the device, do an ID query and reset.\n\n$resName = \"GPIB0::5::INSTR\";\n\n$idQuery = true;\n\n$reset = true;\n\n$options = \"\";\n\n$AgHandle = AG3606_Init($resName, $idQuery, $reset, $options);\n\n\n\n\n\n// Measure in the 100mA range with the Least resolution.\n\n$range = 0.100;\n\n$resol = \"LEAST\";\n\n\n\n\n\n$measure = AG3606_MeasureDutyCycleCurrent($AgHandle, $range, $resol);\n\n\n\n\n\nAG3606_MeasureDutyCycleVoltage\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG3606_MeasureDutyCycleVoltage": {
  "prefix": "AG3606_MeasureDutyCycleVoltage",
  "body": [
   "$$measurement=AG3606_MeasureDutyCycleVoltage($$AgHandle,$$range,$$resolution);"
  ],
  "description": "\n\nThis function resets all duty cycle measurement parameters and trigger parameters to their default values, configures the instrument for duty cycle measurements and immediately triggers a measurement. A single reading is returned.\n\n\n\n\n\nRemarks:\n\nThe Agilent library for this instrument must be installed on the test computer. The version used for building and testing this function library is version 1.1.7 for 64 bit operating systems.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AgHandle\n\nObject\n\nA handle to a device opened with AG3606_Init.\n\n\n\n$range\n\nFloat\n\nThe voltage range for the measurement. Valid ranges are (enter the number only):\n\n\u00b7 0.1 V (minimum)\n\n\u00b7 1 V\n\n\u00b7 10 V\n\n\u00b7 100 V\n\n\u00b7 750 V (maximum)\n\n\u00b7 Use 0 for AUTO\n\n\n\n$resolution\n\nString\n\nThe resolution for the measurements. Valid resolutions are:\n\n\u00b7 BEST\n\n\u00b7 LEAST\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$measurement\n\nFloat\n\nThe measurement read from the instrument.\n\n\n\n\n\nExample:\n\n// Get a handle to the device, do an ID query and reset.\n\n$resName = \"GPIB0::5::INSTR\";\n\n$idQuery = true;\n\n$reset = true;\n\n$options = \"\";\n\n$AgHandle = AG3606_Init($resName, $idQuery, $reset, $options);\n\n\n\n\n\n// Measure in the 10V range with the Least resolution.\n\n$range = 10;\n\n$resol = \"LEAST\";\n\n\n\n\n\n$measure = AG3606_MeasureDutyCycleVoltage($AgHandle, $range, $resol);\n\n\n\n\n\nAG3606_MeasureFrequency\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG3606_MeasureFrequency": {
  "prefix": "AG3606_MeasureFrequency",
  "body": [
   "$$measurement=AG3606_MeasureFrequency($$AgHandle,$$range,$$resolution);"
  ],
  "description": "\n\nThis function resets all frequency measurement parameters and trigger parameters to their default values, configures the instrument for frequency measurements and immediately triggers a measurement. A single reading is returned.\n\n\n\n\n\nRemarks:\n\nThe Agilent library for this instrument must be installed on the test computer. The version used for building and testing this function library is version 1.1.7 for 64 bit operating systems.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AgHandle\n\nObject\n\nA handle to a device opened with AG3606_Init.\n\n\n\n$range\n\nFloat\n\nThe voltage range for the measurement. Valid ranges are (enter the number only):\n\n\u00b7 0.1 V (minimum)\n\n\u00b7 1 V\n\n\u00b7 10 V\n\n\u00b7 100 V\n\n\u00b7 750 V (maximum)\n\n\u00b7 Use 0 for AUTO\n\n\n\n$resolution\n\nString\n\nThe resolution for the measurements. Valid resolutions are:\n\n\u00b7 BEST\n\n\u00b7 LEAST\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$measurement\n\nFloat\n\nThe measurement read from the instrument.\n\n\n\n\n\nExample:\n\n// Get a handle to the device, do an ID query and reset.\n\n$resName = \"GPIB0::5::INSTR\";\n\n$idQuery = true;\n\n$reset = true;\n\n$options = \"\";\n\n$AgHandle = AG3606_Init($resName, $idQuery, $reset, $options);\n\n\n\n\n\n// Measure in the 10V range with the Least resolution.\n\n$range = 10;\n\n$resol = \"LEAST\";\n\n\n\n\n\n$measure = AG3606_MeasureFrequency($AgHandle, $range, $resol);\n\n\n\n\n\nAG3606_MeasureLowResistance\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG3606_MeasureLowResistance": {
  "prefix": "AG3606_MeasureLowResistance",
  "body": [
   "$$measurement=AG3606_MeasureLowResistance($$AgHandle,$$range,$$resolution);"
  ],
  "description": "\n\nThis function resets all low-resistance measurement parameters and trigger parameters to their default values, configures the instrument for 4-wire low-resistance measurements and immediately triggers a measurement. A single reading is returned.\n\n\n\n\n\nRemarks:\n\nThe Agilent library for this instrument must be installed on the test computer. The version used for building and testing this function library is version 1.1.7 for 64 bit operating systems.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AgHandle\n\nObject\n\nA handle to a device opened with AG3606_Init.\n\n\n\n$range\n\nFloat\n\nThe resistance range for the test. Valid ranges are (enter the number only):\n\n\u00b7 0.1 \u03a9 (100 m\u03a9 = minimum)\n\n\u00b7 1 \u03a9 (1 k\u03a9)\n\n\u00b7 10 \u03a9 (maximum)\n\n\u00b7 Use 0 for AUTO\n\n\n\n$resolution\n\nString\n\nThe resolution for the measurements. Valid resolutions are:\n\n\u00b7 BEST\n\n\u00b7 LEAST\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$measurement\n\nFloat\n\nThe measurement read from the instrument.\n\n\n\n\n\nExample:\n\n// Get a handle to the device, do an ID query and reset.\n\n$resName = \"GPIB0::5::INSTR\";\n\n$idQuery = true;\n\n$reset = true;\n\n$options = \"\";\n\n$AgHandle = AG3606_Init($resName, $idQuery, $reset, $options);\n\n\n\n\n\n// Measure in the 100 m\u03a9 range with the Least resolution.\n\n$range = 0.100;\n\n$resol = \"LEAST\";\n\n\n\n\n\n$measure = AG3606_MeasureLowResistance($AgHandle, $range, $resol);\n\n\n\n\n\nAG3606_MeasurePulseWidthCurrent\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG3606_MeasurePulseWidthCurrent": {
  "prefix": "AG3606_MeasurePulseWidthCurrent",
  "body": [
   "$$measurement=AG3606_MeasurePulseWidthCurrent($$AgHandle,$$range,$$resolution);"
  ],
  "description": "\n\nThis function resets all pulse width measurement parameters and trigger parameters to their default values, configures the instrument for pulse width measurements and immediately triggers a measurement. A single reading is returned.\n\n\n\n\n\nRemarks:\n\nThe Agilent library for this instrument must be installed on the test computer. The version used for building and testing this function library is version 1.1.7 for 64 bit operating systems.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AgHandle\n\nObject\n\nA handle to a device opened with AG3606_Init.\n\n\n\n$range\n\nFloat\n\nThe current range for the measurement. Valid ranges are (enter the number only):\n\n\u00b7 0.01 A (minimum)\n\n\u00b7 0.1 A\n\n\u00b7 1 A\n\n\u00b7 3 A (maximum)\n\n\u00b7 Use 0 for AUTO\n\n\n\n$resolution\n\nString\n\nThe resolution for the measurements. Valid resolutions are:\n\n\u00b7 BEST\n\n\u00b7 LEAST\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$measurement\n\nFloat\n\nThe measurement read from the instrument.\n\n\n\n\n\nExample:\n\n// Get a handle to the device, do an ID query and reset.\n\n$resName = \"GPIB0::5::INSTR\";\n\n$idQuery = true;\n\n$reset = true;\n\n$options = \"\";\n\n$AgHandle = AG3606_Init($resName, $idQuery, $reset, $options);\n\n\n\n\n\n// Measure in the 100mA range with the Least resolution.\n\n$range = 0.100;\n\n$resol = \"LEAST\";\n\n\n\n\n\n$measure = AG3606_MeasurePulseWidthCurrent($AgHandle, $range, $resol);\n\n\n\n\n\nAG3606_MeasurePulseWidthVoltage\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG3606_MeasurePulseWidthVoltage": {
  "prefix": "AG3606_MeasurePulseWidthVoltage",
  "body": [
   "$$measurement=AG3606_MeasurePulseWidthVoltage($$AgHandle,$$range,$$resolution);"
  ],
  "description": "\n\nThis function resets all pulse width measurement parameters and trigger parameters to their default values, configures the instrument for pulse width measurements and immediately triggers a measurement. A single reading is returned.\n\n\n\n\n\nRemarks:\n\nThe Agilent library for this instrument must be installed on the test computer. The version used for building and testing this function library is version 1.1.7 for 64 bit operating systems.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AgHandle\n\nObject\n\nA handle to a device opened with AG3606_Init.\n\n\n\n$range\n\nFloat\n\nThe voltage range for the measurement. Valid ranges are (enter the number only):\n\n\u00b7 0.1 V (minimum)\n\n\u00b7 1 V\n\n\u00b7 10 V\n\n\u00b7 100 V\n\n\u00b7 750 V (maximum)\n\n\u00b7 Use 0 for AUTO\n\n\n\n$resolution\n\nString\n\nThe resolution for the measurements. Valid resolutions are:\n\n\u00b7 BEST\n\n\u00b7 LEAST\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$measurement\n\nFloat\n\nThe measurement read from the instrument.\n\n\n\n\n\nExample:\n\n// Get a handle to the device, do an ID query and reset.\n\n$resName = \"GPIB0::5::INSTR\";\n\n$idQuery = true;\n\n$reset = true;\n\n$options = \"\";\n\n$AgHandle = AG3606_Init($resName, $idQuery, $reset, $options);\n\n\n\n\n\n// Measure in the 10V range with the Least resolution.\n\n$range = 10;\n\n$resol = \"LEAST\";\n\n\n\n\n\n$measure = AG3606_MeasurePulseWidthVoltage($AgHandle, $range, $resol);\n\n\n\n\n\nAG3606_MeasureResistance\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG3606_MeasureResistance": {
  "prefix": "AG3606_MeasureResistance",
  "body": [
   "$$measurement=AG3606_MeasureResistance($$AgHandle,$$range,$$resolution);"
  ],
  "description": "\n\nThis function resets all resistance measurement parameters and trigger parameters to their default values, configures the instrument for 2-wire resistance measurements and immediately triggers a measurement. A single reading is returned.\n\n\n\n\n\nRemarks:\n\nThe Agilent library for this instrument must be installed on the test computer. The version used for building and testing this function library is version 1.1.7 for 64 bit operating systems.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AgHandle\n\nObject\n\nA handle to a device opened with AG3606_Init.\n\n\n\n$range\n\nFloat\n\nThe resistance range for the test. Valid ranges are (enter the number only):\n\n\u00b7 100 \u03a9 (minimum)\n\n\u00b7 1000 \u03a9 (1 k\u03a9)\n\n\u00b7 10000 \u03a9 (10 k\u03a9)\n\n\u00b7 100000 \u03a9 (100 k\u03a9)\n\n\u00b7 1000000 \u03a9 (1 M\u03a9)\n\n\u00b7 10000000 \u03a9 (10 M\u03a9)\n\n\u00b7 100000000 \u03a9 (100 M\u03a9 = maximum)\n\n\u00b7 Use 0 for AUTO\n\n\n\n$resolution\n\nString\n\nThe resolution for the measurements. Valid resolutions are:\n\n\u00b7 BEST\n\n\u00b7 LEAST\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$measurement\n\nFloat\n\nThe measurement read from the instrument.\n\n\n\n\n\nExample:\n\n// Get a handle to the device, do an ID query and reset.\n\n$resName = \"GPIB0::5::INSTR\";\n\n$idQuery = true;\n\n$reset = true;\n\n$options = \"\";\n\n$AgHandle = AG3606_Init($resName, $idQuery, $reset, $options);\n\n\n\n\n\n// Measure in the 100 k\u03a9 range with the Least resolution.\n\n$range = 100000;\n\n$resol = \"LEAST\";\n\n\n\n\n\n$measure = AG3606_MeasureResistance($AgHandle, $range, $resol);\n\n\n\n\n\nAG3606_PowerSupplyConfig\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG3606_PowerSupplyConfig": {
  "prefix": "AG3606_PowerSupplyConfig",
  "body": [
   "AG3606_PowerSupplyConfig($$AgHandle,$$voltageRange,$$voltage,$$currentLimit);"
  ],
  "description": "\n\nThis function configures the DC power supply parameters. The output must be disabled before a new configuration will be accepted.\n\n\n\n\n\nRemarks:\n\nThe Agilent library for this instrument must be installed on the test computer. The version used for building and testing this function library is version 1.1.7 for 64 bit operating systems.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AgHandle\n\nObject\n\nA handle to a device opened with AG3606_Init.\n\n\n\n$voltageRange\n\nInteger\n\nThe voltage range for output. Valid ranges are (enter the number only):\n\n\u00b7 30 V - The S1 (30V / 1A) range has a higher voltage range, but a lower current range.\n\n\u00b7 8 V - The S2 (8V / 3A) range provides for a higher current range, but a lower voltage range.\n\n\n\n\n\nThe maximum current is automatically set based on the voltage range chosen.\n\n\n\n$voltage\n\nInteger\n\nThe output voltage. This must be within the specified range.\n\n\n\n$currentLimit\n\nInteger\n\nThe maximum current before Over Current Protection (OCP) is tripped.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n// Get a handle to the device, do an ID query and reset.\n\n$resName = \"GPIB0::5::INSTR\";\n\n$idQuery = true;\n\n$reset = true;\n\n$options = \"\";\n\n$AgHandle = AG3606_Init($resName, $idQuery, $reset, $options);\n\n\n\n\n\n// Configure the supply for 5V output in the 8V.3A range with 2A current limit.\n\n$voltRange = 8;\n\n$voltage = 5;\n\n$currLimit = 2;\n\n\n\n\n\nAG3606_PowerSupplyConfig($AgHandle, $voltRange, $voltage, $currLimit);\n\n\n\n\n\nAG3606_PowerSupplySetOutputState\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG3606_PowerSupplySetOutputState": {
  "prefix": "AG3606_PowerSupplySetOutputState",
  "body": [
   "AG3606_PowerSupplySetOutputState($$AgHandle,$$outputState);"
  ],
  "description": "\n\nThis function toggles the DC power supply output to either ON or OFF. The parameters for the output are set with the AG3606_PowerSupplyConfig function.\n\n\n\n\n\nRemarks:\n\nThe Agilent library for this instrument must be installed on the test computer. The version used for building and testing this function library is version 1.1.7 for 64 bit operating systems.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AgHandle\n\nObject\n\nA handle to a device opened with AG3606_Init.\n\n\n\n$outputState\n\nString\n\nThe state for the output. Must be either ON or OFF.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n// Get a handle to the device, do an ID query and reset.\n\n$resName = \"GPIB0::5::INSTR\";\n\n$idQuery = true;\n\n$reset = true;\n\n$options = \"\";\n\n$AgHandle = AG3606_Init($resName, $idQuery, $reset, $options);\n\n\n\n\n\n// Configure the supply for 5V output in the 8V.3A range with 2A current limit.\n\n$voltRange = 8;\n\n$voltage = 5;\n\n$currLimit = 2;\n\n\n\n\n\nAG3606_PowerSupplyConfig($AgHandle, $voltRange, $voltage, $currLimit);\n\n\n\n\n\n// Turn the power supply on.\n\n$psState = \"ON\";\n\nAG3606_PowerSupplySetOutputState($AgHandle, $psState);\n\n\n\n\n\nNI_DMM_Close\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_DMM_Close": {
  "prefix": "NI_DMM_Close",
  "body": [
   "NI_DMM_Close($$Handle);"
  ],
  "description": "\n\nThis function requires NI-DMM 2.3 to be installed on the system.\n\nCloses the specified session (created with NI_DMM_Initialize) and de-allocates resources that it reserved.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a National Instruments device NI PXI-4070.\n\n\u00b7 This function can be used for all National Instruments digital multimeter types (NI DMM devices).\n\n\n\nResult:\n\nNI_DMM_Close($Handle);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nA handle to a NI DMM device created with the NIDMM_Initialize function.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n\n\nExample:\n\nNI_DMM_Close($Handle);\n\n\n\n\n\nNI_DMM_ConfigureMeasurement\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_DMM_ConfigureMeasurement": {
  "prefix": "NI_DMM_ConfigureMeasurement",
  "body": [
   "NI_DMM_ConfigureMeasurement($$Handle,$$Type,$$Range,$$Resolution);"
  ],
  "description": "\n\nThis function requires NI-DMM 2.3 to be installed on the system.\n\nThis function configures the DMM for a measurement.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a National Instruments device NI PXI-4070.\n\n\u00b7 This function can be used for all National Instruments digital multimeter types (NI DMM devices).\n\n\n\nResult:\n\nNI_DMM_ConfigureMeasurement($Handle, $Type,$Range,$Resolution);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nA handle to a NI DMM device created with the NIDMM_Initialize function.\n\n\n\n$Type\n\nString\n\nMeasurement Type.\n\nThe available types are:\n\n\u00b7 DC Volts\n\n\u00b7 AC Volts\n\n\u00b7 DC Current\n\n\u00b7 AC Current\n\n\u00b7 2Wire Resistance\n\n\u00b7 4Wire Resistance\n\n\u00b7 Frequency\n\n\u00b7 Period\n\n\u00b7 Diode\n\n\u00b7 ACVolts DCCoupled\n\n\n\n$Range\n\nDouble\n\nSpecifies the range for the function. For example, you must type in 100 Hz if you are measuring 101 Hz or higher. For all other functions, you must supply a range that exceeds the value that you are measuring. For example, you must type in 10 V if you are measuring 9 V. Range values are coerced up to the closest input range. Refer to the Devices Overview for a list of valid ranges.\n\n\n\nPossible options:\n\n\u00b7 -1: (On) NI-DMM performs an Auto Range before acquiring the measurement.\n\n\u00b7 -2: (Off) NI-DMM uses the current Auto Range value for all subsequent measurements until the measurement configuration is changed.\n\n\u00b7 -3: (Once) NI-DMM performs an Auto Range before acquiring the measurement. The Auto Range value is stored and used for all subsequent measurements until the measurement configuration is changed.\n\n\u00b7 Any other value.\n\n\n\n$Resolution\n\nDouble\n\nFor a noise-free DMM, resolution is the smallest change in an input signal that produces, on average, a change in the output signal.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n\n\nExample:\n\nNI_DMM_ConfigureMeasurement($Handle, \"DC Volts\", 2.5, 5.5);\n\n\n\n\n\nNI_DMM_ConfigureTrigger\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_DMM_ConfigureTrigger": {
  "prefix": "NI_DMM_ConfigureTrigger",
  "body": [
   "NI_DMM_ConfigureTrigger($$Handle,$$Source,$$Delay);"
  ],
  "description": "\n\nThis function requires NI-DMM 2.3 to be installed on the system.\n\nThis function sets the trigger source and delay of the DMM.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a National Instruments device NI PXI-4070.\n\n\u00b7 This function can be used for all National Instruments digital multimeter types (NI DMM devices).\n\n\n\nResult:\n\nNI_DMM_ConfigureTrigger($Handle,$Source,$Delay);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nA handle to a NI DMM device created with the NIDMM_Initialize function.\n\n\n\n$Source\n\nInteger\n\nTrigger source. See DMM documentation for values.\n\n\n\n$Delay\n\nFloat\n\nTrigger delay in seconds.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n\n\nExample:\n\nNI_DMM_ConfigureTrigger($Handle,1,0.5);\n\n\n\n\n\nNI_DMM_Fetch\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_DMM_Fetch": {
  "prefix": "NI_DMM_Fetch",
  "body": [
   "$$Result=NI_DMM_Fetch($$Handle,$$MaxMeasTime);"
  ],
  "description": "\n\nThis function requires NI-DMM 2.3 to be installed on the system.\n\nThis function fetches a measurement after the NI_DMM_Initiate is executed. The DMM must be setup with the NI_DMM_ConfigureMeasurement.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a National Instruments device NI PXI-4070.\n\n\u00b7 This function can be used for all National Instruments digital multimeter types (NI DMM devices).\n\n\n\nResult:\n\n$Result = NI_DMM_Fetch($Handle, $MaxMeasTime);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nA handle to a NI DMM device created with the NIDMM_Initialize function.\n\n\n\n$MaxMeasTime\n\nInteger\n\nSpecifies the maximum time allowed for this function to complete in milliseconds.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Result\n\nFloat\n\nThe resulting value is returned as a float.\n\n\n\n\n\nExample:\n\n$Result = NI_DMM_Fetch($Handle,1250);\n\n\n\n\n\nNI_DMM_GetBooleanAttribute\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_DMM_GetBooleanAttribute": {
  "prefix": "NI_DMM_GetBooleanAttribute",
  "body": [
   "$$Result=NI_DMM_GetBooleanAttribute($$Handle,$$AttributeIdentifier);"
  ],
  "description": "\n\nThis function requires NI-DMM 2.3 to be installed on the system.\n\nThis function gets the value of a boolean attribute.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a National Instruments device NI PXI-4070.\n\n\u00b7 This function can be used for all National Instruments digital multimeter types (NI DMM devices).\n\n\n\nResult:\n\n$Result = NI_DMM_GetBooleanAttribute($Handle, $AttributeIdentifier);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nA handle to a NI DMM device created with the NIDMM_Initialize function.\n\n\n\n$AttributeIdentifier\n\nString\n\nPass the ID of an attribute.\n\nPossible values:\n\n\u00b7 CACHE\n\n\u00b7 INTERCHANGE CHECK\n\n\u00b7 QUERY INSTRUMENT STATUS\n\n\u00b7 RANGE CHECK\n\n\u00b7 RECORD COERCIONS\n\n\u00b7 SIMULATE\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Result\n\nBoolean\n\nThe value of the attribute identifier.\n\n\n\n\n\nExample:\n\n$Result = NI_DMM_GetBooleanAttribute($Handle, \"RANGE CHECK\");\n\n\n\n\n\nNI_DMM_GetDoubleAttribute\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_DMM_GetDoubleAttribute": {
  "prefix": "NI_DMM_GetDoubleAttribute",
  "body": [
   "$$Result=NI_DMM_GetDoubleAttribute($$Handle,$$AttributeIdentifier);"
  ],
  "description": "\n\nThis function requires NI-DMM 2.3 to be installed on the system.\n\nThis function gets the value of a double attribute.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a National Instruments device NI PXI-4070.\n\n\u00b7 This function can be used for all National Instruments digital multimeter types (NI DMM devices).\n\n\n\nResult:\n\n$Result = NI_DMM_GetDoubleAttribute($Handle, $AttributeIdentifier);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nA handle to a NI DMM device created with the NIDMM_Initialize function.\n\n\n\n$AttributeIdentifier\n\nString\n\nPass the ID of an attribute.\n\nPossible values:\n\n\u00b7 AUTO RANGE VALUE\n\n\u00b7 RANGE\n\n\u00b7 RESOLUTION DIGITS\n\n\u00b7 RESOLUTION ABSOLUTE\n\n\u00b7 AC MAX FREQUENCY\n\n\u00b7 AC MIN FREQUENCY\n\n\u00b7 CURRENT SOURCE\n\n\u00b7 FREQUENCY VOLTAGE AUTO RANGE VALUE\n\n\u00b7 FREQUENCY VOLTAGE RANGE\n\n\u00b7 INPUT RESISTANCE\n\n\u00b7 POWERLINE FREQUENCY\n\n\u00b7 SHUNT VALUE\n\n\u00b7 TRIGGER DELAY\n\n\u00b7 SAMPLE INTERVAL\n\n\u00b7 APERTURE TIME\n\n\u00b7 SETTLE TIME\n\n\u00b7 WAVEFORM RATE\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Result\n\nFloat\n\nThe value of the attribute identifier.\n\n\n\n\n\nExample:\n\n$Result = NI_DMM_GetDoubleAttribute($Handle, \"AC MIN FREQUENCY\");\n\n\n\n\n\nNI_DMM_GetIntegerAttribute\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_DMM_GetIntegerAttribute": {
  "prefix": "NI_DMM_GetIntegerAttribute",
  "body": [
   "$$Result=NI_DMM_GetIntegerAttribute($$Handle,$$AttributeIdentifier);"
  ],
  "description": "\n\nThis function requires NI-DMM 2.3 to be installed on the system.\n\nThis function gets the value of an integer attribute.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a National Instruments device NI PXI-4070.\n\n\u00b7 This function can be used for all National Instruments digital multimeter types (NI DMM devices).\n\n\n\nResult:\n\n$Result = NI_DMM_GetIntegerAttribute($Handle, $AttributeIdentifier);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nA handle to a NI DMM device created with the NIDMM_Initialize function.\n\n\n\n$AttributeIdentifier\n\nString\n\nPass the ID of an attribute.\n\nPossible values:\n\n\u00b7 CHANNEL COUNT\n\n\u00b7 SPECIFIC DRIVER MAJOR VERSION\n\n\u00b7 SPECIFIC DRIVER MINOR VERSION\n\n\u00b7 SPECIFIC DRIVER CLASS SPEC MAJOR VERSION\n\n\u00b7 SPECIFIC DRIVER CLASS SPEC MINOR VERSION\n\n\u00b7 FUNCTION\n\n\u00b7 ADC CALIBRATION\n\n\u00b7 AUTO ZERO\n\n\u00b7 DC NOISE REJECTION\n\n\u00b7 OFFSET COMPENSATED OHMS\n\n\u00b7 MEASUREMENT COMPLETE DESTINATION\n\n\u00b7 MEASUREMENT DESTINATION SLOPE\n\n\u00b7 TRIGGER SLOPE\n\n\u00b7 TRIGGER SOURCE\n\n\u00b7 BUFFER SIZE\n\n\u00b7 LATENCY\n\n\u00b7 SAMPLE COUNT\n\n\u00b7 SAMPLE DELAY MODE\n\n\u00b7 SAMPLE TRIGGER\n\n\u00b7 SAMPLE TRIGGER SLOPE\n\n\u00b7 TRIGGER COUNT\n\n\u00b7 APERTURE TIME UNITS\n\n\u00b7 NUMBER OF AVERAGES\n\n\u00b7 OPERATION MODE\n\n\u00b7 WAVEFORM COUPLING\n\n\u00b7 WAVEFORM POINTS\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Result\n\nBoolean\n\nThe value of the attribute identifier.\n\n\n\n\n\nExample:\n\n$Result= NI_DMM_GetIntegerAttribute($Handle, \"AUTO ZERO\");\n\n\n\n\n\nNI_DMM_GetStringAttribute\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_DMM_GetStringAttribute": {
  "prefix": "NI_DMM_GetStringAttribute",
  "body": [
   "$$Result=NI_DMM_GetStringAttribute($$Handle,$$AttributeIdentifier,$$BufferSize);"
  ],
  "description": "\n\nThis function requires NI-DMM 2.3 to be installed on the system.\n\nThis function gets the value of a string attribute.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a National Instruments device NI PXI-4070.\n\n\u00b7 This function can be used for all National Instruments digital multimeter types (NI DMM devices).\n\n\n\nResult:\n\n$Result = NI_DMM_GetStringAttribute($Handle, $AttributeIdentifier, $BufferSize);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nA handle to a NI DMM device created with the NIDMM_Initialize function.\n\n\n\n$AttributeIdentifier\n\nString\n\nPass the ID of an attribute.\n\nPossible values:\n\n\u00b7 DRIVER SETUP\n\n\u00b7 SPECIFIC DRIVER PREFIX\n\n\u00b7 SPECIFIC DRIVER REVISION\n\n\u00b7 SPECIFIC DRIVER DESCRIPTION\n\n\u00b7 ID QUERY RESPONSE\n\n\u00b7 SPECIFIC DRIVER VENDOR\n\n\u00b7 LOGICAL NAME\n\n\u00b7 I/O RESOURCE DESCRIPTOR\n\n\u00b7 INSTRUMENT FIRMWARE REVISION\n\n\u00b7 INSTRUMENT MANUFACTURER\n\n\u00b7 INSTRUMENT MODEL\n\n\u00b7 SERIAL NUMBER\n\n\u00b7 GROUP CAPABILITIES\n\n\u00b7 SUPPORTED INSTRUMENT MODELS\n\n\n\n$BufferSize\n\nInteger\n\nThe size of the returned attribute value.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Result\n\nString\n\nThe value of the attribute identifier.\n\n\n\n\n\nExample:\n\n$Value = NI_DMM_GetStringAttribute($Handle, \"INSTRUMENT MODEL\", 255);\n\n\n\n\n\nNI_DMM_Initialize\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_DMM_Initialize": {
  "prefix": "NI_DMM_Initialize",
  "body": [
   "$$Handle=NI_DMM_Initialize($$DeviceName,$$IdQuery,$$ResetDevice);"
  ],
  "description": "\n\nThis function requires NI-DMM 2.3 to be installed on the system.\n\nThis function completes the following tasks:\n\n\u00b7 Creates a new instrument driver session.\n\n\u00b7 Opens a session to the device you specify for the $DeviceName parameter.\n\n\u00b7 If the IdQuery parameter is set to true, this function queries the instrument ID and checks that it is valid for this instrument driver.\n\n\u00b7 If the $ResetDevice parameter is set to true, this function resets the instrument to a known state.\n\n\u00b7 Sends initialization commands to set the instrument to the state necessary for the operation of the instrument driver.\n\n\u00b7 Returns a session handle that you use to identify the instrument in all subsequent instrument driver function calls.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a National Instruments device NI PXI-4070.\n\n\u00b7 This function can be used for all National Instruments digital multimeter types (NI DMM devices).\n\n\n\nResult:\n\n$Handle = NI_DMM_Initialize($DeviceName, $IdQuery, $ResetDevice);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$DeviceName\n\nString\n\nContains the resource name of the device to initialize. The resource name is assigned in Measurement & Automation Explorer (MAX).\n\n\n\n$IdQuery\n\nBoolean\n\nSpecifies whether the driver performs an ID query. When this parameter is set to \"true\", the driver verifies that the instrument is of a type that this driver supports.\n\n\n\n$ResetDevice\n\nBoolean\n\nSpecifies whether to reset the instrument during the initialization procedure.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nReturns a handle that you use to identify the instrument in all subsequent instrument driver function calls.\n\n\n\n\n\nExample:\n\n$Handle = NIDMM.Initialize(\"Dev1\", \"true\", \"true\");\n\n\n\n\n\nNI_DMM_Initiate\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_DMM_Initiate": {
  "prefix": "NI_DMM_Initiate",
  "body": [
   "NI_DMM_Initiate($$Handle);"
  ],
  "description": "\n\nThis function requires NI-DMM 2.3 to be installed on the system.\n\nThis function initiates the measurement setup with the NI_DMM_ConfigureMeasurement.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a National Instruments device NI PXI-4070.\n\n\u00b7 This function can be used for all National Instruments digital multimeter types (NI DMM devices).\n\n\n\nResult:\n\nNI_DMM_Initiate($Handle);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nA handle to a NI DMM device created with the NIDMM_Initialize function.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n\n\nExample:\n\nNI_DMM_Initiate($Handle);\n\n\n\n\n\nNI_DMM_Measure2WireResistance\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_DMM_Measure2WireResistance": {
  "prefix": "NI_DMM_Measure2WireResistance",
  "body": [
   "$$Result=NI_DMM_Measure2WireResistance($$Handle,$$MeasureRange,$$Resolution,$$MaxMeasTime,$$PowerLineFrequency,$$AutoZeroMode);"
  ],
  "description": "\n\nThis function requires NI-DMM 2.3 to be installed on the system.\n\nThis function completes the following tasks:\n\n\u00b7 Configures the common attributes of the measurement: the measure range, the maximum measure time, the resolution and the power line frequency.\n\n\u00b7 Configures the DMM for Auto Zero.\n\n\u00b7 After configuration, the function measures the DC voltage present on the DMM instrument using the handle $Handle created with NI_DMM_Initialize.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a National Instruments device NI PXI-4070.\n\n\u00b7 This function can be used for all National Instruments digital multimeter types (NI DMM devices).\n\n\n\nResult:\n\n$Result = NI_DMM_Measure2WireResistance($Handle, $MeasureRange, $Resolution, $MaxMeasTime, $PowerLineFrequency, $AutoZeroMode);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nA handle to a NI DMM device created with the NIDMM_Initialize function.\n\n\n\n$MeasureRange\n\nDouble\n\nSpecifies the range for the function. For example, you must type in 100 Hz if you are measuring 101 Hz or higher. For all other functions, you must supply a range that exceeds the value that you are measuring. For example, you must type in 10 V if you are measuring 9 V. Range values are coerced up to the closest input range. Refer to the Devices Overview for a list of valid ranges.\n\n\n\nPossible options:\n\n\u00b7 -1: (On) NI-DMM performs an Auto Range before acquiring the measurement.\n\n\u00b7 -2: (Off) NI-DMM uses the current Auto Range value for all subsequent measurements until the measurement configuration is changed.\n\n\u00b7 -3: (Once) NI-DMM performs an Auto Range before acquiring the measurement. The Auto Range value is stored and used for all subsequent measurements until the measurement configuration is changed.\n\n\u00b7 Any other value.\n\n\n\n$Resolution\n\nDouble\n\nFor a noise-free DMM, resolution is the smallest change in an input signal that produces, on average, a change in the output signal.\n\n\n\n$MaxMeasTime\n\nInteger\n\nSpecifies the maximum time allowed for this function to complete in milliseconds.\n\n\n\n$PowerLineFrequency\n\nString\n\nSpecifies the powerline frequency. This value is used to select an aperture time to reject power line noise.\n\nPossible values:\n\n\u00b7 50 Hz\n\n\u00b7 60 Hz\n\n\n\n$AutoZeroMode\n\nString\n\nConfigures the DMM for Auto Zero. When Auto Zero is on, the DMM internally disconnects the input signal and takes a zero reading. It then subtracts the zero reading from the measurement. This prevents offset voltages present on the input circuitry of the DMM from affecting measurement accuracy. When Auto Zero is off, the DMM does not compensate for zero reading offset. ON enables Auto Zero for each measurement. ONCE enables Auto Zero before the next measurement. The Auto Zero value is stored and used in subsequent measurements until the device is reconfigured. OFF disables Auto Zero. If you set the Auto Zero mode to AUTO, NI-DMM determines whether to enable Auto Zero based on the measurement function that you configure.\n\n\n\n\n\nPossible values:\n\n\u00b7 Auto\n\n\u00b7 On\n\n\u00b7 Once\n\n\u00b7 Off\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Result\n\nFloat\n\nThe resulting value is returned as a float.\n\n\n\n\n\nExample:\n\nI applied a 10 kOhm resistor on the NI-DMM device according the 2 wire measure method.\n\n\n\n\n\n$Result = NI_DMM_Measure2WireResistance($Handle,10000.0,1.0,50,\"50 Hz\",\"On\");\n\n\n\n\n\nNI_DMM_Measure4WireResistance\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_DMM_Measure4WireResistance": {
  "prefix": "NI_DMM_Measure4WireResistance",
  "body": [
   "$$Result=NI_DMM_Measure4WireResistance($$Handle,$$MeasureRange,$$Resolution,$$MaxMeasTime,$$PowerLineFrequency,$$AutoZeroMode);"
  ],
  "description": "\n\nThis function requires NI-DMM 2.3 to be installed on the system.\n\nFor precision measurements with resistances below 100 k ohms, the 4-wire mode works more reliably and conveniently than the 2-wire mode. The 4-wire mode requires 4-wire switching and more cabling; however, you may decide the tradeoff is acceptable, depending upon the accuracy versus complexity requirements of your system. Look in the documentation for the hardware connections on the NI DMM device.\n\nThis function completes the following tasks:\n\n\u00b7 Configures the common attributes of the measurement: the measure range, the maximum measure time, the resolution and the power line frequency.\n\n\u00b7 Configures the DMM for Auto Zero.\n\n\u00b7 After configuration, the function measures the DC voltage present on the DMM instrument using the handle $Handle created with NI_DMM_Initialize.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a National Instruments device NI PXI-4070.\n\n\u00b7 This function can be used for all National Instruments digital multimeter types (NI DMM devices).\n\n\n\nResult:\n\n$Result = NI_DMM_Measure4WireResistance($Handle, $MeasureRange, $Resolution, $MaxMeasTime, $PowerLineFrequency, $AutoZeroMode);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nA handle to a NI DMM device created with the NIDMM_Initialize function.\n\n\n\n$MeasureRange\n\nDouble\n\nSpecifies the range for the function. For example, you must type in 100 Hz if you are measuring 101 Hz or higher. For all other functions, you must supply a range that exceeds the value that you are measuring. For example, you must type in 10 V if you are measuring 9 V. Range values are coerced up to the closest input range. Refer to the Devices Overview for a list of valid ranges.\n\n\n\n\n\nPossible options:\n\n\u00b7 -1: (On) NI-DMM performs an Auto Range before acquiring the measurement.\n\n\u00b7 -2: (Off) NI-DMM uses the current Auto Range value for all subsequent measurements until the measurement configuration is changed.\n\n\u00b7 -3: (Once) NI-DMM performs an Auto Range before acquiring the measurement. The Auto Range value is stored and used for all subsequent measurements until the measurement configuration is changed.\n\n\u00b7 Any other value.\n\n\n\n$Resolution\n\nDouble\n\nFor a noise-free DMM, resolution is the smallest change in an input signal that produces, on average, a change in the output signal.\n\n\n\n$MaxMeasTime\n\nInteger\n\nSpecifies the maximum time allowed for this function to complete in milliseconds.\n\n\n\n$PowerLineFrequency\n\nString\n\nSpecifies the powerline frequency. This value is used to select an aperture time to reject power line noise.\n\nPossible values:\n\n\u00b7 50 Hz\n\n\u00b7 60 Hz\n\n\n\n$AutoZeroMode\n\nString\n\nConfigures the DMM for Auto Zero. When Auto Zero is on, the DMM internally disconnects the input signal and takes a zero reading. It then subtracts the zero reading from the measurement. This prevents offset voltages present on the input circuitry of the DMM from affecting measurement accuracy. When Auto Zero is off, the DMM does not compensate for zero reading offset. ON enables Auto Zero for each measurement. ONCE enables Auto Zero before the next measurement. The Auto Zero value is stored and used in subsequent measurements until the device is reconfigured. OFF disables Auto Zero. If you set the Auto Zero mode to AUTO, NI-DMM determines whether to enable Auto Zero based on the measurement function that you configure.\n\n\n\n\n\nPossible values:\n\n\u00b7 Auto\n\n\u00b7 On\n\n\u00b7 Once\n\n\u00b7 Off\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Result\n\nFloat\n\nThe resulting value is returned as a float.\n\n\n\n\n\nExample:\n\nI applied a 10 kOhm resistor on the NI-DMM device according the 4 wire measure method.\n\n\n\n\n\n$Result = NI_DMM_Measure4WireResistance($Handle,10000.0,1.0,50,\"50 Hz\",\"On\");\n\n\n\n\n\nNI_DMM_MeasureCurrentAC\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_DMM_MeasureCurrentAC": {
  "prefix": "NI_DMM_MeasureCurrentAC",
  "body": [
   "$$Result=NI_DMM_MeasureCurrentAC($$Handle,$$MeasureRange,$$Resolution,$$MaxMeasTime,$$PowerLineFrequency,$$AutoZeroMode);"
  ],
  "description": "\n\nThis function requires NI-DMM 2.3 to be installed on the system.\n\nThis function completes the following tasks:\n\n\u00b7 Configures the common attributes of the measurement: the measure range, the maximum measure time, the resolution and the power line frequency.\n\n\u00b7 Configures the DMM for Auto Zero.\n\n\u00b7 After configuration, the function measures the AC current present on the DMM instrument using the handle $Handle created with NI_DMM_Initialize.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a National Instruments device NI PXI-4070.\n\n\u00b7 This function can be used for all National Instruments digital multimeter types (NI DMM devices).\n\n\n\nResult:\n\n$Result = NI_DMM_MeasureCurrentAC($Handle, $MeasureRange, $Resolution, $MaxMeasTime, $PowerLineFrequency, $AutoZeroMode);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nA handle to a NI DMM device created with the NIDMM_Initialize function.\n\n\n\n$MeasureRange\n\nDouble\n\nSpecifies the range for the function. For example, you must type in 100 Hz if you are measuring 101 Hz or higher. For all other functions, you must supply a range that exceeds the value that you are measuring. For example, you must type in 10 V if you are measuring 9 V. Range values are coerced up to the closest input range. Refer to the Devices Overview for a list of valid ranges.\n\n\n\n\n\nPossible options:\n\n\u00b7 -1: (On) NI-DMM performs an Auto Range before acquiring the measurement.\n\n\u00b7 -2: (Off) NI-DMM uses the current Auto Range value for all subsequent measurements until the measurement configuration is changed.\n\n\u00b7 -3: (Once) NI-DMM performs an Auto Range before acquiring the measurement. The Auto Range value is stored and used for all subsequent measurements until the measurement configuration is changed.\n\n\u00b7 Any other value.\n\n\n\n$Resolution\n\nDouble\n\nFor a noise-free DMM, resolution is the smallest change in an input signal that produces, on average, a change in the output signal.\n\n\n\n$MaxMeasTime\n\nInteger\n\nSpecifies the maximum time allowed for this function to complete in milliseconds.\n\n\n\n$PowerLineFrequency\n\nString\n\nSpecifies the powerline frequency. This value is used to select an aperture time to reject power line noise.\n\nPossible values:\n\n\u00b7 50 Hz\n\n\u00b7 60 Hz\n\n\n\n$AutoZeroMode\n\nString\n\nConfigures the DMM for Auto Zero. When Auto Zero is on, the DMM internally disconnects the input signal and takes a zero reading. It then subtracts the zero reading from the measurement. This prevents offset voltages present on the input circuitry of the DMM from affecting measurement accuracy. When Auto Zero is off, the DMM does not compensate for zero reading offset. ON enables Auto Zero for each measurement. ONCE enables Auto Zero before the next measurement. The Auto Zero value is stored and used in subsequent measurements until the device is reconfigured. OFF disables Auto Zero. If you set the Auto Zero mode to AUTO, NI-DMM determines whether to enable Auto Zero based on the measurement function that you configure.\n\n\n\n\n\nPossible values:\n\n\u00b7 Auto\n\n\u00b7 On\n\n\u00b7 Once\n\n\u00b7 Off\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Result\n\nFloat\n\nThe resulting value is returned as a float.\n\n\n\n\n\nExample:\n\n$Result = NI_DMM_MeasureCurrentAC($Handle,-1,1.0,50,\"50 Hz\",\"On\");\n\n\n\n\n\nNI_DMM_MeasureCurrentDC\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_DMM_MeasureCurrentDC": {
  "prefix": "NI_DMM_MeasureCurrentDC",
  "body": [
   "$$Result=NI_DMM_MeasureCurrentDC($$Handle,$$MeasureRange,$$Resolution,$$MaxMeasTime,$$PowerLineFrequency,$$AutoZeroMode);"
  ],
  "description": "\n\nThis function requires NI-DMM 2.3 to be installed on the system.\n\nThis function completes the following tasks:\n\n\u00b7 Configures the common attributes of the measurement: the measure range, the maximum measure time, the resolution and the power line frequency.\n\n\u00b7 Configures the DMM for Auto Zero.\n\n\u00b7 After configuration, the function measures the DC current present on the DMM instrument using the handle $Handle created with NI_DMM_Initialize.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a National Instruments device NI PXI-4070.\n\n\u00b7 This function can be used for all National Instruments digital multimeter types (NI DMM devices).\n\n\n\nResult:\n\n$Result = NI_DMM_MeasureCurrentDC($Handle, $MeasureRange, $Resolution, $MaxMeasTime, $PowerLineFrequency, $AutoZeroMode);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nA handle to a NI DMM device created with the NIDMM_Initialize function.\n\n\n\n$MeasureRange\n\nDouble\n\nSpecifies the range for the function. For example, you must type in 100 Hz if you are measuring 101 Hz or higher. For all other functions, you must supply a range that exceeds the value that you are measuring. For example, you must type in 10 V if you are measuring 9 V. Range values are coerced up to the closest input range. Refer to the Devices Overview for a list of valid ranges.\n\n\n\n\n\nPossible options:\n\n\u00b7 -1: (On) NI-DMM performs an Auto Range before acquiring the measurement.\n\n\u00b7 -2: (Off) NI-DMM uses the current Auto Range value for all subsequent measurements until the measurement configuration is changed.\n\n\u00b7 -3: (Once) NI-DMM performs an Auto Range before acquiring the measurement. The Auto Range value is stored and used for all subsequent measurements until the measurement configuration is changed.\n\n\u00b7 Any other value.\n\n\n\n$Resolution\n\nDouble\n\nFor a noise-free DMM, resolution is the smallest change in an input signal that produces, on average, a change in the output signal.\n\n\n\n$MaxMeasTime\n\nInteger\n\nSpecifies the maximum time allowed for this function to complete in milliseconds.\n\n\n\n$PowerLineFrequency\n\nString\n\nSpecifies the powerline frequency. This value is used to select an aperture time to reject power line noise.\n\nPossible values:\n\n\u00b7 50 Hz\n\n\u00b7 60 Hz\n\n\n\n$AutoZeroMode\n\nString\n\nConfigures the DMM for Auto Zero. When Auto Zero is on, the DMM internally disconnects the input signal and takes a zero reading. It then subtracts the zero reading from the measurement. This prevents offset voltages present on the input circuitry of the DMM from affecting measurement accuracy. When Auto Zero is off, the DMM does not compensate for zero reading offset. ON enables Auto Zero for each measurement. ONCE enables Auto Zero before the next measurement. The Auto Zero value is stored and used in subsequent measurements until the device is reconfigured. OFF disables Auto Zero. If you set the Auto Zero mode to AUTO, NI-DMM determines whether to enable Auto Zero based on the measurement function that you configure.\n\n\n\n\n\nPossible values:\n\n\u00b7 Auto\n\n\u00b7 On\n\n\u00b7 Once\n\n\u00b7 Off\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Result\n\nFloat\n\nThe resulting value is returned as a float.\n\n\n\n\n\nExample:\n\nI applied a 10 ohm/25W series resistor (with a PSU = 5V). The current consumption should be 0,5A.\n\n\n\n\n\n$Result = NI_DMM_MeasureCurrentDC($Handle,1.0,1.0,50,\"50 Hz\",\"On\");\n\n\n\n\n\nNI_DMM_MeasureDiode\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_DMM_MeasureDiode": {
  "prefix": "NI_DMM_MeasureDiode",
  "body": [
   "$$Result=NI_DMM_MeasureDiode($$Handle,$$MeasureRange,$$Resolution,$$MaxMeasTime,$$PowerLineFrequency,$$AutoZeroMode,$$CurrentSource);"
  ],
  "description": "\n\nThis function requires NI-DMM 2.3 to be installed on the system.\n\nThis function completes the following tasks:\n\n\u00b7 Configures the common attributes of the measurement: the measure range, the maximum measure time, the resolution and the power line frequency.\n\n\u00b7 Configures the DMM for Auto Zero.\n\n\u00b7 After configuration, the function measures the voltage drop present on the DMM instrument using the handle $Handle created with NI_DMM_Initialize.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a National Instruments device NI PXI-4070.\n\n\u00b7 This function can be used for all National Instruments digital multimeter types (NI DMM devices).\n\n\n\nResult:\n\n$Result = NI_DMM_MeasureDiode($Handle, $MeasureRange, $Resolution, $MaxMeasTime, $PowerLineFrequency, $AutoZeroMode, $CurrentSource);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nA handle to a NI DMM device created with the NIDMM_Initialize function.\n\n\n\n$MeasureRange\n\nDouble\n\nSpecifies the range for the function. For example, you must type in 100 Hz if you are measuring 101 Hz or higher. For all other functions, you must supply a range that exceeds the value that you are measuring. For example, you must type in 10 V if you are measuring 9 V. Range values are coerced up to the closest input range. Refer to the Devices Overview for a list of valid ranges.\n\n\n\n\n\nPossible options:\n\n\u00b7 -1: (On) NI-DMM performs an Auto Range before acquiring the measurement.\n\n\u00b7 -2: (Off) NI-DMM uses the current Auto Range value for all subsequent measurements until the measurement configuration is changed.\n\n\u00b7 -3: (Once) NI-DMM performs an Auto Range before acquiring the measurement. The Auto Range value is stored and used for all subsequent measurements until the measurement configuration is changed.\n\n\u00b7 Any other value.\n\n\n\n$Resolution\n\nDouble\n\nFor a noise-free DMM, resolution is the smallest change in an input signal that produces, on average, a change in the output signal.\n\n\n\n$MaxMeasTime\n\nInteger\n\nSpecifies the maximum time allowed for this function to complete in milliseconds.\n\n\n\n$PowerLineFrequency\n\nString\n\nSpecifies the powerline frequency. This value is used to select an aperture time to reject power line noise.\n\nPossible values:\n\n\u00b7 50 Hz\n\n\u00b7 60 Hz\n\n\n\n$AutoZeroMode\n\nString\n\nConfigures the DMM for Auto Zero. When Auto Zero is on, the DMM internally disconnects the input signal and takes a zero reading. It then subtracts the zero reading from the measurement. This prevents offset voltages present on the input circuitry of the DMM from affecting measurement accuracy. When Auto Zero is off, the DMM does not compensate for zero reading offset. ON enables Auto Zero for each measurement. ONCE enables Auto Zero before the next measurement. The Auto Zero value is stored and used in subsequent measurements until the device is reconfigured. OFF disables Auto Zero. If you set the Auto Zero mode to AUTO, NI-DMM determines whether to enable Auto Zero based on the measurement function that you configure.\n\n\n\n\n\nPossible values:\n\n\u00b7 Auto\n\n\u00b7 On\n\n\u00b7 Once\n\n\u00b7 Off\n\n\n\n$CurrentSource\n\nString\n\nSpecifies the current source provided during diode measurements.\n\n\n\n\n\nPossible values:\n\n\u00b7 1 uA\n\n\u00b7 10 uA\n\n\u00b7 100 uA\n\n\u00b7 1 mA\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Result\n\nFloat\n\nThe resulting value is returned as a float.\n\n\n\n\n\nExample:\n\nI applied a diode 1N4002 to the NI DMM device.\n\n\n\n\n\n$Result = NI_DMM_MeasureDiode($Handle,1.0,1.0,50,\"50 Hz\",\"On\",\"1 mA\");\n\n\n\n\n\nNI_DMM_MeasureFrequency\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_DMM_MeasureFrequency": {
  "prefix": "NI_DMM_MeasureFrequency",
  "body": [
   "$$Result=NI_DMM_MeasureFrequency($$Handle,$$MeasureRange,$$Resolution,$$MaxMeasTime,$$VoltageRange);"
  ],
  "description": "\n\nThis function requires NI-DMM 2.3 to be installed on the system.\n\nThis function completes the following tasks:\n\n\u00b7 Configures the common attributes of the measurement: the measure range, the maximum measure time, the resolution and the power line frequency.\n\n\u00b7 After configuration, the function measures the frequency of the AC signal present on the DMM instrument using the handle $Handle created with NI_DMM_Initialize.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a National Instruments device NI PXI-4070.\n\n\u00b7 This function can be used for all National Instruments digital multimeter types (NI DMM devices).\n\n\n\nResult:\n\n$Result = NI_DMM_MeasureFrequency($Handle, $MeasureRange, $Resolution, $MaxMeasTime, $VoltageRange);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nA handle to a NI DMM device created with the NIDMM_Initialize function.\n\n\n\n$MeasureRange\n\nDouble\n\nSpecifies the range for the function. For example, you must type in 100 Hz if you are measuring 101 Hz or higher. For all other functions, you must supply a range that exceeds the value that you are measuring. For example, you must type in 10 V if you are measuring 9 V. Range values are coerced up to the closest input range. Refer to the Devices Overview for a list of valid ranges.\n\n\n\n\n\nPossible options:\n\n\u00b7 -1: (On) NI-DMM performs an Auto Range before acquiring the measurement.\n\n\u00b7 -2: (Off) NI-DMM uses the current Auto Range value for all subsequent measurements until the measurement configuration is changed.\n\n\u00b7 -3: (Once) NI-DMM performs an Auto Range before acquiring the measurement. The Auto Range value is stored and used for all subsequent measurements until the measurement configuration is changed.\n\n\u00b7 Any other value.\n\n\n\n$Resolution\n\nDouble\n\nFor a noise-free DMM, resolution is the smallest change in an input signal that produces, on average, a change in the output signal.\n\n\n\n$MaxMeasTime\n\nInteger\n\nSpecifies the maximum time allowed for this function to complete in milliseconds.\n\n\n\n$VoltageRange\n\n\n\nSets the expected maximum amplitude of the input signal.\n\n\n\n\n\nPossible values:\n\n\u00b7 -1: (On) Configures the DMM to take an Auto Range measurement to calculate the voltage range before each frequency or period measurement.\n\n\u00b7 -2: (Off) Disables Auto Ranging. The driver sets the voltage range to the last calculated voltage range.\n\n\u00b7 -3: (Once) NI-DMM performs an Auto Range before acquiring the measurement. The Auto Range value is stored and used for all subsequent measurements until the measurement configuration is changed.\n\n\u00b7 Any other value.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Result\n\nFloat\n\nThe resulting value is returned as a float.\n\n\n\n\n\nExample:\n\nI applied a AC voltage of 1.25V (1.25kHz) to the NI DMM device.\n\n\n\n\n\n$Result = NI_DMM_MeasureFrequency($Handle,1250,0.001,1000,2.0);\n\n\n\n\n\nNI_DMM_MeasurePeriod\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_DMM_MeasurePeriod": {
  "prefix": "NI_DMM_MeasurePeriod",
  "body": [
   "$$Result=NI_DMM_MeasurePeriod($$Handle,$$MeasureRange,$$Resolution,$$MaxMeasTime,$$VoltageRange);"
  ],
  "description": "\n\nThis function requires NI-DMM 2.3 to be installed on the system.\n\nThis function completes the following tasks:\n\n\u00b7 Configures the common attributes of the measurement: the measure range, the maximum measure time, the resolution and the power line frequency.\n\n\u00b7 After configuration, the function measures the period of the AC signal present on the DMM instrument using the handle $Handle created with NI_DMM_Initialize.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a National Instruments device NI PXI-4070.\n\n\u00b7 This function can be used for all National Instruments digital multimeter types (NI DMM devices).\n\n\n\nResult:\n\n$Result = NI_DMM_MeasurePeriod($Handle, $MeasureRange, $Resolution, $MaxMeasTime, $VoltageRange);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nA handle to a NI DMM device created with the NIDMM_Initialize function.\n\n\n\n$MeasureRange\n\nDouble\n\nSpecifies the range for the function. For example, you must type in 100 Hz if you are measuring 101 Hz or higher. For all other functions, you must supply a range that exceeds the value that you are measuring. For example, you must type in 10 V if you are measuring 9 V. Range values are coerced up to the closest input range. Refer to the Devices Overview for a list of valid ranges.\n\n\n\n\n\nPossible options:\n\n\u00b7 -1: (On) NI-DMM performs an Auto Range before acquiring the measurement.\n\n\u00b7 -2: (Off) NI-DMM uses the current Auto Range value for all subsequent measurements until the measurement configuration is changed.\n\n\u00b7 -3: (Once) NI-DMM performs an Auto Range before acquiring the measurement. The Auto Range value is stored and used for all subsequent measurements until the measurement configuration is changed.\n\n\u00b7 Any other value.\n\n\n\n$Resolution\n\nDouble\n\nFor a noise-free DMM, resolution is the smallest change in an input signal that produces, on average, a change in the output signal.\n\n\n\n$MaxMeasTime\n\nInteger\n\nSpecifies the maximum time allowed for this function to complete in milliseconds.\n\n\n\n$VoltageRange\n\n\n\nSets the expected maximum amplitude of the input signal.\n\n\n\n\n\nPossible values:\n\n\u00b7 -1: (On) Configures the DMM to take an Auto Range measurement to calculate the voltage range before each frequency or period measurement.\n\n\u00b7 -2: (Off) Disables Auto Ranging. The driver sets the voltage range to the last calculated voltage range.\n\n\u00b7 -3: (Once) NI-DMM performs an Auto Range before acquiring the measurement. The Auto Range value is stored and used for all subsequent measurements until the measurement configuration is changed.\n\n\u00b7 Any other value.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Result\n\nFloat\n\nThe resulting value is returned as a float.\n\n\n\n\n\nExample:\n\nI applied a AC voltage of 1.25V (1.25kHz) to the NI DMM device.\n\n\n\n\n\n$Result = NIDMM.MeasurePeriod($Handle,0.0008,0.001,1000,2.0);\n\n\n\n\n\nNI_DMM_MeasureVoltageAC\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NIDMM_MeasureVoltageAC": {
  "prefix": "NIDMM_MeasureVoltageAC",
  "body": [
   "$$Result=NIDMM_MeasureVoltageAC($$Handle,$$MeasureRange,$$Resolution,$$MaxMeasTime,$$PowerLineFrequency,$$MinBandWidth,$$MaxBandWidth,$$AutoZeroMode);"
  ],
  "description": "\n\nThis function requires NI-DMM 2.3 to be installed on the system.\n\nThis function completes the following tasks:\n\n\u00b7 Configures the common attributes of the measurement: the measure range, the maximum measure time, the resolution and the power line frequency.\n\n\u00b7 Configures the DMM for Auto Zero.\n\n\u00b7 After configuration, the function measures the AC voltage present on the DMM instrument using the handle $Handle created with NIDMM.Initialize.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a National Instruments device NI PXI-4070.\n\n\u00b7 This function can be used for all National Instruments digital multimeter types (NI DMM devices).\n\n\n\nResult:\n\n$Result = NIDMM_MeasureVoltageAC($Handle, $MeasureRange, $Resolution, $MaxMeasTime, $PowerLineFrequency, $MinBandWidth, $MaxBandWidth, $AutoZeroMode);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nA handle to a NI DMM device created with the NIDMM_Initialize function.\n\n\n\n$MeasureRange\n\nDouble\n\nSpecifies the range for the function. For example, you must type in 100 Hz if you are measuring 101 Hz or higher. For all other functions, you must supply a range that exceeds the value that you are measuring. For example, you must type in 10 V if you are measuring 9 V. Range values are coerced up to the closest input range. Refer to the Devices Overview for a list of valid ranges.\n\n\n\n\n\nPossible options:\n\n\u00b7 -1: (On) NI-DMM performs an Auto Range before acquiring the measurement.\n\n\u00b7 -2: (Off) NI-DMM uses the current Auto Range value for all subsequent measurements until the measurement configuration is changed.\n\n\u00b7 -3: (Once) NI-DMM performs an Auto Range before acquiring the measurement. The Auto Range value is stored and used for all subsequent measurements until the measurement configuration is changed.\n\n\u00b7 Any other value.\n\n\n\n$Resolution\n\nDouble\n\nFor a noise-free DMM, resolution is the smallest change in an input signal that produces, on average, a change in the output signal.\n\n\n\n$MaxMeasTime\n\nInteger\n\nSpecifies the maximum time allowed for this function to complete in milliseconds.\n\n\n\n$PowerLineFrequency\n\nString\n\nSpecifies the powerline frequency. This value is used to select an aperture time to reject power line noise.\n\nPossible values:\n\n\u00b7 50 Hz\n\n\u00b7 60 Hz\n\n\n\n$MinBandWidth\n\nDouble\n\nMin Frequency specifies the minimum expected frequency component of the input signal in Hz.\n\n\n\n$MaxBandWidth\n\nDouble\n\nMax Frequency specifies the maximum expected frequency component of the input signal in Hz within the device\n\n\n\n$AutoZeroMode\n\nString\n\nConfigures the DMM for Auto Zero. When Auto Zero is on, the DMM internally disconnects the input signal and takes a zero reading. It then subtracts the zero reading from the measurement. This prevents offset voltages present on the input circuitry of the DMM from affecting measurement accuracy. When Auto Zero is off, the DMM does not compensate for zero reading offset. ON enables Auto Zero for each measurement. ONCE enables Auto Zero before the next measurement. The Auto Zero value is stored and used in subsequent measurements until the device is reconfigured. OFF disables Auto Zero. If you set the Auto Zero mode to AUTO, NI-DMM determines whether to enable Auto Zero based on the measurement function that you configure.\n\n\n\n\n\nPossible values:\n\n\u00b7 Auto\n\n\u00b7 On\n\n\u00b7 Once\n\n\u00b7 Off\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Result\n\nFloat\n\nThe resulting value is returned as a float.\n\n\n\n\n\nExample:\n\nI applied a AC voltage of 1.25V (1.25kHz) to the NI DMM device.\n\n\n\n\n\n$Result = NI_DMM_MeasureVoltageAC($Handle,-1.0,0.001,2000,\"50 Hz\",\"750\",\"1250\",\"Auto\");\n\n\n\n\n\nNI_DMM_MeasureVoltageAC\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_DMM_Measure_VoltageAC_DC_Coupled": {
  "prefix": "NI_DMM_Measure_VoltageAC_DC_Coupled",
  "body": [
   "$$Result=NI_DMM_Measure_VoltageAC_DC_Coupled($$Handle,$$MeasureRange,$$Resolution,$$MaxMeasTime,$$PowerLineFrequency,$$MinBandWidth,$$MaxBandWidth,$$AutoZeroMode);"
  ],
  "description": "\n\nThis function requires NI-DMM 2.3 to be installed on the system.\n\nThis function completes the following tasks:\n\n\u00b7 Configures the common attributes of the measurement: the measure range, the maximum measure time, the resolution and the power line frequency.\n\n\u00b7 Configures the DMM for Auto Zero.\n\n\u00b7 After configuration, the function measures the AC voltage present on the DMM instrument using the handle $Handle created with NIDMM.Initialize.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a National Instruments device NI PXI-4070.\n\n\u00b7 This function can be used for all National Instruments digital multimeter types (NI DMM devices).\n\n\n\nResult:\n\n$Result = NI_DMM_Measure_VoltageAC_DC_Coupled($Handle, $MeasureRange, $Resolution, $MaxMeasTime, $PowerLineFrequency, $MinBandWidth, $MaxBandWidth, $AutoZeroMode);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nA handle to a NI DMM device created with the NIDMM_Initialize function.\n\n\n\n$MeasureRange\n\nDouble\n\nSpecifies the range for the function. For example, you must type in 100 Hz if you are measuring 101 Hz or higher. For all other functions, you must supply a range that exceeds the value that you are measuring. For example, you must type in 10 V if you are measuring 9 V. Range values are coerced up to the closest input range. Refer to the Devices Overview for a list of valid ranges.\n\n\n\n\n\nPossible options:\n\n\u00b7 -1: (On) NI-DMM performs an Auto Range before acquiring the measurement.\n\n\u00b7 -2: (Off) NI-DMM uses the current Auto Range value for all subsequent measurements until the measurement configuration is changed.\n\n\u00b7 -3: (Once) NI-DMM performs an Auto Range before acquiring the measurement. The Auto Range value is stored and used for all subsequent measurements until the measurement configuration is changed.\n\n\u00b7 Any other value.\n\n\n\n$Resolution\n\nDouble\n\nFor a noise-free DMM, resolution is the smallest change in an input signal that produces, on average, a change in the output signal.\n\n\n\n$MaxMeasTime\n\nInteger\n\nSpecifies the maximum time allowed for this function to complete in milliseconds.\n\n\n\n$PowerLineFrequency\n\nString\n\nSpecifies the powerline frequency. This value is used to select an aperture time to reject power line noise.\n\nPossible values:\n\n\u00b7 50 Hz\n\n\u00b7 60 Hz\n\n\n\n$MinBandWidth\n\nDouble\n\nMin Frequency specifies the minimum expected frequency component of the input signal in Hz.\n\n\n\n$MaxBandWidth\n\nDouble\n\nMax Frequency specifies the maximum expected frequency component of the input signal in Hz within the device\n\n\n\n$AutoZeroMode\n\nString\n\nConfigures the DMM for Auto Zero. When Auto Zero is on, the DMM internally disconnects the input signal and takes a zero reading. It then subtracts the zero reading from the measurement. This prevents offset voltages present on the input circuitry of the DMM from affecting measurement accuracy. When Auto Zero is off, the DMM does not compensate for zero reading offset. ON enables Auto Zero for each measurement. ONCE enables Auto Zero before the next measurement. The Auto Zero value is stored and used in subsequent measurements until the device is reconfigured. OFF disables Auto Zero. If you set the Auto Zero mode to AUTO, NI-DMM determines whether to enable Auto Zero based on the measurement function that you configure.\n\n\n\n\n\nPossible values:\n\n\u00b7 Auto\n\n\u00b7 On\n\n\u00b7 Once\n\n\u00b7 Off\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Result\n\nFloat\n\nThe resulting value is returned as a float.\n\n\n\n\n\nExample:\n\nI applied a AC voltage of 1.25V on a DC level of 2V to the NI DMM device.\n\n\n\n\n\n$Result = NI_DMM_Measure_VoltageAC_DC_Coupled($Handle,1.0,0.001,1200,\"50 Hz\",\"750\",\"1000\",\"Auto\");\n\n\n\n\n\nNI_DMM_MeasureVoltageDC\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NIDMM_MeasureVoltageDC": {
  "prefix": "NIDMM_MeasureVoltageDC",
  "body": [
   "$$Result=NIDMM_MeasureVoltageDC($$Handle,$$MeasureRange,$$Resolution,$$MaxMeasTime,$$PowerLineFrequency,$$AutoZeroMode);"
  ],
  "description": "\n\nThis function requires NI-DMM 2.3 to be installed on the system.\n\nThis function completes the following tasks:\n\n\u00b7 Configures the common attributes of the measurement: the measure range, the maximum measure time, the resolution and the power line frequency.\n\n\u00b7 Configures the DMM for Auto Zero.\n\n\u00b7 After configuration, the function measures the DC voltage present on the DMM instrument using the handle $Handle created with NI_DMM_Initialize.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a National Instruments device NI PXI-4070.\n\n\u00b7 This function can be used for all National Instruments digital multimeter types (NI DMM devices).\n\n\n\nResult:\n\n$Result = NIDMM_MeasureVoltageDC($Handle, $MeasureRange, $Resolution, $MaxMeasTime, $PowerLineFrequency, $AutoZeroMode);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nA handle to a NI DMM device created with the NIDMM_Initialize function.\n\n\n\n$MeasureRange\n\nDouble\n\nSpecifies the range for the function. For example, you must type in 100 Hz if you are measuring 101 Hz or higher. For all other functions, you must supply a range that exceeds the value that you are measuring. For example, you must type in 10 V if you are measuring 9 V. Range values are coerced up to the closest input range. Refer to the Devices Overview for a list of valid ranges.\n\n\n\n\n\nPossible options:\n\n\u00b7 -1: (On) NI-DMM performs an Auto Range before acquiring the measurement.\n\n\u00b7 -2: (Off) NI-DMM uses the current Auto Range value for all subsequent measurements until the measurement configuration is changed.\n\n\u00b7 -3: (Once) NI-DMM performs an Auto Range before acquiring the measurement. The Auto Range value is stored and used for all subsequent measurements until the measurement configuration is changed.\n\n\u00b7 Any other value.\n\n\n\n$Resolution\n\nDouble\n\nFor a noise-free DMM, resolution is the smallest change in an input signal that produces, on average, a change in the output signal.\n\n\n\n$MaxMeasTime\n\nInteger\n\nSpecifies the maximum time allowed for this function to complete in milliseconds.\n\n\n\n$PowerLineFrequency\n\nString\n\nSpecifies the powerline frequency. This value is used to select an aperture time to reject power line noise.\n\nPossible values:\n\n\u00b7 50 Hz\n\n\u00b7 60 Hz\n\n\n\n$AutoZeroMode\n\nString\n\nConfigures the DMM for Auto Zero. When Auto Zero is on, the DMM internally disconnects the input signal and takes a zero reading. It then subtracts the zero reading from the measurement. This prevents offset voltages present on the input circuitry of the DMM from affecting measurement accuracy. When Auto Zero is off, the DMM does not compensate for zero reading offset. ON enables Auto Zero for each measurement. ONCE enables Auto Zero before the next measurement. The Auto Zero value is stored and used in subsequent measurements until the device is reconfigured. OFF disables Auto Zero. If you set the Auto Zero mode to AUTO, NI-DMM determines whether to enable Auto Zero based on the measurement function that you configure.\n\n\n\n\n\nPossible values:\n\n\u00b7 Auto\n\n\u00b7 On\n\n\u00b7 Once\n\n\u00b7 Off\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Result\n\nFloat\n\nThe resulting value is returned as a float.\n\n\n\n\n\nExample:\n\nI applied a DC voltage of 5V to the NI DMM device.\n\n\n\n\n\n$Result = NI_DMM_MeasureVoltageDC($Handle,5.0,1.0,50,\"50 Hz\",\"On\");\n\n\n\n\n\nNI_DMM_SetACBandwidth\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_DMM_SetACBandwidth": {
  "prefix": "NI_DMM_SetACBandwidth",
  "body": [
   "NI_DMM_SetACBandwidth($$Handle,$$MinimumFrequency,$$MaximumFrequency);"
  ],
  "description": "\n\nThis function requires NI-DMM 2.3 to be installed on the system.\n\nThis function sets the AC Bandwidth of the DMM.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a National Instruments device NI PCI-4060.\n\n\u00b7 This function can be used for all National Instruments digital multimeter types (NI DMM devices).\n\n\n\nResult:\n\nNI_DMM_SetACBandwidth($Handle, $MinimumFrequency,$MaximumFrequency);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nA handle to a NI DMM device created with the NIDMM_Initialize function.\n\n\n\n$MinimumFrequency\n\nFloat\n\nMinimum frequency\n\n\n\n$MaximumFrequency\n\nFloat\n\nMaximum frequency\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n\n\nExample:\n\nNI_DMM_SetACBandwidth($Handle,100.0,1000.0);\n\n\n\n\n\nNI_DMM_SetAutoZeroMode\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_DMM_SetAutoZeroMode": {
  "prefix": "NI_DMM_SetAutoZeroMode",
  "body": [
   "NI_DMM_SetAutoZeroMode($$Handle,$$Mode);"
  ],
  "description": "\n\nThis function requires NI-DMM 2.3 to be installed on the system.\n\nThis function sets the Auto Zero Mode of the DMM.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a National Instruments device NI PCI-4060.\n\n\u00b7 This function can be used for all National Instruments digital multimeter types (NI DMM devices).\n\n\n\nResult:\n\nNI_DMM_SetAutoZeroMode($Handle,$Mode);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nA handle to a NI DMM device created with the NIDMM_Initialize function.\n\n\n\n$AutoZeroMode\n\nString\n\nConfigures the DMM for Auto Zero. When Auto Zero is on, the DMM internally disconnects the input signal and takes a zero reading. It then subtracts the zero reading from the measurement. This prevents offset voltages present on the input circuitry of the DMM from affecting measurement accuracy. When Auto Zero is off, the DMM does not compensate for zero reading offset. ON enables Auto Zero for each measurement. ONCE enables Auto Zero before the next measurement. The Auto Zero value is stored and used in subsequent measurements until the device is reconfigured. OFF disables Auto Zero. If you set the Auto Zero mode to AUTO, NI-DMM determines whether to enable Auto Zero based on the measurement function that you configure.\n\n\n\nPossible values:\n\n\u00b7 Auto\n\n\u00b7 On\n\n\u00b7 Once\n\n\u00b7 Off\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n\n\nExample:\n\nNI_DMM_SetAutoZeroMode($Handle,\"Off\");\n\n\n\n\n\nNI_DMM_SetBooleanAttribute\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_DMM_SetBooleanAttribute": {
  "prefix": "NI_DMM_SetBooleanAttribute",
  "body": [
   "$$Result=NI_DMM_SetBooleanAttribute($$Handle,$$AttributeIdentifier,$$AttributeValue);"
  ],
  "description": "\n\nThis function requires NI-DMM 2.3 to be installed on the system.\n\nThis function sets the value of a boolean attribute.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a National Instruments device NI PXI-4070.\n\n\u00b7 This function can be used for all National Instruments digital multimeter types (NI DMM devices).\n\n\n\nResult:\n\n$Result = NI_DMM_SetBooleanAttribute($Handle, $AttributeIdentifier, $AttributeValue);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nA handle to a NI DMM device created with the NIDMM_Initialize function.\n\n\n\n$AttributeIdentifier\n\nString\n\nPass the ID of an attribute.\n\nPossible values:\n\n\u00b7 CACHE\n\n\u00b7 INTERCHANGE CHECK\n\n\u00b7 QUERY INSTRUMENT STATUS\n\n\u00b7 RANGE CHECK\n\n\u00b7 RECORD COERCIONS\n\n\u00b7 SIMULATE\n\n\n\n$AttributeValue\n\nBoolean\n\nPass the value that you want to set the attribute to.\n\nPossible values:\n\n\u00b7 true\n\n\u00b7 false\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Result\n\nBoolean\n\nThe value of the attribute identifier.\n\n\n\n\n\nExample:\n\n$Value = NI_DMM_SetBooleanAttribute($Handle, \"RANGE CHECK\", \"false\");\n\n\n\n\n\nNI_DMM_SetDoubleAttribute\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_DMM_SetDoubleAttribute": {
  "prefix": "NI_DMM_SetDoubleAttribute",
  "body": [
   "NI_DMM_SetDoubleAttribute($$Handle,$$AttributeIdentifier,$$AttributeValue);"
  ],
  "description": "\n\nThis function requires NI-DMM 2.3 to be installed on the system.\n\nThis function gets the value of a double attribute.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a National Instruments device NI PXI-4070.\n\n\u00b7 This function can be used for all National Instruments digital multimeter types (NI DMM devices).\n\n\n\nResult:\n\nNI_DMM_SetDoubleAttribute($Handle, $AttributeIdentifier, $AttributeValue);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nA handle to a NI DMM device created with the NIDMM_Initialize function.\n\n\n\n$AttributeIdentifier\n\nString\n\nPass the ID of an attribute.\n\nPossible values:\n\n\u00b7 RANGE\n\n\u00b7 RESOLUTION DIGITS\n\n\u00b7 RESOLUTION ABSOLUTE\n\n\u00b7 AC MAX FREQUENCY\n\n\u00b7 AC MIN FREQUENCY\n\n\u00b7 CURRENT SOURCE\n\n\u00b7 FREQUENCY VOLTAGE RANGE\n\n\u00b7 INPUT RESISTANCE\n\n\u00b7 POWERLINE FREQUENCY\n\n\u00b7 SHUNT VALUE\n\n\u00b7 TRIGGER DELAY\n\n\u00b7 SAMPLE INTERVAL\n\n\u00b7 APERTURE TIME\n\n\u00b7 SETTLE TIME\n\n\u00b7 WAVEFORM RATE\n\n\n\n$AttributeValue\n\nFloat\n\nPass the value that you want to set the attribute to.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n\n\nExample:\n\n$Value = NI_DMM_SetDoubleAttribute($Handle, \"RESOLUTION DIGITS\", 5.5);\n\n\n\n\n\nNI_DMM_SetIntegerAttribute\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_DMM_SetIntegerAttribute": {
  "prefix": "NI_DMM_SetIntegerAttribute",
  "body": [
   "NI_DMM_SetIntegerAttribute($$Handle,$$AttributeIdentifier,$$AttributeValue);"
  ],
  "description": "\n\nThis function requires NI-DMM 2.3 to be installed on the system.\n\nThis function gets the value of an integer attribute.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a National Instruments device NI PXI-4070.\n\n\u00b7 This function can be used for all National Instruments digital multimeter types (NI DMM devices).\n\n\n\nResult:\n\nNI_DMM_SetIntegerAttribute($Handle, $AttributeIdentifier, $AttributeValue);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nA handle to a NI DMM device created with the NIDMM_Initialize function.\n\n\n\n$AttributeIdentifier\n\nString\n\nPass the ID of an attribute.\n\nPossible values:\n\n\u00b7 FUNCTION\n\n\u00b7 ADC CALIBRATION\n\n\u00b7 AUTO ZERO\n\n\u00b7 DC NOISE REJECTION\n\n\u00b7 OFFSET COMPENSATED OHMS\n\n\u00b7 MEASUREMENT COMPLETE DESTINATION\n\n\u00b7 MEASUREMENT DESTINATION SLOPE\n\n\u00b7 TRIGGER SLOPE\n\n\u00b7 TRIGGER SOURCE\n\n\u00b7 BUFFER SIZE\n\n\u00b7 LATENCY\n\n\u00b7 SAMPLE COUNT\n\n\u00b7 SAMPLE DELAY MODE\n\n\u00b7 SAMPLE TRIGGER\n\n\u00b7 SAMPLE TRIGGER SLOPE\n\n\u00b7 TRIGGER COUNT\n\n\u00b7 APERTURE TIME UNITS\n\n\u00b7 NUMBER OF AVERAGES\n\n\u00b7 OPERATION MODE\n\n\u00b7 WAVEFORM COUPLING\n\n\u00b7 WAVEFORM POINTS\n\n\n\n$AttributeValue\n\nInteger\n\nPass the value that you want to set the attribute to.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Result\n\nBoolean\n\nThe value of the attribute identifier.\n\n\n\n\n\nExample:\n\n$Value = NI_DMM_SetIntegerAttribute($Handle, \"SAMPLE COUNT\", 100);\n\n\n\n\n\nNI_DMM_SetPowerLineFrequency\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_DMM_SetPowerLineFrequency": {
  "prefix": "NI_DMM_SetPowerLineFrequency",
  "body": [
   "NI_DMM_SetPowerLineFrequency($$Handle,$$PowerLineFrequency);"
  ],
  "description": "\n\nThis function requires NI-DMM 2.3 to be installed on the system.\n\nThis function sets the power line frequency of the DMM.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a National Instruments device NI PCI-4060.\n\n\u00b7 This function can be used for all National Instruments digital multimeter types (NI DMM devices).\n\n\n\nResult:\n\nNI_DMM_SetPowerLineFrequency($Handle, $PowerLineFrequency);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nA handle to a NI DMM device created with the NIDMM_Initialize function.\n\n\n\n$PowerLineFrequency\n\nString\n\nSpecifies the powerline frequency. This value is used to select an aperture time to reject power line noise.\n\nPossible values:\n\n\u00b7 50 Hz\n\n\u00b7 60 Hz\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n\n\nExample:\n\nNI_DMM_SetPowerLineFrequency($Handle,\"60 Hz\");\n\n\n\n\n\nSCXI1124DCOut\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS TDRIVE_ApplyProfileName": {
  "prefix": "TDRIVE_ApplyProfileName",
  "body": [
   "TDRIVE_ApplyProfileName($$Handle,$$ProfileName);Note:ThisfunctionsupportstheTDRIVETFTSignalGeneratorFromWestarDisplayTechnologies.Formoreinformation,seetheuser'smanualprovidedwiththeinstrument."
  ],
  "description": "\n\nThe ApplyProfileNumber function applies a profile already stored in T-Drive with the name specified by the second argument to the function. If the profile is loaded successfully, a PASS is returned to the executive, otherwise an explanation of the failure is displayed, and a failure is returned to the executive.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nAn object pointing to the TDRIVE instrument handle in memory.\n\n\n\n$ProfileName\n\nString\n\nThe name of the profile to be loaded.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nTDRIVE_ApplyProfileNumber\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS TDRIVE_ApplyProfileNumber": {
  "prefix": "TDRIVE_ApplyProfileNumber",
  "body": [
   "TDRIVE_ApplyProfileNumber($$Handle,$$ProfileNumber);Note:ThisfunctionsupportstheTDRIVETFTSignalGeneratorFromWestarDisplayTechnologies.Formoreinformation,seetheuser'smanualprovidedwiththeinstrument."
  ],
  "description": "\n\nThe ApplyProfileNumber function applies a profile already stored in T-Drive with the number specified by the second argument to the function. If the profile is loaded successfully, a PASS is returned to the executive, otherwise an explanation of the failure is displayed, and a failure is returned to the executive.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nAn object pointing to the TDRIVE instrument handle in memory.\n\n\n\n$ProfileNumber\n\nInteger\n\nThe number of the profile to be loaded.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nTDRIVE_BacklightBrightness\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS TDRIVE_BacklightBrightness": {
  "prefix": "TDRIVE_BacklightBrightness",
  "body": [
   "TDRIVE_BacklightBrightness($$Handle,$$Brightness);Note:ThisfunctionsupportstheTDRIVETFTSignalGeneratorFromWestarDisplayTechnologies.Formoreinformation,seetheuser'smanualprovidedwiththeinstrument."
  ],
  "description": "\n\nThe TDRIVE_BacklightBrightness function sets the brightness of a baclight to a percentage of the backlight's brightness range. The method of control for the backlight is specified in the DUT profile and can be voltage controlled, resistive controlled, or I2C controlled. FOr example, if the backlight is voltage controlled and can go from 0 to 5V, 50% is 2.5V.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nAn object pointing to the TDRIVE instrument handle in memory.\n\n\n\n$Brightness\n\nInteger\n\nThe brightness to set the TFT backlight in percent. Allowable values are 0 to 100.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nTDRIVE_BacklightPower\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS TDRIVE_BacklightPower": {
  "prefix": "TDRIVE_BacklightPower",
  "body": [
   "TDRIVE_BacklightPower($$Handle,$$PowerState);Note:ThisfunctionsupportstheTDRIVETFTSignalGeneratorFromWestarDisplayTechnologies.Formoreinformation,seetheuser'smanualprovidedwiththeinstrument."
  ],
  "description": "\n\nThe TDRIVE_BacklightPower function powers a backlight on or off according to the backlight settings in the DUT profile.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nAn object pointing to the TDRIVE instrument handle in memory.\n\n\n\n$PowerState\n\nString\n\nSets the TFT Power state.\n\nValid values are:\n\n\u00b7 \"ON\"\n\n\u00b7 \"OFF\"\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nTDRIVE_Bitmap\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS TDRIVE_Bitmap": {
  "prefix": "TDRIVE_Bitmap",
  "body": [
   "TDRIVE_Bitmap($$Handle,$$BitmapName);Note:ThisfunctionsupportstheTDRIVETFTSignalGeneratorFromWestarDisplayTechnologies.Formoreinformation,seetheuser'smanualprovidedwiththeinstrument."
  ],
  "description": "\n\nThe TDRIVE_Bitmap function is used to display a bitmap on the attached display device. The bitmap is accessed via name, and must be loaded unto the TDRIVE prior to calling this function. The Bitmap must be properly sized to the display, otherwise an error will be generated.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nAn object pointing to the TDRIVE instrument handle in memory.\n\n\n\n$BitmapName\n\nString\n\nThe name of the bitmap to display.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nTDRIVE_Blink\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS TDRIVE_Blink": {
  "prefix": "TDRIVE_Blink",
  "body": [
   "TDRIVE_Blink($$Handle,$$Red1,$$Green1,$$Blue1,$$Red2,$$Green2,$$Blue2,$$EvenFrames,$$OddFrames);Note:ThisfunctionsupportstheTDRIVETFTSignalGeneratorFromWestarDisplayTechnologies.Formoreinformation,seetheuser'smanualprovidedwiththeinstrument."
  ],
  "description": "\n\nThe TDRIVE_Blink function causes the display to alternate between two colors. The color and number of frames it displays for each color can be specified.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nAn object pointing to the TDRIVE instrument handle in memory.\n\n\n\n$Red1\n\nInteger\n\nSets the intensity value of the color component for the even frames. Valid values are 0-255.\n\n\n\n$Green1\n\nInteger\n\nSets the intensity value of the color component for the even frames. Valid values are 0-255.\n\n\n\n$Blue1\n\nInteger\n\nSets the intensity value of the color component for the even frames. Valid values are 0-255.\n\n\n\n$Red2\n\nInteger\n\nSets the intensity value of the color component for the odd frames. Valid values are 0-255.\n\n\n\n$Green2\n\nInteger\n\nSets the intensity value of the color component for the odd frames. Valid values are 0-255.\n\n\n\n$Blue2\n\nInteger\n\nSets the intensity value of the color component for the odd frames. Valid values are 0-255.\n\n\n\n$EvenFrames\n\nInteger\n\nSpecifies the number of frames that the even color is displayed.\n\n\n\n$OddFrames\n\nInteger\n\nSpecifies the number of frames that the odd color is displayed.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nTDRIVE_Border\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS TDRIVE_Border": {
  "prefix": "TDRIVE_Border",
  "body": [
   "TDRIVE_Border($$Handle,$$Red1,$$Green1,$$Blue1,$$Red2,$$Green2,$$Blue2);Note:ThisfunctionsupportstheTDRIVETFTSignalGeneratorFromWestarDisplayTechnologies.Formoreinformation,seetheuser'smanualprovidedwiththeinstrument."
  ],
  "description": "\n\nThe TDRIVE_Border function draws a static boarder on the display. The color of the border and background can be specified.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nAn object pointing to the TDRIVE instrument handle in memory.\n\n\n\n$Red1\n\nInteger\n\nSets the intensity value of the color component for the border. Valid values are 0-255.\n\n\n\n$Green1\n\nInteger\n\nSets the intensity value of the color component for the border. Valid values are 0-255.\n\n\n\n$Blue1\n\nInteger\n\nSets the intensity value of the color component for the border. Valid values are 0-255.\n\n\n\n$Red2\n\nInteger\n\nSets the intensity value of the color component for the background. Valid values are 0-255.\n\n\n\n$Green2\n\nInteger\n\nSets the intensity value of the color component for the background. Valid values are 0-255.\n\n\n\n$Blue2\n\nInteger\n\nSets the intensity value of the color component for the background. Valid values are 0-255.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nTDRIVE_Checkerboard\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS TDRIVE_Checkerboard": {
  "prefix": "TDRIVE_Checkerboard",
  "body": [
   "TDRIVE_Checkerboard($$Handle,$$Red1,$$Green1,$$Blue1,$$Red2,$$Green2,$$Blue2,$$Width,$$Height);Note:ThisfunctionsupportstheTDRIVETFTSignalGeneratorFromWestarDisplayTechnologies.Formoreinformation,seetheuser'smanualprovidedwiththeinstrument."
  ],
  "description": "\n\nThe TDRIVE_Checkerboard function draws a checkboard on the display. The colors, height, and width of the secions can be specified.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nAn object pointing to the TDRIVE instrument handle in memory.\n\n\n\n$Red1\n\nInteger\n\nSets the intensity value of the color component for the even sections. Valid values are 0-255.\n\n\n\n$Green1\n\nInteger\n\nSets the intensity value of the color component for the even sections. Valid values are 0-255.\n\n\n\n$Blue1\n\nInteger\n\nSets the intensity value of the color component for the even sections. Valid values are 0-255.\n\n\n\n$Red2\n\nInteger\n\nSets the intensity value of the color component for the odd sections. Valid values are 0-255.\n\n\n\n$Green2\n\nInteger\n\nSets the intensity value of the color component for the odd sections. Valid values are 0-255.\n\n\n\n$Blue2\n\nInteger\n\nSets the intensity value of the color component for the odd sections. Valid values are 0-255.\n\n\n\n$Width\n\nInteger\n\nSpecifies the width of the sections. Limited to value 1 or 2.\n\n\n\n$Height\n\nInteger\n\nSpecifies the height of the sections. Limit to value 1 or 2.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nTDRIVE_Close\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS TDRIVE_Close": {
  "prefix": "TDRIVE_Close",
  "body": [
   "TDRIVE_Close($$Handle);Note:ThisfunctionsupportstheTDRIVETFTSignalGeneratorFromWestarDisplayTechnologies.Formoreinformation,seetheuser'smanualprovidedwiththeinstrument."
  ],
  "description": "\n\nCloses the TDRIVE Signal Generator via USB. This function generates a failure if the instrument can't be close, otherwise a PASS is generated and the instrument handle is freed from memory.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nAn object pointing to the TDRIVE instrument handle in memory.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nTDRIVE_DUTPower\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS TDRIVE_DUTPower": {
  "prefix": "TDRIVE_DUTPower",
  "body": [
   "TDRIVE_DUTPower($$Handle,$$PowerState,$$State);Note:ThisfunctionsupportstheTDRIVETFTSignalGeneratorFromWestarDisplayTechnologies.Formoreinformation,seetheuser'smanualprovidedwiththeinstrument."
  ],
  "description": "\n\nThe TDRIVE_DUTPower function powers a TFT module on or off. The TFT can be powered up in the state the T-Drive was last in, or the default state. The $PowerState argument specifies whether the TFT is to be powered up or down. The $State argument specifies which state the T-Drive will be in once the TFT is powered up. \"DEFAULT\" specifies the default state, in which the TFT is powered up with the first pattern of the default pattern list visible at maximum backflight brightness. If powered in the the last state, the T-Drive maintains the previous pattern list, test pattern, test pattern settings, and backlight brightness.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nAn object pointing to the TDRIVE instrument handle in memory.\n\n\n\n$PowerState\n\nString\n\nSets the TFT Power state.\n\nValid values are:\n\n\u00b7 \"ON\"\n\n\u00b7 \"OFF\"\n\n\n\n$State\n\nString\n\nSets the default state to which the TFT is powered up.\n\nValid values are:\n\n\u00b7 \"DEFAULT\"\n\n\u00b7 \"LAST\"\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nTDRIVE_Discrete\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS TDRIVE_Discrete": {
  "prefix": "TDRIVE_Discrete",
  "body": [
   "TDRIVE_Discrete($$Handle,$$Discrete,$$Setting);Note:ThisfunctionsupportstheTDRIVETFTSignalGeneratorFromWestarDisplayTechnologies.Formoreinformation,seetheuser'smanualprovidedwiththeinstrument."
  ],
  "description": "\n\nThe Discrete function sets or clears a discrete of the specified bit mask.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nAn object pointing to the TDRIVE instrument handle in memory.\n\n\n\n$Discrete\n\nInteger\n\nThe discrete line to Toggle, Allowed values are (1,2,3,4,5,6,7,8)\n\n\n\n$Setting\n\nString\n\nThe Setting For the Discrete Line. Allowed values are:\n\n\u00b7 \"ON\"\n\n\u00b7 \"OFF\"\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nTDRIVE_FloodField\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS TDRIVE_FloodField": {
  "prefix": "TDRIVE_FloodField",
  "body": [
   "TDRIVE_FloodField($$Handle,$$Red,$$Green,$$Blue);Note:ThisfunctionsupportstheTDRIVETFTSignalGeneratorFromWestarDisplayTechnologies.Formoreinformation,seetheuser'smanualprovidedwiththeinstrument."
  ],
  "description": "\n\nThe TDRIVE_FloodField function draws a field of one color on the display.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nAn object pointing to the TDRIVE instrument handle in memory.\n\n\n\n$Red\n\nInteger\n\nSets the intensity value of the color component. Valid values are 0-255.\n\n\n\n$Green\n\nInteger\n\nSets the intensity value of the color component. Valid values are 0-255.\n\n\n\n$Blue\n\nInteger\n\nSets the intensity value of the color component. Valid values are 0-255.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nTDRIVE_GrayScale\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS TDRIVE_GrayScale": {
  "prefix": "TDRIVE_GrayScale",
  "body": [
   "TDRIVE_GrayScale($$Handle,$$Direction,$$Color,$$Side);Note:ThisfunctionsupportstheTDRIVETFTSignalGeneratorFromWestarDisplayTechnologies.Formoreinformation,seetheuser'smanualprovidedwiththeinstrument."
  ],
  "description": "\n\nThe TDRIVE_GrayScale function draws a color scale on the display. The color, orientation, and direction of the scale can be specified.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nAn object pointing to the TDRIVE instrument handle in memory.\n\n\n\n$Direction\n\nString\n\nSpecifies the Direction of the grayscale pattern. \"HORIZONTAL\" or \"VERTICAL\" are the allowable values.\n\n\n\n$Color\n\nString\n\nSpcifies the color of the scale. Allowable values are \"RED\",\"GREEN\",\"BLUE\", or \"WHITE\"\n\n\n\n$Side\n\nString\n\nSpecifies whether the grayscale starts at the left (darkest area is on the left) or right (darkest area is on the right). Allowable values are \"LEFT\" or \"RIGHT\"\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nTDRIVE_Measure\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS TDRIVE_Measure": {
  "prefix": "TDRIVE_Measure",
  "body": [
   "$$result=TDRIVE_Measure($$Handle,$$Measure);Note:ThisfunctionsupportstheTDRIVETFTSignalGeneratorFromWestarDisplayTechnologies.Formoreinformation,seetheuser'smanualprovidedwiththeinstrument."
  ],
  "description": "\n\nThe TDRIVE_Measure function measures a specified power rail, and stores the value in $result.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nAn object pointing to the TDRIVE instrument handle in memory.\n\n\n\n$Measure\n\nString\n\nThe measurement you wish to make. Allowed values are:\n\n\u00b7 \"AD_P1_CURRENT\" = P1 Current\n\n\u00b7 \"AD_P2_CURRENT\" = P2 Current\n\n\u00b7 \"AD_P3_CURRENT\" = P3 Current\n\n\u00b7 \"AD_SPARE1\" = Spare\n\n\u00b7 \"AD_5VDC\" = 5V DC\n\n\u00b7 \"AD_5VDC_REF\" = 5V DC Reference\n\n\u00b7 \"AD_TMDS_P1_TESTIN\" = TMDS Test In\n\n\u00b7 \"AD_LVDS_P1_TESTIN\" = LVDS Test In\n\n\u00b7 \"AD_P1_LDO_IN\" = P1 LDO In\n\n\u00b7 \"AD_P2_LDO_IN\" = P2 LDO In\n\n\u00b7 \"AD_P3_LDO_IN\" = P3 LDO In\n\n\u00b7 \"AD_P1_FUSE\" = P1 Fuse\n\n\u00b7 \"AD_P2_FUSE\" = P2 Fuse\n\n\u00b7 \"AD_P3_FUSE\" = P3 Fuse\n\n\u00b7 \"AD_M5VDC\" = -5V DC\n\n\u00b7 \"AD_SPARE0\" = Spare\n\n\u00b7 \"AD_3_3VDC\" = 3.3V DC\n\n\u00b7 \"AD_M15VDC\" = -15V DC\n\n\u00b7 \"AD_15VDC\" = 15V DC\n\n\u00b7 \"AD_2_5VDC\" = 2.5V DC\n\n\u00b7 \"AD_ANALOG_5VDC\" = Analog 5V DC\n\n\u00b7 \"AD_P1_OUT\" = P1 Output\n\n\u00b7 \"AD_P2_OUT\" = P2 Output\n\n\u00b7 \"AD_P3_OUT\" = P3 Output\n\n\u00b7 \"AD_P4_OUT\" = P4 Output\n\n\u00b7 \"AD_P1_INTERNAL\" = P1 Internal\n\n\u00b7 \"AD_P2_INTERNAL\" = P2 Internal\n\n\u00b7 \"AD_P3_INTERNAL\" = P3 Internal\n\n\u00b7 \"AD_P4_INTERNAL\" = P4 Internal\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$result\n\nFloat\n\nThe returned measurement.\n\n\n\n\n\nTDRIVE_Open\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS TDRIVE_Open": {
  "prefix": "TDRIVE_Open",
  "body": [
   "$$Handle=TDRIVE_Open();Note:ThisfunctionsupportstheTDRIVETFTSignalGeneratorFromWestarDisplayTechnologies.Formoreinformation,seetheuser'smanualprovidedwiththeinstrument."
  ],
  "description": "\n\nOpens the TDRIVE Signal Generator via USB. This function generates a failure if the instrument can't be initialized, otherwise a PASS is generated and the instrument handle is returned.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nReturns a handle to the instrument.\n\n\n\n\n\nTDRIVE_PixelLine\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS TDRIVE_PixelLine": {
  "prefix": "TDRIVE_PixelLine",
  "body": [
   "TDRIVE_PixelLine($$Handle,$$Red1,$$Green1,$$Blue1,$$Red2,$$Green2,$$Blue2,$$Direction,$$Size);Note:ThisfunctionsupportstheTDRIVETFTSignalGeneratorFromWestarDisplayTechnologies.Formoreinformation,seetheuser'smanualprovidedwiththeinstrument."
  ],
  "description": "\n\nThe TDRIVE_PixelLine function draws a field of lines on the display. They can be horizontal or vertical, one or two pixel lines thich, and be a specified color.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nAn object pointing to the TDRIVE instrument handle in memory.\n\n\n\n$Red1\n\nInteger\n\nSets the intensity value of the color component for the even lines. Valid values are 0-255.\n\n\n\n$Green1\n\nInteger\n\nSets the intensity value of the color component for the even lines. Valid values are 0-255.\n\n\n\n$Blue1\n\nInteger\n\nSets the intensity value of the color component for the even lines. Valid values are 0-255.\n\n\n\n$Red2\n\nInteger\n\nSets the intensity value of the color component for the odd lines. Valid values are 0-255.\n\n\n\n$Green2\n\nInteger\n\nSets the intensity value of the color component for the odd lines. Valid values are 0-255.\n\n\n\n$Blue2\n\nInteger\n\nSets the intensity value of the color component for the odd lines. Valid values are 0-255.\n\n\n\n$Direction\n\nString\n\nSpecifies whether the lines run horizontal or vertical. Zero specifies horizontal and one spcifies vertical. Allowed values are \"HORIZONTAL\" or \"VERTICAL\"\n\n\n\n$Size\n\nInteger\n\nSpecifies the pixel width of the line. Can be 1 or 2.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nTDRIVE_PixelSelect\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS TDRIVE_PixelSelect": {
  "prefix": "TDRIVE_PixelSelect",
  "body": [
   "$$PixelList=TDRIVE_PixelSelect($$Handle,$$Red1,$$Green1,$$Blue1,$$Red2,$$Green2,$$Blue2,$$Instructions,$$VerticalRes,$$HorizontalRes);Note:ThisfunctionsupportstheTDRIVETFTSignalGeneratorFromWestarDisplayTechnologies.Formoreinformation,seetheuser'smanualprovidedwiththeinstrument."
  ],
  "description": "\n\nThe TDRIVE_PixelSelect function can be used to select a list of pixels from a given TFT Panel. The selected pixels are returned as a string to the test executive.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nAn object pointing to the TDRIVE instrument handle in memory.\n\n\n\n$Red1\n\nInteger\n\nSets the intensity value of the color component for the cross-hair lines. Valid values are 0-255.\n\n\n\n$Green1\n\nInteger\n\nSets the intensity value of the color component for the cross-hair lines. Valid values are 0-255.\n\n\n\n$Blue1\n\nInteger\n\nSets the intensity value of the color component for the cross-hair lines. Valid values are 0-255.\n\n\n\n$Red2\n\nInteger\n\nSets the intensity value of the color component for the background. Valid values are 0-255.\n\n\n\n$Green2\n\nInteger\n\nSets the intensity value of the color component for the background. Valid values are 0-255.\n\n\n\n$Blue2\n\nInteger\n\nSets the intensity value of the color component for the background. Valid values are 0-255.\n\n\n\n$Instructions\n\nString\n\nSpecifies the instructions that will be displayed to the user.\n\n\n\n$VerticalRes\n\nInteger\n\nSpecifies the number of lines of resolution in the vertical plane\n\n\n\n$HorizontalRes\n\nInteger\n\nSpecifies the number of lines of resolution in the horizontal plane\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$PixelList\n\nString\n\nA list of the pixels that have been selected by the operator.\n\n\n\n\n\nTDRIVE_StaticRect\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS TDRIVE_StaticRect": {
  "prefix": "TDRIVE_StaticRect",
  "body": [
   "TDRIVE_StaticRect($$Handle,$$Red1,$$Green1,$$Blue1,$$Red2,$$Green2,$$Blue2,$$Width,$$Height,$$X,$$Y,$$Center);Note:ThisfunctionsupportstheTDRIVETFTSignalGeneratorFromWestarDisplayTechnologies.Formoreinformation,seetheuser'smanualprovidedwiththeinstrument."
  ],
  "description": "\n\nThe TDRIVE_PixelLine function draws a static rectangle on the display. The position and color of the rectangle and background can be specified.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nAn object pointing to the TDRIVE instrument handle in memory.\n\n\n\n$Red1\n\nInteger\n\nSets the intensity value of the color component for the rectangle. Valid values are 0-255.\n\n\n\n$Green1\n\nInteger\n\nSets the intensity value of the color component for the rectangle. Valid values are 0-255.\n\n\n\n$Blue1\n\nInteger\n\nSets the intensity value of the color component for the rectangle. Valid values are 0-255.\n\n\n\n$Red2\n\nInteger\n\nSets the intensity value of the color component for the background. Valid values are 0-255.\n\n\n\n$Green2\n\nInteger\n\nSets the intensity value of the color component for the background. Valid values are 0-255.\n\n\n\n$Blue2\n\nInteger\n\nSets the intensity value of the color component for the background. Valid values are 0-255.\n\n\n\n$Width\n\nInteger\n\nSpecifies the Width of the rectangle.\n\n\n\n$Height\n\nInteger\n\nSpecifies the Height of the rectangle.\n\n\n\n$X\n\nInteger\n\nSpecifies the position of the left side of the rectangle.\n\n\n\n$Y\n\nInteger\n\nSpecifies the position of the top of the rectangle.\n\n\n\n$Center\n\nInteger\n\nSpecifies whether the rectangle is centered. '1' specifies that the rectangle is centered on the display and sized to 30% of the display width and height. The X,Y,Width,and Height parameters are overwritten. '0' Specifies that the rectangle is not centered and sized. The X,Y,Width, and Height parameters are used.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nTDRIVE_Wedge\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS TDRIVE_Wedge": {
  "prefix": "TDRIVE_Wedge",
  "body": [
   "TDRIVE_Wedge($$Handle,$$Direction,$$Side);Note:ThisfunctionsupportstheTDRIVETFTSignalGeneratorFromWestarDisplayTechnologies.Formoreinformation,seetheuser'smanualprovidedwiththeinstrument."
  ],
  "description": "\n\nThe TDRIVE_Wedge function draws a 4 color wedge on the display. The orientation and direction of the wedge can be specified.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nAn object pointing to the TDRIVE instrument handle in memory.\n\n\n\n$Direction\n\nString\n\nSpecifies the Direction of the wedge pattern. \"HORIZONTAL\" or \"VERTICAL\" are the allowable values.\n\n\n\n$Side\n\nString\n\nSpecifies whether the color wedge starts at the left (darkest area is on the left) or right (darkest area is on the right). Allowable values are \"LEFT\" or \"RIGHT\"\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nMSP430_CloseCom\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS MSP430_CloseCom": {
  "prefix": "MSP430_CloseCom",
  "body": [
   "MSP430_CloseCom();"
  ],
  "description": "\n\nMSP430 is a in-system gang programmer tool that can be used to program up to 8 MSP430 FLASH devices simultaneously.\n\nCloseCom releases the communications port.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$None\n\nNone\n\nNone\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\nInteger\n\nErrorCode describing a specific error.\n\n\n\n\n\nMSP430_EraseImage\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS MSP430_EraseImage": {
  "prefix": "MSP430_EraseImage",
  "body": [
   "MSP430_EraseImage();"
  ],
  "description": "\n\nMSP430 is a in-system gang programmer tool that can be used to program up to 8 MSP430 FLASH devices simultaneously.\n\nGangEraseImage clears (presets with 0xFF) the image memory at the progr. unit\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$None\n\nNone\n\nNone\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\nInteger\n\nErrorCode describing a specific error.\n\n\n\n\n\nMSP430_InitCom\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS MSP430_InitCom": {
  "prefix": "MSP430_InitCom",
  "body": [
   "MSP430_InitCom($$ComPort,$$BaudRate);"
  ],
  "description": "\n\nMSP430 is a in-system gang programmer tool that can be used to program up to 8 MSP430 FLASH devices simultaneously.\n\nInitCom opens a communications port, sets the baudrate and checks if the GANG430 is present.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ComPort\n\nString\n\nCommunication Port\n\n\n\n$BaudRate\n\nInteger\n\nBaud Rate\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\nInteger\n\nErrorCode describing a specific error.\n\n\n\n\n\nMSP430_LoadImage\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS MSP430_LoadImage": {
  "prefix": "MSP430_LoadImage",
  "body": [
   "MSP430_LoadImage($$Filename,$$DeviceName);"
  ],
  "description": "\n\nMSP430 is a in-system gang programmer tool that can be used to program up to 8 MSP430 FLASH devices simultaneously.\n\nWrites data from a file either of type TI-txt or of type Intel-hex (auto-detect) into the programmer's image flash memory. It also writes the memory model parameters of the selected device type and the checksums for main and information memory into the programmer's flash system memory\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Filename\n\nString\n\nThe full path of the code file\n\n\n\n$DeviceName\n\nString\n\nThe device name in Gang430.ini\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\nInteger\n\nErrorCode describing a specific error.\n\n\n\n\n\nMSP430_LoadParameters\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS MSP430_LoadParameters": {
  "prefix": "MSP430_LoadParameters",
  "body": [
   "MSP430_LoadParameters($$Flag,$$Supply,$$VccSettleTime);"
  ],
  "description": "\n\nMSP430 is a in-system gang programmer tool that can be used to program up to 8 MSP430 FLASH devices simultaneously.\n\nLoadParameters controls the main process at the programmer unit\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Flag_Erase_Info\n\nString\n\nF_ERASE_INFO- executes erasure of info memory\n\nF_ERASE_MAIN - executes erasure of main memory\n\nF_ERASE_MASS - executes erasure of info and main memory\n\n\n\n$Flag_Program_Info\n\nString\n\nF_PROGRAM_INFO - executes programming of info memory\n\nF_PROGRAM_MAIN - executes programming of main memory\n\nF_PROGRAM_MASS - executes programming of info and main memory\n\n\n\n$Flag_Erase_Check\n\nBoolean\n\nTrue - executes erase check of info and main memory\n\n\n\n$Flag_Verify\n\nBoolean\n\nTrue - executes verifaction of info and main memory\n\n\n\n$Flag_Blow_Fuse\n\nBoolean\n\nTrue - executes fuse blowing\n\n\n\n$Supply\n\nInteger\n\nSupply voltage in 100mV, max 127, add. F_VCC_OFF= 128\n\n\n\n$Vcc_off\n\nString\n\n128 - switches target Vcc off after main process ends\n\n\n\n$Vcc_SettleTime\n\nString\n\nIn milliseconds, max 65535\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\nInteger\n\nErrorCode describing a specific error.\n\n\n\n\n\nMSP430_MainProcess\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS MSP430_MainProcess": {
  "prefix": "MSP430_MainProcess",
  "body": [
   "MSP430_MainProcess($$TimeOut);"
  ],
  "description": "\n\nMSP430 is a in-system gang programmer tool that can be used to program up to 8 MSP430 FLASH devices simultaneously.\n\nMainProcess executes the main process at the programmer unit\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$TimeOut\n\nInteger\n\nTime out in 100 ms\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\nInteger\n\nErrorCode describing a specific error.\n\n\n\n\n\nMSP430_ReadTargetFile\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS MSP430_ReadTargetFile": {
  "prefix": "MSP430_ReadTargetFile",
  "body": [
   "MSP430_ReadTargetFile($$Target,$$Start,$$Length,$$Filename,$$FileType);"
  ],
  "description": "\n\nMSP430 is a in-system gang programmer tool that can be used to program up to 8 MSP430 FLASH devices simultaneously.\n\nReads data from one selectable target into a file\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Target\n\nInteger\n\nThe target number 0..7\n\n\n\n$Start\n\nInteger\n\nStart of buffer eg.64512\n\n\n\n$Length\n\nInteger\n\nLength of buffer eg.1024\n\n\n\n$Filename\n\nString\n\nThe file\n\n\n\n$Filetype\n\nInteger\n\nThe file type code:\n\nFILETYPE_AUTO 0\n\nFILETYPE_TI_TXT 1\n\nFILETYPE_INTEL_HEX 2\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\nInteger\n\nErrorCode describing a specific error.\n\n\n\n\n\nMSP430_SelfTest\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS MSP430_SelfTest": {
  "prefix": "MSP430_SelfTest",
  "body": [
   "MSP430_SelfTest($$TimeOut);"
  ],
  "description": "\n\nMSP430 is a in-system gang programmer tool that can be used to program up to 8 MSP430 FLASH devices simultaneously.\n\nSelftest performs a selftest of the programmer unit\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$TimeOut\n\nInteger\n\nTime out in 100 ms\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\nInteger\n\nErrorCode describing a specific error.\n\n\n\n\n\nMSP430_SetSignals\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS MSP430_SetSignal": {
  "prefix": "MSP430_SetSignal",
  "body": [
   "MSP430_SetSignal($$Signal,$$Voltage);"
  ],
  "description": "\n\nMSP430 is a in-system gang programmer tool that can be used to program up to 8 MSP430 FLASH devices simultaneously.\n\nSets specified signals on the programmer target connector\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Signals\n\nInteger\n\nSignals determines output signals\n\n\n\n$Voltage\n\nInteger\n\nVoltage determines logic high level voltage of signals\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\nInteger\n\nErrorCode describing a specific error.\n\n\n\n\n\nMSP430_SetVccTarget\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS MSP430_SetVccTarget": {
  "prefix": "MSP430_SetVccTarget",
  "body": [
   "MSP430_SetVccTarget($$Voltage);"
  ],
  "description": "\n\nMSP430 is a in-system gang programmer tool that can be used to program up to 8 MSP430 FLASH devices simultaneously.\n\nSets the target Vcc voltage at the programmer's target connector pin VCC_MSP\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Voltage\n\nInteger\n\nTarget Vcc Voltage\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\nInteger\n\nErrorCode describing a specific error.\n\n\n\n\n\nMSP_GetResults\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS MSP430_GetResults": {
  "prefix": "MSP430_GetResults",
  "body": [
   "$$Result0,$$Result1,$$Result2,$$Result4,$$Result4=MSP430_GetResults($$Timeout);"
  ],
  "description": "\n\nMSP430 is a in-system gang programmer tool that can be used to program up to 8 MSP430 FLASH devices simultaneously.\n\nGetResults returns the result of the previous MainProcess command.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Timeout\n\nInteger\n\nTimeout in seconds to wait for results.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Result0\n\nInteger\n\nResult code 0. This byte contains the flags indicating which channels are connected to a target device. LSB is channel 1 and MSB is channel 8.\n\n\n\n$Result1\n\nInteger\n\nResult code 1. This byte contains the flags indicating which channels passed the Erase Check operation.\n\n\n\n$Result2\n\nInteger\n\nResult code 2. This byte contains the flags indicating which channels passed the Verification operation.\n\n\n\n$Result3\n\nInteger\n\nResult code 3. This byte contains the flags indicating which channels passed the Fuse Blow operation.\n\n\n\n$Result4\n\nInteger\n\nResult code 4. This byte contains the flags indicating which channels passed all operations.\n\n\n\n\n\nMSP_GANG_ChangeBaudRate\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS MSP_GANG_ChangeBaudRate": {
  "prefix": "MSP_GANG_ChangeBaudRate",
  "body": [
   "MSP_GANG_ChangeBaudRate($$baudRate);"
  ],
  "description": "\n\nThis function will change the baud rate for the connection to the MSP-GANG programmer.\n\n\n\nRemarks\n\nCommunication with the MSP-GANG Programmer must already have been opened using the MSP_GANG_InitComm function.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$baudRate\n\nInteger\n\nThe baud rate to change the connection speed to.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n\n\n\n\n// Open communication on COM3.\n\n$startBaud = 9600;\n\n$port = \"COM4\";\n\n\n\nMSP_GANG_InitComm($port, $startBaud);\n\n\n\n// Change baud rate to 115200 bps.\n\n$baud = 115200;\n\n\n\nMSP_GANG_ChangeBaudRate($baud);\n\n\n\n\n\nMSP_GANG_CreateGangImage\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS MSP_GANG_GetCodeInfo": {
  "prefix": "MSP_GANG_GetCodeInfo",
  "body": [
   "$$codeInfo=MSP_GANG_GetCodeInfo($$infoType);"
  ],
  "description": "\n\nThis function will return information about the code that is loaded into the computer memory.\n\n\n\nRemarks\n\nCommunication with the MSP-GANG Programmer must already have been opened using the MSP_GANG_InitComm function.\n\nThe code file must already have been loaded into memory using the MSP_GANG_ReadCodeFile function.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$infoType\n\nString\n\nThe type of information to return. Valid entries are: CodeSize1\n\nCodeChecksum1\n\nCodeSize2\n\nCodeChecksum2\n\nAppendSize\n\nAppendCheckSum\n\nWholeCodeSize\n\nWholeCodeChecksum\n\nCsprGang\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$codeInfo\n\nString\n\nThe returned information about the loaded code.\n\n\n\n\n\nExample:\n\n\n\n\n\n// Open communication on COM3.\n\n$startBaud = 9600;\n\n$port = \"COM4\";\n\n\n\nMSP_GANG_InitComm($port, $startBaud);\n\n\n\n// Load a code file.\n\n$codeFile = \"C:\\\\CodeFiles\\\\MSP_Code_File.hex\";\n\n\n\nMSP_GANG_ReadCodeFile($codeFile);\n\n\n\n// Find the code size and checksum.\n\n$infoType = \"CodeSize1\";\n\n$returned = MSP_GANG_GetCodeInfo($infoType);\n\n$outStr = \"Code Size = \" + $returned;\n\nUpdateStatus($outStr);\n\n$infoType = \"CodeChecksum1\";\n\n$returned = MSP_GANG_GetCodeInfo($infoType);\n\n$outStr = \"Code Checksum = \" + $returned;\n\nUpdateStatus($outStr);\n\n\n\n\n\nMSP_GANG_GetProgressStatus\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS MSP_GANG_GetProgressStatus": {
  "prefix": "MSP_GANG_GetProgressStatus",
  "body": [
   "($$status,$$tasks,$$cumul,$$request,$$connect,$$erased,$$blank,$$program,$$verify,$$secure,$$vccErr,$$jtagInit,$$jtagFuse,$$wrongMCU,$$vtio,$$comment)=MSP_GANG_GetProgressStatus();"
  ],
  "description": "\n\nThis function will return information about the targets after the last process ran.\n\n\n\nRemarks\n\nCommunication with the MSP-GANG Programmer must already have been opened using the MSP_GANG_InitComm function.\n\nThe boolean status arrays contain 8 boolean values representing the 8 targets. Array element 0 is the status for target 1, element 1 for target 2, etc.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$status\n\nString\n\nThe status of the last process. This will be: \"In Progress\", \"ACK\", \"NACK\", or \"No Status\".\n\n\n\n$tasks\n\nString\n\nA list of the processes that have run, separated by commas.\n\n\n\n$cumul\n\nBoolean Array\n\nThe accumulation of the process status for each of the targets.\n\n\n\n$request\n\nBoolean Array\n\nWhich targets were requested to be processed.\n\n\n\n$connect\n\nBoolean Array\n\nWhether each of the targets was successfully connected to.\n\n\n\n$erased\n\nBoolean Array\n\nWhether each of the targets was successfully erased.\n\n\n\n$blank\n\nBoolean Array\n\nWhether each of the targets passed a blank check test.\n\n\n\n$program\n\nBoolean Array\n\nWhether each of the targets was successfully programmed.\n\n\n\n$verify\n\nBoolean Array\n\nWhether each of the targets passed a verify code test.\n\n\n\n$secure\n\nBoolean Array\n\nWhether each of the targets was successfully secured.\n\n\n\n$vccErr\n\nBoolean Array\n\nWhether each of the targets had a VCC error.\n\n\n\n$jtagInit\n\nBoolean Array\n\nWhether there was an error when the JTAG was initialized for each of the targets. This data is not valid if JTAG is not the interface being used.\n\n\n\n$jtagFuse\n\nBoolean Array\n\nWhether the JTAG fuse was already blown before programming for each of the targets. This data is not valid if JTAG is not the interface being used.\n\n\n\n$wrongMCU\n\nBoolean Array\n\nWhether the wrong MCU was specified for each of the targets. Note this data is only valid if there are errors while programming. If there are no errors, this will be the same as $request.\n\n\n\n$vtio\n\nInteger\n\nThe IO voltage for the programmer.\n\n\n\n$comment\n\nString\n\nThe comment that is on the programmer screen.\n\n\n\n\n\nExample:\n\n\n\n\n\n// Get the progress status.\n\n(status, $tasks, $cumul, $request, $connect, $erased, $blank, $program, $verify, $secure, $vccErr, $jtagInit, $jtagFuse, $wrongMCU, $vtio, $comment) = MSP_GANG_GetProgressStatus();\n\n\n\n\n\nMSP_GANG_InitComm\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS MSP_GANG_InitComm": {
  "prefix": "MSP_GANG_InitComm",
  "body": [
   "MSP_GANG_InitComm($$comPort,$$baudRate);"
  ],
  "description": "\n\nThis function will initialize communication with the MSP-GANG programmer.\n\n\n\nRemarks\n\nWhen all programming is complete, communication with the MSP-GANG Programmer must be closed using the MSP_GANG_ReleaseComm function.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$comPort\n\nString\n\nThe name of the COM port to open.\n\n\n\n$baudRate\n\nInteger\n\nThe baud rate for communication with the programmer.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n\n\n\n\n// Open communication on COM3.\n\n$startBaud = 9600;\n\n$port = \"COM4\";\n\n\n\nMSP_GANG_InitComm($port, $startBaud);\n\n\n\n\n\nMSP_GANG_InteractiveProcess\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS MSP_GANG_InteractiveProcess": {
  "prefix": "MSP_GANG_InteractiveProcess",
  "body": [
   "MSP_GANG_InteractiveProcess($$timeOut);"
  ],
  "description": "\n\nThis function will cause the specified function process to run.\n\n\n\nRemarks\n\nCommunication with the MSP-GANG Programmer must already have been opened using the MSP_GANG_InitComm function.\n\nThe functions to perform to program the target(s) must already have been specified using the MSP_GANG_SetProgrammerFunctions function.\n\nThe targets to perform the function on must already have been specified using the MSP_GANG_SetProgramTargets, MSP_GANG_SetMCUName and MSP_GANG_SetTargetInterface functions.\n\nIf one of the functions to perform is to program the target(s), the code file must already have been loaded into memory using the MSP_GANG_ReadCodeFile function.\n\nThe code file must already have been converted to an image using the MSP_GANG_CreateGangImage function.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$timeOut\n\nInteger\n\nThe time to wait for the functions to complete before generating an error.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n\n\n\n\n// Open communication on COM3.\n\n$startBaud = 115200;\n\n$port = \"COM4\";\n\nMSP_GANG_InitComm($port, $startBaud);\n\n\n\n// Set the type of MCU in use.\n\n$mcuName = \"MSP430FR5738\";\n\nMSP_GANG_SetMCUName($mcuName);\n\n\n\n// Set for 3.3V from the programmer with a 10ms settling time.\n\n$level = 3300;\n\n$fromProg = true;\n\n$turnOn = true;\n\n$settle = 10;\n\nMSP_GANG_SetVCC($level, $fromProg, $turnOn, $settle);\n\n\n\n// Set to fast SBW without using RST.\n\n$interface = \"SBWFAST\";\n\n$sbwIO = false;\n\nMSP_GANG_SetTargetInterface($interface, $sbwIO);\n\n\n\n// Set to perform functions on targets 1, 5 and 8.\n\n$targets = Array1DCreate(\"BOOLEAN\", 8);\n\nArray1DSetValue($targets, 0, true);\n\nArray1DSetValue($targets, 4, true);\n\nArray1DSetValue($targets, 7, true);\n\nMSP_GANG_SetProgramTargets($targets);\n\n\n\n// Set to perform all functions on the targets except for securing them.\n\n$connect = true;\n\n$erase = true;\n\n$blank = true;\n\n$program = true;\n\n$verify = true;\n\n$secure = false;\n\nMSP_GANG_SetProgrammerFunctions($connect, $erase, $blank, $program, $verify, $secure);\n\n\n\n// Read a code file into memory.\n\n$filePath = \"C:\\\\code_files\\\\target_code.hex\";\n\nMSP_GANG_ReadCodeFile($filePath);\n\n\n\n// Create an image to be programmed.\n\n$imageName = \"BurnImage\";\n\nMSP_GANG_CreateGangImage($imageName);\n\n\n\n// Start the Interactive Process functions with a 20 second timeout.\n\n$timeOut = 20;\n\n\n\nMSP_GANG_InteractiveProcess($timeOut);\n\n\n\n\n\nMSP_GANG_InteractiveProcessBool\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS MSP_GANG_InteractiveProcessBool": {
  "prefix": "MSP_GANG_InteractiveProcessBool",
  "body": [
   "($$success,$$error)=MSP_GANG_InteractiveProcessBool($$timeOut);"
  ],
  "description": "\n\nThis function will cause the specified function process to run and will always pass.\n\n\n\nRemarks\n\nCommunication with the MSP-GANG Programmer must already have been opened using the MSP_GANG_InitComm function.\n\nThe functions to perform to program the target(s) must already have been specified using the MSP_GANG_SetProgrammerFunctions function.\n\nThe targets to perform the function on must already have been specified using the MSP_GANG_SetProgramTargets, MSP_GANG_SetMCUName and MSP_GANG_SetTargetInterface functions.\n\nIf one of the functions to perform is to program the target(s), the code file must already have been loaded into memory using the MSP_GANG_ReadCodeFile function.\n\nThe code file must already have been converted to an image using the MSP_GANG_CreateGangImage function.\n\nThis function will not fail the test script. If there is an error, the boolean for success will be false and the error string will contain the description of the error.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$timeOut\n\nInteger\n\nThe time to wait for the functions to complete before generating an error.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$success\n\nBoolean\n\nWhether the interactive process command completed successfully. (true = success, false = failed)\n\n\n\n$error\n\nString\n\nThe error description. (blank if no error)\n\n\n\n\n\nExample:\n\n\n\n\n\n// Open communication on COM3.\n\n$startBaud = 115200;\n\n$port = \"COM4\";\n\nMSP_GANG_InitComm($port, $startBaud);\n\n\n\n// Set the type of MCU in use.\n\n$mcuName = \"MSP430FR5738\";\n\nMSP_GANG_SetMCUName($mcuName);\n\n\n\n// Set for 3.3V from the programmer with a 10ms settling time.\n\n$level = 3300;\n\n$fromProg = true;\n\n$turnOn = true;\n\n$settle = 10;\n\nMSP_GANG_SetVCC($level, $fromProg, $turnOn, $settle);\n\n\n\n// Set to fast SBW without using RST.\n\n$interface = \"SBWFAST\";\n\n$sbwIO = false;\n\nMSP_GANG_SetTargetInterface($interface, $sbwIO);\n\n\n\n// Set to perform functions on targets 1, 5 and 8.\n\n$targets = Array1DCreate(\"BOOLEAN\", 8);\n\nArray1DSetValue($targets, 0, true);\n\nArray1DSetValue($targets, 4, true);\n\nArray1DSetValue($targets, 7, true);\n\nMSP_GANG_SetProgramTargets($targets);\n\n\n\n// Set to perform all functions on the targets except for securing them.\n\n$connect = true;\n\n$erase = true;\n\n$blank = true;\n\n$program = true;\n\n$verify = true;\n\n$secure = false;\n\nMSP_GANG_SetProgrammerFunctions($connect, $erase, $blank, $program, $verify, $secure);\n\n\n\n// Read a code file into memory.\n\n$filePath = \"C:\\\\code_files\\\\target_code.hex\";\n\nMSP_GANG_ReadCodeFile($filePath);\n\n\n\n// Create an image to be programmed.\n\n$imageName = \"BurnImage\";\n\nMSP_GANG_CreateGangImage($imageName);\n\n\n\n// Start the Interactive Process functions with a 20 second timeout.\n\n$timeOut = 20;\n\n\n\n($success, $error) = MSP_GANG_InteractiveProcessBool($timeOut);\n\n\n\n\n\nMSP_GANG_ReadCodeFile\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS MSP_GANG_ReadCodeFile": {
  "prefix": "MSP_GANG_ReadCodeFile",
  "body": [
   "MSP_GANG_ReadCodeFile($$filePath);"
  ],
  "description": "\n\nThis function will load the specified code file into memory.\n\n\n\nRemarks\n\nCommunication with the MSP-GANG Programmer must already have been opened using the MSP_GANG_InitComm function.\n\nBefore the code is programmed into a target, the code must be converted to an image using the MSP_GANG_CreateGangImage function.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$filePath\n\nString\n\nThe full path to the code file to load into memory.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n\n\n\n\n// Read a code file into memory.\n\n$filePath = \"C:\\\\code_files\\\\target_code.hex\";\n\nMSP_GANG_ReadCodeFile($filePath);\n\n\n\n\n\nMSP_GANG_ReleaseComm\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS MSP_GANG_ReleaseComm": {
  "prefix": "MSP_GANG_ReleaseComm",
  "body": [
   "MSP_GANG_ReleaseComm();"
  ],
  "description": "\n\nThis function will release the Com port used for communication with the MSP-GANG programmer.\n\n\n\nRemarks\n\nCommunication with the MSP-GANG Programmer must already have been opened using the MSP_GANG_InitComm function.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n\n\n\n\n// Open communication on COM3.\n\n$startBaud = 9600;\n\n$port = \"COM4\";\n\n\n\nMSP_GANG_InitComm($port, $startBaud);\n\n\n\n// Close communication.\n\nMSP_GANG_ReleaseComm();\n\n\n\n\n\nMSP_GANG_SetMCUName\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS MSP_GANG_SetMCUName": {
  "prefix": "MSP_GANG_SetMCUName",
  "body": [
   "MSP_GANG_SetMCUName($$mcuName);"
  ],
  "description": "\n\nThis function will select the type of MCU that will be programmed.\n\n\n\nRemarks\n\nCommunication with the MSP-GANG Programmer must already have been opened using the MSP_GANG_InitComm function.\n\nThe MCU name must already be a known type to the MSP-GANG programmer.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$mcuName\n\nString\n\nThe name of the MCU to be programmed.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n\n\n\n\n// Open communication on COM3.\n\n$startBaud = 9600;\n\n$port = \"COM4\";\n\n\n\nMSP_GANG_InitComm($port, $startBaud);\n\n\n\n// Set the type of MCU in use.\n\n$mcuName = \"MSP430FR5738\";\n\nMSP_GANG_SetMCUName($mcuName);\n\n\n\n\n\nMSP_GANG_SetProgrammerFunctions\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS MSP_GANG_SetProgrammerFunctions": {
  "prefix": "MSP_GANG_SetProgrammerFunctions",
  "body": [
   "MSP_GANG_SetProgrammerFunctions($$connect,$$erase,$$blank,$$program,$$verify,$$secure);"
  ],
  "description": "\n\nThis function will select which functions will be performed on the target(s).\n\n\n\nRemarks\n\nCommunication with the MSP-GANG Programmer must already have been opened using the MSP_GANG_InitComm function.\n\nAt least one function must be selected.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$connect\n\nBoolean\n\nWhether to connect to the target(s). A target must be connected to before any other functions are performed.\n\n\n\n$erase\n\nBoolean\n\nWhether to erase the target(s).\n\n\n\n$blank\n\nBoolean\n\nWhether to perform a blank-check on the target(s).\n\n\n\n$program\n\nBoolean\n\nWhether to program the target(s).\n\n\n\n$verify\n\nBoolean\n\nWhether to verify the programming of the target(s).\n\n\n\n$secure\n\nBoolean\n\nWhether to secure the target(s).\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n\n\n\n\n// Open communication on COM3.\n\n$startBaud = 9600;\n\n$port = \"COM4\";\n\n\n\nMSP_GANG_InitComm($port, $startBaud);\n\n\n\n// Set to perform all functions on the targets except for securing them.\n\n$connect = true;\n\n$erase = true;\n\n$blank = true;\n\n$program = true;\n\n$verify = true;\n\n$secure = false;\n\nMSP_GANG_SetProgrammerFunctions($connect, $erase, $blank, $program, $verify, $secure);\n\n\n\n\n\nMSP_GANG_SetProgramTargets\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS MSP_GANG_SetProgramTargets": {
  "prefix": "MSP_GANG_SetProgramTargets",
  "body": [
   "MSP_GANG_SetProgramTargets($$targetArray);"
  ],
  "description": "\n\nThis function will select which targets will have the specified functions performed on them.\n\n\n\nRemarks\n\nCommunication with the MSP-GANG Programmer must already have been opened using the MSP_GANG_InitComm function.\n\nAt least one function must be selected using the MSP_GANG_SetProgrammerFunctions function.\n\nIn the boolean array, element 0 is for target slot 1, element 1 is for target slot 2, etc. Up to element 7 representing target slot 8.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$targetArray\n\nBoolean Array\n\nAn 8 element Boolean array with each element representing one of the potential targets.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n\n\n\n\n// Open communication on COM3.\n\n$startBaud = 9600;\n\n$port = \"COM4\";\n\n\n\nMSP_GANG_InitComm($port, $startBaud);\n\n\n\n// Set to perform functions on targets 1, 5 and 8.\n\n$targets = Array1DCreate(\"BOOLEAN\", 8);\n\nArray1DSetValue($targets, 0, true);\n\nArray1DSetValue($targets, 4, true);\n\nArray1DSetValue($targets, 7, true);\n\nMSP_GANG_SetProgramTargets($targets);\n\n\n\n\n\nMSP_GANG_SetTargetInterface\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS MSP_GANG_SetTargetInterface": {
  "prefix": "MSP_GANG_SetTargetInterface",
  "body": [
   "MSP_GANG_SetTargetInterface($$interface,$$sbwIO);"
  ],
  "description": "\n\nThis function will set the target communication interface type.\n\n\n\nRemarks\n\nCommunication with the MSP-GANG Programmer must already have been opened using the MSP_GANG_InitComm function.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$interface\n\nString\n\nThe type and speed of the interface to use. Valid entries are: JTAGFAST\n\nJTAGMED\n\nJTAGSLOW\n\nSBWFAST\n\nSBWMED\n\nSBWSLOW\n\n\n\n\n\n$sbwIO\n\nBoolean\n\nWhether to communicate on SBW through the RST line. This input is ignored for the JTAG interface type.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n\n\n\n\n// Open communication on COM3.\n\n$startBaud = 9600;\n\n$port = \"COM4\";\n\n\n\nMSP_GANG_InitComm($port, $startBaud);\n\n\n\n// Set to fast SBW without using RST.\n\n$interface = \"SBWFAST\";\n\n$sbwIO = false;\n\n\n\nMSP_GANG_SetTargetInterface($interface, $sbwIO);\n\n\n\n\n\nMSP_GANG_SetVCC\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS MSP_GANG_SetVCC": {
  "prefix": "MSP_GANG_SetVCC",
  "body": [
   "MSP_GANG_SetVCC($$value,$$fromProg,$$turnOn,$$settleTime);"
  ],
  "description": "\n\nThis function will set the output voltage to the targets and where the voltage is coming from.\n\n\n\nRemarks\n\nCommunication with the MSP-GANG Programmer must already have been opened using the MSP_GANG_InitComm function.\n\nIf the VCC value is set as 0, then the voltage will not be set and only the other parameters will be used. This allows for turning the output on and off without changing the voltage level.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$value\n\nInteger\n\nThe voltage level to set for the targets - in millivolts.\n\n\n\n$fromProg\n\nBoolean\n\nWhether the voltage is to be supplied by the MSP-GANG programmer. If set to false then an external power supply must provide the voltage to the targets.\n\n\n\n$turnOn\n\nBoolean\n\nWhether the voltage is applied to the targets.\n\n\n\n$settleTime\n\nInteger\n\nThe time to wait for the VCC to settle after applying it to the targets - in milliseconds.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n\n\n\n\n// Open communication on COM3.\n\n$startBaud = 9600;\n\n$port = \"COM4\";\n\n\n\nMSP_GANG_InitComm($port, $startBaud);\n\n\n\n// Set for 3.3V from the programmer with a 10ms settling time.\n\n$level = 3300;\n\n$fromProg = true;\n\n$turnOn = true;\n\n$settle = 10;\n\n\n\nMSP_GANG_SetVCC($level, $fromProg, $turnOn, $settle);\n\n\n\n\n\nAG53131A_Close\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG53131A_Close": {
  "prefix": "AG53131A_Close",
  "body": [
   "AG53131A_Close($$Handle);"
  ],
  "description": "\n\nThis function uses the Agilent IVI Instrument drivers, in order to use the AG53131 functions in JabilTest, you need to have the Agilent COM components installed.\n\nThis function closes and released the AG53131A. This should be done at the end of every session using the AG53131A.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nThe COM object representing the instance of the AG53131A.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nAG53131A_Init\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG53131A_Init": {
  "prefix": "AG53131A_Init",
  "body": [
   "$$AgInstance=AG53131A_Init($$ResourceString,$$Reset);"
  ],
  "description": "\n\nThis function uses the Agilent IVI Instrument drivers, in order to use the AG53131 functions in JabilTest, you need to have the Agilent COM components installed.\n\nThis function initializes the AG53131A for operation. If $Reset is set to true, the instrument is reinitialized to it's default setting.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ResourceString\n\nString\n\nThe resource string identifying the instrument. For example, \"GPIB0::9::Instr\".\n\n\n\n$Reset\n\nBoolean\n\nSpecifies whether or not to reset the instrument upon initialization\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AgInstance\n\nObject\n\nThe COM object representing the instance of the AG53131A.\n\n\n\n\n\nAG53131A_InputConfig\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG53131A_InputConfig": {
  "prefix": "AG53131A_InputConfig",
  "body": [
   "AG53131A_InputConfig($$Handle,$$InputChannel,$$Coupling,$$Impedance,$$Attenuation,$$Filter);"
  ],
  "description": "\n\nThis function uses the Agilent IVI Instrument drivers, in order to use the AG53131 functions in JabilTest, you need to have the Agilent COM components installed.\n\nThis function closes and released the AG53131A. This should be done at the end of every session using the AG53131A.\n\nExample:\n\nAG53131A.InputConfig($Handle,1,\"AC\",\"LOW\",10,\"OFF\");\n\n\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nThe COM object representing the instance of the AG53131A.\n\n\n\n$InputChannel\n\nInteger\n\nThe channel number to configure\n\n\n\n$Coupling\n\nString\n\nThe coupling setting for the input. Allowable values are 'AC' or 'DC'.\n\n\n\n$Impedance\n\nString\n\nThe impedance setting for the input. Allowable values are 'LOW' and 'HIGH', Low impedance sets the input impedance to 50 Ohms, 'HIGH' sets the input impedance to 1 Mega-Ohm.\n\n\n\n$Attenuation\n\nInteger\n\nSets the attenuation setting for the input. Allowable values are '1' and '10'.\n\n\n\n$Filter\n\nString\n\nTurns on and off the low pass filter options for the input. Allowable values are 'ON' and 'OFF'\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nAG53131A_MeasureExpectedFreq\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG53131A_MeasureExpectedFreq": {
  "prefix": "AG53131A_MeasureExpectedFreq",
  "body": [
   "$$Measurement=AG53131A_MeasureExpectedFreq($$Handle,$$InputChannel,$$ExpectedFrequency,$$DesiredResolution);"
  ],
  "description": "\n\nThis function uses the Agilent IVI Instrument drivers, in order to use the AG53131 functions in JabilTest, you need to have the Agilent COM components installed.\n\nThis function measures the Frequency on the specified input, with a specified expected frequency, and a desired resolution.\n\nThe expected frequency and resolution are entered as strings, Example:\n\n$Measurement = AG53131A.MeasureExpectedFreq($Handle,1,\"13 MHZ\",\"0.1 HZ\");\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nThe COM object representing the instance of the AG53131A.\n\n\n\n$InputChannel\n\nInteger\n\nThe channel number to measure\n\n\n\n$ExpectedFrequency\n\nString\n\nThe expected frequency specified as a string containing the numeric expected frequency, as well as an abbrevation for the units, such as \"13 Mhz\", or \"1000 HZ\", etc\n\n\n\n$DesiredResolution\n\nString\n\nThe desired resolution for the measurement specified as a string containing the numeric frequency, as well as an abbreviation for units, such as \"0.1 HZ\".\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Measurement\n\nFloat\n\nThe measurement of the frequency in hertz.\n\n\n\n\n\nAG53131A_MeasureFallTime\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG53131A_MeasureFallTime": {
  "prefix": "AG53131A_MeasureFallTime",
  "body": [
   "$$Measurement=AG53131A_MeasureFallTime($$Handle,$$InputChannel);"
  ],
  "description": "\n\nThis function uses the Agilent IVI Instrument drivers, in order to use the AG53131 functions in JabilTest, you need to have the Agilent COM components installed.\n\nThis function measures the Fall Time on the specified input.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nThe COM object representing the instance of the AG53131A.\n\n\n\n$InputChannel\n\nInteger\n\nThe channel number to measure\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Measurement\n\nFloat\n\nThe measurement of the fall time in seconds.\n\n\n\n\n\nAG53131A_MeasureFreq\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG53131A.MeasureFreq": {
  "prefix": "AG53131A.MeasureFreq",
  "body": [
   "$$Measurement=AG53131A.MeasureFreq($$Handle,$$InputChannel);"
  ],
  "description": "\n\nThis function uses the Agilent IVI Instrument drivers, in order to use the AG53131 functions in JabilTest, you need to have the Agilent COM components installed.\n\nThis function measures the Frequency on the specified input.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nThe COM object representing the instance of the AG53131A.\n\n\n\n$InputChannel\n\nInteger\n\nThe channel number to measure\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Measurement\n\nFloat\n\nThe measurement of the frequency in hertz.\n\n\n\n\n\nAG53131A_MeasurePeriod\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG53131A_MeasurePeriod": {
  "prefix": "AG53131A_MeasurePeriod",
  "body": [
   "$$Measurement=AG53131A_MeasurePeriod($$Handle,$$InputChannel);"
  ],
  "description": "\n\nThis function uses the Agilent IVI Instrument drivers, in order to use the AG53131 functions in JabilTest, you need to have the Agilent COM components installed.\n\nThis function measures the Period on the specified input.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nThe COM object representing the instance of the AG53131A.\n\n\n\n$InputChannel\n\nInteger\n\nThe channel number to measure\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Measurement\n\nFloat\n\nThe measurement of the period in seconds.\n\n\n\n\n\nAG53131A_MeasurePhase\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG53131A_MeasurePhase": {
  "prefix": "AG53131A_MeasurePhase",
  "body": [
   "$$Measurement=AG53131A_MeasurePhase($$Handle,$$InputChannel1,$$InputChannel2);"
  ],
  "description": "\n\nThis function uses the Agilent IVI Instrument drivers, in order to use the AG53131 functions in JabilTest, you need to have the Agilent COM components installed.\n\nThis function measures the phase difference (in degrees) between the two channels specified.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nThe COM object representing the instance of the AG53131A.\n\n\n\n$InputChannel1\n\nInteger\n\nThe channel number to measure 1\n\n\n\n$InputChannel2\n\nInteger\n\nThe channel number to measure 2\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Measurement\n\nFloat\n\nThe measurement of the phase in degrees\n\n\n\n\n\nAG53131A_MeasureVoltageMax\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG53131A.MeasureVoltageMax": {
  "prefix": "AG53131A.MeasureVoltageMax",
  "body": [
   "$$Measurement=AG53131A.MeasureVoltageMax($$Handle,$$InputChannel);"
  ],
  "description": "\n\nThis function uses the Agilent IVI Instrument drivers, in order to use the AG53131 functions in JabilTest, you need to have the Agilent COM components installed.\n\nThis function measures the maximum voltage on the specified input.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nThe COM object representing the instance of the AG53131A.\n\n\n\n$InputChannel\n\nInteger\n\nThe channel number to measure\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Measurement\n\nFloat\n\nThe measurement of the maximum voltage in volts.\n\n\n\n\n\nAG53131A_MeasureVoltageMin\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG53131A.MeasureVoltageMin": {
  "prefix": "AG53131A.MeasureVoltageMin",
  "body": [
   "$$Measurement=AG53131A.MeasureVoltageMin($$Handle,$$InputChannel);"
  ],
  "description": "\n\nThis function uses the Agilent IVI Instrument drivers, in order to use the AG53131 functions in JabilTest, you need to have the Agilent COM components installed.\n\nThis function measures the minimum voltage on the specified input.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nThe COM object representing the instance of the AG53131A.\n\n\n\n$InputChannel\n\nInteger\n\nThe channel number to measure\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Measurement\n\nFloat\n\nThe measurement of the minimum voltage in volts.\n\n\n\n\n\nAG53131A_MeasureVoltagePTPeak\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG53131A.MeasureVoltagePTPeak": {
  "prefix": "AG53131A.MeasureVoltagePTPeak",
  "body": [
   "$$Measurement=AG53131A.MeasureVoltagePTPeak($$Handle,$$InputChannel);"
  ],
  "description": "\n\nThis function uses the Agilent IVI Instrument drivers, in order to use the AG53131 functions in JabilTest, you need to have the Agilent COM components installed.\n\nThis function measures the peak to peak voltage on the specified input.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nThe COM object representing the instance of the AG53131A.\n\n\n\n$InputChannel\n\nInteger\n\nThe channel number to measure\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Measurement\n\nFloat\n\nThe measurement of the peak to peak voltage in volts.\n\n\n\n\n\nAG53131A_ReadBuffer\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG53131A_ReadBuffer": {
  "prefix": "AG53131A_ReadBuffer",
  "body": [
   "($$ItemCount,$$Buffer)=AG53131A_ReadBuffer($$Handle);"
  ],
  "description": "\n\n\n\nThis function reads the instrument buffer for the responses to any queries that have been submitted to the instrument using the AG53131A_SendCommand function.\n\nThis function can be used to leverage any instrument functionality that's not exposed by the other functions in the library.\n\nNOTE: This function uses the Agilent IVI Instrument drivers, in order to use the AG53131 functions in JabilTest, you need to have the Agilent COM components installed.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nThe handle of the instrument returned from the initialization function.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ItemCount\n\nInteger\n\nThe number of items remaining in the instruments output buffer. These will all be returned using the currently configured delimiter character in the instruments output buffer.\n\n\n\n$Buffer\n\nString\n\nThe entire pending output buffer of the instrument. The $ItemCount return parameter can be used to determine how many items are contained in the returned output buffer. The items will be seperated by the currently configured delimiter character for the instrument.\n\n\n\n\n\nExample:\n\n\n\n\n\n$Measurement = AG53131A_MeasureExpectedFreq($Handle,1,\"10 Mhz\",\"0.1 Hz\");\n\nAG53131A_SendCommand($Handle,\":Fetch?\");\n\n($ItemCount,$RetData) = AG53131A_ReadBuffer($Handle);\n\nUpdateStatus($ItemCount);\n\nUpdateStatus($RetData);\n\n\n\n\n\nAG53131A_SendCommand\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG53131A_SendCommand": {
  "prefix": "AG53131A_SendCommand",
  "body": [
   "AG53131A_SendCommand($$Handle,$$TimeoutMS);"
  ],
  "description": "\n\n\n\nThis function sets the measurement timeout value on the instrument. The timeout value is expressed in milliseconds.\n\nNOTE: This function uses the Agilent IVI Instrument drivers, in order to use the AG53131 functions in JabilTest, you need to have the Agilent COM components installed.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nThe handle of the instrument returned from the initialization function.\n\n\n\n$TimeoutMS\n\nInteger\n\nThe measurement time out value expressed in milliseconds.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\nAG53131A_SetTimeout($Handle,5000); // Set measurement timeout to 5 seconds\n\n\n\n\n\nAG53131A_TriggerConfig\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG53131A_TriggerConfig": {
  "prefix": "AG53131A_TriggerConfig",
  "body": [
   "AG53131A_TriggerConfig($$Handle,$$InputChannel,$$Auto,$$TriggerLevel,$$TriggerSlope,$$Sensitivity);"
  ],
  "description": "\n\nThis function uses the Agilent IVI Instrument drivers, in order to use the AG53131 functions in JabilTest, you need to have the Agilent COM components installed.\n\nThis function measures the peak to peak voltage on the specified input.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nThe COM object representing the instance of the AG53131A.\n\n\n\n$InputChannel\n\nInteger\n\nThe channel number to measure\n\n\n\n$Auto\n\nString\n\nTurns on or off the AUTO trigger setting. Allowable values are:\n\n\"ON\"\n\n\"OFF\"\n\n\n\n$TriggerLevel\n\nFloat\n\nSets the trigger level of the specified input. In the event that the \"AUTO\" trigger is turned on, this number specifies the percentage of the signal at which to trigger. In the event that the \"AUTO\" trigger is turned off, this number specifies the absolute voltage level at which to trigger. Allowable values are:\n\nIf AutoTriggering is Enabled:\n\n10 = 10%\n\n20 = 20%\n\n30 = 30%\n\n40 = 40%\n\n50 = 50%\n\n60 = 60%\n\n70 = 70%\n\n80 = 80%\n\n90 = 90%\n\nIf Auto-Triggering is Disabled, any voltage level within the acceptable range is permitted.\n\n\n\n$TriggerSlope\n\nString\n\nSpecifies the trigger slope for the given input channel. Allowable values are:\n\n\"NEG\" = Trigger on Negative Slope\n\n\"POS\" = Trigger on Positive Slope\n\n\n\n$Sensitivity\n\nString\n\nSpecifies the hysterisis function level. Allowable values are:\n\n\"LOW\"\n\n\"MED\"\n\n\"HIGH\"\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nAR7054SA_DCHipotMeasurement\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AR7504SA_DC_Hipot_Measurement": {
  "prefix": "AR7504SA_DC_Hipot_Measurement",
  "body": [
   "$$Measurement=AR7504SA_DC_Hipot_Measurement($$HipotInstance,$$Timeout);"
  ],
  "description": "\n\nThis function uses the Agilent IO Lib and NI-VISA,in order to use the AgilentIOLibs functions in JabilTest, you need to have the Agilent IO Lib and NI-VISA installed.\n\nThis function returns a DC dielectric withstand leakage current measurement. In the case of instrument communication failure, or a timeout , a failure is generated by the fuction.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$HipotInstance\n\nObject\n\nThe AR7504SAHipotClass representing the instance of the AR7504SA to be operated.\n\n\n\n$Timeout\n\nInteger\n\nTimeout (in Second) to wait for a reading before failure.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Measurement\n\nFloat\n\nThe DC Hipot leakage current measurement.\n\n\n\n\n\nAR7054SA_DCHipotSetup\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AR7504SA_DC_Hipot_Setup": {
  "prefix": "AR7504SA_DC_Hipot_Setup",
  "body": [
   "AR7504SA_DC_Hipot_Setup($$HipotInstance,$$Voltage,$$Low_Limit,$$High_Limit,$$Ramp_Time,$$Dwell_Time,$$Arc_Sense);"
  ],
  "description": "\n\nThis function uses the Agilent IO Lib and NI-VISA,in order to use the AgilentIOLibs functions in JabilTest, you need to have the Agilent IO Lib and NI-VISA installed.\n\nThis function setup the instrument for DC dielectric withstand measurement. In the case of instrument communication failure, or the setting is beyond the instrument range ,a failure is generated by the function .\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$HipotInstance\n\nObject\n\nThe AR7504SAHipotClass representing the instance of the AR7504SA to be operated.\n\n\n\n$Voltage\n\nFloat\n\nThe High Voltage apply for the measurement. For AR7504SA the range 0~6000V .\n\n\n\n$Low_Limit\n\nFloat\n\nThe Low Limit for the measurement. For AR7504SA Hipot tester ,the Low Limit is 0~999.9 uA.\n\n\n\n$High_Limit\n\nInteger\n\nThe High Limit for the measurement. For AR7504SA Hipot tester ,the High Limit is 0~9999 uA.\n\n\n\n$Ramp_Time\n\nFloat\n\nThe Ramp Time for the measurement is the high voltage rise from 0 to the setting value. For AR7504SA Hipot tester is 0.4~999.9 S.\n\n\n\n$Dwell_Time\n\nFloat\n\nDwell Time is the duration of applying voltage for the measurement. For AR7504SA Hipot tester is 0.3~999.9 S.\n\n\n\n$Arc_Sense\n\nInteger\n\nArc Sense is the sensitivity for detection the arc. If set 0 the arc sense is off, otherwise is on. For AR7504SA Hipot tester is 0~9 selectable. Value is greater and sensitivity is more higer.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$None\n\n\n\n\n\nAR7504SAHipot_Close\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AR7504SAHipot_Close": {
  "prefix": "AR7504SAHipot_Close",
  "body": [
   "AR7504SAHipot_Close($$HipotInstance);"
  ],
  "description": "\n\nThis function uses the Agilent IO Lib and NI-VISA,in order to use the AgilentIOLibs functions in JabilTest, you need to have the Agilent IO Lib and NI-VISA installed.\n\nThis function close the Associated Research 7504SA Hipot teser and recovers used resources. It does not reset tester or change it\u2019s existing settings.This function returns a passing result if the tester can be closed successfully,otherwise a failure is generated by the script function.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$HipotInstance\n\nObject\n\nThe AR7504SAHipotClass representing the instance of the AR7504SA to be closed. Closes the tester and release all resources.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nAR7504SAHipot_Init\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AR7504SAHipot_Init": {
  "prefix": "AR7504SAHipot_Init",
  "body": [
   "$$HipotInstance=AR7504SAHipot_Init($$ResourceString);"
  ],
  "description": "\n\nThis function uses the Agilent IO Lib and NI-VISA,in order to use the AgilentIOLibs functions in JabilTest, you need to have the Agilent IO Lib and NI-VISA installed.\n\nThis function initialize the Associated Research 7504SA Hipot teser for operation. It does reset tester and enable all pass,fail,abort,error SRQ setting. It simply grabs an instance of the AR7504SAHipotClass to use in further test script operations.This function returns a passing result if the tester can be initialized successfully,otherwise a failure is generated by the script function.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ResourceString\n\nString\n\nThe resource string identifying the tester. For example,\"GPIB0::8\".\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$HipotInstance\n\nObject\n\nThe AR7504SAHipotClass representing the instance of the AR7504SA.\n\n\n\n\n\nAR7504SA_AC_Hipot_Measurement\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AR7504SA_AC_Hipot_Measurement": {
  "prefix": "AR7504SA_AC_Hipot_Measurement",
  "body": [
   "$$Measurement=AR7504SA_AC_Hipot_Measurement($$HipotInstance,$$Timeout);"
  ],
  "description": "\n\nThis function uses the Agilent IO Lib and NI-VISA,in order to use the AgilentIOLibs functions in JabilTest, you need to have the Agilent IO Lib and NI-VISA installed.\n\nThis function returns a AC dielectric withstand leakage current measurement. In the case of instrument communication failure, or a timeout , a failure is generated by the fuction.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$HipotInstance\n\nObject\n\nThe AR7504SAHipotClass representing the instance of the AR7504SA to be operated.\n\n\n\n$Timeout\n\nInteger\n\nTimeout (in Second) to wait for a reading before failure.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Measurement\n\nFloat\n\nThe AC Hipot leakage current measurement.\n\n\n\n\n\nAR7504SA_AC_Hipot_Setup\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AR7504SA_AC_Hipot_Setup": {
  "prefix": "AR7504SA_AC_Hipot_Setup",
  "body": [
   "AR7504SA_AC_Hipot_Setup($$HipotInstance,$$Voltage,$$Low_Limit,$$High_Limit,$$Ramp_Time,$$Dwell_Time,$$Frequency,$$Arc_Sense);"
  ],
  "description": "\n\nThis function uses the Agilent IO Lib and NI-VISA,in order to use the AgilentIOLibs functions in JabilTest, you need to have the Agilent IO Lib and NI-VISA installed.\n\nThis function setup the instrument for AC dielectric withstand measurement. In the case of instrument communication failure, or the setting is beyond the instrument range ,a failure is generated by the function .\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$HipotInstance\n\nObject\n\nThe AR7504SAHipotClass representing the instance of the AR7504SA to be operated.\n\n\n\n$Voltage\n\nFloat\n\nThe High Voltage apply for the measurement. For AR7504SA the range 0~5000V .\n\n\n\n$Low_Limit\n\nFloat\n\nThe Low Limit for the measurement. For AR7504SA Hipot tester ,the Low Limit is 0~9.999 mA.\n\n\n\n$High_Limit\n\nFloat\n\nThe High Limit for the measurement. For AR7504SA Hipot tester ,the High Limit is 0~99.00 mA.\n\n\n\n$Ramp_Time\n\nFloat\n\nThe Ramp Time for the measurement is the high voltage rise from 0 to the setting value. For AR7504SA Hipot tester is 0.1~999.9 S.\n\n\n\n$Dwell_Time\n\nFloat\n\nDwell Time is the duration of applying voltage for the measurement. For AR7504SA Hipot tester is 0.3~999.9 S.\n\n\n\n$Frequency\n\nInteger\n\nFrequency for the measurement is the AC Voltage frequency. For AR7504SA Hipot 50 or 60Hz selectable.\n\n\n\n$Arc_Sense\n\nInteger\n\nArc Sense is the sensitivity for detection the arc. If set 0 the arc sense is off, otherwise is on. For AR7504SA Hipot tester is 0~9 selectable. Value is greater and sensitivity is more higer.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$None\n\n\n\n\n\nAR7504SA_GroundBondMeasurement\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AR7504SA_GBOND_Measurement": {
  "prefix": "AR7504SA_GBOND_Measurement",
  "body": [
   "($$Measurement,$$ApplyCurrent)=AR7504SA_GBOND_Measurement($$HipotInstance,$$Timeout);"
  ],
  "description": "\n\nThis function uses the Agilent IO Lib and NI-VISA,in order to use the AgilentIOLibs functions in JabilTest, you need to have the Agilent IO Lib and NI-VISA installed.\n\nThis function returns a ground bond resistance measurement. In the case of instrument communication failure, or a timeout , a failure is generated by the fuction.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$HipotInstance\n\nObject\n\nThe AR7504SAHipotClass representing the instance of the AR7504SA to be operated.\n\n\n\n$Timeout\n\nInteger\n\nTimeout (in Second) to wait for a reading before failure.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Measurement\n\nFloat\n\nThe Ground Bond Resistance measurement.\n\n\n\n$ApplyCurrent\n\nFloat\n\nThe Current Applied actually for the measurement.If the applied current actually is not in the range of 0.98"
 }
,
 "JTS AR7504SA_GBOND_Setup": {
  "prefix": "AR7504SA_GBOND_Setup",
  "body": [
   "AR7504SA_GBOND_Setup($$HipotInstance,$$Current,$$Voltaqge,$$Low_Limit,$$High_Limit,$$DwellTime);"
  ],
  "description": "\n\nThis function uses the Agilent IO Lib and NI-VISA,in order to use the AgilentIOLibs functions in JabilTest, you need to have the Agilent IO Lib and NI-VISA installed.\n\nThis function setup the instrument for ground bond measurement. In the case of instrument communication failure, or the setting is beyond the instrument range ,a failure is generated by the function .\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$HipotInstance\n\nObject\n\nThe AR7504SAHipotClass representing the instance of the AR7504SA to be operated.\n\n\n\n$Current\n\nFloat\n\nThe Current apply for the measurement. For AR7504SA the range is 3.0~30.0A.\n\n\n\n$Voltage\n\nFloat\n\nThe Voltage apply for the measurement. For AR7504SA the range is 3.0~8.0V.\n\n\n\n$Low_Limit\n\nInteger\n\nThe Low Limit for the measurement. For AR7504SA Hipot tester ,the Low Limit is 0 to 600 mOhm at Current 3-10A and 0 to 150 mOhm at Current 3-30A.\n\n\n\n$High_Limit\n\nInteger\n\nThe High Limit for the measurement. For AR7504SA Hipot tester ,the Low Limit is 0 to 600 mOhm at Current 3-10A and 0 to 150 mOhm at Current 3-30A.\n\n\n\n$DwellTime\n\nInteger\n\nDwell Time is the duration of applying voltage and current for the measurement.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$None\n\n\n\n\n\nAVT_GigE_CameraList\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AVT_GigE_CameraList": {
  "prefix": "AVT_GigE_CameraList",
  "body": [
   "($$ConnectedNum,$$DataArray)=AVT_GigE_CameraList($$ArrayLength);"
  ],
  "description": "\n\nThis function lists the Allied Vision Technologies cameras currently visible to this system.\n\n\n\n\n\nResult:\n\n($ConnectedNum,$DataArray) = AVT_GigE_CameraList($ArrayLength);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ArrayLength\n\nInteger\n\nThe size of the return array\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ConnectedNum\n\nInteger\n\nThe number of cameras found\n\n\n\n$DataArray\n\nArray\n\nAn array containing all camera information:\n\n\u00b7 Camera name\n\n\u00b7 A value unique to each camera shipped by Allied Vision Technologies.\n\n\u00b7 Interface type\n\n\u00b7 Unique value for each interface or bus\n\n\u00b7 Camera's serial number\n\n\n\n\n\nExample:\n\n($ConnectedNum,$DataArray) = AVT_GigE_CameraList(1);\n\n\n\n\n\nAVT_GigE_CaptureFrame\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AVT_GigE_CaptureFrame": {
  "prefix": "AVT_GigE_CaptureFrame",
  "body": [
   "$$ErrorCode=AVT_GigE_CaptureFrame($$objCamera,$$FileName,$$Timeout);"
  ],
  "description": "\n\nThis function captures a frame and saves that frame as a bitmap on the provided location.\n\n\n\n\n\nResult:\n\n$ErrorCode = AVT_GigE_CaptureFrame($objCamera,$FileName,$Timeout);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$objCamera\n\nInteger\n\nThe handle to the Allied Vision Technologies GigE camera\n\n\n\n$FileName\n\nString\n\nPath and filename of the bitmap file.\n\n\n\n$Timeout\n\nInteger\n\nTimeout for frame capture.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\nInteger\n\nThe execution error code.\n\nError codes:\n\n\u00b7 0: no error\n\n\u00b7 >0: error (I refer to the API documentation for detailed error code information)\n\n\n\n\n\nExample:\n\n$ErrorCode = AVT_GigE_CaptureFrame($objCamera,\"C:\\\\test.bmp\",1000);\n\n\n\n\n\nAVT_GigE_CloseCamera\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AVT_GigE_CloseCamera": {
  "prefix": "AVT_GigE_CloseCamera",
  "body": [
   "$$ErrorCode=AVT_GigE_CloseCamera($$objCamera);"
  ],
  "description": "\n\nThis function closes the previously opened session.\n\n\n\n\n\nResult:\n\n$ErrorCode = AVT_GigE_CloseCamera($objCamera);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$objCamera\n\nInteger\n\nThe handle to the Allied Vision Technologies GigE camera\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\nInteger\n\nThe execution error code.\n\nError codes:\n\n\u00b7 0: no error\n\n\u00b7 >0: error (I refer to the API documentation for detailed error code information)\n\n\n\n\n\nExample:\n\n$ErrorCode = AVT_GigE_CloseCamera($objCamera);\n\n\n\n\n\nAVT_GigE_GetAttributeEnum\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AVT_GigE_GetAttributeEnum": {
  "prefix": "AVT_GigE_GetAttributeEnum",
  "body": [
   "($$ErrorCode,$$AttributeValue)=AVT_GigE_GetAttributeEnum($$objCamera,$$AttributeName);"
  ],
  "description": "\n\nThis function gets the value of a enumeration attribute.\n\n\n\n\n\nResult:\n\n($ErrorCode,$AttributeValue) = AVT_GigE_GetAttributeEnum($objCamera,$AttributeName);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$objCamera\n\nInteger\n\nThe handle to the Allied Vision Technologies GigE camera\n\n\n\n$AttributeName\n\nString\n\nThe name of the camera attribute to get the value. See the list of camera and driver attributes which can be retrieved from www.alliedvisiontec.com\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\nInteger\n\nThe execution error code.\n\nError codes:\n\n\u00b7 0: no error\n\n\u00b7 >0: error (I refer to the API documentation for detailed error code information)\n\n\n\n$AttributeValue\n\nString\n\nThe value of the attribute\n\n\n\n\n\nExample:\n\n($ErrorCode,$AttributeValue) = AVT_GigE_GetAttributeEnum($objCamera,\"PixelFormat\");\n\n\n\n\n\nAVT_GigE_GetAttributeString\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AVT_GigE_GetAttributeString": {
  "prefix": "AVT_GigE_GetAttributeString",
  "body": [
   "($$ErrorCode,$$AttributeValue)=AVT_GigE_GetAttributeString($$objCamera,$$AttributeName);"
  ],
  "description": "\n\nThis function gets the value of a string attribute.\n\n\n\n\n\nResult:\n\n($ErrorCode,$AttributeValue) = AVT_GigE_GetAttributeString($objCamera,$AttributeName);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$objCamera\n\nInteger\n\nThe handle to the Allied Vision Technologies GigE camera\n\n\n\n$AttributeName\n\nString\n\nThe name of the camera attribute to get the value. See the list of camera and driver attributes which can be retrieved from www.alliedvisiontec.com\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\nInteger\n\nThe execution error code.\n\nError codes:\n\n\u00b7 0: no error\n\n\u00b7 >0: error (I refer to the API documentation for detailed error code information)\n\n\n\n$AttributeValue\n\nString\n\nThe value of the attribute\n\n\n\n\n\nExample:\n\n($ErrorCode,$AttributeValue) = AVT_GigE_GetAttributeString($objCamera,\"CameraName\");\n\n\n\n\n\nAVT_GigE_GetAttributeUInt32\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AVT_GigE_GetAttributeUInt32": {
  "prefix": "AVT_GigE_GetAttributeUInt32",
  "body": [
   "($$ErrorCode,$$AttributeValue)=AVT_GigE_GetAttributeUInt32($$objCamera,$$AttributeName);"
  ],
  "description": "\n\nThis function gets the value of a UInt32 attribute.\n\n\n\n\n\nResult:\n\n($ErrorCode,$AttributeValue) = AVT_GigE_GetAttributeUInt32($objCamera,$AttributeName);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$objCamera\n\nInteger\n\nThe handle to the Allied Vision Technologies GigE camera\n\n\n\n$AttributeName\n\nString\n\nThe name of the camera attribute to get the value. See the list of camera and driver attributes which can be retrieved from www.alliedvisiontec.com\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\nInteger\n\nThe execution error code.\n\nError codes:\n\n\u00b7 0: no error\n\n\u00b7 >0: error (I refer to the API documentation for detailed error code information)\n\n\n\n$AttributeValue\n\nString\n\nThe value of the attribute\n\n\n\n\n\nExample:\n\n($ErrorCode,$AttributeValue) = AVT_GigE_GetAttributeUInt32($objCamera,\"AcquisitionFrameCount\");\n\n\n\n\n\nAVT_GigE_OpenCameraByIP\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AVT_GigE_OpenCameraByIP": {
  "prefix": "AVT_GigE_OpenCameraByIP",
  "body": [
   "($$ErrorCode,$$objCamera)=AVT_GigE_OpenCameraByIP($$IP);"
  ],
  "description": "\n\nThis function opens a session to the AVT GigE camera using the provided IP address. If an invalid IP address or no IP address is provided, this function returns an error code.\n\n\n\n\n\nResult:\n\n($ErrorCode,$objCamera) = AVT_GigE_OpenCameraByIP($IP);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$IP\n\nString\n\nThe IP address of the camera.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\nInteger\n\nThe execution error code.\n\nError codes:\n\n\u00b7 -1: no IP address provided.\n\n\u00b7 -2: no valid IP address provided.\n\n\u00b7 -3: no camera detected.\n\n\u00b7 0: no error\n\n\u00b7 >0: error (I refer to the API documentation for detailed error code information)\n\n\n\n$objCamera\n\nObject\n\nA reference to the camera which can be used in the other function calls.\n\n\n\n\n\nExample:\n\n($ErrorCode,$objCamera) = AVT_GigE_OpenCameraByIP($IP);\n\n\n\n\n\nAVT_GigE_OpenCameraBySN\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AVT_GigE_OpenCameraBySN": {
  "prefix": "AVT_GigE_OpenCameraBySN",
  "body": [
   "($$ErrorCode,$$objCamera)=AVT_GigE_OpenCameraBySN($$SerialNumber);"
  ],
  "description": "\n\nThis function opens a session to the AVT GigE camera using the provided serial number. If no serial number is provided, this function returns an error code.\n\n\n\n\n\nResult:\n\n($ErrorCode,$objCamera) = AVT_GigE_OpenCameraBySN($SerialNumber);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$SerialNumber\n\nString\n\nThe serial number of the camera.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\nInteger\n\nThe execution error code.\n\nError codes:\n\n\u00b7 -1: no serial number provided.\n\n\u00b7 -2: no camera detected.\n\n\u00b7 -3: opening camera with provided serial number fails\n\n\u00b7 0: no error\n\n\u00b7 >0: error (I refer to the API documentation for detailed error code information)\n\n\n\n$objCamera\n\nObject\n\nA reference to the camera which can be used in the other function calls.\n\n\n\n\n\nExample:\n\n($ErrorCode,$objCamera) = AVT_GigE_OpenCameraBySN($SerialNumber);\n\n\n\n\n\nAVT_GigE_OpenCameraByUID\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AVT_GigE_OpenCameraByUID": {
  "prefix": "AVT_GigE_OpenCameraByUID",
  "body": [
   "($$ErrorCode,$$objCamera)=AVT_GigE_OpenCameraByUID($$UID);"
  ],
  "description": "\n\nThis function opens a session to the AVT GigE camera using the provided unique identifier. If no unique identifier is provided, this function returns an error code.\n\n\n\n\n\nResult:\n\n($ErrorCode,$objCamera) = AVT_GigE_OpenCameraByUID($UID);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$UID\n\nInteger\n\nThe unique ID of the camera.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\nInteger\n\nThe execution error code.\n\nError codes:\n\n\u00b7 -1: no camera detected.\n\n\u00b7 -2: opening camera with provided unique identifier fails\n\n\u00b7 0: no error\n\n\u00b7 >0: error (I refer to the API documentation for detailed error code information)\n\n\n\n$objCamera\n\nObject\n\nA reference to the camera which can be used in the other function calls.\n\n\n\n\n\nExample:\n\n($ErrorCode,$objCamera) = AVT_GigE_OpenCameraByUID(123203);\n\n\n\n\n\nAVT_GigE_SetAttributeEnum\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AVT_GigE_SetAttributeEnum": {
  "prefix": "AVT_GigE_SetAttributeEnum",
  "body": [
   "$$ErrorCode=AVT_GigE_SetAttributeEnum($$objCamera,$$AttributeName,$$AttributeValue);"
  ],
  "description": "\n\nThis function sets the value of an enumeration attribute.\n\n\n\n\n\nResult:\n\n$ErrorCode = AVT_GigE_SetAttributeEnum($objCamera,$AttributeName,$AttributeValue);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$objCamera\n\nInteger\n\nThe handle to the Allied Vision Technologies GigE camera\n\n\n\n$AttributeName\n\nString\n\nThe name of the camera attribute to set the value.\n\n\n\n$AttributeValue\n\nString\n\nThe value to set the camera attribute.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\nInteger\n\nThe execution error code.\n\nError codes:\n\n\u00b7 0: no error\n\n\u00b7 >0: error (I refer to the API documentation for detailed error code information)\n\n\n\n\n\nExample:\n\n$ErrorCode = AVT_GigE_SetAttributeEnum($objCamera,\"PixelFormat\",$Format);\n\n\n\n\n\nAVT_GigE_SetAttributeString\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AVT_GigE_SetAttributeString": {
  "prefix": "AVT_GigE_SetAttributeString",
  "body": [
   "$$ErrorCode=AVT_GigE_SetAttributeString($$objCamera,$$AttributeName,$$AttributeValue);"
  ],
  "description": "\n\nThis function sets the value of a string attribute.\n\n\n\n\n\nResult:\n\n$ErrorCode = AVT_GigE_SetAttributeString($objCamera,$AttributeName,$AttributeValue);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$objCamera\n\nInteger\n\nThe handle to the Allied Vision Technologies GigE camera\n\n\n\n$AttributeName\n\nString\n\nThe name of the camera attribute to set the value.\n\n\n\n$AttributeValue\n\nString\n\nThe value to set the camera attribute.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\nInteger\n\nThe execution error code.\n\nError codes:\n\n\u00b7 0: no error\n\n\u00b7 >0: error (I refer to the API documentation for detailed error code information)\n\n\n\n\n\nExample:\n\n$ErrorCode = AVT_GigE_SetAttributeString($objCamera,\"CameraName\",\"TestCamera\");\n\n\n\n\n\nAVT_GigE_SetAttributeUInt32\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AVT_GigE_SetAttributeUInt32": {
  "prefix": "AVT_GigE_SetAttributeUInt32",
  "body": [
   "$$ErrorCode=AVT_GigE_SetAttributeUInt32($$objCamera,$$AttributeName,$$AttributeValue);"
  ],
  "description": "\n\nThis function sets the value of an enumeration attribute.\n\n\n\n\n\nResult:\n\n$ErrorCode = AVT_GigE_SetAttributeUInt32($objCamera,$AttributeName,$AttributeValue);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$objCamera\n\nInteger\n\nThe handle to the Allied Vision Technologies GigE camera\n\n\n\n$AttributeName\n\nString\n\nThe name of the camera attribute to set the value.\n\n\n\n$AttributeValue\n\nInteger\n\nThe value to set the camera attribute.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\nInteger\n\nThe execution error code.\n\nError codes:\n\n\u00b7 0: no error\n\n\u00b7 >0: error (I refer to the API documentation for detailed error code information)\n\n\n\n\n\nExample:\n\n$ErrorCode = AVT_GigE_SetAttributeUInt32($objCamera,\"PacketSize\",1500);\n\n\n\n\n\nAptina_GetOption\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Aptina_GetOption": {
  "prefix": "Aptina_GetOption",
  "body": [
   "$$value=Aptina_GetOption($$DevWare,$$option);"
  ],
  "description": "\n\nReturns a DevWare configuration parameter. These are usually items found in the various configuration menus of the program GUI, and are included in a device's .ini file.\n\n\n\n\n\nSee the DevWare COM Interface development guide for a partial list of options. Unknown option names will return a value of \"0\".\n\n\n\n\n\nNote:\n\nThese API functions require the DevSuite generic software package to be installed.\n\n\n\nFunction Arguments\n\n\n\n\n\nParameter\n\n\n\nVariable Type\n\nDescription\n\n\n\n$DevWare\n\nObject\n\nHandle to DevWare program instance created by the Aptina_Init() function.\n\n\n\n$option\n\nString\n\nName of option to get.\n\n\n\n\n\nReturn Parameters\n\n\n\n\n\nParameter\n\n\n\nVariable Type\n\nDescription\n\n\n\n$value\n\nString\n\nValue option was set for. An empty string value or invalid option name will return a value of \"0\". Note that this could also be a valid integer return value.\n\n\n\n\n\nExample:\n\n//set numeric option\n\n$value= Aptina_GetOption($DevWare, \"RAM Capture MB\");\n\nUpdateStatus(\"\\nOption before:\");\n\nUpdateStatus($value);\n\nAptina_SetOption($DevWare, \"RAM Capture MB\", 69);\n\n$value= Aptina_GetOption($DevWare, \"RAM Capture MB\");\n\nUpdateStatus(\"Option after:\");\n\nUpdateStatus($value);\n\n\n\n\n\n//set string option\n\n$value= Aptina_GetOption($DevWare, \"VidCap File\");\n\nUpdateStatus(\"\\nOption before:\");\n\nUpdateStatus($value);\n\nAptina_SetOption($DevWare, \"VidCap File\", \"C:\\\\TEST\\\\TEST.VIDEO\");\n\n$value= Aptina_GetOption($DevWare, \"VidCap File\");\n\nUpdateStatus(\"Option after:\");\n\nUpdateStatus($value);\n\n\n\n\n\nAptina_GetState\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Aptina_GetState": {
  "prefix": "Aptina_GetState",
  "body": [
   "$$value=Aptina_GetState($$DevWare,$$state);"
  ],
  "description": "\n\nReturns a DevWare state parameter, which control the image color processing and display. These are the same settings that are programmed with the STATE= command in DevWare .ini files.\n\n\n\n\n\nSee the INI File User\u2019s Guide for a complete list of the STATE variables. Unknown state names will return a value of \"0\".\n\n\n\n\n\nNote:\n\nThese API functions require the DevSuite generic software package to be installed.\n\n\n\nFunction Arguments\n\n\n\n\n\nParameter\n\n\n\nVariable Type\n\nDescription\n\n\n\n$DevWare\n\nObject\n\nHandle to DevWare program instance created by the Aptina_Init() function.\n\n\n\n$state\n\nString\n\nName of state to get.\n\n\n\n\n\nReturn Parameters\n\n\n\n\n\nParameter\n\n\n\nVariable Type\n\nDescription\n\n\n\n$value\n\nString\n\nValue state was set for. An empty string value or invalid state name will return a value of \"0\". Note that this could also be a valid integer return value.\n\n\n\n\n\nExample:\n\n//set numeric option\n\n$value= Aptina_GetOption($DevWare, \"RAM Capture MB\");\n\nUpdateStatus(\"\\nOption before:\");\n\nUpdateStatus($value);\n\nAptina_SetOption($DevWare, \"RAM Capture MB\", 69);\n\n$value= Aptina_GetOption($DevWare, \"RAM Capture MB\");\n\nUpdateStatus(\"Option after:\");\n\nUpdateStatus($value);\n\n\n\n\n\n//set string option\n\n$value= Aptina_GetOption($DevWare, \"VidCap File\");\n\nUpdateStatus(\"\\nOption before:\");\n\nUpdateStatus($value);\n\nAptina_SetOption($DevWare, \"VidCap File\", \"C:\\\\TEST\\\\TEST.VIDEO\");\n\n$value= Aptina_GetOption($DevWare, \"VidCap File\");\n\nUpdateStatus(\"Option after:\");\n\nUpdateStatus($value);\n\n\n\n\n\nAptina_Init\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Aptina_Init": {
  "prefix": "Aptina_Init",
  "body": [
   "$$DevWare=Aptina_Init($$deviceNum,$$probeForDevices);"
  ],
  "description": "\n\nInitializes the DevWare software, closing any currently open instances.\n\n\n\n\n\nNote:\n\nThese API functions require the DevSuite generic software package to be installed.\n\n\n\nFunction Arguments\n\n\n\n\n\nParameter\n\n\n\nVariable Type\n\nDescription\n\n\n\n$deviceNum\n\nInteger\n\nDevice number if more than one device is present, otherwise ignored.\n\n\n\n$probeForDevices\n\nBoolean\n\nIf true, performs a probe for attached devices.\n\n\n\n\n\nReturn Parameters\n\n\n\n\n\nParameter\n\n\n\nVariable Type\n\nDescription\n\n\n\n$DevWare\n\nObject\n\nHandle to DevWare program instance.\n\n\n\n\n\nExample:\n\n$DevWare = Aptina_Init(1, false); //initialize first (and only) device on computer\n\n\n\n\n\nAptina_LoadPresets\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Aptina_LoadPresets": {
  "prefix": "Aptina_LoadPresets",
  "body": [
   "Aptina_LoadPresets($$DevWare,$$iniFilePath,$$presetName);"
  ],
  "description": "\n\nOverrides power-on defaults with setting in preset file. More than one group of settings can exist in a single .ini file.\n\n\n\n\n\nNote:\n\nThese API functions require the DevSuite generic software package to be installed.\n\n\n\nFunction Arguments\n\n\n\n\n\nParameter\n\n\n\nVariable Type\n\nDescription\n\n\n\n$DevWare\n\nObject\n\nHandle to DevWare program instance created by the Aptina_Init() function.\n\n\n\n$iniFilePath\n\nString\n\nPath and filename of presets file to load for the sensor.\n\n\n\n$presetName\n\nString\n\nName of preset inside the .ini file to load (e.g., \"Demo Initialization\", \"Reset\", etc.)\n\n\n\n\n\nReturn Parameters\n\n\n\n\n\nParameter\n\n\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n--\n\n\n\n\n\nExample:\n\n$IniPath = \"C:\\\\TEST\\\\TEST.INI\";\n\n$Preset = \"Test\";\n\nAptina_LoadPresets($DevWare, $IniPath, $Preset);\n\n\n\n\n\nAptina_Quit\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Aptina_Quit": {
  "prefix": "Aptina_Quit",
  "body": [
   "Aptina_Quit($$DevWare);"
  ],
  "description": "\n\nCloses the DevWare program and releases all resources.\n\n\n\n\n\nNote:\n\nThese API functions require the DevSuite generic software package to be installed.\n\n\n\nFunction Arguments\n\n\n\n\n\nParameter\n\n\n\nVariable Type\n\nDescription\n\n\n\n$DevWare\n\nObject\n\nHandle to DevWare program instance created by the Aptina_Init() function.\n\n\n\n\n\nReturn Parameters\n\n\n\n\n\nParameter\n\n\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n--\n\n\n\n\n\nExample:\n\n\n\n\n\nfunction Finalize()\n\n{\n\nUpdateStatus(\"\\n"
 }
,
 "JTS Aptina_SaveCapture": {
  "prefix": "Aptina_SaveCapture",
  "body": [
   "Aptina_SaveCapture($$DevWare,$$fileType,$$savePath,$$timeoutms);"
  ],
  "description": "\n\nCaptures an image and saves it to a file in the selected format.\n\n\n\n\n\nNote:\n\nThese API functions require the DevSuite generic software package to be installed.\n\n\n\nFunction Arguments\n\n\n\n\n\nParameter\n\n\n\nVariable Type\n\nDescription\n\n\n\n$DevWare\n\nObject\n\nHandle to DevWare program instance created by the Aptina_Init() function.\n\n\n\n$fileType\n\nString\n\nFormat to save the image to. The following formats are supported:\n\n\u00b7 BMP\n\n\u00b7 TIFF\n\n\u00b7 PNG\n\n\u00b7 JPG\n\n\n\n$savePath\n\nString\n\nPath and filename to save image to, NOT INCLUDING the file extension.\n\n\n\n$timeoutms\n\nInteger\n\nTimeout in ms to wait for the capture of the image, saving the image to the file, or the dismissal of the capture window (returning to live capture) to complete. Each operation has a separate timeout. This value needs to be raised if averaging is turn ON to prevent an error.\n\n\n\n\n\nReturn Parameters\n\n\n\n\n\nParameter\n\n\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n--\n\n\n\n\n\nExample:\n\nAptina_SaveCapture($DevWare, \"BMP\", \"C:\\\\TEST\\\\Default_CAP\", 15000); //timeout 15s\n\n\n\n\n\nAptina_SaveRgbImage\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Aptina_SaveRgbImage": {
  "prefix": "Aptina_SaveRgbImage",
  "body": [
   "Aptina_SaveRgbImage($$DevWare,$$savepath);"
  ],
  "description": "\n\nSaves a 32-bit RGB bitmap image to a file. This function only captures a single frame and ignores the averaging state.\n\n\n\nTo specify a different file format or utilize averaging, use the Aptina_SaveCapture() function.\n\n\n\n\n\nNote:\n\nThese API functions require the DevSuite generic software package to be installed.\n\n\n\nFunction Arguments\n\n\n\n\n\nParameter\n\n\n\nVariable Type\n\nDescription\n\n\n\n$DevWare\n\nObject\n\nHandle to DevWare program instance created by the Aptina_Init() function.\n\n\n\n$savePath\n\nString\n\nPath and filename to save image to, INCLUDING the file extension.\n\n\n\n\n\nReturn Parameters\n\n\n\n\n\nParameter\n\n\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n--\n\n\n\n\n\nExample:\n\nAptina_SaveRgbImage($DevWare, \"C:\\\\TEST\\\\Default_RGB.BMP\");\n\n\n\n\n\nAptina_SetAveraging\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Aptina_SetAveraging": {
  "prefix": "Aptina_SetAveraging",
  "body": [
   "Aptina_SetAveraging($$DevWare,$$averaging,$$avgCount,$$delayms);"
  ],
  "description": "\n\nTurns averaging on/off. When on, several frames are combined into a single imaging when capturing. A large number of frames will require a longer time to acquire.\n\n\n\n\n\nNote:\n\nThese API functions require the DevSuite generic software package to be installed.\n\n\n\nFunction Arguments\n\n\n\n\n\nParameter\n\n\n\nVariable Type\n\nDescription\n\n\n\n$DevWare\n\nObject\n\nHandle to DevWare program instance created by the Aptina_Init() function.\n\n\n\n$averaging\n\nBoolean\n\nTRUE turns image averaging on, FALSE turns it off (ignoring all values that follow)\n\n\n\n$avgCount\n\nInteger\n\nNumber of image frames to average together.\n\n\n\n$delayms\n\nInteger\n\nDelay in milliseconds between the frames captured for use in the averaging\n\n\n\n\n\nReturn Parameters\n\n\n\n\n\nParameter\n\n\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n--\n\n\n\n\n\nExample:\n\nAptina_SetAveraging($DevWare, true, 100, 25); //averages 100 frames spaced 25ms apart together\n\n\n\n\n\nAptina_SetColorCorrection\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Aptina_SetColorCorrection": {
  "prefix": "Aptina_SetColorCorrection",
  "body": [
   "Aptina_SetColorCorrection($$DevWare,$$colorCorrect,$$contrast,$$saturation,$$gamma,$$black);"
  ],
  "description": "\n\nTurns SW color correction on/off and sets several basic correction type values for the device.\n\n\n\n\n\nNote:\n\nThese API functions require the DevSuite generic software package to be installed.\n\n\n\nFunction Arguments\n\n\n\n\n\nParameter\n\n\n\nVariable Type\n\nDescription\n\n\n\n$DevWare\n\nObject\n\nHandle to DevWare program instance created by the Aptina_Init() function.\n\n\n\n$colorCorrect\n\nBoolean\n\nTRUE turns color correction on, FALSE turns it off (ignoring all values that follow)\n\n\n\n$contrast\n\nInteger\n\nContrast enhancement factor (20 - 40). Actual contrast level is this value / 20 (e.g., the default value of 25 = a contrast enhancement of 1.25)\n\n\n\n$saturation\n\nInteger\n\nSaturation boost factor (0 - 20). Actual saturation level is this value / 10. A value of 0 gives a black & white image, while a value of 10 means no boost\n\n\n\n$gamma\n\nInteger\n\nGamma correction level (1 - 125). Actual gamma level is this value / 100 (e.g., the default value of 45 = a gamma correction of 0.45)\n\n\n\n$black\n\nInteger\n\nBlack correction level (0 - 20). Darkens blacks to enhance image\n\n\n\n\n\nReturn Parameters\n\n\n\n\n\nParameter\n\n\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n--\n\n\n\n\n\nExample:\n\n//Color correction HIGH\n\nAptina_SetColorCorrection($DevWare, true, 40, 20, 125, 20);\n\n\n\n\n\n//Color correction LOW\n\nAptina_SetColorCorrection($DevWare, true, 20, 0, 20, 0);\n\n\n\n\n\n//Color correction OFF, value set to default\n\nAptina_SetColorCorrection($DevWare, false, 25, 10, 45, 10);\n\n\n\n\n\nAptina_SetOption\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Aptina_SetOption": {
  "prefix": "Aptina_SetOption",
  "body": [
   "Aptina_SetOption($$DevWare,$$option,$$value);"
  ],
  "description": "\n\nSets a DevWare program configuration parameter. These are usually items found in the various configuration menus of the program GUI, and are included in a device's .ini file.\n\n\n\n\n\nSee the DevWare COM Interface development guide for a partial list of options. Unknown option names will add new custom options to the .ini file.\n\n\n\n\n\nNote:\n\nThese API functions require the DevSuite generic software package to be installed.\n\n\n\nFunction Arguments\n\n\n\n\n\nParameter\n\n\n\nVariable Type\n\nDescription\n\n\n\n$DevWare\n\nObject\n\nHandle to DevWare program instance created by the Aptina_Init() function.\n\n\n\n$option\n\nString\n\nName of option to set.\n\n\n\n$value\n\nString\n\nString or integer value to set the option to.\n\n\n\n\n\nReturn Parameters\n\n\n\n\n\nParameter\n\n\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n--\n\n\n\n\n\nExample:\n\n//set numeric option\n\n$value= Aptina_GetOption($DevWare, \"RAM Capture MB\");\n\nUpdateStatus(\"\\nOption before:\");\n\nUpdateStatus($value);\n\nAptina_SetOption($DevWare, \"RAM Capture MB\", 69);\n\n$value= Aptina_GetOption($DevWare, \"RAM Capture MB\");\n\nUpdateStatus(\"Option after:\");\n\nUpdateStatus($value);\n\n\n\n\n\n//set string option\n\n$value= Aptina_GetOption($DevWare, \"VidCap File\");\n\nUpdateStatus(\"\\nOption before:\");\n\nUpdateStatus($value);\n\nAptina_SetOption($DevWare, \"VidCap File\", \"C:\\\\TEST\\\\TEST.VIDEO\");\n\n$value= Aptina_GetOption($DevWare, \"VidCap File\");\n\nUpdateStatus(\"Option after:\");\n\nUpdateStatus($value);\n\n\n\n\n\nAptina_SetState\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Aptina_SetState": {
  "prefix": "Aptina_SetState",
  "body": [
   "Aptina_SetState($$DevWare,$$state,$$value);"
  ],
  "description": "\n\nSets a DevWare state parameter, which control the image color processing and display. These are the same settings that are programmed with the \"STATE=\" command in DevWare ini files.\n\n\n\n\n\nSee the INI File User\u2019s Guide for a complete list of the STATE variables. Unknown state names will create a new custom entry in the .ini file.\n\n\n\n\n\nNote:\n\nThese API functions require the DevSuite generic software package to be installed.\n\n\n\nFunction Arguments\n\n\n\n\n\nParameter\n\n\n\nVariable Type\n\nDescription\n\n\n\n$DevWare\n\nObject\n\nHandle to DevWare program instance created by the Aptina_Init() function.\n\n\n\n$state\n\nString\n\nName of state variable to set.\n\n\n\n$value\n\nString\n\nString or integer value to set the state to.\n\n\n\n\n\nReturn Parameters\n\n\n\n\n\nParameter\n\n\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n--\n\n\n\n\n\nExample:\n\n//set numeric state\n\n$value= Aptina_GetState($DevWare, \"Display Zoom\");\n\nUpdateStatus(\"\\nState before:\");\n\nUpdateStatus($value);\n\nAptina_SetState($DevWare, \"Display Zoom\", 150);\n\n$value= Aptina_GetState($DevWare, \"Display Zoom\");\n\nUpdateStatus(\"State after:\");\n\nUpdateStatus($value);\n\n\n\n\n\n//set string state\n\n$value= Aptina_GetState($DevWare, \"WB Custom\");\n\nUpdateStatus(\"\\nState before:\");\n\nUpdateStatus($value);\n\nAptina_SetState($DevWare, \"WB Custom\", \"1 0 1 0 1 0 1 0 1\");\n\n$value= Aptina_GetState($DevWare, \"WB Custom\");\n\nUpdateStatus(\"State after:\");\n\nUpdateStatus($value);\n\n\n\n\n\nDH_CameraADCControl\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS DH_CameraADCControl": {
  "prefix": "DH_CameraADCControl",
  "body": [
   "DH_CameraADCControl($$Handle,$$ADCControlType,$$ADCLevel);"
  ],
  "description": "\n\nThis function is used to set the A/D transition type of the camera.\n\n\n\n\n\nNOTE: The device Handle is acquired from the function DH_CameraBegin.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nThe Handle of the device to be closed.\n\n\n\n$ADCControlType\n\nString\n\nThe A/D transition type.\n\nValues:\n\n\u00b7 \"ADC_BITS\"\n\n\u00b7 \"ADC_BLKLEVEL_CAL\"\n\n\u00b7 \"ADC_BLKLEVEL_CAL_REDCHANNEL\"\n\n\u00b7 \"ADC_BLKLEVEL_CAL_GREENCHANNEL1\"\n\n\u00b7 \"ADC_BLKLEVEL_CAL_GREENCHANNEL2\"\n\n\u00b7 \"ADC_BLKLEVEL_CAL_BLUECHANNEL\"\n\n\n\n$ADCLevel\n\nString\n\nThe A/D transition level.\n\nValues:\n\n\u00b7 \"ADC_LEVEL0\"\n\n\u00b7 \"ADC_LEVEL1\"\n\n\u00b7 \"ADC_LEVEL2\"\n\n\u00b7 \"ADC_LEVEL3\"\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone.\n\n\n\n\n\nExample:\n\n$ADCControlType = \"ADC_BITS\";\n\n$ADCLevel = \"ADC_LEVEL2\";\n\nDH_CameraADCControl($Handle, $ADCControlType, $ADCLevel);\n\n\n\n\n\nDH_CameraAGCControl\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS DH_CameraAGCControl": {
  "prefix": "DH_CameraAGCControl",
  "body": [
   "DH_CameraAGCControl($$Handle,$$AGCControlType,$$GainLevel);"
  ],
  "description": "\n\nThis function is used to set the Gain of the camera.\n\n\n\n\n\nNOTE: The device Handle is acquired from the function DH_CameraBegin.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nThe Handle of the device to be closed.\n\n\n\n$AGCControlType\n\nString\n\nThe A/D transition type.\n\nValues:\n\n\u00b7 \"AGC_GAIN_RED_CHANNEL\"\n\n\u00b7 \"AGC_GAIN_GREEN_CHANNEL1\"\n\n\u00b7 \"AGC_GAIN_GREEN_CHANNEL2\"\n\n\u00b7 \"AGC_GAIN_BLUE_CHANNEL\"\n\n\u00b7 \"AGC_GAIN\"\n\n\n\n$GainLevel\n\nInteger\n\nThe Gain Value.\n\nValues: 0 to 1023.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone.\n\n\n\n\n\nExample:\n\n$AGCControlType = \"ADC_GAIN\";\n\n$GainLevel = 50;\n\nDH_CameraAGCControl($Handle, $AGCControlType, $GainLevel);\n\n\n\n\n\nDH_CameraBegin\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS DH_CameraBegin": {
  "prefix": "DH_CameraBegin",
  "body": [
   "$$Handle=DH_CameraBegin($$deviceNumber);"
  ],
  "description": "\n\nThis function will initialize the camera driver and return a handle to the driver. This driver must be supplied to all other functions for DaHeng USB cameras.\n\n\n\n\n\nNOTE: The first camera device number is 1.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$deviceNumber\n\nInteger\n\nThe device number of the camera to initialize.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nThe device handle for all camera functions.\n\n\n\n\n\nExample:\n\n// Get the first DaHeng Camera Handle\n\n$Handle = DH_CameraBegin(1);\n\n\n\n\n\nDH_CameraClose\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS DH_CameraClose": {
  "prefix": "DH_CameraClose",
  "body": [
   "DH_CameraClose($$Handle);"
  ],
  "description": "\n\nThis function will close the camera specified by the device Handle.\n\n\n\n\n\nNOTE: The device Handle is acquired from the function DH_CameraBegin.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nThe Handle of the device to be closed.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone.\n\n\n\n\n\nExample:\n\nDH_CameraClose($Handle);\n\n\n\n\n\nDH_CameraEnableVideoMirror\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS DH_CameraEnableVideoMirror": {
  "prefix": "DH_CameraEnableVideoMirror",
  "body": [
   "DH_CameraEnableVideoMirror($$Handle,$$Direction,$$Enable);"
  ],
  "description": "\n\nThis function is used to set up image mirroring. The camera can mirror the image in the Horizontal, Vertical or Both directions.\n\n\n\n\n\nNOTE: The device Handle is acquired from the function DH_CameraBegin.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nThe Handle of the device to be closed.\n\n\n\n$Direction\n\nString\n\nThe direction of the mirroring.\n\nValues:\n\n\u00b7 \"FULL\"\n\n\u00b7 \"HOR\"\n\n\u00b7 \"VERT\"\n\n\n\n$Enable\n\nBoolean\n\n\u00b7 Set to \"true\" for returned images to be mirrored. \"false\" will turn off mirroring.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone.\n\n\n\n\n\nExample:\n\n$Handle = DH_CameraBegin(1);\n\nDH_CameraEnableVideoMirror($Handle, \"FULL\", true);\n\n\n\n\n\nDH_CameraGetBlankingSize\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS DH_CameraGetBlankingSize": {
  "prefix": "DH_CameraGetBlankingSize",
  "body": [
   "($$HorMin,$$HorMax,$$VertMin,$$VertMax)=DH_CameraGetBlankingSize($$Handle);"
  ],
  "description": "\n\nThis function is used to get the camera line blanking and field blanking size.\n\n\n\n\n\nNOTE: The device Handle is acquired from the function DH_CameraBegin.\n\nThis function only supports DaHeng's USB cameras and not the Firewire (IEEE 1394 bus) cameras.\n\nAll sizes are in pixels.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nThe Handle of the device to be closed.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$HorMin\n\nInteger\n\nThe horizontal minimum line blanking size.\n\n\n\n$HorMax\n\nInteger\n\nThe horizontal maximum line blanking size.\n\n\n\n$VertMin\n\nInteger\n\nThe vertical minimum field blanking size.\n\n\n\n$VertMax\n\nInteger\n\nThe vertical maximum field blanking size.\n\n\n\n\n\nExample:\n\n$Handle = DH_CameraBegin(1);\n\n($HorMin, $HorMax, $VertMin, $VertMax) = DH_CameraGetBlankingSize($Handle);\n\n\n\n\n\nDH_CameraSetBlanking\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS DH_CameraSetBlanking": {
  "prefix": "DH_CameraSetBlanking",
  "body": [
   "DH_CameraSetBlanking($$Handle,$$Hor,$$Vert);"
  ],
  "description": "\n\nThis function is used to set line blanking and field blanking.\n\n\n\n\n\nNOTE: The device Handle is acquired from the function DH_CameraBegin.\n\nThis function only supports DaHeng's USB cameras and not the Firewire (IEEE 1394 bus) cameras.\n\nAll sizes are in pixels.\n\nThe blanking ranges are acquired with the function DH_CameraGetBlankingSize\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nThe Handle of the device to be closed.\n\n\n\n$Hor\n\nInteger\n\nLine (horizontal) Blanking.\n\n\n\n$Vert\n\nInteger\n\nField (vertical) Blanking.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone.\n\n\n\n\n\nExample:\n\n$Handle = DH_CameraBegin(1);\n\nDH_CameraSetBlanking($Handle, $Hor, $Vert);\n\n\n\n\n\nDH_CameraSetExposureTime\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS DH_CameraSetExposureTime": {
  "prefix": "DH_CameraSetExposureTime",
  "body": [
   "DH_CameraSetExposureTime($$Handle,$$ExposureTime,$$TimeUnit);"
  ],
  "description": "\n\nThis function will set the exposure time for the DaHeng camera.\n\n\n\n\n\nNOTES:\n\n\u00b7 The device Handle is acquired from the function DH_CameraBegin.\n\n\u00b7 If using a MicroVisio camera use the function MicroVisio_CameraSetExposureTime.\n\n\u00b7 If you want to change the exposure time, you must close the camera and re-open it before setting the new exposure time.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nThe Handle of the device to be closed.\n\n\n\n$ExposureTime\n\nInteger\n\nThe Exposure Time to set the camera to.\n\n\n\n$TimeUnit\n\nString\n\nThe time unit for the exposure time.\n\nValues:\n\n\u00b7 \"us\"\n\n\u00b7 \"ms\"\n\n\u00b7 \"s\"\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone.\n\n\n\n\n\nExample:\n\n$ExposureTime = 20;\n\nDH_CameraSetExposureTime($Handle, $ExposureTime, \"ms\");\n\n\n\n\n\nDH_CameraSetOutput_Window\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS DH_CameraSetOutput_Window": {
  "prefix": "DH_CameraSetOutput_Window",
  "body": [
   "DH_CameraSetOutput_Window($$Handle,$$StartX,$$StartY,$$Width,$$Height);"
  ],
  "description": "\n\nThis function will set the camera Area of Interest (AOI).\n\n\n\n\n\nNOTE: The device Handle is acquired from the function DH_CameraBegin.\n\nThe starting point for the AOI is the top left corner of the area.\n\nThe AOI locations are in pixels.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nThe Handle of the device to be closed.\n\n\n\n$StartX\n\nInteger\n\nThe left edge of the AOI.\n\n\n\n$StartY\n\nInteger\n\nThe top edge of the AOI.\n\n\n\n$Width\n\nInteger\n\nThe width of the AOI. Counted from $StartX.\n\n\n\n$Height\n\nInteger\n\nThe height of the AOI. Counted from $StartY.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone.\n\n\n\n\n\nExample:\n\n$DHCameraNum = 1;\n\n$Handle = DH_CameraBegin($DHCameraNum);\n\n$ResolutionMode = \"RES_MODE0\";\n\nDH_CameraSetResolution($Handle, $ResolutionMode);\n\n$ADCControlType = \"ADC_BITS\";\n\n$ADCLevel = \"ADC_LEVEL2\";\n\nDH_CameraADCControl($Handle, $ADCControlType, $ADCLevel);\n\nDH_CameraSetOutput_Window($Handle, 0, 0, 800, 600);\n\nDH_CameraClose($Handle);\n\n\n\n\n\nDH_CameraSetResolution\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS DH_CameraSetResolution": {
  "prefix": "DH_CameraSetResolution",
  "body": [
   "DH_CameraSetResolution($$Handle,$$ResolutionMode);"
  ],
  "description": "\n\nThis function will set the resolution for the DaHeng camera.\n\n\n\n\n\nThere are four resolutions available. For a model HV3110FC camera the modes correspond to the following resolutions:\n\nMode0: 2048 x 1536\n\nMode1: 1024 x 768\n\nMode2: 512 x 384\n\nMode3: 256 x 192\n\n\n\n\n\nNOTE: The device Handle is acquired from the function DH_CameraBegin.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nThe Handle of the device to be closed.\n\n\n\n$ResolutionMode\n\nString\n\nThe resolution mode to set.\n\nValues\n\n\u00b7 \"RES_MODE0\"\n\n\u00b7 \"RES_MODE1\"\n\n\u00b7 \"RES_MODE2\"\n\n\u00b7 \"RES_MODE3\"\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone.\n\n\n\n\n\nExample:\n\n$DHCameraNum = 1;\n\n$Handle = DH_CameraBegin($DHCameraNum);\n\n$ResolutionMode = \"RES_MODE0\";\n\nDH_CameraSetResolution($Handle, $ResolutionMode);\n\nDH_CameraClose($Handle);\n\n\n\n\n\nDH_CameraSetShutterTime\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS DH_CameraSetShutterTime": {
  "prefix": "DH_CameraSetShutterTime",
  "body": [
   "DH_CameraSetShutterTime($$Handle,$$ShutterTime,$$ShutterTimeUnit);"
  ],
  "description": "\n\nThis function is used to set the shutter time for the camera.\n\n\n\n\n\nNOTE: The device Handle is acquired from the function DH_CameraBegin.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nThe Handle of the device to be closed.\n\n\n\n$ShutterTime\n\nInteger\n\nThe shutter time.\n\n\n\n$ShutterTimeUnit\n\nString\n\nThe time unit for the shutter time.\n\nValues:\n\n\u00b7 \"us\"\n\n\u00b7 \"ms\"\n\n\u00b7 \"s\"\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone.\n\n\n\n\n\nExample:\n\n$Handle = DH_CameraBegin(1);\n\nDH_CameraSetShutterTime($Handle, 100, \"ms\");\n\n\n\n\n\nDH_CameraSetSnapMode\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS DH_CameraSetSnapMode": {
  "prefix": "DH_CameraSetSnapMode",
  "body": [
   "DH_CameraSetSnapMode($$Handle,$$SnapMode);"
  ],
  "description": "\n\nThis function is used to set the snap mode for the camera.\n\n\n\n\n\nNOTE: The device Handle is acquired from the function DH_CameraBegin.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nThe Handle of the device to be closed.\n\n\n\n$SnapMode\n\nString\n\nThe Snap Mode.\n\nValues:\n\n\u00b7 \"CONTINUTATION\"\n\n\u00b7 \"TRIGGER\"\n\n\u00b7 \"TRIGGER_EDGE\"\n\n\u00b7 \"TRIGGER_LEVEL\"\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone.\n\n\n\n\n\nExample:\n\n$Handle = DH_CameraBegin(1);\n\nDH_CameraSetSnapMode($Handle, \"CONTINUATION\");\n\n\n\n\n\nDH_CameraSetSnapSpeed\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS DH_CameraSetSnapSpeed": {
  "prefix": "DH_CameraSetSnapSpeed",
  "body": [
   "DH_CameraSetSnapSpeed($$Handle,$$SnapSpeed);"
  ],
  "description": "\n\nThis function will set the snap speed for the DaHeng camera.\n\n\n\n\n\nDaHeng cameras have two snap speeds: Normal Speed and High Speed.\n\n\n\n\n\nNOTE: The device Handle is acquired from the function DH_CameraBegin.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nThe Handle of the device to be closed.\n\n\n\n$SnapSpeed\n\nString\n\nThe snap speed to set.\n\nValues:\n\n\u00b7 \"NORMAL_SPEED\"\n\n\u00b7 \"HIGH_SPEED\"\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone.\n\n\n\n\n\nExample:\n\n$DHCameraNum = 1;\n\n$Handle = DH_CameraBegin($DHCameraNum);\n\n$ResolutionMode = \"RES_MODE0\";\n\nDH_CameraSetResolution($Handle, $ResolutionMode);\n\n$SnapSpeed = \"HIGH_SPEED\";\n\nDH_CameraSetSnapSpeed($Handle, $SnapSpeed);\n\nDH_CameraClose($Handle);\n\n\n\n\n\nDH_CameraSnapShot\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS DH_CameraSnapShot": {
  "prefix": "DH_CameraSnapShot",
  "body": [
   "$$bitmap=DH_CameraSnapShot($$Handle,$$Width,$$Height);"
  ],
  "description": "\n\nThis function is used to snap a photo with the DaHeng camera.\n\n\n\n\n\nThe snap is returned as a gray-scale bitmap of size $Width x $Height.\n\n\n\n\n\nNOTE: The device Handle is acquired from the function DH_CameraBegin.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nThe Handle of the device to be closed.\n\n\n\n$Width\n\nInteger\n\nThe horizontal size of the returned bitmap in pixels.\n\n\n\n$Height\n\nInteger\n\nThe vertical size of the returned bitmap in pixels.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$bitmap\n\nObject\n\nThe returned gray-scale bitmap.\n\n\n\n\n\nExample:\n\n$DHCameraNum = 1;\n\n$Handle = DH_CameraBegin($DHCameraNum);\n\n$ResolutionMode = \"RES_MODE0\";\n\nDH_CameraSetResolution($Handle, $ResolutionMode);\n\n$ADCControlType = \"ADC_BITS\";\n\n$ADCLevel = \"ADC_LEVEL2\";\n\nDH_CameraADCControl($Handle, $ADCControlType, $ADCLevel);\n\nDH_CameraSetOutput_Window($Handle, 0, 0, $Width, $Height);\n\n$bitmap = DH_CameraSnapShot($Handle, $Width, $Height);\n\nDH_CameraClose($Handle);\n\n\n\n\n\nDH_CameraSnapShot_Color\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS DH_CameraSnapShot_Color": {
  "prefix": "DH_CameraSnapShot_Color",
  "body": [
   "$$bitmap=DH_CameraSnapShot_Color($$Handle,$$Width,$$Height);"
  ],
  "description": "\n\nThis function is used to snap a photo with the DaHeng camera.\n\n\n\n\n\nThe snap is returned as a color bitmap of size $Width x $Height.\n\n\n\n\n\nNOTE: The device Handle is acquired from the function DH_CameraBegin.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nThe Handle of the device to be closed.\n\n\n\n$Width\n\nInteger\n\nThe horizontal size of the returned bitmap in pixels.\n\n\n\n$Height\n\nInteger\n\nThe vertical size of the returned bitmap in pixels.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$bitmap\n\nObject\n\nThe returned color bitmap.\n\n\n\n\n\nExample:\n\n$DHCameraNum = 1;\n\n$Handle = DH_CameraBegin($DHCameraNum);\n\n$ResolutionMode = \"RES_MODE0\";\n\nDH_CameraSetResolution($Handle, $ResolutionMode);\n\n$ADCControlType = \"ADC_BITS\";\n\n$ADCLevel = \"ADC_LEVEL2\";\n\nDH_CameraADCControl($Handle, $ADCControlType, $ADCLevel);\n\nDH_CameraSetOutput_Window($Handle, 0, 0, $Width, $Height);\n\n$bitmap = DH_CameraSnapShot_Color($Handle, $Width, $Height);\n\nDH_CameraClose($Handle);\n\n\n\n\n\nMicroVisio_CameraSetExposureTime\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS MicroVisio_CameraSetExposureTime": {
  "prefix": "MicroVisio_CameraSetExposureTime",
  "body": [
   "MicroVisio_CameraSetExposureTime($$Handle,$$SnapSpeed,$$ResMode,$$BlankingHor,$$ExposureTime,$$TimeUnit);"
  ],
  "description": "\n\nThis function will set the exposure time for the MicroVisio camera.\n\n\n\n\n\nNOTES:\n\n\u00b7 The device Handle is acquired from the function DH_CameraBegin.\n\n\u00b7 If using a DaHen camera use the function DH_CameraSetExposureTime.\n\n\u00b7 If you want to change the exposure time, you must close the camera and re-open it before setting the new exposure time.\n\n\u00b7 This function is used for camera models HV1300UC and HV2000UC.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nThe Handle of the device to be closed.\n\n\n\n$SnapSpeed\n\nString\n\nThe snap speed to set the camera to.\n\nValues:\n\n\u00b7 \"NORMAL_SPEED\"\n\n\u00b7 \"HIGH_SPEED\"\n\n\n\n$RedMode\n\nString\n\nThe resolution of the image\n\nValues:\n\n\u00b7 \"RES_MODE0\"\n\n\u00b7 \"RES_MODE1\"\n\n\u00b7 \"RES_MODE2\"\n\n\u00b7 \"RES_MODE3\"\n\n\n\n$BlankingHor\n\nInteger\n\nThe horizontal blanking to set the camera to.\n\n\n\n$ExposureTime\n\nInteger\n\nThe Exposure Time to set the camera to.\n\n\n\n$TimeUnit\n\nString\n\nThe time unit for the exposure time.\n\nValues:\n\n\u00b7 \"us\"\n\n\u00b7 \"ms\"\n\n\u00b7 \"s\"\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone.\n\n\n\n\n\nExample:\n\n$ExposureTime = 20;\n\n$ResolutionMode = \"RES_MODE0\";\n\nMicroVisio_CameraSetExposureTime($Handle, \"HIGH_SPEED\", $ResolutionMode, 0, $ExposureTime, \"ms\");\n\n\n\n\n\ndPcit_NexeonHD_CaptureImage\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS dPict_NexeonHD_CaptureImage": {
  "prefix": "dPict_NexeonHD_CaptureImage",
  "body": [
   "$$Image=dPict_NexeonHD_CaptureImage($$DeviceHandle,$$Width,$$Height,$$ColorSpace,$$Output,$$Filename,$$Timeout);"
  ],
  "description": "\n\nThis function captures a frame from the dPict Nexeon HD PCI with the specified width and height. An optional fourth argument will specify the name of the file to save the bitmap image as.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$DeviceHandle\n\nObject\n\nThe handle of the device returned from the DekTeck_DTA112_Init function\n\n\n\n$Width\n\nInteger\n\nThe width (pixels) of the frame\n\n\n\n$Height\n\nInteger\n\nThe height (pixels) of the frame\n\n\n\n$ColorSpace\n\nString\n\nThe Image colorspace [RGB16,RGB24,RGB32]\n\n\n\n$Output\n\nBool\n\nDetermines if output image will be saved [TRUE,FALSE]\n\n\n\n$FileName\n\nString\n\nThe Bitmap file name to save the captured image (Optional)\n\n\n\n$Timeout\n\nInteger\n\nTimeout length (seconds) to wait for capturing a frame\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Image\n\nObject\n\nThe Bitmap object created by the capture (Of Type System.Drawing.Bitmap)\n\n\n\n\n\nExamples:\n\n$image = dPict_NexeonHD_CaptureImage($handle,1922,1080,\"RGB24\",TRUE,C:\\\\newBitmap.bmp\",1);\n\n\n\n\n\ndPict_NexeonHD_Close\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS dPict_NexeonHD_Close": {
  "prefix": "dPict_NexeonHD_Close",
  "body": [
   "dPict_NexeonHD_Close($$DeviceHandle);"
  ],
  "description": "\n\nThe close function terminates the software connection to the dPict Nexeon HD PCI card and de-allocates system resources. It detaches the device object from the device hardware.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$DeviceHandle\n\nObject\n\nThe handle of the device returned from the dPict_NexeonHD_Init function\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\ndPict_NexeonHD_Close($handle);\n\n\n\n\n\ndPict_NexeonHD_Init\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS dPict_NexeonHD_Init": {
  "prefix": "dPict_NexeonHD_Init",
  "body": [
   "dPict_NexeonHD_Init($$DeviceIndex);"
  ],
  "description": "\n\nThis function establishes a connection to the dPict Nexeon HD PCI card and attaches the device object to the device hardware.\n\n\n\n\n\nNote: It is generally a good programming habit to close the instrument handle when the program is done using the instrument. This can be done with the dPict_NexeonHD_Close function.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$DeviceIndex\n\nInteger\n\nZero-based index of the device to open\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$DeviceHandle\n\nObject\n\nThe handle of the device\n\n\n\n\n\nExamples:\n\n$DeviceHandle = dPict_NexeonHD_Init(0);\n\n\n\n\n\ndPict_NexeonHD_SetInput\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS dPict_NexeonHD_SetInput": {
  "prefix": "dPict_NexeonHD_SetInput",
  "body": [
   "dPict_NexeonHD_SetInput($$DeviceHandle,$$Input);"
  ],
  "description": "\n\nThis function sets the input type of the dPict Nexeon HD PCI.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$DeviceHandle\n\nObject\n\nThe handle of the device returned from the DekTeck_DTA112_Init function\n\n\n\n$Input\n\nString\n\nThe input standard [COMPOSITE,COMPONENT, HD, ANALOG]\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\ndPict_NexeonHD_SetInput($handle,\"COMPOSITE\");\n\n\n\n\n\nEpiphanFrmGrabber_Capture\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS EpiphanFrmGrabber_Capture": {
  "prefix": "EpiphanFrmGrabber_Capture",
  "body": [
   "$$Image=EpiphanFrmGrabber_Capture($$Grabber,$$SaveToFile,$$Filename);"
  ],
  "description": "\n\nThis function allows the captured image to be stored to the location and filename specified.\n\n\n\nRemarks:\n\nThis function requires the Epiphan drivers from Epiphan Systems to be installed.\n\nThis function is tested with a Epiphan VGA2PCIe device.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Grabber\n\nObject\n\nHandle to the Epiphan Frame Grabber card. Obtained from the EpiphanFrmGrabber_Init function.\n\n\n\n$SaveToFile\n\nBoolean\n\nWhether or not to save the image to a file.\n\n\n\n$Filename\n\nString\n\nPath and Filename to store the captured image.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Image\n\nObject\n\nThe captured image.\n\n\n\n\n\nExample:\n\n$Image = EpiphanFrmGrabber_Capture($Grabber, true, $Filename);\n\n\n\n\n\nEpiphanFrmGrabber_Close\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS EpiphanFrmGrabber_Close": {
  "prefix": "EpiphanFrmGrabber_Close",
  "body": [
   "EpiphanFrmGrabber_Close($$Grabber);"
  ],
  "description": "\n\nThis function closes the session with the Epiphan Frame Capture card and releases any memory or resources allocated to it.\n\n\n\nRemarks:\n\nThis function requires the Epiphan drivers from Epiphan Systems to be installed.\n\nThis function is tested with a Epiphan VGA2PCIe device.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Grabber\n\nObject\n\nHandle to the Epiphan Frame Grabber card. Obtained from the EpiphanFrmGrabber_Init function.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\nEpiphanFrmGrabber_Close($Grabber);\n\n\n\n\n\nEpiphanFrmGrabber_HorizontalShift\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS EpiphanFrmGrabber_HorizontalShift": {
  "prefix": "EpiphanFrmGrabber_HorizontalShift",
  "body": [
   "EpiphanFrmGrabber_HorizontalShift($$Grabber,$$HorizontalShift);"
  ],
  "description": "\n\nThis function sets the Horizontal Shift for the Epiphan Video Capture device.\n\n\n\nRemarks:\n\nThis function requires the Epiphan drivers from Epiphan Systems to be installed.\n\nThis function is tested with a Epiphan VGA2PCIe device.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Grabber\n\nObject\n\nHandle to the Epiphan Frame Grabber card. Obtained from the EpiphanFrmGrabber_Init function.\n\n\n\n$HorizontalShift\n\nInteger\n\nHorizontal shift (-200 to 200).\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\nEpiphanFrmGrabber_HorizontalShift($Grabber, 50);\n\n\n\n\n\nEpiphanFrmGrabber_Init\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS EpiphanFrmGrabber_Init": {
  "prefix": "EpiphanFrmGrabber_Init",
  "body": [
   "$$Grabber=EpiphanFrmGrabber_Init($$GrabberSerialNo);"
  ],
  "description": "\n\nThis function configures and returns a handle to the Epiphan Video Capture device.\n\n\n\nRemarks:\n\nThis function requires the Epiphan drivers from Epiphan Systems to be installed.\n\nThis function is tested with a Epiphan VGA2PCIe device.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$GrabberSerialNo\n\nString\n\nThe Serial Number of the Epiphan card to be used for frame capture.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Grabber\n\nObject\n\nA handle to the Epiphan capture card.\n\n\n\n\n\nExample:\n\n$Grabber = EpiphanFrmGrabber_Init(\"V2P81036\");\n\n\n\n\n\nEpiphanFrmGrabber_SetGain\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS EpiphanFrmGrabber_SetGain": {
  "prefix": "EpiphanFrmGrabber_SetGain",
  "body": [
   "EpiphanFrmGrabber_SetGain($$Grabber,$$Gain);"
  ],
  "description": "\n\nThis function sets the Gain for the capture card.\n\n\n\nRemarks:\n\nThis function requires the Epiphan drivers from Epiphan Systems to be installed.\n\nThis function is tested with a Epiphan VGA2PCIe device.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Grabber\n\nObject\n\nHandle to the Epiphan Frame Grabber card. Obtained from the EpiphanFrmGrabber_Init function.\n\n\n\n$Gain\n\nInteger\n\nGain value (0 to 255).\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\nEpiphanFrmGrabber_SetGain($Grabber, 42);\n\n\n\n\n\nEpiphanFrmGrabber_SetOffset\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS EpiphanFrmGrabber_SetOffset": {
  "prefix": "EpiphanFrmGrabber_SetOffset",
  "body": [
   "EpiphanFrmGrabber_SetOffset($$Grabber,$$Offset);"
  ],
  "description": "\n\nThis function sets the Offset for the Epiphan Video Capture device.\n\n\n\nRemarks:\n\nThis function requires the Epiphan drivers from Epiphan Systems to be installed.\n\nThis function is tested with a Epiphan VGA2PCIe device.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Grabber\n\nObject\n\nHandle to the Epiphan Frame Grabber card. Obtained from the EpiphanFrmGrabber_Init function.\n\n\n\n$Offset\n\nInteger\n\nHorizontal shift (0 to 63).\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\nEpiphanFrmGrabber_SetOffset($Grabber, 25);\n\n\n\n\n\nEpiphanFrmGrabber_SetPLLAdjustment\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS EpiphanFrmGrabber_SetPLLAdjustment": {
  "prefix": "EpiphanFrmGrabber_SetPLLAdjustment",
  "body": [
   "EpiphanFrmGrabber_SetPLLAdjustment($$Grabber,$$PLLAdjustment);"
  ],
  "description": "\n\nThis function sets the PLLAdjustment for the Epiphan Video Capture device.\n\n\n\nRemarks:\n\nThis function requires the Epiphan drivers from Epiphan Systems to be installed.\n\nThis function is tested with a Epiphan VGA2PCIe device.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Grabber\n\nObject\n\nHandle to the Epiphan Frame Grabber card. Obtained from the EpiphanFrmGrabber_Init function.\n\n\n\n$PLLAdjustment\n\nInteger\n\nPLL adjustment value (-300 to 300)\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\nEpiphanFrmGrabber_SetPLLAdjustment($Grabber, 200);\n\n\n\n\n\nEpiphanFrmGrabber_SetSamplingPhase\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS EpiphanFrmGrabber_SetSamplingPhase": {
  "prefix": "EpiphanFrmGrabber_SetSamplingPhase",
  "body": [
   "EpiphanFrmGrabber_SetSamplingPhase($$Grabber,$$SamplingPhase);"
  ],
  "description": "\n\nThis function sets the Sampling Phase for the Epiphan Video Capture device.\n\n\n\nRemarks:\n\nThis function requires the Epiphan drivers from Epiphan Systems to be installed.\n\nThis function is tested with a Epiphan VGA2PCIe device.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Grabber\n\nObject\n\nHandle to the Epiphan Frame Grabber card. Obtained from the EpiphanFrmGrabber_Init function.\n\n\n\n$SamplingPhase\n\nInteger\n\nSampling Phase value (0 to 31)\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\nEpiphanFrmGrabber_SetSamplingPhase($Grabber, 15);\n\n\n\n\n\nEpiphanFrmGrabber_SetVerticalShift\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS EpiphanFrmGrabber_SetVerticalShift": {
  "prefix": "EpiphanFrmGrabber_SetVerticalShift",
  "body": [
   "EpiphanFrmGrabber_SetVerticalShift($$Grabber,$$VerticalShift);"
  ],
  "description": "\n\nThis function sets the Sampling Phase for the Epiphan Video Capture device.\n\n\n\nRemarks:\n\nThis function requires the Epiphan drivers from Epiphan Systems to be installed.\n\nThis function is tested with a Epiphan VGA2PCIe device.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Grabber\n\nObject\n\nHandle to the Epiphan Frame Grabber card. Obtained from the EpiphanFrmGrabber_Init function.\n\n\n\n$VerticalShift\n\nInteger\n\nVertical Shift value (-35 to 35)\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\nEpiphanFrmGrabber_SetSamplingPhase($Grabber, -10);\n\n\n\n\n\nEuresys_CaptureImageToFile\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Euresys_CaptureImageToFile": {
  "prefix": "Euresys_CaptureImageToFile",
  "body": [
   "Euresys_CaptureImageToFile($$Channel,$$AcquisitionTimeout,$$DestinationFilename);"
  ],
  "description": "\n\n\n\n\n\nThis function captures an image from the supplied channel and saves to it the filename specified by the destination filename.\n\nIn order to use this function, the channel must be configured, and set to 'Active'.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Channel\n\nObject\n\nThe channel object on the Euresys Image Acquisition board to close.\n\n\n\n$AcquisitionTimeout\n\nInteger\n\nThe timeout limit for acquiring the image. If an acquisition fails in this time, a failure is returned by the function. This argument is supplied in milliseconds.\n\n\n\n$DestinationFilename\n\nString\n\nThe filename and path to save the image.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples: (Entire Euresys Operation)\n\nEuresys_Initialize();\n\n$Channel = Euresys_ConfigureChannel(0,\"VID2\",\"NTSC\",\"VIDEO\",\"RGB16\");\n\nEuresys_SetChannelState($Channel,\"ACTIVE\");\n\nEuresys_DisplayImageForm($Channel,\"Camera 1\");\n\nEuresys_CaptureImageToFile($Channel,1000,\"c:\\\\myfile.bmp\");\n\nEuresys_SetChannelState($Channel,\"IDLE\");\n\nEuresys_CloseChannel($Channel);\n\n\n\n\n\nSupported Instruments\n\nAll Supported Cameras and Euresys Image Acquisition Devices\n\n\n\n\n\nEuresys_CloseChannel\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Euresys_CloseChannel": {
  "prefix": "Euresys_CloseChannel",
  "body": [
   "Euresys_CloseChannel($$Channel);"
  ],
  "description": "\n\n\n\n\n\nThis function closes the image acquisition channel that was previously configured and initialized using the Euresys_ConfigureChannel command.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Channel\n\nObject\n\nThe channel object on the Euresys Image Acquisition board to close.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\nEuresys_CloseChannel\n\n\n\n\n\nSupported Instruments\n\nAll Supported Cameras and Euresys Image Acquisition Devices\n\n\n\n\n\nEuresys_ConfigureChannel\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Euresys_ConfigureChannel": {
  "prefix": "Euresys_ConfigureChannel",
  "body": [
   "$$Channel=Euresys_ConfigureChannel($$BoardNumber,$$ConnectorName,$$VideoFormat,$$AcquisitionMode,$$ColorFormat);"
  ],
  "description": "\n\n\n\n\n\nThis function configures and initializes a channel on a Euresys framegrabber or image acquisition card.\n\nBefore initializing a channel, you should call the Euresys_Initialize() function.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$BoardNumber\n\nInteger\n\nThe index number of the acquisition board on which you want to configure a channel.\n\n\n\n$ConnectorName\n\nString\n\nThe connector name on the acquisition board that you wish to initialize. For example, \"VID1\".\n\n\n\n$VideoFormat\n\nString\n\nThe video format for the camera connected to the acquisition channel. Allowable values are :\n\n\u00b7 \"NTSC\"\n\n\u00b7 \"PAL\"\n\n\n\n$AcqusitionMode\n\nString\n\nThe acquisiton mode of the channel you wish to configure. The allowable values are:\n\n\u00b7 \"VIDEO\"\n\n\u00b7 \"SNAPSHOT\"\n\n\n\n$ColorFormat\n\nString\n\nThe color format to configure for the acquisition channel. Supported color format values are:\n\n\u00b7 \"RAW8\"\n\n\u00b7 \"RGB24\"\n\n\u00b7 \"RGB16\"\n\n\u00b7 \"Y8\"\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Channel\n\nObject\n\nThe configured channel object to pass to subsequent euresys functions.\n\n\n\n\n\nExamples: (Entire Euresys Operation)\n\nEuresys_Initialize();\n\n$Channel = Euresys_ConfigureChannel(0,\"VID2\",\"NTSC\",\"VIDEO\",\"RGB16\");\n\nEuresys_SetChannelState($Channel,\"ACTIVE\");\n\nEuresys_DisplayImageForm($Channel,\"Camera 1\");\n\nEuresys_CaptureImageToFile($Channel,1000,\"c:\\\\myfile.bmp\");\n\nEuresys_SetChannelState($Channel,\"IDLE\");\n\nEuresys_CloseChannel($Channel);\n\n\n\n\n\nSupported Instruments\n\nAll Supported Cameras and Euresys Image Acquisition Devices\n\n\n\n\n\nEuresys_DisplayImageForm\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Euresys_DisplayImageForm": {
  "prefix": "Euresys_DisplayImageForm",
  "body": [
   "Euresys_DisplayImageForm($$Channel,$$WindowTitle);"
  ],
  "description": "\n\n\n\n\n\nThis function displays a model Windows form containing a live, continuously updated image from the supplied channel.\n\nThis functions blocks script execution until the window form is closed by the user.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Channel\n\nObject\n\nThe channel object on the Euresys Image Acquisition board to display.\n\n\n\n$WindowTitle\n\nString\n\nThe title to display on the Window\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\nEuresys_DisplayImageForm($Channel,\"Camera 1 Live Image\");\n\n\n\n\n\nSupported Instruments\n\nAll Supported Cameras and Euresys Image Acquisition Devices\n\n\n\n\n\nEuresys_Initialize\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Euresys_Initialize": {
  "prefix": "Euresys_Initialize",
  "body": [
   "Euresys_Initialize();"
  ],
  "description": "\n\n\n\n\n\nThis function activates the Euresys image acquisition library. This function should be called before running any other Euresys functions.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\nEuresys_Initialize();\n\n\n\n\n\nSupported Instruments\n\nAll Supported Cameras and Euresys Image Acquisition Devices\n\n\n\n\n\nEuresys_SetChannelState\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Euresys_SetChannelState": {
  "prefix": "Euresys_SetChannelState",
  "body": [
   "Euresys_SetChannelState($$Channel,$$ChannelState);"
  ],
  "description": "\n\n\n\n\n\nThis function sets the specified channel to either an Active or Idle state.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Channel\n\nObject\n\nThe channel object on the Euresys Image Acquisition board to set the state.\n\n\n\n$ChannelState\n\nString\n\nThe desired state of the Euresys Channel. Allowable values are:\n\n\u00b7 \"IDLE\"\n\n\u00b7 \"ACTIVE\"\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\nEuresys_SetChannelState($Channel,\"ACTIVE\");\n\n\n\n\n\nSupported Instruments\n\nAll Supported Cameras and Euresys Image Acquisition Devices\n\n\n\n\n\nIMAQ_AddConstant\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS IMAQ_AddConstant": {
  "prefix": "IMAQ_AddConstant",
  "body": [
   "$$destimage=IMAQ_AddConstant($$sourceimage,$$constant);"
  ],
  "description": "\n\nThis function adds a constant value to each pixel of an image.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$sourceimage\n\nObject\n\nIMAQ source image object.\n\n\n\n$constant\n\nFloat\n\nConstant value to add to each pixel.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$destimage\n\nObject\n\nResulting IMAQ image object.\n\n\n\n\n\nIMAQ.AddImages\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS IMAQ_AddImages": {
  "prefix": "IMAQ_AddImages",
  "body": [
   "$$destimage=IMAQ_AddImages($$sourceimage1,$$sourceimage2);"
  ],
  "description": "\n\nThis function adds two images together.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$sourceimage1\n\nObject\n\nIMAQ source image 1 object.\n\n\n\n$sourceimage2\n\nObject\n\nIMAQ source image 2 object.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$destimage\n\nObject\n\nResulting IMAQ image object.\n\n\n\n\n\nIMAQ_AndConstant\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS IMAQ_AndConstant": {
  "prefix": "IMAQ_AndConstant",
  "body": [
   "$$destimage=IMAQ_AndConstant($$sourceimage,$$constant,$$not);"
  ],
  "description": "\n\nThis function ANDs or NANDs a constant value with each pixel of an image.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$sourceimage\n\nObject\n\nIMAQ source image object.\n\n\n\n$constant\n\nFloat\n\nConstant value to AND or NAND with each pixel.\n\n\n\n$not\n\nBoolean\n\nIf True a NAND operation is performed. If False, a AND operation is performed.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$destimage\n\nObject\n\nResulting IMAQ image object.\n\n\n\n\n\nIMAQ_AndImages\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS IMAQ_AndImages": {
  "prefix": "IMAQ_AndImages",
  "body": [
   "$$destimage=IMAQ_AndImages($$sourceimage1,$$sourceimage2,$$not);"
  ],
  "description": "\n\nThis function ANDs or NANDS sourceimage1 and sourceimage2.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$sourceimage1\n\nObject\n\nIMAQ source image 1 object.\n\n\n\n$sourceimage2\n\nObject\n\nIMAQ source image 2 object\n\n\n\n$not\n\nBoolean\n\nIf True, a NAND operation is performed. If False, an AND operation is performed.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$destimage\n\nObject\n\nResulting IMAQ image object.\n\n\n\n\n\nIMAQ_Capture\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS IMAQ_Capture": {
  "prefix": "IMAQ_Capture",
  "body": [
   "$$image=IMAQ_Capture($$devicename);"
  ],
  "description": "\n\nThis function captures in image from the specified IMAQ device.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$devicename\n\nString\n\nDevice name of camera. This name is assigned by NI MAX.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$image\n\nObject\n\nIMAQ image object of the captured image.\n\n\n\n\n\nIMAQ_CaptureAndSaveUsingNoCam\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS IMAQ_CaptureAndSaveUsingNoCam": {
  "prefix": "IMAQ_CaptureAndSaveUsingNoCam",
  "body": [
   "$$image=IMAQ_CaptureAndSaveUsingNoCam($$Camfile,$$path);"
  ],
  "description": " This function captures an image from the NI capture card and save it as a bmp file to the specified location\n\nIt will also return back as an Image of the type IMAQ Image Function Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Camfile\n\nString\n\nThe file that has been configured to the card as image file\n\n\n\n$path\n\nString\n\nThe path and filename where the picture needs to be stored.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$image\n\nObject\n\nThe captured image as IMAQ image type\n\n\n\n\n\nExample:\n\n$image = IMAQ_CaptureAndSaveUsingNoCam(\"Img0\",\"c:\\\\captured.bmp\");\n\nThis example takes an image supplied to the NI card, without using a real camera, but using the Image file\n\nImg0 that has been set to the card.\n\nThe file will be stored as c:\\captured.bmp.\n\n\n\n\n\nIMAQ_CaptureAndSaveUsingNoCamBool\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS IMAQ_CaptureAndSaveUsingNoCamBool": {
  "prefix": "IMAQ_CaptureAndSaveUsingNoCamBool",
  "body": [
   "($$image,$$status)=IMAQ_CaptureAndSaveUsingNoCamBool($$Camfile,$$path);"
  ],
  "description": "\n\nThis function captures an image from the NI capture card and save it as a bmp file to the specified location\n\nIt will also return back as an Image of the type IMAQ Image and a Boolean status indicating the success or failure of the operation.\n\n\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Camfile\n\nString\n\nThe file that has been configured to the card as image file\n\n\n\n$path\n\nString\n\nThe path and filename where the picture needs to be stored.\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$image\n\nObject\n\nThe captured image as IMAQ image type\n\n\n\n$status\n\nBoolean\n\nTrue if image successfully saved, otherwise false.\n\n\n\n\n\nExample:\n\n$image = IMAQ_CaptureAndSaveUsingNoCam(\"Img0\",\"c:\\\\captured.bmp\");\n\nThis example takes an image supplied to the NI card, without using a real camera, but using the Image file\n\nImg0 that has been set to the card.\n\nThe file will be stored as c:\\captured.bmp.\n\n\n\n\n\nIMAQ_CaptureToClipboard\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS IMAQ_CaptureToClipBoard": {
  "prefix": "IMAQ_CaptureToClipBoard",
  "body": [
   "$$Image=IMAQ_CaptureToClipBoard($$Device);"
  ],
  "description": "\n\nThis function copies the captured Imaq Image to the clipboard, so it can be used by any other program.\n\nThe Image will also be returned from the function.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Device\n\nString\n\nThe NI interface name of the capture card.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Image\n\nObject\n\nThe captured image\n\n\n\n\n\nExample:\n\n$Image = IMAQ_CaptureToClipBoard(\"Img0\");\n\nThis example captures an image via Img0 and stores it into the clipboard.\n\nIt also returns it as object $Image.\n\n\n\n\n\nIMAQ_CaptureUsingNoCam\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS IMAQ_CaptureUsingNoCam": {
  "prefix": "IMAQ_CaptureUsingNoCam",
  "body": [
   "$$image=IMAQ_CaptureUsingNoCam($$Camfile);"
  ],
  "description": " This function captures an image from the NI capture card and\n\nreturned this as an Image of the type IMAQ Image Function Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Camfile\n\nString\n\nThe file that has been configured to the card as image file\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Image\n\nObject\n\nThe captured image as IMAQ image type\n\n\n\n\n\nExample:\n\n$image = IMAQ_CaptureUsingNoCam(\"Img0\");\n\nThis example takes an image supplied to the NI card, without using a real camera, but using the Image file\n\nImg0 that has been set to the card.\n\n\n\n\n\nIMAQ_Cast\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS IMAQ_Cast": {
  "prefix": "IMAQ_Cast",
  "body": [
   "$$destimage=IMAQ_Cast($$sourceimage,$$newtype);"
  ],
  "description": "\n\nThis function casts an image from one type to another.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$sourceimage\n\nObject\n\nSource IMAQ image object.\n\n\n\n$newtype\n\nString\n\nNew image type. Valid values are:\n\n\"U8\" = 8 bit unsigned monochrome.\n\n\"RGB\" = 32 bit RGB.\n\n\"HLS\" = 32 bit HLS.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$destimage\n\nObject\n\nIMAQ image object cast to the new image type.\n\n\n\n\n\nIMAQ_ColorBCGTransform\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS IMAQ_ColorBCGTransform": {
  "prefix": "IMAQ_ColorBCGTransform",
  "body": [
   "$$destimage=IMAQ_ColorBCGTransform($$sourceimage,$$redbrightness,$$redcontrast,$$redgamma,$$greenbrightness,$$greencontrast,$$greengamma,$$bluebrightnes,$$bluecontrast,$$bluegamma);"
  ],
  "description": "\n\nThis function performs a BCG transformation on the specified RGB image.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$sourceimage\n\nObject\n\nIMAQ sourc image object. This image must be a RGB image.\n\n\n\n$redbrightness\n\nFloat\n\nNew red plane brightness value. A value of 128 leaves the brightness unchanged. Values below 128 darken the image, and values above 128 brighten the image.\n\n\n\n$redcontrast\n\nFloat\n\nNew red plane contrast value. A value of 45 leaves the contrast unchanged. Values below 45 decrease the contrast, and values above 45 increase the contrast.\n\n\n\n$redgamma\n\nFloat\n\nNew red plane gamma value. A value of 1.0 is neutral. Values below 1.0 enhance contrast for darker pixels at the expense of brighter pixels. Values above 1.0 enhance contrast for brighter pixels at the expense of darker pixels.\n\n\n\n$greenbrightness\n\nFloat\n\nNew green plane brightness value. A value of 128 leaves the brightness unchanged. Values below 128 darken the image, and values above 128 brighten the image.\n\n\n\n$greencontrast\n\nFloat\n\nNew green plane contrast value. A value of 45 leaves the contrast unchanged. Values below 45 decrease the contrast, and values above 45 increase the contrast.\n\n\n\n$greengamma\n\nFloat\n\nNew green plane brightness value. A value of 128 leaves the brightness unchanged. Values below 128 darken the image, and values above 128 brighten the image.\n\n\n\n$bluebrightness\n\nFloat\n\nNew blue plane brightness value. A value of 128 leaves the brightness unchanged. Values below 128 darken the image, and values above 128 brighten the image.\n\n\n\n$bluecontrast\n\nFloat\n\nNew blue plane contrast value. A value of 45 leaves the contrast unchanged. Values below 45 decrease the contrast, and values above 45 increase the contrast.\n\n\n\n$bluegamma\n\nFloat\n\nNew blue plane brightness value. A value of 128 leaves the brightness unchanged. Values below 128 darken the image, and values above 128 brighten the image.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$destimage\n\nObject\n\nIMAQ image object of the transformed image.\n\n\n\n\n\nIMAQ_ColorTheshold\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS IMAQ_ColorThreshold": {
  "prefix": "IMAQ_ColorThreshold",
  "body": [
   "$$destimage=IMAQ_ColorThreshold($$sourceimage,$$plane1min,$$plane1max,$$plane2min,$$plane2max,$$plane3min,$$plane3max,$$newvalue);"
  ],
  "description": "\n\nThis function thresholds the specified RGB or HSL image.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$sourceimage\n\nObject\n\nIMAQ sourc image object. This image must be a RGB or an HSL image.\n\n\n\n$plane1min\n\nInteger\n\nMinimum value for plane 1 pixel range.\n\n\n\n$plane1max\n\nInteger\n\nMaximum value for plane 1 pixel range.\n\n\n\n$plane2min\n\nInteger\n\nMinimum value for plane 2 pixel range.\n\n\n\n$plane2max\n\nInteger\n\nMaximum value for plane 2 pixel range.\n\n\n\n$plane3min\n\nInteger\n\nMinimum value for plane 3 pixel range.\n\n\n\n$plane3max\n\nInteger\n\nMaximum value for plane 3 pixel range.\n\n\n\n$newvalue\n\nInteger\n\nValue for a pixel in U8 destination image if the pixel in all of the planes of the source image fall in the range specified for the plane.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$destimage\n\nObject\n\nIMAQ image object of the thresholded image. Note, the output of a color image threshold operation is a U8 image.\n\n\n\n\n\nIMAQ_CopyImage\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS IMAQ_CopyImage": {
  "prefix": "IMAQ_CopyImage",
  "body": [
   "$$destimage=IMAQ_CopyImage($$sourceimage);"
  ],
  "description": "\n\nThis function produces a copy of an image.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$sourceimage\n\nObject\n\nIMAQ source image object.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$destimage\n\nObject\n\nResulting IMAQ image object.\n\n\n\n\n\nIMAQ_ExtractColorPlanes\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS IMAQ_ExtractColorPlanes": {
  "prefix": "IMAQ_ExtractColorPlanes",
  "body": [
   "$$plane1,$$plane2,$$plane3=IMAQ_ExtractColorPlanes($$sourceimage);"
  ],
  "description": "\n\nThis function returns a U8 image for each of the three color planes of the source image.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$sourceimage\n\nObject\n\nSource IMAQ image object. This image type must be RGB or HLS.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$plane1\n\nObject\n\nU8 image representing plane 1 (Red for RGB images or Hue for HSL images) of the source image.\n\n\n\n$plane2\n\nObject\n\nU8 image representing plane 2 (Green for RGB images or Saturation for HSL images) of the source image.\n\n\n\n$plane3\n\nObject\n\nU8 image representing plane 3 (Blue for RGB images or Luminence for HSL images) of the source image.\n\n\n\n\n\nIMAQ_ExtractSingleColorPlane\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS IMAQ_ExtractSingleColorPlane": {
  "prefix": "IMAQ_ExtractSingleColorPlane",
  "body": [
   "$$NewImage=IMAQ_ExtractSingleColorPlane($$Image,$$Type);"
  ],
  "description": "\n\nThis function extracts a color plane from an IMAQ image and returns it into a new image\n\nRemarks:\n\nThis function requires Ni Vision runtime to be installed on the system. Function Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Image\n\nObject\n\noriginal Image of the type castable to IMAQ image.\n\n\n\n$Type\n\nString\n\nWhich colorplane to extract.\n\nvalid inputs are: BLUE, RED, GREEN, LUMINANCE, INTENSITY, HUE, SATURATION and VALUE\n\nThis input is case insensitive\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NewImage\n\nObject\n\nThe IMAQ image representing the colorplane extracted\n\n\n\n\n\nExample:\n\n$myNewImage = IMAQ_ExtractSingleColorPlane($image2,\"Luminance\")\n\nThis example will extract the luminance value of $image2 and convert it towards a new image called $myNewImage.\n\n\n\n\n\nIMAQ_GetColorHistogram\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS IMAQ_GetColorHistogram": {
  "prefix": "IMAQ_GetColorHistogram",
  "body": [
   "$$plane1,$$plane2,$$plane3=IMAQ_GetColorHistogram($$sourceimage,$$top,$$left,$$height,$$width);"
  ],
  "description": "\n\nThis function returns the histogram for each plane of the specified region in a color image.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$sourceimage\n\nObject\n\nSource IMAQ image object. This image type must be RGB or HLS.\n\n\n\n$top\n\nInteger\n\nTop edge of the region.\n\n\n\n$left\n\nInteger\n\nLeft edge of the region.\n\n\n\n$height\n\nInteger\n\nHeight of the region in pixels.\n\n\n\n$width\n\nInteger\n\nWidth of the region in pixels.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$plane1\n\nObject\n\nIMAQ histogram object for plane 1 of the image. This is the Red plane of an RGB image or the Hue plane of an HSL image.\n\n\n\n$plane2\n\nObject\n\nIMAQ histogram object for plane 2 of the image. This is the Green plane of an RGB image or the Saturation plane of an HSL image.\n\n\n\n$plane3\n\nObject\n\nIMAQ histogram object for plane 3 of the image. This is the Blue plane of an RGB image or the Luminance plane of an HSL image.\n\n\n\n\n\nIMAQ_GetHistogramField\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS IMAQ_GetHistogramField": {
  "prefix": "IMAQ_GetHistogramField",
  "body": [
   "$$fieldvalue=IMAQ_GetHistogramField($$histogram,$$field);"
  ],
  "description": "\n\nThis function returns the specified field of a histogram.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$histogram\n\nObject\n\nHistogram object to retrieve the field from\n\n\n\n$field\n\nString\n\nField to return. Value fields are \"MIN\", \"MAX\", \"MEAN\" and \"STDDEV\".\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$fieldvalue\n\nFloat\n\nRequested histogram field.\n\n\n\n\n\nIMAQ_GetMonoHistogram\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS IMAQ_GetMonoHistogram": {
  "prefix": "IMAQ_GetMonoHistogram",
  "body": [
   "$$histogram=IMAQ_GetMonoHistogram($$sourceimage,$$top,$$left,$$height,$$width);"
  ],
  "description": "\n\nThis function returns the histogram of the specified region in a monochrome image.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$sourceimage\n\nObject\n\nSource IMAQ image object. This image type must be a U8 image.\n\n\n\n$top\n\nInteger\n\nTop edge of the region.\n\n\n\n$left\n\nInteger\n\nLeft edge of the region.\n\n\n\n$height\n\nInteger\n\nHeight of the region in pixels.\n\n\n\n$width\n\nInteger\n\nWidth of the region in pixels.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$histogram\n\nObject\n\nIMAQ histogram object for U8 image.\n\n\n\n\n\nIMAQ_GetPixelValue\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS IMAQ_GetPixelValue": {
  "prefix": "IMAQ_GetPixelValue",
  "body": [
   "$$PixelValue=IMAQ_GetPixelValue($$SourceImage,$$PosX,$$PosY);"
  ],
  "description": "\n\nThis function returns the pixel value of a wanted xy position within an IMAQ picture. Function Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$SourceImage\n\nObject\n\nThe picture which is IMAQ format.\n\n\n\n$PosX\n\nInt\n\nThe x axis pixel position\n\n\n\n$PosY\n\nInt\n\nThe y axis pixel position.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$PixelValue\n\nFloat\n\nThe returned pixel value of the requested position.\n\n\n\n\n\nExample:\n\n$PixelValue = IMAQ_GetPixelValue($IMaqImage, 120,360 );\n\nReturns the pixel value from pixel at position 120, 360.\n\n\n\n\n\nIMAQ_GetPixelandSubtract\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS IMAQ_GetPixelandSubtract": {
  "prefix": "IMAQ_GetPixelandSubtract",
  "body": [
   "$$newImage=IMAQ_GetPixelandSubtract($$image,$$posX,$$posY);"
  ],
  "description": "\n\nThis function gets the color info from a pixel location and subtract this color from the total picture content.\n\nRemarks:\n\nPicture need to be of a IMAQIMAGE castable format. Function Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$image\n\nObject\n\nThe image to work on, must be from a IMAQIMAGE castable type like .bmp\n\n\n\n$posX\n\nInteger\n\nThe Pixel at X position\n\n\n\n$posY\n\nInteger\n\nThe Pixel at Y position.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$newImage\n\nObject\n\nThe returned image\n\n\n\n\n\nExample:\n\n$newImage = IMAQ_GetPixelandSubtract($image,10,85);\n\nThis example generates takes the color info from pixel at position x=10,y=85 and subtract it from\n\n$image and the new image will be returned as $newImage\n\n\n\n\n\nIMAQ_GrabPixelRGBValue\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS IMAQ_GrabPixelRGBValue": {
  "prefix": "IMAQ_GrabPixelRGBValue",
  "body": [
   "($$Red,$$Green,$$Blue)=IMAQ_GrabPixelRGBValue($$Interface,$$PixelXValue,$$PixelYValue);"
  ],
  "description": "\n\nThis function requires National Instruments NI-Imaq 3.1 or later.\n\nYou have to define an interface in the MAX explorer. This interface contains the settings:\n\n\u00b7 Acquisition window: left, top, width, height.\n\n\u00b7 Frame timeout\n\n\u00b7 White level\n\n\u00b7 Image representation\n\nThis function opens an interface by name $Interface as specified in Measurement & Automation Explorer (MAX).\n\nThe function will return an error when the $Interface is already opened or used.\n\nThe function will grab the content on the input and returns the R,G and B value of the requested pixel (according the $PixelXValue and the $PixelYValue).\n\nRemarks:\n\nThis function is tested with a NI PCI-1411 device.\n\nResult:\n\n($Red, $Green, $Blue) = IMAQ_GrabPixelRGBValue($Interface, $PixelXValue, $PixelYValue);\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Interface\n\nString\n\nThe name of the NI-Imaq interface created in MAX explorer. This interface is saved in a file and contains all the settings for this interface.\n\n\n\n$PixelXValue\n\ninteger\n\nThe X coordinate of the pixel (like in MAX explorer)\n\n\n\n$PixelYValue\n\ninteger\n\nThe Y coordinate of the pixel (like in MAX explorer)\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Red\n\nInteger\n\nThe red value of the pixel at $PixelXValue and $PixelYValue.\n\n\n\n$Green\n\nInteger\n\nThe green value of the pixel at $PixelXValue and $PixelYValue.\n\n\n\n$Blue\n\nInteger\n\nThe blue value of the pixel at $PixelXValue and $PixelYValue.\n\n\n\n\n\nExample:\n\nIn this example I want to have the color values of the pixel at X = 513 and Y = 128. The interface is \"PAL\". After executing the function, I can validate the values or own value. I'm measuring in a red colorbar.\n\n\n\n($Red, $Green, $Blue) = IMAQ_GrabPixelRGBValue(\"PAL\", 513, 128);\n\nNumericLimitTest($Red, 180, 255);\n\nNumericLimitTest($Green, 1, 5);\n\nNumericLimitTest($Blue, 1, 5);\n\n\n\n\n\nIMAQ_Inverse\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS IMAQ_Inverse": {
  "prefix": "IMAQ_Inverse",
  "body": [
   "$$DestImage=IMAQ_Inverse($$SourceImage);"
  ],
  "description": "\n\nThis function returns the Inverse picture of the provided IMAQ picture. Function Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$SourceImage\n\nObject\n\nThe picture which is IMAQ format.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$DestImage\n\nObject\n\nThe returned inversed IMAQ picture.\n\n\n\n\n\nExample:\n\n$destimage = IMAQ_Inverse($image);\n\nReturns the $destimage as being the reverse of $image. Both are in IMAQ format\n\n\n\n\n\nIMAQ_LoadImageFromFile\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS IMAQ.LoadImageFromFile": {
  "prefix": "IMAQ.LoadImageFromFile",
  "body": [
   "$$image=IMAQ.LoadImageFromFile($$filename);"
  ],
  "description": "\n\nThis function loads an image file into an IMAQ image object.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$filename\n\nString\n\nImage file name\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$image\n\nObject\n\nIMAQ image object of the specified file.\n\n\n\n\n\nIMAQ_MonoBCGTransform\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS IMAQ.MonoBCGTransform": {
  "prefix": "IMAQ.MonoBCGTransform",
  "body": [
   "$$destimage=IMAQ.MonoBCGTransform($$sourceimage,$$brightness,$$contrast,$$gamma);"
  ],
  "description": "\n\nThis function performs a BCG transformation on the specified U8 image.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$sourceimage\n\nObject\n\nIMAQ source image object. This image must be a U8 image.\n\n\n\n$brightness\n\nFloat\n\nNew brightness value. A value of 128 leaves the brightness unchanged. Values below 128 darken the image, and values above 128 brighten the image.\n\n\n\n$contrast\n\nFloat\n\nNew contrast value. A value of 45 leaves the contrast unchanged. Values below 45 decrease the contrast, and values above 45 increase the contrast.\n\n\n\n$gamma\n\nFloat\n\nNew gamma value. A value of 1.0 is neutral. Values below 1.0 enhance contrast for darker pixels at the expense of brighter pixels. Values above 1.0 enhance contrast for brighter pixels at the expense of darker pixels.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$destimage\n\nObject\n\nIMAQ image object of the transformed image.\n\n\n\n\n\nIMAQ_MonoThreshold\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS IMAQ_MonoThreshold": {
  "prefix": "IMAQ_MonoThreshold",
  "body": [
   "$$destimage=IMAQ_MonoThreshold($$sourceimage,$$minvalue,$$maxvalue,$$usenew,$$newvalue);"
  ],
  "description": "\n\nThis function thresholds the specified U8 image.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$sourceimage\n\nObject\n\nIMAQ source image object. This image must be a U8 image.\n\n\n\n$minvalue\n\nInteger\n\nMinimum value for pixel range.\n\n\n\n$maxvalue\n\nInteger\n\nMaximum value for pixel range.\n\n\n\n$usenew\n\nBoolean\n\nUse new value flag. If this parameter is True all pixels in range are set to the new value. If this parameter is False, all pixels in range are left unchanged. Pixels outside of the range are set to 0.\n\n\n\n$newvalue\n\nInteger\n\nNew value for pixels in range if $usenew is True.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$destimage\n\nObject\n\nIMAQ image object of the thresholded image.\n\n\n\n\n\nIMAQ_OCR_Reading\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS IMAQ_OCR_Reading": {
  "prefix": "IMAQ_OCR_Reading",
  "body": [
   "$$TheAnswer=IMAQ_OCR_Reading($$Image,$$ABCfilename,$$LeftPos,$$TopPos,$$WidthPos,$$HeightPos);"
  ],
  "description": "\n\nThis function will read Text out of a Picture. NI software needs to be installed. Vision runtime engine This function will in fact shrink the image to the ROI (region of interest) which is determined by $LeftPos,$TopPos,$WidthPos and $HeigthPos. And then do a read out of the text inside that shrinked image. In order to be able to have a good read out, an ABC file needs to be generated by the vision software from NI, in order to supply towards this function. Function Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Image\n\nObject\n\nThe image in which you need to read text.Only images which are castable towards an CWIMAQImage are allowed. e.g. .bmp\n\n\n\n$ABCfilename\n\nString\n\nPath and file name of the ABC file needed to translate the reading to text.\n\n\n\n$LeftPos\n\nInteger\n\nThe Left value of the window to what the image will be cropped.\n\n\n\n\n\n$TopPos\n\nInteger\n\nThe Top value of the window to what the image will be cropped.\n\n\n\n$WidthPos\n\nInteger\n\nThe Width value of the window to what the image will be cropped.\n\n\n\n$HeigthPos\n\nInteger\n\nThe Heighth value of the window to what the image will be cropped.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$TheAnswer\n\nString\n\nThe text that was read out of the to ROI 'shrinked' image\n\n\n\n\n\nExample:\n\n$TheAnswer = IMAQ_OCR_Reading($image,\"c:\\\\visionoef\\\\menuOCR.abc\",150,105,80,18);\n\nThis example Reads text inside the $image picture, by shrinking the image to the supplied dimensions of the ROI and reading all the data it recognizes while using the menuOCR.abc file.\n\n\n\n\n\nIMAQ_OCR_Reading2\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS IMAQ_OCR_Reading2": {
  "prefix": "IMAQ_OCR_Reading2",
  "body": [
   "$$TheAnswer=IMAQ_OCR_Reading2($$Image,$$ABCfilename,$$LeftPos,$$TopPos,$$WidthPos,$$HeightPos);"
  ],
  "description": "\n\nThis function will read Text out of a Picture. NI software needs to be installed. Vision runtime engine This function will use the ROI to locate the position where the text will be read out. Imaq_OCR_Reading2, will not shrink the picture to the ROI as the function IMAQ_OCR_Reading does. The ROI is determined by $LeftPos,$TopPos,$WidthPos and $HeigthPos. Text will be read out directly in the ROI. In order to be able to have a good read out, an ABC file needs to be generated by the vision software from NI, in order to supply towards this function. Function Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Image\n\nObject\n\nThe image in which you need to read text.Only images which are castable towards an CWIMAQImage are allowed. e.g. .bmp\n\n\n\n$ABCfilename\n\nString\n\nPath and file name of the ABC file needed to translate the reading to text.\n\n\n\n$LeftPos\n\nInteger\n\nThe Left value of the ROI window.\n\n\n\n\n\n$TopPos\n\nInteger\n\nThe Top value of the ROI window.\n\n\n\n$WidthPos\n\nInteger\n\nThe Width value of the ROI window.\n\n\n\n$HeigthPos\n\nInteger\n\nThe Height value of the ROI window.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$TheAnswer\n\nString\n\nThe text that was read out, in the ROI\n\n\n\n\n\nExample:\n\n$TheAnswer = IMAQ_OCR_Reading2($image,\"c:\\\\visionoef\\\\menuOCR.abc\",150,105,80,18);\n\nThis example Reads text inside the $image picture, by by using the ROI supplied to the function menuOCR.abc file is used to translate the readings into text.\n\n\n\n\n\nIMAQ_ReadFromClipBoard\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS IMAQ_ReadFromClipBoard": {
  "prefix": "IMAQ_ReadFromClipBoard",
  "body": [
   "$$Image=IMAQ_ReadFromClipBoard($$Device);"
  ],
  "description": "\n\nThis function Reads the Imaq Image from the clipboard,\n\nWhich was placed into the clipboard by the function IMAQ_CaptureToClipBoard Function Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Device\n\nString\n\nThe NI interface name of the capture card.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Image\n\nObject\n\nThe Imaq Image read from the ClipBoard\n\n\n\n\n\nExample:\n\n$Image = IMAQ_ReadFromClipBoard(\"Img0\");\n\nThis example loads the $Image object from to the clipboard.\n\nImg0 is the interface or camfile of the NI capture card which was used to store the function into the clipboard in the first place.\n\n\n\n\n\nIMAQ_ReplaceColorPlanes\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS IMAQ.ReplaceColorPlanes": {
  "prefix": "IMAQ.ReplaceColorPlanes",
  "body": [
   "$$destination=IMAQ.ReplaceColorPlanes($$plane1,$$plane2,$$plane3,$$colorspace);"
  ],
  "description": "\n\nThis function replaces the three U8 images representing the three color planes in the destination image.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$plane1\n\nObject\n\nU8 image representing plane 1 of the color image (Red plane for RGB images or Hue plane for HSL images).\n\n\n\n$plane2\n\nObject\n\nU8 image representing plane 2 of the color image (Green plane for RGB images or Saturation plane for HSL images).\n\n\n\n$plane3\n\nObject\n\nU8 image representing plane 3 of the color image (Blue plane for RGB images or Luminence plane for HSL images).\n\n\n\n$colorspace\n\nString\n\nColor space of destination image. Must be \"RGB\" or \"HSL\".\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$destination\n\nObject\n\nColor image containing the information from the three color planes. The color space of this image will be what was specified above.\n\n\n\n\n\nIMAQ_Resample\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS IMAQ_Resample": {
  "prefix": "IMAQ_Resample",
  "body": [
   "$$destimage=IMAQ_Resample($$sourceimage,$$method,$$newWidth,$$newHeight);"
  ],
  "description": "\n\nThis function performs a resample operation on an image.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$sourceimage\n\nObject\n\nIMAQ source image object.\n\n\n\n$method\n\nInteger\n\nResample Method\n\n0 = BiLinear\n\n1 = Cubic\n\n2 = Quadratic\n\n3 = Zero Order\n\n\n\n$newWidth\n\nInteger\n\nNew width for image.\n\n\n\n$newHeight\n\nInteger\n\nNew height for image.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$destimage\n\nObject\n\nResulting IMAQ image object.\n\n\n\n\n\nIMAQ_SubtractConstant\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS IMAQ_SubtractConstant": {
  "prefix": "IMAQ_SubtractConstant",
  "body": [
   "$$destimage=IMAQ_SubtractConstant($$sourceimage,$$constant);"
  ],
  "description": "\n\nThis function subtracts a constant value from each pixel of an image.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$sourceimage\n\nObject\n\nIMAQ source image object.\n\n\n\n$constant\n\nFloat\n\nConstant value to subtract from each pixel.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$destimage\n\nObject\n\nResulting IMAQ image object.\n\n\n\n\n\nIMAQ_SubtractImages\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS IMAQ_SubtractImages": {
  "prefix": "IMAQ_SubtractImages",
  "body": [
   "$$destimage=IMAQ_SubtractImages($$sourceimage1,$$sourceimage2);"
  ],
  "description": "\n\nThis function subtracts sourceimage2 from sourceimage1.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$sourceimage1\n\nObject\n\nIMAQ source image 1 object.\n\n\n\n$sourceimage2\n\nObject\n\nIMAQ source image 2 object\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$destimage\n\nObject\n\nResulting IMAQ image object.\n\n\n\n\n\nIMAQ_VisionGoldenTemplate\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS IMAQ_VisionGoldenTemplate": {
  "prefix": "IMAQ_VisionGoldenTemplate",
  "body": [
   "$$Errors=IMAQ_VisionGoldenTemplate($$Image,$$GoldenTemplate,$$pathGoldenTemplate,$$Angle,$$Scale,$$X,$$Y,$$BrigthThreshHold,$$DarkThreshHold,$$EdgeThicknessToIgnore,$$ErrorWidth,$$ErrorHeigth);"
  ],
  "description": "\n\nThis function needs the NI Vision Runtime to be installed on the system.\n\nThis functions can be used to compare an image with a previous defined golden template.\n\nIt is used to detects differences between 2 images of the type IMAQIMAGE\n\nAdditional parameters can be set, to allow some differences on bright, dark and edge thickness. Also Error Width and Height can be used to specify a minimum size of an error to be detected.\n\nRemarks:\n\nVision Developments needs NI Vision Assistant to create goldentemplates and other parameters. .\n\nResult: Function Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Image\n\nObject\n\nThis is the Image which you want to compare.Needs to be a IMAQIMAGE castable image, e.g. bmp\n\n\n\n$GoldenTemplate\n\nObject\n\nThis is the goldentemplate image .png file, generated via Vision Assistant\n\n\n\n$PathGoldenTemplate\n\nString\n\nPath + extension of the goldentemplate file\n\n\n\n$Angle\n\nInteger\n\nThe rotate angle of the window to be validated\n\n\n\n$Scale\n\nInteger\n\nThe scale factor\n\n\n\n$X\n\nFloat\n\nHeight of the comparision area\n\n\n\n$Y\n\nFloat\n\nWidth of the comparision area\n\n\n\n$BrigthThreshHold\n\nDouble\n\nThreshHold for detecting bright errors\n\n\n\n$DarkThreshHold\n\nDouble\n\nThreshHold for detecting dark errors\n\n\n\n$EdgeThicknessToIgnore\n\nDouble\n\nA certain thickness of edges to ignore\n\n\n\n$ErrorWidth\n\nInteger\n\nMin of error pixels to count as an error\n\n\n\n$ErrorHeigth\n\nInteger\n\nMin of error pixels to count as an error\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Errors\n\nInteger\n\nNumber of mismatches\n\n\n\n\n\nExample:\n\n$myErrors = IMAQ_VisionGoldenTemplate($myNewImage ,$image1,$pathwithExtension,0,100,$X,$Y,30,30,1,5,5);\n\nRemark: It might be needed to cast you image to a Luminance type before using the IMAQ_VisionGoldenTemplate\n\nThis depends on the development in the vision assistant and the technique that is used. Example: $myNewImage = IMAQ_ExtractSingleColorPlane($image2,\"Luminance\")\n\n\n\n\n\nIMAQ_WriteBMPFile\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS IMAQ_WriteBMPFile": {
  "prefix": "IMAQ_WriteBMPFile",
  "body": [
   "IMAQ_WriteBMPFile($$image,$$filename);"
  ],
  "description": "\n\nThis function writes the specified IMAQ image object to the specified BMP file.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$image\n\nObject\n\nIMAQ image object to write to the file\n\n\n\n$filename\n\nString\n\nFile name for the image.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$none\n\n\n\n\n\nIMAQ1394.Capture\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS IMAQ1394.Capture": {
  "prefix": "IMAQ1394.Capture",
  "body": [
   "$$image=IMAQ1394.Capture($$cameraobject,$$framecount,$$frameindex);"
  ],
  "description": "\n\nThis function captures an image from an IEEE1394 camera\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$cameraobject\n\nObject\n\nCamera object returned by IMAQ1394_OpenCamera.\n\n\n\n$framecount\n\nInteger\n\nNumber of frames to capture.\n\n\n\n$frameindex\n\nInteger\n\nFrame number to return to script.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$image\n\nObject\n\nIMAQ image object of the specified frame.\n\n\n\n\n\nIMAQ1394.CloseCamera\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS IMAQ1394.CloseCamera": {
  "prefix": "IMAQ1394.CloseCamera",
  "body": [
   "IMAQ1394.CloseCamera($$cameraobject);"
  ],
  "description": "\n\nThis function closes a session with an IEEE1394 camera.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$cameraobject\n\nObject\n\nCamera object returned by IMAQ1394_OpenCamera.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$none\n\n\n\n\n\nIMAQ1394.GetCameraAttribute\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS IMAQ1394.GetCameraAttribute": {
  "prefix": "IMAQ1394.GetCameraAttribute",
  "body": [
   "$$attributevalue=IMAQ1394.GetCameraAttribute($$cameraobject,$$attributenumber);"
  ],
  "description": "\n\nThis function gets the specified attribute of an IEEE1394 camera.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$cameraobject\n\nObject\n\nCamera object returned by IMAQ1394_OpenCamera.\n\n\n\n$attributenumber\n\nInteger\n\nIndex of attribute to set. Valid values will depend on the camera being used.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$attributevalue\n\nInteger\n\nValue of attribute.\n\n\n\n\n\nIMAQ1394.OpenCamera\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS IMAQ1394.OpenCamera": {
  "prefix": "IMAQ1394.OpenCamera",
  "body": [
   "$$cameraobject=IMAQ1394.OpenCamera($$devicename);"
  ],
  "description": "\n\nThis function opens a session with the specified IEEE1394 camera.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$devicename\n\nString\n\nName of camera. This name is assigned by NI MAX\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$cameraobject\n\nObject\n\nAn instance of a camera object is returned to the script.\n\n\n\n\n\nIMAQ1394.SetCameraAttribute\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS IMAQ1394.SetCameraAttribute": {
  "prefix": "IMAQ1394.SetCameraAttribute",
  "body": [
   "IMAQ1394.SetCameraAttribute($$cameraobject,$$attributenumber,$$attributevalue);"
  ],
  "description": "\n\nThis function sets the specified attribute of an IEEE1394 camera to the specified value..\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$cameraobject\n\nObject\n\nCamera object returned by IMAQ1394_OpenCamera.\n\n\n\n$attributenumber\n\nInteger\n\nIndex of attribute to set. Valid values will depend on the camera being used.\n\n\n\n$attributevalue\n\nInteger\n\nValue for attribute.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$none\n\n\n\n\n\nScanWorks_CallAction\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ScanWorks_CallAction": {
  "prefix": "ScanWorks_CallAction",
  "body": [
   "ScanWorks_CallAction($$ProjectName,$$DesignName,$$MappingName,$$ActionName);"
  ],
  "description": "\n\nNote: This function requires for the Scanworks package to be installed on the test station. This function merely calls the existing COM server that is part of the scanworks package.\n\nThis function is used to run a specific action in a scanworks project, and retrieve a diagnosis. The script will generate a failing result if any of the supplied parameters (Project, Design, Mapping Name, Action Name) can't be found in the Scanworks environment. A passing result is generated in the event of a successful action.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ProjectName\n\nString\n\nThe name of the Scanworks project to load.\n\n\n\n$DesignName\n\nString\n\nThe name of the design in the supplied Scanworks project.\n\n\n\n$MappingName\n\nString\n\nThe name of the mapping name in the supplied Scanworks project.\n\n\n\n$ActionName\n\nString\n\nThe name of the action in the supplied Scanworks project.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nScanWorks_Connect\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ScanWorks_Connect": {
  "prefix": "ScanWorks_Connect",
  "body": [
   "ScanWorks_Connect();"
  ],
  "description": "\n\nNote: This function requires for the Scanworks package to be installed on the test station. This function merely calls the existing COM server that is part of the scanworks package.\n\nThis function is used establish connection for a scanworks project. A passing result is generated in the event of a successful action.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$N/A\n\nN/A\n\nNo Arguments are required for this function\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nScanWorks_Disconnect\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ScanWorks_Disconnect": {
  "prefix": "ScanWorks_Disconnect",
  "body": [
   "ScanWorks_Disconnect();"
  ],
  "description": "\n\nNote: This function requires for the Scanworks package to be installed on the test station. This function merely calls the existing COM server that is part of the scanworks package.\n\nThis function is used Tear down connection for a scanworks project. A passing result is generated in the event of a successful action.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$N/A\n\nN/A\n\nNo Arguments are required for this function\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nScanworks_RunSequence\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ScanWorks_RunSequence": {
  "prefix": "ScanWorks_RunSequence",
  "body": [
   "ScanWorks_RunSequence($$ProjectName,$$DesignName,$$SequenceName);Note:ThisfunctionrequiresfortheScanworkspackagetobeinstalledbeforeitcanbeused.ThisfunctioncallstheexistingCOMserverthatispartoftheScanworkspackage."
  ],
  "description": "\n\nThis function executes the sequence specified. If the function fails and a summary report is available, it will be dropped as the failure message to the report writer collection.\n\n\n\n\n\nBefore this function can be used, the ScanWorks instance must first be opened using the ScanWorks_Connect function. After this function has been completed, the Scanworks instance should be closed using the Scanworks_Disconnect function.\n\nFunction Arguments\n\n\n\n$ProjectName\n\nString\n\nThe name of the project name to load which contains the sequence to be executed.\n\n\n\n$DesignName\n\nString\n\nThe name of the design name to load which contains the sequence to be executed.\n\n\n\n$SequenceName\n\nString\n\nThe name of the sequence to execute.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nScanworks_RunSequenceBOOL\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ScanWorks_RunSequenceBOOL": {
  "prefix": "ScanWorks_RunSequenceBOOL",
  "body": [
   "$$TestPassed=ScanWorks_RunSequenceBOOL($$ProjectName,$$DesignName,$$SequenceName);Note:ThisfunctionrequiresfortheScanworkspackagetobeinstalledbeforeitcanbeused.ThisfunctioncallstheexistingCOMserverthatispartoftheScanworkspackage."
  ],
  "description": "\n\nThis function executes the sequence specified. If the function fails and a summary report is available, it will be dropped as the failure message to the report writer collection. This function will always return a passing result, regardless of the test status. The pass/fail information in this function is returned as a boolean variable back to the test script.\n\n\n\n\n\nBefore this function can be used, the ScanWorks instance must first be opened using the ScanWorks_Connect function. After this function has been completed, the Scanworks instance should be closed using the ScanWorks_Disconnect function.\n\nFunction Arguments\n\n\n\n$ProjectName\n\nString\n\nThe name of the project name to load which contains the sequence to be executed.\n\n\n\n$DesignName\n\nString\n\nThe name of the design name to load which contains the sequence to be executed.\n\n\n\n$SequenceName\n\nString\n\nThe name of the sequence to execute.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$TestPassed\n\nBoolean\n\nA boolean variable indicating if the test passed or failed. If the test fails to execute properly, this value will also be set as a failing result.\n\n\n\n\n\nScanworks_RunTest\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ScanWorks_RunTest": {
  "prefix": "ScanWorks_RunTest",
  "body": [
   "ScanWorks_RunTest($$ProjectName,$$DesignName,$$MappingName,$$ActionName);"
  ],
  "description": "\n\nNote: This function requires for the Scanworks package to be installed on the test station. This function merely calls the existing COM server that is part of the scanworks package.\n\nThis function is used to run a specific action in a scanworks project, and retrieve a diagnosis. The script will generate a failing result if any of the supplied parameters (Project, Design, Mapping Name, Action Name) can't be found in the Scanworks environment. A passing result is generated in the event of a successful action.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ProjectName\n\nString\n\nThe name of the Scanworks project to load.\n\n\n\n$DesignName\n\nString\n\nThe name of the design in the supplied Scanworks project.\n\n\n\n$MappingName\n\nString\n\nThe name of the mapping name in the supplied Scanworks project.\n\n\n\n$ActionName\n\nString\n\nThe name of the action in the supplied Scanworks project.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nScanworks_RunTestBool\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ScanWorks_RunTestBool": {
  "prefix": "ScanWorks_RunTestBool",
  "body": [
   "$$Result=ScanWorks_RunTestBool($$ProjectName,$$DesignName,$$MappingName,$$ActionName);"
  ],
  "description": "\n\nNote: This function requires for the Scanworks package to be installed on the test station. This function merely calls the existing COM server that is part of the scanworks package.\n\nThis function is used to run a specific action in a scanworks project, and retrieve a diagnosis. The script will generate a false if any of the supplied parameters (Project, Design, Mapping Name, Action Name) can't be found in the Scanworks environment. A boolean result is generated in the event of a successful action. In the event that the test was successful, a TRUE value is returned, otherwise a FALSE value is returned from the function.\n\nNote: This test will always generate a passing result. The result of the test must be determined from the returned boolean value, and then acted upon.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ProjectName\n\nString\n\nThe name of the Scanworks project to load.\n\n\n\n$DesignName\n\nString\n\nThe name of the design in the supplied Scanworks project.\n\n\n\n$MappingName\n\nString\n\nThe name of the mapping name in the supplied Scanworks project.\n\n\n\n$ActionName\n\nString\n\nThe name of the action in the supplied Scanworks project.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Result\n\nBoolean\n\nThe result of the test.\n\n\"TRUE\" indicates a passing test\n\n\"FALSE\" indicates a test failure\n\n\n\n\n\nCorelis_GetFailedUUT\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Corelis_GetFailedUUT": {
  "prefix": "Corelis_GetFailedUUT",
  "body": [
   "$$FailedUUTList=Corelis_GetFailedUUT();"
  ],
  "description": "\n\n\n\n\n\nAll the Corelis functions require the Corelis Scan Express Runner software and the dongle to be installed in the system. Corelis_InitHardware() and Corelis_LoadTestPlan() functions need to be called prior to calling this function.\n\n\n\n\n\nThis function returns the failed UUTs.\n\n\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\nN/A\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$FailedUUTList\n\nChar\n\nThe function returns NULL if there are no failed UUTs (or Corelis_InitHardware was not called). Otherwise, it returns a pointer to a character array containing the failed UUTs separated by commas. For example, a return value of \"1,3,5\" means UUT 1, 3, and 5 failed.\n\n\n\n\n\nCorelis_GetNumUUT\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Corelis_GetNumUUT": {
  "prefix": "Corelis_GetNumUUT",
  "body": [
   "$$NumUUT=Corelis_GetNumUUT();"
  ],
  "description": "\n\n\n\n\n\nAll the Corelis functions require the Corelis Scan Express Runner software and the dongle to be installed in the system. Corelis_InitHardware() and Corelis_LoadTestPlan() functions need to be called prior to calling this function.\n\n\n\n\n\nThis function returns the maximum number of UUTs that can be tested with regard to the number of TAPs available on the current controller and the number of TAPs per UUT.\n\n\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\nN/A\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NumUUT\n\nInteger\n\nAn integer value representing the number of UUTs configured for gang testing.\n\n\n\n\n\nCorelis_GetTestStepCount\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Corelis_GetTestStepCount": {
  "prefix": "Corelis_GetTestStepCount",
  "body": [
   "$$TestStepCount=Corelis_GetTestStepCount();"
  ],
  "description": "\n\n\n\n\n\nAll the Corelis functions require the Corelis Scan Express Runner software and the dongle to be installed in the system. Corelis_InitHardware() and Corelis_LoadTestPlan() functions need to be called prior to calling this function.\n\n\n\n\n\nThis function returns the total number of Test Steps in the Test Plan.\n\n\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\nN/A\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$TestStepCount\n\nInteger\n\nAn integer value representing the total number of Test Steps in the Test Plan.\n\n\n\n\n\nGetTestStepName\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Corelis_GetTestStepName": {
  "prefix": "Corelis_GetTestStepName",
  "body": [
   "$$TestStepNumber=Corelis_GetTestStepName();"
  ],
  "description": "\n\n\n\n\n\nAll the Corelis functions require the Corelis Scan Express Runner software and the dongle to be installed in the system. Corelis_InitHardware() and Corelis_LoadTestPlan() functions need to be called prior to calling this function.\n\n\n\n\n\nThis function returns the name of a specified Test Step in the Test Plan.\n\n\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\nN/A\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$TestStepNumber\n\nInteger\n\nAn integer value representing the Test Step number.\n\n\n\n\n\nCorelis_InitHardware\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS New(\"String\",\"C:\\\\ProgramFiles\\\\ScanExpressRunnerv6\\\\\");Corelis_InitHardware": {
  "prefix": "New(\"String\",\"C:\\\\ProgramFiles\\\\ScanExpressRunnerv6\\\\\");Corelis_InitHardware",
  "body": [
   "$$CorelisInstallPath=New(\"String\",\"C:\\\\ProgramFiles\\\\ScanExpressRunnerv6\\\\\");Corelis_InitHardware($$CorelisInstallPath);"
  ],
  "description": "\n\n\n\n\n\nAll the Corelis functions require the Corelis Scan Express Runner software and the dongle to be installed in the system.\n\n\n\n\n\nThis function performs a dongle check to verify permission to run the ScanExpressRunner.dll. This function must be called before any other function is called.\n\n\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nScanExpressInstallPath\n\nString\n\nThe path to the directory where Scan Express software is installed.\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nCorelis_InitHardware\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS New(\"String\",\"C:\\\\ProgramFiles\\\\ScanExpressRunnerv6\\\\Tutorial\\\\ScanPlusDemoBoard\\\\ScanPlusDemoBoard.tsp\");$CorelisControllerString=New(\"String\",\"USB-1149.1/E,42,87,1,2,,,\");Corelis_LoadTestPlan": {
  "prefix": "New(\"String\",\"C:\\\\ProgramFiles\\\\ScanExpressRunnerv6\\\\Tutorial\\\\ScanPlusDemoBoard\\\\ScanPlusDemoBoard.tsp\");$CorelisControllerString=New(\"String\",\"USB-1149.1/E,42,87,1,2,,,\");Corelis_LoadTestPlan",
  "body": [
   "$$CorelisTestPlanFile=New(\"String\",\"C:\\\\ProgramFiles\\\\ScanExpressRunnerv6\\\\Tutorial\\\\ScanPlusDemoBoard\\\\ScanPlusDemoBoard.tsp\");$$CorelisControllerString=New(\"String\",\"USB-1149.1/E,42,87,1,2,,,\");Corelis_LoadTestPlan($$CorelisTestPlanFile,$$CorelisControllerString);"
  ],
  "description": "\n\n\n\n\n\nAll the Corelis functions require the Corelis Scan Express Runner software and the dongle to be installed in the system. Corelis_InitHardware() needs to be called prior to calling this function.\n\n\n\n\n\nThe function loads a Test Plan ("
 }
,
 "JTS Corelis_RunTestPlan": {
  "prefix": "Corelis_RunTestPlan",
  "body": [
   "Corelis_RunTestPlan();"
  ],
  "description": "\n\n\n\n\n\nAll the Corelis functions require the Corelis Scan Express Runner software and the dongle to be installed in the system. Corelis_InitHardware() and Corelis_LoadTestPlan() functions need to be called prior to calling this function.\n\n\n\n\n\nThis function runs a Test Plan based on a set of controller parameters.\n\n\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\nN/A\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nCorelis_RunTestPlan_Nofail\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Corelis_RunTestPlan_Nofail": {
  "prefix": "Corelis_RunTestPlan_Nofail",
  "body": [
   "Corelis_RunTestPlan_Nofail();"
  ],
  "description": "\n\n\n\n\n\nAll the Corelis functions require the Corelis Scan Express Runner software and the dongle to be installed in the system. Corelis_InitHardware() and Corelis_LoadTestPlan() functions need to be called prior to calling this function. The function will not fail. The function Corelis_GetFailedUUT() needs to be called to determine if any UUT has failed.\n\n\n\n\n\nThis function runs a Test Plan based on a set of controller parameters.\n\n\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\nN/A\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nCorelis_SetCurrentUUT\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Corelis_SetCurrentUUT": {
  "prefix": "Corelis_SetCurrentUUT",
  "body": [
   "Corelis_SetCurrentUUT($$CurrentUUT);"
  ],
  "description": "\n\n\n\n\n\nAll the Corelis functions require the Corelis Scan Express Runner software and the dongle to be installed in the system. Corelis_InitHardware(), Corelis_LoadTestPlan(), and SetNumUUT functions need to be called prior to calling this function.\n\n\n\n\n\nThis function selects the specified UUT as the current UUT so that the test can be run on a single target with detailed diagnostics.\n\n\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$CurrentUUT\n\ninteger\n\nThe unit number of the UUT to be tested. If 0, all UUTs will be tested at the same time in gang test mode.\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\nN/A\n\n\n\n\n\nCorelis_SetNumUUT\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Corelis_SetNumUUT($Count,$MaxValue);Corelis_SetNumUUT": {
  "prefix": "Corelis_SetNumUUT($Count,$MaxValue);Corelis_SetNumUUT",
  "body": [
   "$$Status=Corelis_SetNumUUT($$Count,$$MaxValue);Corelis_SetNumUUT($$Count,$$MaxValue);"
  ],
  "description": "\n\n\n\n\n\nAll the Corelis functions require the Corelis Scan Express Runner software and the dongle to be installed in the system. Corelis_InitHardware(), Corelis_LoadTestPlan(), and SetNumUUT functions need to be called prior to calling this function.\n\n\n\n\n\nThis function sets the number of UUTs configured for gang testing.\n\n\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Count\n\ninteger\n\nThe number of UUTs to configure for gang testing.\n\n\n\n$MaxValue\n\ninteger\n\nA pointer to an integer value where the function returns the maximum number of UUTs that can be tested with the current controller and connected ScanTAPs.\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Status\n\nChar\n\nThe function returns NULL if the specified number of UUTs is not greater than the maximum number of UUTs that can be tested for the current controller and connected ScanTAPs; otherwise it returns a pointer to a character array containing an error message.\n\n\n\n\n\nIntroduction\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS JT37X7_Close": {
  "prefix": "JT37X7_Close",
  "body": [
   "JT37X7_Close($$Handle);"
  ],
  "description": "\n\nThis function requires JTAG technologies drivers to be installed on the system.\n\nThis function closes the JT37x7 driver. Always close the driver when it is no longer needed.\n\nThe only parameter is the $Handle that was created with JT37x7_Initialize.\n\n\n\n\n\nRemarks:\n\nThis function is tested with a JT3707/PCI device.\n\n\n\n\n\nResult:\n\nJT37X7_Close($Handle);\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nInstrument handle\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n\n\nExample:\n\nJT37X7_Close($Handle);\n\n\n\n\n\nJT37X7_Initialize\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS JT37X7_Initialize": {
  "prefix": "JT37X7_Initialize",
  "body": [
   "$$Handle=JT37X7_Initialize($$Interface,$$Voltage,$$TapMask,$$OutputVoltTap1,$$OutputVoltTap2,$$OutputVoltTap3,$$OutputVoltTap4,$$ThresholdVoltTap1,$$ThresholdVoltTap2,$$ThresholdVoltTap3,$$ThresholdVoltTap4,$$InfoVisible);"
  ],
  "description": "\n\nThis function requires JTAG technologies drivers to be installed on the system.\n\nThis function opens the JT37x7 driver which is specified by the $interface parameter and controller number, and returns an $Handle.\n\nThe first parameter is a string that specifies the interface type of the JT37x7 controller which will be used. Possible values are:\n\n\u00b7 \"PCI\", \"PCI0\" ... \"PCI31\"\n\n\u00b7 \"USB\", \"USB0\" ... \"USB126\"\n\n\u00b7 \"FW\", \"FW0\" ... \"FW63\"\n\n\u00b7 \"ETH192.168.1.20\" or any other IP address.\n\nThe JT2147 QuadPod system will be activated and switches the activity indicator LED on the POD to the colour green.\n\nThe SCSI-II type cable cannot be swapped after the POD is activated.\n\nIf the POD system PF2137 is used, the function will apply the voltage level $Voltage to the TAP's.\n\nIf the POD system JT2147 is used, the function will apply the voltage level $OutputVoltTap1 and threshold level $ThresholdVoltTap1 to TAP1.\n\nIf the POD system JT2147 is used, the function will apply the voltage level $OutputVoltTap2 and threshold level $ThresholdVoltTap2 to TAP2.\n\nIf the POD system JT2147 is used, the function will apply the voltage level $OutputVoltTap3 and threshold level $ThresholdVoltTap3 to TAP3.\n\nIf the POD system JT2147 is used, the function will apply the voltage level $OutputVoltTap4 and threshold level $ThresholdVoltTap4 to TAP4.\n\nRemarks:\n\nThis function is tested with a JT3707/PCI device.\n\nResult:\n\n$Handle = JT37X7.Initialize($Interface, $Voltage, $TapMask, $OutputVoltTap1, $OutputVoltTap2, $OutputVoltTap3, $OutputVoltTap4, $ThresholdVoltTap1, $ThresholdVoltTap2, $ThresholdVoltTap3, $ThresholdVoltTap4, $InfoVisible);\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Interface\n\nString\n\nThe name of the JT37x7 interface. Possible values:\n\n\u00b7 \"PCI\", \"PCI0\" ... \"PCI31\"\n\n\u00b7 \"USB\", \"USB0\" ... \"USB126\"\n\n\u00b7 \"FW\", \"FW0\" ... \"FW63\"\n\n\u00b7 \"ETH192.168.1.20\" or any other IP address.\n\n\n\n$Voltage\n\nString\n\nThe PF2137 TAPPOD voltage level if used. Possible values:\n\n\u00b7 \"3V3\"\n\n\u00b7 \"5V\"\n\n\u00b7 Every other value will cause an error.\n\n\n\n$TapMask\n\nString\n\nSpecifies the TAPs for this voltage levels setting. Possible values:\n\n\u00b7 \"TAP1\"\n\n\u00b7 \"TAP2\"\n\n\u00b7 \"TAP3\"\n\n\u00b7 \"TAP4\"\n\n\n\n$OutputVoltTap1\n\nInteger\n\nThis is the output voltage in tenth of a volt for TAP1. This value has to be between 15 and 36.\n\n\n\n$OutputVoltTap2\n\nInteger\n\nThis is the output voltage in tenth of a volt for TAP2. This value has to be between 15 and 36.\n\n\n\n$OutputVoltTap3\n\nInteger\n\nThis is the output voltage in tenth of a volt for TAP3. This value has to be between 15 and 36.\n\n\n\n$OutputVoltTap4\n\nInteger\n\nThis is the output voltage in tenth of a volt for TAP4. This value has to be between 15 and 36.\n\n\n\n$ThresholdVoltTap1\n\nInteger\n\nThis is the input threshold in tenth of a volt for TAP1. This value has to be between 0 and 18.\n\n\n\n$ThresholdVoltTap2\n\nInteger\n\nThis is the input threshold in tenth of a volt for TAP2. This value has to be between 0 and 18.\n\n\n\n$ThresholdVoltTap3\n\nInteger\n\nThis is the input threshold in tenth of a volt for TAP3. This value has to be between 0 and 18.\n\n\n\n$ThresholdVoltTap4\n\nInteger\n\nThis is the input threshold in tenth of a volt for TAP4. This value has to be between 0 and 18.\n\n\n\n$InfoVisible\n\nBoolean\n\nWith this parameter on true, you will receive a lot of execution information on this function. With this parameter on false, there is no screen output.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nInstrument handle that can be used for all the execution steps.\n\n\n\n\n\nExample:\n\n$Handle = JT37X7_Initialize(\"PCI0\", \"5V\", \"TAP1, TAP2-TAP3-TAP4\", 36, 36, 36, 36, 15, 15, 15, 15, \"false\");\n\n$Handle = JT37X7_Initialize(\"PCI0\", \"5V\", \"TAP1\", 36, 36, 36, 36, 15, 15, 15, 15, \"false\");\n\n\n\n\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS JT37X7_ProgramBool": {
  "prefix": "JT37X7_ProgramBool",
  "body": [
   "$$BoolResult=JT37X7_ProgramBool($$Handle,$$ProgramParameters);"
  ],
  "description": "\n\nThis function requires at least the JTAG software CD7 to be installed on the system.\n\nThis function executes an action generated with the JTAG Technologies FlashProg Manager.\n\n\n\nResult:\n\n$BoolResult = JT37X7_ProgramBool($Handle, $ProgramParameters);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nThe instrument handle you obtain from JT37X7_Initialize that identifies a particular instrument's session.\n\n\n\n$ProgramParameters\n\nArray\n\nThis parameter contains all the programming options available for the user to set.\n\nThe user has to create an string array in the script and has to fill that array with the correct information as described here:\n\n\u00b7 Array[0, 0]: the path and file name of the BSX file\n\n\u00b7 Array[0, 1]: the path and file name of the image file to program. This file will be loaded into the JTAG controller memory.\n\n\u00b7 Array[0, 2]: specifies the start address of the image data in the image memory of the controller.\n\n\u00b7 Array[0, 3]: specifies the length of the image data in the image memory of the controller.\n\n\u00b7 Array[0, 4]: Specifies the start address in the target.\n\n\u00b7 Array[0, 5]: First byte in the image file that is loaded. (File offset)\n\n\u00b7 Array[0, 6]: Specifies the source of the frequency. Valid values:\n\n1. \"CLK INT\": frequency generated by controller.\n\n2. \"CLK EXT\": external frequency applied.\n\n\u00b7 Array[0, 7]: specifies the value of the frequency at which an application is executed.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$BoolResult\n\nBoolean\n\n\u00b7 True: Test passed.\n\n\u00b7 False: Test failed.\n\n\n\n\n\nRemarks:\n\n\u00b7 This function is tested with JT37x7/TSI controller.\n\n\u00b7 When there occurs an error during the execution of the low level JTAG functions, JabilTest while fail and return the error message.\n\n\u00b7 When the program action fails, JabilTest will fail.\n\n\u00b7 The function will verify if the given parameter are correct, otherwise JabilTest fails and returns the error message.\n\n\u00b7 This function does next extra actions to avoid user errors:\n\n\u00b7 Check if the used BSX file (program parameter element [0, 0]) is existing on the system.\n\n\u00b7 Check if the used BSX file is generated with the JTAG Technologies FlashProg manager tool.\n\n\u00b7 Check if the used frequency source (program parameter element [0, 6]) is valid.\n\n\u00b7 Check if the used image file (program parameter element [0, 1]) is existing on the system.\n\n\u00b7 If the program length (program parameter element [0, 3]) is equal to 0, the function will automatically use the file size as program length.\n\n\u00b7 This function has to be used with the controller type JT3717 or JT3727. The function detects which controller is connected and fails if the wrong controller type is used.\n\n\u00b7 This function will check if the generated BSX file is valid to use with the connected TAPPOD.\n\n\n\n\n\nExample:\n\n\n\n\n\n$ProgramParameters = ArrayCreate(\"String\", 1, 10);\n\nArraySetValue($ProgramParameters, 0, 0, \"C:\\\\boards\\\\IBO2\\\\Wr_multi.bsx\");\n\nArraySetValue($ProgramParameters, 0, 1, \"C:\\\\boards\\\\IBO2\\\\ibo2.bin\");\n\nArraySetValue($ProgramParameters, 0, 2, \"0\");\n\nArraySetValue($ProgramParameters, 0, 3, \"0\");\n\nArraySetValue($ProgramParameters, 0, 4, \"0\");\n\nArraySetValue($ProgramParameters, 0, 5, \"0\");\n\nArraySetValue($ProgramParameters, 0, 6, \"CLK INT\");\n\nArraySetValue($ProgramParameters, 0, 7, \"20000\");\n\n\n\n\n\ncall ProgramBool();\n\n\n\n\n\nfunction ProgramBool()\n\n{\n\n$Counter = New(\"Integer\", 0);\n\nLabel ProgramBoolRetry:\n\n\n\n\n\n$Counter = Add($Counter, 1);\n\n$Boolean = NumericComparison($Counter, 20, \"==\");\n\nScriptIf($Boolean, \"GOTO\", \"ProgramBoolFailed\", \"\");\n\n\n\n$ResultBool = JT37X7_ProgramBool($Handle, $ProgramParameters);\n\nScriptIf($ResultBool, \"GOTO\", \"ProgramBoolPassed\", \"ProgramBoolRetry\");\n\n\n\n\n\nLabel ProgramBoolFailed:\n\nFail(\"JT37X7_Program failed\");\n\nreturn;\n\n\n\n\n\nLabel ProgramBoolPassed:\n\nreturn;\n\n}\n\n\n\n\n\nJT37X7_RunFlash\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS JT37X7_RunFlash": {
  "prefix": "JT37X7_RunFlash",
  "body": [
   "JT37X7_RunFlash($$Controller,$$Interface,$$Tap,$$Voltage,$$Threshold,$$GenFile,$$AplFile,$$CnnFile,$$ImageFileType,$$ImageFile,$$ImageStartRange,$$ImageProgramRange,$$ExecuteFrequency,$$ErrorDirectory,$$ErrorFilename,$$InfoVisible);"
  ],
  "description": "\n\nThis function requires JTAG technologies drivers to be installed on the system. Make sure that the JT37x7 controller is closed, otherwise run JT37x7_Close.\n\nThis function programs a device (FLASH/SEEPROM) using the GEN, APL and CNN file.\n\nRemarks:\n\nThis function is tested with a JT3707/PCI device.\n\nThis function can only be used with the JT3707 device.\n\nMake sure to close all the opened handles before executing this function.\n\nResult:\n\nJT3707_RunFlash($Controller, $Interface, $Tap, $Voltage, $Threshold, $GenFile, $AplFile, $CnnFile, $ImageFileType, $ImageFile, $ImageStartRange, $ImageProgramRange, $ExecuteFrequency, $ErrorDirectory, $ErrorFilename, $InfoVisible);\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Controller\n\nString\n\nThis parameter specifies which Sfl controller DLL has to be used.\n\nPossible values are:\n\n\u00b7 \"3705\"\n\n\u00b7 \"3710\"\n\n\u00b7 \"37x7\"\n\n\n\n$Interface\n\nString\n\nThis parameter specifies the used interface. Possible values are:\n\n\u00b7 \"PCI\", \"PCI0\" ... \"PCI31\"\n\n\u00b7 \"USB\", \"USB0\" ... \"USB126\"\n\n\u00b7 \"FW\", \"FW0\" ... \"FW63\"\n\n\u00b7 \"ETH192.168.1.20\" or any other IP address.\n\n\n\n$Tap\n\nInteger\n\nThis parameter specifies which TAP to use during execution.\n\n\n\n$Voltage\n\nInteger\n\nThis parameter specifies the voltage level in tenth of a volt. Possible values are:\n\n\u00b7 33\n\n\u00b7 50\n\n\n\n$Threshold\n\nInteger\n\nThis parameter specifies the threshold voltage level in tenth of a volt. Value range is between 0 and 41.\n\n\n\n$GenFile\n\nString\n\nThis parameter specifies the general data file that is used for the flash programming action.\n\n\n\n$AplFile\n\nString\n\nThis parameter specifies the application data file that is used for the flash programming action.\n\n\n\n$CnnFile\n\nString\n\nThis parameter specifies the connection data file that is used for the flash programming action. This parameter is optional. You have to use it if the boundary scan test developer has used a CON file during development.\n\n\n\n$ImageFileType\n\nString\n\nThis parameter specifies the type of the image data file to program. Possible values are:\n\n\u00b7 \"BIN\"\n\n\u00b7 \"HEX\"\n\n\u00b7 \"SREC\"\n\n\n\n$ImageFile\n\nString\n\nThis parameter specifies the the image data file to program.\n\n\n\n$ImageStartRange\n\nInteger\n\nThis parameter specifies the start address of the specified image data file.\n\n\n\n$ImageProgramRange\n\nInteger\n\nThis parameter specifies the number of bytes of the image data file that are programmed into the device.\n\n\n\n$ExecuteFrequency\n\nInteger\n\nThis parameter specifies the scan frequency in kHz.\n\n\n\n$InfoVisible\n\nBoolean\n\nWith this parameter on true, you will receive a lot of execution information on this function. With this parameter on false, there is no screen output.\n\n\n\n$ErrorLogDirectory\n\nString\n\nThe error directory. This is the place where all the error files will be logged of a failed program action.\n\n\n\n$LogFile\n\nString\n\nThe error filename.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n\n\nExample:\n\nJT37X7_RunFlash(\"37x7\",\"PCI0\",1,33,15,\"C:\\\\_bart_\\\\IBO2\\\\7203.gen\",\"C:\\\\_bart_\\\\IBO2\\\\7203_Wr_multi(EEPROM_ST_M24C64).apl\",\"\",\"BIN\",\"C:\\\\_bart_\\\\ibo2.bin\",0,10,4000,$RvmLogDirectory,\"bart\",\"false\");\n\n\n\n\n\nJT37X7_RunJpf\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS JT37X7_RunJpf": {
  "prefix": "JT37X7_RunJpf",
  "body": [
   "JT37X7_RunJpf($$JtagController,$$Tap,$$Voltage,$$ThresholdVoltage,$$Parameters,$$SerialNumber,$$InfoVisible);"
  ],
  "description": "\n\nThis function requires at least the JTAG software CD7 to be installed on the system.\n\nThis function programs PLD devices using JPF files. JPF files describe PLD programming actions in the JTAG Programming Format and have been compiled from PRG, GEN, (optionally) CON and SVF (serial vector format) files.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a JTAG PCI-3707 card.\n\n\u00b7 When there occurs an error during the execution of the low level JTAG functions, JabilTest while fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise JabilTest fails and returns the error message.\n\n\n\nResult:\n\nJT37X7_RunJpf($JtagController, $Tap, $Voltage, $ThresholdVoltage, $Parameters, $SerialNumber, $InfoVisible);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$JtagController\n\nString\n\nThis parameter is a string that specifies the interface used in your system.\n\n\n\n$Tap\n\nInteger\n\nThis parameter specifies the TAP number you want to use to program the PLD.\n\n\n\n$Voltage\n\nInteger\n\nThis parameter specifies the output voltage level in tenths of a volt for the TAP and the I/O output pins on the selected TAPPOD. Supported are all values between 15 and 36.\n\n\n\n$ThresholdVoltage\n\nInteger\n\nThis parameter specifies the threshold level in tenths of a volt for the TAP and the I/O input pins on the selected TAP. Supported are all values between 0 and 41.\n\n\n\n$Parameters\n\nArray\n\nThis parameter contains all the programming options available for the user to set.\n\nThe user has to create an array in the script and has to fill that array with the correct information as described here:\n\n\u00b7 Array[0, 0]: the path and file name of the JPF file\n\n\u00b7 Array[0, 1]: the frequency (kHz) used during programming execution. The frequency will be changed if a command in JPF file defines a frequency lower than this value. When this parameter is 0, the frequency value is not changed by JPF file execution.\n\n\u00b7 Array[0, 2]: 23 bit operation definition. The user has to use the hex value for this parameter. (without 0x prefix) If this value is 0, the compiler operations are used. Next bits supported by JPF compilers, operations executed in defined order:\n\n1. JPF_USERCODE = 0x01 : this programming instruction reads the user code which has been entered in the selected PLD.\n\n2. JPF_READBACK = 0x02 : this programming instruction will enable the contents of the selected PLD to be read. The return data is saved in the file specified in the elementj Array[0, 5]\n\n3. JPF_ERASE = 0x04 : this programming instruction erases the contents of the selected PLD.\n\n4. JPF_BLANK_CHECK = 0x08 : this programming instruction verifies whether the device has been erased completely.\n\n5. JPF_PROGRAM = 0x10 : this programming instruction downloads the programming code into the selected PLD.\n\n6. JPF_VERIFY = 0x20 : this programming instruction compares the contents of the selected PLD against the contents of the input file with the programming code.\n\n7. JPF_SECURITY = 0x40 : this programming instruction sets the security fuses. Security fuses are commonly used mechanisms in PLDs to disable, for instance, the possibility of reading back the input program pattern into a part.\n\n8. IMPORTANT: The programming operation you specify must have been manually marked in the input SVF file as follows //!ACTION <action_type> (example. //!ACTION PROGRAM). If no action statements were entered, the compiled SVF file will be executed completely, irrespective of the programming operations you select.\n\n\u00b7 Array[0, 3] : this parameter contains the programming flags:\n\n1. JPF_USE_GANGING = 0x10\n\n\u00b7 Array[0, 4] : This parameter is an ordered list of tester taps to be used. Multiple target boards can be programmed simultaneously, depending on the number of TAPs for one target.\n\n\u00b7 Array[0, 5] : This parameter is a string containing the path and file name of the result file.This file contains a log with information about the result of the test expressed in terms of TAPs and Bscan cells.\n\n\n\n$SerialNumber\n\nString\n\nThis parameter is a string containing the serial identity of the active target board.\n\n\n\n$InfoVisible\n\nBoolean\n\nThis parameter enables the program to write extra information to the screen.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n\n\nExample:\n\n\n\n\n\n$Parameters = ArrayCreate(\"String\", 1, 10);\n\nArraySetValue($Parameters, 0, 0, \"C:\\\\boards\\\\ss\\\\sony_119\\\\jabil.jpf\");\n\nArraySetValue($Parameters, 0, 1, \"800\");\n\nArraySetValue($Parameters, 0, 2, \"0\");\n\nArraySetValue($Parameters, 0, 3, \"0\");\n\nArraySetValue($Parameters, 0, 4, \"0\");\n\nArraySetValue($Parameters, 0, 5, \"jabil.err\");\n\nJT37X7_RunJpf(\"pci0\", 1, 33, 15, $Parameters, $SerialNumber, \"true\");\n\n\n\n\n\n$Parameters = ArrayCreate(\"String\", 1, 10);\n\nArraySetValue($Parameters, 0, 0, \"C:\\\\boards\\\\ss\\\\sony_119\\\\jabil.jpf\");\n\nArraySetValue($Parameters, 0, 1, \"800\");\n\nArraySetValue($Parameters, 0, 2, \"0\");\n\nArraySetValue($Parameters, 0, 3, \"0\");\n\nArraySetValue($Parameters, 0, 4, \"0\");\n\nArraySetValue($Parameters, 0, 5, \"jabil.err\");\n\nJT37X7_RunJpf(\"pci0\", 1, 33, 15, $Parameters, \"123456\", \"true\");\n\n\n\n\n\nJT37X7_RunTest\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS JT37X7_RunTest": {
  "prefix": "JT37X7_RunTest",
  "body": [
   "JT37X7_RunTest($$Handle,$$BstDirectory,$$ActionName,$$TestFrequency,$$RvmLogDirectory,$$RvmLogFormat,$$InfoVisible);"
  ],
  "description": "\n\nThis function requires JTAG technologies drivers to be installed on the system.\n\nThis function executes a BSX file (generated with the JTAG technologies software). If the test fails, there will be created an error file (RVM file). The JT37x7 controller while be closed after a failure.\n\nRemarks:\n\nThis function is tested with a JT3707/PCI device.\n\nResult:\n\nJT37X7_RunTest($Handle, $BstDirectory, $ActionName, $TestFrequency, $RvmLogDirectory, $RvmLogFile, $InfoVisible);\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nInstrument handle created with JT37x7_Initialize.\n\n\n\n$BstDirectory\n\nString\n\nThe boundary scan file directory.\n\n\n\n$ActionName\n\nString\n\nThe boundary scan file to execute (BSX file).\n\n\n\n$TestFrequency\n\nInteger\n\nThe boundary scan test frequency (in kHz). When you enter 0, the test will use the frequency from the BSX file. During boundary scan test generation, the developer can apply a frequency that is saved into the BSX file.\n\n\n\n$RvmLogDirectory\n\nString\n\nThe RVM directory. This is the place where all the error files will be logged of a failed test.\n\n\n\n$RvmLogFile\n\nString\n\nThe RVM filename.\n\n\n\n$InfoVisible\n\nBoolean\n\nWith this parameter on true, you will receive a lot of execution information on this function. With this parameter on false, there is no screen output.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n\n\nExample:\n\nJT37X7_RunTest($Handle, \"C:\\\\_bart_\\\\IBO2\", \"capture\", 1000, \"C:\\\\rvm\", \"error\", \"false\"); Another way of using this function:\n\n\n\n$BstDirectory = New(\"String\",\"C:\\\\_bart_\\\\IBO2\");\n\n$RvmLogDirectory = New(\"String\",\"C:\\\\RVM\");\n\n($month,$day,$year,$hour,$minutes,$seconds,$dayname) = SystemTime();\n\n...\n\n$ActionName = New(\"String\",\"capture\");\n\ncall RunBstTest();\n\n...\n\nfunction RunBstTest()\n\n{\n\n$RvmLogFormat = StringCat($SerialNumber, \"_\");\n\n$RvmLogFormat = StringCat($RvmLogFormat, $ActionName);\n\n$RvmLogFormat = StringCat($RvmLogFormat, \"_\");\n\n$RvmLogFormat = StringCat($RvmLogFormat, $day);\n\n$RvmLogFormat = StringCat($RvmLogFormat, \"-\");\n\n$RvmLogFormat = StringCat($RvmLogFormat, $month);\n\n$RvmLogFormat = StringCat($RvmLogFormat, \"-\");\n\n$RvmLogFormat = StringCat($RvmLogFormat, $year);\n\nJT37X7_RunTest($Handle, $BstDirectory,$ActionName, 1000,$RvmLogDirectory,$RvmLogFormat,\"false\");\n\nreturn;\n\n}\n\n\n\n\n\nJT37X7_RunTest2\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS JT37X7_RunTest2": {
  "prefix": "JT37X7_RunTest2",
  "body": [
   "JT37X7_RunTest2($$Handle,$$BstDirectory,$$ActionName,$$TestFrequency,$$RvmLogDirectory,$$RvmLogFormat,$$InfoVisible);"
  ],
  "description": "\n\nThis function requires JTAG technologies drivers to be installed on the system.\n\nThis function executes a BSX file (generated with the JTAG technologies software).\n\nRemarks:\n\nThis function is tested with a JT3707/PCI device.\n\nResult:\n\nJT37X7_RunTest2($Handle, $BstDirectory, $ActionName, $TestFrequency, $RvmLogDirectory, $RvmLogFile, $InfoVisible);\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nInstrument handle created with JT37x7_Initialize.\n\n\n\n$BstDirectory\n\nString\n\nThe boundary scan file directory.\n\n\n\n$ActionName\n\nString\n\nThe boundary scan file to execute (BSX file).\n\n\n\n$TestFrequency\n\nInteger\n\nThe boundary scan test frequency (in kHz). When you enter 0, the test will use the frequency from the BSX file. During boundary scan test generation, the developer can apply a frequency that is saved into the BSX file.\n\n\n\n$RvmLogDirectory\n\nString\n\nThe RVM directory. This is the place where all the error files will be logged of a failed test.\n\n\n\n$RvmLogFile\n\nString\n\nThe RVM filename.\n\n\n\n$InfoVisible\n\nBoolean\n\nWith this parameter on true, you will receive a lot of execution information on this function. With this parameter on false, there is no screen output.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n\n\nExample:\n\nJT37X7_RunTest2($Handle, \"C:\\\\_bart_\\\\IBO2\", \"capture\", 1000, \"C:\\\\rvm\", \"error\", \"false\"); Another way of using this function:\n\n\n\n$BstDirectory = New(\"String\",\"C:\\\\_bart_\\\\IBO2\");\n\n$RvmLogDirectory = New(\"String\",\"C:\\\\RVM\");\n\n($month,$day,$year,$hour,$minutes,$seconds,$dayname) = SystemTime();\n\n...\n\n$ActionName = New(\"String\",\"capture\");\n\ncall RunBstTest();\n\n...\n\nfunction RunBstTest()\n\n{\n\n$RvmLogFormat = StringCat($SerialNumber, \"_\");\n\n$RvmLogFormat = StringCat($RvmLogFormat, $ActionName);\n\n$RvmLogFormat = StringCat($RvmLogFormat, \"_\");\n\n$RvmLogFormat = StringCat($RvmLogFormat, $day);\n\n$RvmLogFormat = StringCat($RvmLogFormat, \"-\");\n\n$RvmLogFormat = StringCat($RvmLogFormat, $month);\n\n$RvmLogFormat = StringCat($RvmLogFormat, \"-\");\n\n$RvmLogFormat = StringCat($RvmLogFormat, $year);\n\nJT37X7_RunTest2($Handle, $BstDirectory,$ActionName, 1000,$RvmLogDirectory,$RvmLogFormat,\"false\");\n\nreturn;\n\n}\n\n\n\n\n\nJT37X7_RunTestBool\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS JT37X7_RunTestBool": {
  "prefix": "JT37X7_RunTestBool",
  "body": [
   "$$BoolValue=JT37X7_RunTestBool($$Handle,$$BstDirectory,$$ActionName,$$TestFrequency,$$RvmLogDirectory,$$RvmLogFormat,$$InfoVisible);"
  ],
  "description": "\n\nThis function requires JTAG technologies drivers to be installed on the system.\n\nThis function executes a BSX file (generated with the JTAG technologies software).\n\nRemarks:\n\nThis function is tested with a JT3707/PCI device.\n\nResult:\n\n$BoolValue = JT37X7_RunTestBool($Handle, $BstDirectory, $ActionName, $TestFrequency, $RvmLogDirectory, $RvmLogFile, $InfoVisible);\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nInstrument handle created with JT37x7_Initialize.\n\n\n\n$BstDirectory\n\nString\n\nThe boundary scan file directory.\n\n\n\n$ActionName\n\nString\n\nThe boundary scan file to execute (BSX file).\n\n\n\n$TestFrequency\n\nInteger\n\nThe boundary scan test frequency (in kHz). When you enter 0, the test will use the frequency from the BSX file. During boundary scan test generation, the developer can apply a frequency that is saved into the BSX file.\n\n\n\n$RvmLogDirectory\n\nString\n\nThe RVM directory. This is the place where all the error files will be logged of a failed test.\n\n\n\n$RvmLogFile\n\nString\n\nThe RVM filename.\n\n\n\n$InfoVisible\n\nBoolean\n\nWith this parameter on true, you will receive a lot of execution information on this function. With this parameter on false, there is no screen output.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$BoolValue\n\nBoolean\n\nTrue: Test passed.\n\nFalse: Test failed.\n\n\n\n\n\nExample:\n\n$BoolValue = JT37X7_RunTestBool($Handle, \"C:\\\\_bart_\\\\IBO2\", \"capture\", 1000, \"C:\\\\rvm\", \"error\", \"false\");\n\n\n\n\n\nFEASA_Acquire\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS FEASA_Acquire": {
  "prefix": "FEASA_Acquire",
  "body": [
   "FEASA_Acquire($$comPort);"
  ],
  "description": "\n\nIssues the FEASA Acquire command to sample all LED Sensors for the color and intensity values. The first parameter to this functon is a SerialPort object which first must be created by using the SerialOpen function. The SerialOpen function should be passed the parameters (57600,8,\"N\",1) for communication with the FEASA LED Analyzer. After issuing the FEASA_Acquire command, all the LED measurements for each specific port can be read back using the FEASA_Query command. If the unit returns a successful response, a PASS result is generated, otherwise a FAIL result is returned from this function.\n\nFor more information about the FEASA LED Analyzer, consult their website at http://www.feasa.ie/.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$comPort\n\nObject\n\nAn instance of the SerialPort object to be used for communicating with the FEASA LED Analyzer\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nFEASA.Query\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS FEASA_Query": {
  "prefix": "FEASA_Query",
  "body": [
   "($$RedValue,$$BlueValue,$$Greenvalue,$$IntensityValue)=FEASA_Query($$comPort,$$LEDSensor);"
  ],
  "description": "\n\nIssues the FEASA Query command to to return the values measured for a particular LED sensor. Before using the FEASA_Query command, you first must issue the FEASA.Acquire command to sample all the LED data into the units buffer. In the event of a succesful query operation, a PASS result is returned from the function, otherwise a FAIL result is returned. After sampling all the LED values, they can be independently evaluated by using the NumericLimitTest function.\n\nFor more information about the FEASA LED Analyzer, consult their website at http://www.feasa.ie/.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$comPort\n\nObject\n\nAn instance of the SerialPort object to be used for communicating with the FEASA LED Analyzer\n\n\n\n$LEDSensor\n\nInteger\n\nThe LED Sensor to query for parametric measurement. Valid values are 1-20.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$RedValue\n\nInteger\n\nThe 8-bit value representing the RED component of the LED measurement.\n\n\n\n$BlueValue\n\nInteger\n\nThe 8-bit value representing the BLUE component of the LED measurement.\n\n\n\n$GreenValue\n\nInteger\n\nThe 8-bit value representing the GREEN component of the LED measurement.\n\n\n\n$Intensity\n\nInteger\n\nThe 16-bit value representing the Intensity of the LED measurement.\n\n\n\n\n\nMDA_GetLowLimitDbl\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Mda_GetLowLimitDbl": {
  "prefix": "Mda_GetLowLimitDbl",
  "body": [
   "$$TestLoLimit=Mda_GetLowLimitDbl($$MdaCurrentStep);"
  ],
  "description": "\n\nThis function uses the Checksum TR10 EMS software.\n\nThis function returns data from the MDA test results.\n\nNote: This function requires the installation of version 6.0 or greater of the National Instruments CVI run-time to function correctly.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$MdaCurrentStep\n\nInteger\n\nThe test step number to index to.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$TestLoLimit\n\nDouble\n\nThe low limit of the indexed test step.\n\n\n\n\n\nMda_ExeVisemsToTest\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Mda_ExeVisemsToTest": {
  "prefix": "Mda_ExeVisemsToTest",
  "body": [
   "Mda_ExeVisemsToTest($$MdaExecutable,$$MdaProgramFile,$$MdaTestWindow,WaitStartTime);"
  ],
  "description": "\n\nThis function uses the Checksum TR10 EMS software.\n\nThis function returns data from the MDA test results.\n\nNote: This function requires the installation of version 6.0 or greater of the National Instruments CVI run-time to function correctly.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$MdaExecutable\n\nString\n\nThe complete path with executable name of checksum executable. (i.e. \"c:\\\\checksum\\visems.exe\" )\n\n\n\n$MdaProgramFile\n\nString\n\nThe test program spec file. (i.e. \"Y86801-307-A.spec\" )\n\n\n\n$MdaTestWindow\n\nBoolean\n\nDetermine if the MDA test program will be brought to the front.\n\n\n\n$WaitStartTime\n\nInteger\n\nWaiting time before launching executable.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nMda_GetAllTestSteps\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Mda_GetAllTestSteps": {
  "prefix": "Mda_GetAllTestSteps",
  "body": [
   "$$MdaTestSteps=Mda_GetAllTestSteps();"
  ],
  "description": "\n\nThis function uses the Checksum TR10 EMS software.\n\nThis function returns data from the MDA test results.\n\nNote: This function requires the installation of version 6.0 or greater of the National Instruments CVI run-time to function correctly.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$MdaTestSteps\n\nInteger\n\nThe total number of test steps ran\n\n\n\n\n\nMda_GetHighLimitDbl\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Mda_GetHighLimitDbl": {
  "prefix": "Mda_GetHighLimitDbl",
  "body": [
   "$$TestHiLimit=Mda_GetHighLimitDbl($$MdaCurrentStep);"
  ],
  "description": "\n\nThis function uses the Checksum TR10 EMS software.\n\nThis function returns data from the MDA test results.\n\nNote: This function requires the installation of version 6.0 or greater of the National Instruments CVI run-time to function correctly.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$MdaCurrentStep\n\nInteger\n\nThe test step number to index to.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$TestHiLimit\n\nDouble\n\nThe hi limit of the indexed test step.\n\n\n\n\n\nMda_GetHighLimitStr\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Mda_GetHighLimitStr": {
  "prefix": "Mda_GetHighLimitStr",
  "body": [
   "$$TestHiLimit=Mda_GetHighLimitStr($$MdaCurrentStep);"
  ],
  "description": "\n\nThis function uses the Checksum TR10 EMS software.\n\nThis function returns data from the MDA test results.\n\nNote: This function requires the installation of version 6.0 or greater of the National Instruments CVI run-time to function correctly.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$MdaCurrentStep\n\nInteger\n\nThe test step number to index to.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$TestHiLimit\n\nString\n\nThe hi limit of the indexed test step.\n\n\n\n\n\nMda_GetLowLimitStr\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Mda_GetLowLimitStr": {
  "prefix": "Mda_GetLowLimitStr",
  "body": [
   "$$TestLoLimit=Mda_GetLowLimitStr($$MdaCurrentStep);"
  ],
  "description": "\n\nThis function uses the Checksum TR10 EMS software.\n\nThis function returns data from the MDA test results.\n\nNote: This function requires the installation of version 6.0 or greater of the National Instruments CVI run-time to function correctly.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$MdaCurrentStep\n\nInteger\n\nThe test step number to index to.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$TestLoLimit\n\nString\n\nThe low limit of the indexed test step.\n\n\n\n\n\nMda_GetMeasuredValueDbl\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Mda_GetMeasuredValueDbl": {
  "prefix": "Mda_GetMeasuredValueDbl",
  "body": [
   "$$TestValue=Mda_GetMeasuredValueDbl($$MdaCurrentStep);"
  ],
  "description": "\n\nThis function uses the Checksum TR10 EMS software.\n\nThis function returns data from the MDA test results.\n\nNote: This function requires the installation of version 6.0 or greater of the National Instruments CVI run-time to function correctly.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$MdaCurrentStep\n\nInteger\n\nThe test step number to index to.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$TestValue\n\nDouble\n\nThe value measured from the indexed test step.\n\n\n\n\n\nMda_GetMeasuredValueStr\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Mda_GetMeasuredValueStr": {
  "prefix": "Mda_GetMeasuredValueStr",
  "body": [
   "$$TestValue=Mda_GetMeasuredValueStr($$MdaCurrentStep);"
  ],
  "description": "\n\nThis function uses the Checksum TR10 EMS software.\n\nThis function returns data from the MDA test results.\n\nNote: This function requires the installation of version 6.0 or greater of the National Instruments CVI run-time to function correctly.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$MdaCurrentStep\n\nInteger\n\nThe test step number to index to.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$TestValue\n\nString\n\nThe value measured of the indexed test step.\n\n\n\n\n\nMda_GetPassFailFlag\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Mda_GetPassFailFlag": {
  "prefix": "Mda_GetPassFailFlag",
  "body": [
   "$$PassFlag=Mda_GetPassFailFlag($$MdaCurrentStep);"
  ],
  "description": "\n\nThis function uses the Checksum TR10 EMS software.\n\nThis function returns data from the MDA test results.\n\nNote: This function requires the installation of version 6.0 or greater of the National Instruments CVI run-time to function correctly.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$MdaCurrentStep\n\nInteger\n\nThe test step number to index to.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$PassFlag\n\nBoolean\n\nThe test result of the indexed test step.\n\n\n\n\n\nMda_GetTestTitleStr\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Mda_GetTestTitleStr": {
  "prefix": "Mda_GetTestTitleStr",
  "body": [
   "$$TestName=Mda_GetTestTitleStr($$MdaCurrentStep);"
  ],
  "description": "\n\nThis function uses the Checksum TR10 EMS software.\n\nThis function returns data from the MDA test results.\n\nNote: This function requires the installation of version 6.0 or greater of the National Instruments CVI run-time to function correctly.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$MdaCurrentStep\n\nInteger\n\nThe test step number to index to.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$TestName\n\nString\n\nThe test label of the indexed test step.\n\n\n\n\n\nMda_MdaTestComplete\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Mda_MdaTestComplete": {
  "prefix": "Mda_MdaTestComplete",
  "body": [
   "$$MdaComplete=Mda_MdaTestComplete($$MdaProgramFile);"
  ],
  "description": "\n\nThis function uses the Checksum TR10 EMS software.\n\nThis function returns data from the MDA test results.\n\nNote: This function requires the installation of version 6.0 or greater of the National Instruments CVI run-time to function correctly.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$MdaProgramFile\n\nString\n\nThe test program spec file. (i.e. \"Y86801-307-A.spec\" )\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$MdaComplete\n\nBoolean\n\nStatus has testing completed.\n\n\n\n\n\nAgNA_Abort\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AgNA_Abort": {
  "prefix": "AgNA_Abort",
  "body": [
   "AgNA_Abort($$AgNA_Handle);"
  ],
  "description": "\n\nThis function requires Agilent network analyzer IVI drivers to be installed on the system.\n\nAborts all sweeps on all channels.\n\n\n\nResult:\n\nAgNA_Abort($AgNA_Handle);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AgNA_Handle\n\nobject\n\nThe object representing the instance of the Agilent network analyzer.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n\n\nExample:\n\nAgNA_Abort($AgNA_Handle);\n\n\n\n\n\nAgNA_Cal_CollectData\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AgNA_Cal_CollectData": {
  "prefix": "AgNA_Cal_CollectData",
  "body": [
   "AgNA_Cal_CollectData($$AgNA_Handle,$$channelNum,$$measurementType,$$responsePort,$$stimulusPort);"
  ],
  "description": "\n\nPerforms a calibration measurement. OPEN, SHORT, and LOAD measurements are one port cals and the stimulus and response ports are the same. Use the AgNA_Cal_SetMethod() function to select a calibration type before performing these measurements.\n\n\n\n\n\nEquivalent SCPI commands\n\n:SENSe{[1]|2|3|4}:CORRection:COLLect[:ACQuire]:{OPEN|SHORt|THRU|LOAD|ISOLation} <numeric 1><numeric2>]\n\n\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AgNA_Handle\n\nObject\n\nHandle to instrument created with the AgNA_Init() function.\n\n\n\n$channelNum\n\nInteger\n\nChannel to calibrate.\n\n\n\n$measurementType\n\nString\n\nCalibration measurement type:\n\nOPEN\n\nSHORT\n\nTHRU\n\nLOAD\n\nISOLATION\n\n\n\n$responsePort\n\nInteger\n\nResponse port (e.g., S[2]1, the response on port 2 due to a stimulus on port 1)\n\n\n\n$stimulusPort\n\nInteger\n\nStimulus port (e.g., S2[1], port 1 stimulates a response on port 2)\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariably Type\n\nDescription\n\n\n\nNone\n\n--\n\n\n\n\n\nExample:\n\n//perform measurements for OPEN & THRU cal types\n\nOperatorPrompt(\"Connect SHORT standard to port 1.\", \"OK\");\n\nAgNA_Cal_CollectData($AgNA_Handle,1, \"SHORT\", 1, 1);\n\nAgNA_WaitForOperationComplete($AgNA_Handle, 3000);\n\nOperatorPrompt(\"Connect THRU standard between ports 1 and 2.\", \"OK\");\n\nAgNA_Cal_CollectData($AgNA_Handle,1, \"THRU\", 2, 1);\n\nAgNA_WaitForOperationComplete($AgNA_Handle, 3000);\n\n\n\n\n\nAgNA_Cal_Save\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AgNA_Cal_Save": {
  "prefix": "AgNA_Cal_Save",
  "body": [
   "AgNA_Cal_Save($$AgNA_Handle,$$channelNum);"
  ],
  "description": "\n\nFrom the measured calibration data, calculates and saves the calibration coefficients depending on the selected calibration type.\n\n\n\n\n\nEquivalent SCPI commands\n\n:SENSe{[1]|2|3|4}:CORRection:COLLect:SAVE\n\n\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AgNA_Handle\n\nObject\n\nHandle to instrument created with the AgNA_Init() function.\n\n\n\n$channelNum\n\nInteger\n\nChannel to save calibration data to.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariably Type\n\nDescription\n\n\n\nNone\n\n--\n\n\n\n\n\nExample:\n\n//calculate and store cal coefficients to channel 1\n\nAgNA_Cal_Save($AgNA_Handle,1);\n\nAgNA_WaitForOperationComplete($AgNA_Handle, 3000);\n\n\n\n\n\nAgNA_Cal_SetCalKit\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AgNA_Cal_SetCalKit": {
  "prefix": "AgNA_Cal_SetCalKit",
  "body": [
   "AgNA_Cal_SetCalKit($$AgNA_Handle,$$channelNum,$$calkitNum);"
  ],
  "description": "\n\nSet the cal kit to use for calibration measurements. Each instrument will have a different set of cal kits programmed into it. You can add custom cal kit definitions, or load new ones using the disk provided with the cal kit.\n\n\n\n\n\nEquivalent SCPI commands\n\n:SENSe{[1]|2|3|4}:CORRection:COLLect:CKIT[:SELect] <numeric>\n\n\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AgNA_Handle\n\nObject\n\nHandle to instrument created with the AgNA_Init() function.\n\n\n\n$channelNum\n\nInteger\n\nChannel to save calibration data to.\n\n\n\n$calkitNum\n\nInteger\n\n# of cal kit to use (#1 starts at top, goes down list to #10). Check the cal kit menu on the instrument to see the names of the cal kits.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariably Type\n\nDescription\n\n\n\nNone\n\n--\n\n\n\n\n\nExample:\n\n//set cal kit for channel 1 to first kit in list\n\nAgNA_Cal_SetCalKit($E5062A,1, 1);\n\n\n\n\n\nAgNA_Cal_SetMethod\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AgNA_Cal_SetMethod": {
  "prefix": "AgNA_Cal_SetMethod",
  "body": [
   "AgNA_Cal_SetMethod($$AgNA_Handle,$$channelNum,$$methodType,$$responsePort,$$stimulusPort);"
  ],
  "description": "\n\nSelects the calibration type. This will affect how the calibration coefficients are calculated, as well as which measurements using the AgNA_Cal_CollectData() function are necessary for a complete cal. SOLT1, OPEN, and SHORT methods use the same stimulus and response ports.\n\n\n\n\n\nEquivalent SCPI commands\n\n:SENSe{[1]|2|3|4}:CORRection:COLLect:METHod:{SOLT1|SOLT2|OPEN|SHORT|THRU|ERES} <numeric 1><numeric 2>]\n\n\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AgNA_Handle\n\nObject\n\nHandle to instrument created with the AgNA_Init() function.\n\n\n\n$channelNum\n\nInteger\n\nChannel to calibrate.\n\n\n\n$methodType\n\nString\n\nCalibration method:\n\nSOLT1 \u2013 1 port reflect (short-open-load)\n\nSOLT2 \u2013 2 port full (short-open-load-thru)\n\nOPEN \u2013 1 port open response\n\nSHORT \u2013 1 port short response\n\nTHRU \u2013 2 port thru response\n\nERES \u2013 enhanced response\n\n\n\n$responsePort\n\nInteger\n\nResponse port (e.g., S[2]1, the response on port 2 due to a stimulus on port 1)\n\n\n\n$stimulusPort\n\nInteger\n\nStimulus port (e.g., S2[1], port 1 stimulates a response on port 2)\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariably Type\n\nDescription\n\n\n\nNone\n\n--\n\n\n\n\n\nExample:\n\nUpdateStatus(\"\\nCalibrating out cables for 1-stimulus port NA setup (S21 response on CH1)\");\n\nAgNA_Cal_SetCalKit($E5062A, 1, 1); //set cal kit\n\nAgNA_Cal_SetMethod($E5062A, 1, \"ERES\", 2, 1); //select calibration method\n\n\n\n\n\n//perform measurements for selected cal type - OPEN, SHORT, THRU, LOAD\n\n$timeout = 3000;\n\nOperatorPrompt(\"Connect SHORT standard to port 1.\", \"OK\");\n\nAgNA_Cal_CollectData($AgNA_Handle, 1, \"SHORT\", 1, 1);\n\nAgNA_WaitForOperationComplete($AgNA_Handle, $timeout);\n\nOperatorPrompt(\"Connect OPEN standard to port 1.\", \"OK\");\n\nAgNA_Cal_CollectData($AgNA_Handle, 1, \"OPEN\", 1, 1);\n\nAgNA_WaitForOperationComplete($AgNA_Handle, $timeout);\n\nOperatorPrompt(\"Connect LOAD standard to port 1.\", \"OK\");\n\nAgNA_Cal_CollectData($AgNA_Handle, 1, \"LOAD\", 1, 1);\n\nAgNA_WaitForOperationComplete($AgNA_Handle, $timeout);\n\nOperatorPrompt(\"Connect thru standard between port 2 and port 1.\", \"OK\");\n\nAgNA_Cal_CollectData($AgNA_Handle, 1, \"THRU\", 2, 1);\n\nAgNA_WaitForOperationComplete($AgNA_Handle, $timeout);\n\n\n\n//calculate and store cal coefficients\n\nAgNA_Cal_Save($AgNA_Handle, 1);\n\nAgNA_WaitForOperationComplete($AgNA_Handle, $timeout);\n\n\n\n//save the cal state into slot 2\n\n$state02 = \"STATE02.STA\";\n\nAgNA_SaveState($AgNA_Handle, $state02);\n\nAgNA_WaitForOperationComplete($AgNA_Handle, $timeout);\n\n\n\nOperatorPrompt(\"Calibration cables have been calibrated out. Calibration data stored in State #2.\",\"OK\");\n\n\n\n\n\nAgNA_Chan_GetChannelName\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AgNA_Chan_GerChannelName": {
  "prefix": "AgNA_Chan_GerChannelName",
  "body": [
   "AgNA_Chan_GerChannelName($$AgNA_Handle,$$channelNum);"
  ],
  "description": "\n\nReturns the name of the specified channel number. Channel names are used by several functions to reference the channel.\n\n\n\n\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AgNA_Handle\n\nObject\n\nHandle to instrument created with the AgNA_Init() function.\n\n\n\n$channelNum\n\nInteger\n\nChannel to retrieve name of.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariably Type\n\nDescription\n\n\n\n$channelName\n\nString\n\nName of channel.\n\n\n\n\n\nExample:\n\n//get NetAn\u2019s internal name for channel #1\n\n$Channel1 = AgNA_Chan_GetChannelName($AgNA_Handle, 1);\n\n\n\n\n\nAgNA_Chan_Meas_Create\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AgNA_Chan_Meas_Create": {
  "prefix": "AgNA_Chan_Meas_Create",
  "body": [
   "AgNA_Chan_Meas_Create($$AgNA_Handle,$$ChannelName,$$MeasurementName,$$ReceiverPort,$$SourcePort);"
  ],
  "description": "\n\nThis function requires Agilent network analyzer IVI drivers to be installed on the system.\n\nThis function creates a new measurement with specified Source and Receiver port values.\n\n\n\nResult:\n\nAgNA_Chan_Meas_Create($AgNA_Handle,$ChannelName,$MeasurementName,$ReceiverPort,$SourcePort);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AgNA_Handle\n\nobject\n\nThe object representing the instance of the Agilent network analyzer.\n\n\n\n$ChannelName\n\nstring\n\nThe name of the channel.\n\n\n\n$MeasurementName\n\nstring\n\nThe name of the measurement.\n\n\n\n$ReceiverPort\n\ninteger\n\nThe instrument receiver port value.\n\n\n\n$SourcePort\n\ninteger\n\nThe instrument source port value.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n\n\nExample:\n\n// This example creates an S21 measurement.\n\nAgNA_Chan_Meas_Create($AgNA_Handle,\"Channel1\",\"Measurement1\",2,1);\n\n\n\n\n\nAgNA_Chan_Meas_Delete\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AgNA_Chan_Meas_Delete": {
  "prefix": "AgNA_Chan_Meas_Delete",
  "body": [
   "AgNA_Chan_Meas_Delete($$AgNA_Handle,$$channelName,$$measurementName);"
  ],
  "description": "\n\nThis function deletes a measurement for the specified channel.\n\n\n\n\n\nRemarks:\n\nThis function requires Agilent Network Analyzer IVI drivers to be installed on the system.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AgNA_Handle\n\nObject\n\nThe object representing the instance of the Agilent Network Analyzer.\n\n\n\n$channelName\n\nString\n\nThe name of the channel.\n\n\n\n$measurementName\n\nString\n\nThe name of the measurement.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n\n\n\n\n// Delete one measurement.\n\n$channel = \"Channel1\";\n\n$measName = \"Measurement1\";\n\n\n\nAgNA_Chan_Meas_Delete($agHandle, $channel, $measName);\n\n\n\n\n\nAgNA_Chan_Meas_GetTraceName\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AgNA_Chan_Meas_GetTraceName": {
  "prefix": "AgNA_Chan_Meas_GetTraceName",
  "body": [
   "AgNA_Chan_Meas_GetTraceName($$AgNA_Handle,$$channelNum,$$traceNum);"
  ],
  "description": "\n\nReturns the name of the specified trace (measurement) number. Trace names are used by several functions to reference the trace.\n\n\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AgNA_Handle\n\nObject\n\nHandle to instrument created with the AgNA_Init() function.\n\n\n\n$channelNum\n\nInteger\n\nChannel #.\n\n\n\n$traceNum\n\nInteger\n\nTrace #.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariably Type\n\nDescription\n\n\n\n$traceName\n\nString\n\nName of trace.\n\n\n\n\n\nExample:\n\n//get NetAn\u2019s internal name for trace #1 of channel #1\n\n$Trace1 = AgNA_Chan_Meas_GetTraceName($AgNA_Handle, 1, 1);\n\n\n\n\n\nAgNA_Chan_Meas_Marker_Activate\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AgNA_Chan_Meas_Marker_Activate": {
  "prefix": "AgNA_Chan_Meas_Marker_Activate",
  "body": [
   "AgNA_Chan_Meas_Marker_Activate($$AgNA_Handle,$$ChannelName,$$MeasurementName,$$MarkerName);"
  ],
  "description": "\n\nThis function requires Agilent network analyzer IVI drivers to be installed on the system.\n\nThis function activates the selected marker of the measurement on a channel.\n\n\n\nResult:\n\nAgNA_Chan_Meas_Marker_Activate($AgNA_Handle,$ChannelName,$MeasurementName,$MarkerName);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AgNA_Handle\n\nobject\n\nThe object representing the instance of the Agilent network analyzer.\n\n\n\n$ChannelName\n\nstring\n\nThe name of the channel where you want to activate the marker.\n\n\n\n$MeasurementName\n\nstring\n\nThe name of the measurement where you want to activate the marker.\n\n\n\n$MarkerName\n\nstring\n\nThe name of the marker to activate.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n\n\nExample:\n\nAgNA_Chan_Meas_Marker_Activate($AgNA_Handle,\"Channel1\",\"Measurement1\",\"Marker1\");\n\n\n\n\n\nAgNA_Chan_Meas_Marker_GetProperty\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AgNA_Chan_Meas_Marker_GetProperty": {
  "prefix": "AgNA_Chan_Meas_Marker_GetProperty",
  "body": [
   "$$PropertyValue=AgNA_Chan_Meas_Marker_GetProperty($$AgNA_Handle,$$ChannelName,$$MeasurementName,$$MarkerName,$$Property);"
  ],
  "description": "\n\nThis function requires Agilent network analyzer IVI drivers to be installed on the system.\n\nThis function sets a selected property of a channel measurement marker to the provided value.\n\n\n\nResult:\n\n$PropertyValue = AgNA_Chan_Meas_Marker_GetProperty($AgNA_Handle,$ChannelName,$MeasurementName,$MarkerName,$Property);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AgNA_Handle\n\nobject\n\nThe object representing the instance of the Agilent network analyzer.\n\n\n\n$ChannelName\n\nstring\n\nThe name of the channel.\n\n\n\n$MeasurementName\n\nstring\n\nThe name of the measurement.\n\n\n\n$MarkerName\n\nstring\n\nThe name of the marker.\n\n\n\n$Property\n\nstring\n\nThe marker property you want to get the value.\n\nValid values:\n\n\u00b7 BANDWIDTH_THRESHOLD (double)\n\n\u00b7 ENABLED (boolean)\n\n\u00b7 PEAK_EXCURSION (double)\n\n\u00b7 STIMULUS (double)\n\n\u00b7 TARGET_VALUE (double)\n\n\u00b7 TRACK_ENABLED (boolean)\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$PropertyValue\n\nobject\n\nThe value of the property.\n\n\n\n\n\nExample:\n\n$PropertyValue = AgNA_Chan_Meas_Marker_SetProperty($AgNAObj,\"Channel1\",\"Measurement1\",\"Marker1\",\"enabled\");\n\n\n\n\n\nAgNA_Chan_Meas_QueryValue\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AgNA_Chan_Meas_Marker_QueryValue": {
  "prefix": "AgNA_Chan_Meas_Marker_QueryValue",
  "body": [
   "($$RealValue,$$ImaginaryValue)=AgNA_Chan_Meas_Marker_QueryValue($$AgNA_Handle,$$ChannelName,$$MeasurementName,$$MarkerName);"
  ],
  "description": "\n\nThis function requires Agilent network analyzer IVI drivers to be installed on the system.\n\nThis function queries the marker position value and returns the real dB value.\n\n\n\nResult:\n\n($RealValue,$ImaginaryValue) = AgNA_Chan_Meas_Marker_QueryValue($AgNA_Handle,$ChannelName,$MeasurementName,$MarkerName);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AgNA_Handle\n\nobject\n\nThe object representing the instance of the Agilent network analyzer.\n\n\n\n$ChannelName\n\nstring\n\nThe name of the channel.\n\n\n\n$MeasurementName\n\nstring\n\nThe name of the measurement.\n\n\n\n$MarkerName\n\nstring\n\nThe name of the marker.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$RealValue\n\nfloat\n\nReal data part.\n\n\n\n$ImaginaryValue\n\nfloat\n\nImaginary data part.\n\n\n\n\n\nExample:\n\n($RealValue,$ImaginaryValue) = AgNA_Chan_Meas_Marker_QueryValue($AgNA_Handle,\"Channel1\",\"Measurement1\",\"Marker1\");\n\n\n\n\n\nAgNA_Chan_Meas_Marker_Search\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AgNA_Chan_Meas_Marker_Search": {
  "prefix": "AgNA_Chan_Meas_Marker_Search",
  "body": [
   "AgNA_Chan_Meas_Marker_Search($$AgNA_Handle,$$ChannelName,$$MeasurementName,$$MarkerName,$$MarkerSearchType);"
  ],
  "description": "\n\nThis function requires Agilent network analyzer IVI drivers to be installed on the system.\n\nThis function moves the marker to the maximum,minimum,.... value of that measurement.\n\n\n\nResult:\n\nAgNA_Chan_Meas_Marker_Search($AgNA_Handle,$ChannelName,$MeasurementName,$MarkerName,$MarkerSearchType);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AgNA_Handle\n\nobject\n\nThe object representing the instance of the Agilent network analyzer.\n\n\n\n$ChannelName\n\nstring\n\nThe name of the channel.\n\n\n\n$MeasurementName\n\nstring\n\nThe name of the measurement.\n\n\n\n$MarkerName\n\nstring\n\nThe name of the marker.\n\n\n\n$MarkerSearchType\n\nstring\n\nThe marker search type.\n\nValid values:\n\n\u00b7 MINIMUM\n\n\u00b7 MAXIMUM\n\n\u00b7 PEAK\n\n\u00b7 PEAK_LEFT\n\n\u00b7 PEAK_RIGHT\n\n\u00b7 TARGET\n\n\u00b7 TARGET_LEFT\n\n\u00b7 TARGET_RIGHT\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n\n\nExample:\n\nAgNA_Chan_Meas_Marker_Search($AgNA_Handle,\"Channel1\",\"Measurement1\",\"Marker1\",\"MINIMUM\");\n\n\n\n\n\nAgNA_Chan_Meas_Marker_SetProperty\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AgNA_Chan_Meas_Marker_SetProperty": {
  "prefix": "AgNA_Chan_Meas_Marker_SetProperty",
  "body": [
   "AgNA_Chan_Meas_Marker_SetProperty($$AgNA_Handle,$$ChannelName,$$MeasurementName,$$MarkerName,$$Property,$$PropertyValue);"
  ],
  "description": "\n\nThis function requires Agilent network analyzer IVI drivers to be installed on the system.\n\nThis function sets a selected property of a channel measurement marker to the provided value.\n\n\n\nResult:\n\nAgNA_Chan_Meas_Marker_SetProperty($AgNA_Handle,$ChannelName,$MeasurementName,$MarkerName,$Property,$PropertyValue);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AgNA_Handle\n\nobject\n\nThe object representing the instance of the Agilent network analyzer.\n\n\n\n$ChannelName\n\nstring\n\nThe name of the channel.\n\n\n\n$MeasurementName\n\nstring\n\nThe name of the measurement.\n\n\n\n$MarkerName\n\nstring\n\nThe name of the marker.\n\n\n\n$Property\n\nstring\n\nThe marker property you want to update.\n\nValid values:\n\n\u00b7 BANDWIDTH_THRESHOLD (double)\n\n\u00b7 ENABLED (boolean)\n\n\u00b7 PEAK_EXCURSION (double)\n\n\u00b7 STIMULUS (double)\n\n\u00b7 TARGET_VALUE (double)\n\n\u00b7 TRACK_ENABLED (boolean)\n\n\n\n$PropertyValue\n\nobject\n\nThe property value for the corresponding property.\n\n\n\n\n\nThe property BANDWIDTH_THRESHOLD: This turns on and sets markers 1 through 4 to calculate filter bandwidth. The value sets the point below the maximum bandwidth peak that establishes the bandwidth of a filter. For example, if you want to determine the filter bandwidth 3 db below the bandpass peak value, set value to -3.0.\n\nThe property ENABLED: Turns the specified marker ON or OFF. Validate values are true or false.\n\nThe property PEAK_EXCURSION: Sets amplitude peak excursion for the specified marker. The Excursion value determines what is considered a 'peak'. This command applies to marker peak searches (Next peak, Peak Right, Peak Left).\n\nThe property STIMULUS: Sets the marker's X-axis value (frequency, power, or time).\n\nThe property TARGET_VALUE: Sets the target value for the specified marker when doing target searches.\n\nThe property TRACK_ENABLED: Sets the tracking capability for the specified marker. The tracking function finds the selected search function every sweep. Validate values are true or false.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n\n\nExample:\n\nAgNA_Chan_Meas_Marker_SetProperty($AgNAObj,\"Channel1\",\"Measurement1\",\"Marker1\",\"enabled\",true);\n\n\n\n\n\nAgNA_Chan_Meas_SetProperty\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AgNA_Chan_Meas_SetProperty": {
  "prefix": "AgNA_Chan_Meas_SetProperty",
  "body": [
   "AgNA_Chan_Meas_SetProperty($$AgNA_Handle,$$ChannelName,$$MeasurementName,$$Property,$$PropertyValue);"
  ],
  "description": "\n\nThis function requires Agilent network analyzer IVI drivers to be installed on the system.\n\nThis function sets a selected property of a channel measurement to the provided value.\n\n\n\nResult:\n\nAgNA_Chan_Meas_SetProperty($AgNA_Handle,$ChannelName,$MeasurementName,$Property,$PropertyValue);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AgNA_Handle\n\nobject\n\nThe object representing the instance of the Agilent network analyzer.\n\n\n\n$ChannelName\n\nstring\n\nThe name of the channel.\n\n\n\n$MeasurementName\n\nstring\n\nThe name of the measurement.\n\n\n\n$Property\n\nstring\n\nThe channel measurement property you want to update.\n\nValid values:\n\n\u00b7 DISPLAY_FORMAT (string)\n\n\u00b7 SMOOTHING (boolean)\n\n\u00b7 SMOOTHING_APERTURE (double)\n\n\u00b7 TRACE_MATH (string)\n\n\n\n$PropertyValue\n\nobject\n\nThe property value for the corresponding property.\n\n\n\n\n\nThe property DISPLAY_FORMAT: the display format for the measurement. Valid values: GROUP_DELAY, IMAG, LIN_MAG, LOG_MAG, PHASE, P_LINEAR, P_LOGARITHMIC, POLAR, P_PHASE, REAL, S_ADMITTANCE, S_COMPLEX, S_LINEAR, S_LOGARITHMIC, SMITH, SWR, U_PHASE\n\nThe property SMOOTHING: Enables/Disables smoothing on measurement. Valid values: true, false.\n\nThe property SMOOTHING_APERTURE: Sets the value of smooting aperture for the measurement.\n\nThe property TRACE_MATH: Sets the mathematical operation to be performed on the trace.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n\n\nExample:\n\nAgNA_Chan_Meas_SetProperty($AgNAObj,\"Channel1\",\"Measurement1\",\"DISPLAY_FORMAT\",\"LOG_MAG\");\n\n\n\n\n\nAgNA_Chan_Meas_Trace_AutoScale\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AgNA_Chan_Meas_Trace_AutoScale": {
  "prefix": "AgNA_Chan_Meas_Trace_AutoScale",
  "body": [
   "AgNA_Chan_Meas_Trace_AutoScale($$AgNA_Handle,$$ChannelName,$$MeasurementName);"
  ],
  "description": "\n\nThis function requires Agilent network analyzer IVI drivers to be installed on the system.\n\nThis function performs an auto scale on the selected channel measurement.\n\n\n\nResult:\n\nAgNA_Chan_Meas_Trace_AutoScale($AgNA_Handle,$ChannelName,$MeasurementName);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AgNA_Handle\n\nobject\n\nThe object representing the instance of the Agilent network analyzer.\n\n\n\n$ChannelName\n\nstring\n\nThe name of the channel.\n\n\n\n$MeasurementName\n\nstring\n\nThe name of the measurement.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n\n\nExample:\n\nAgNA_Chan_Meas_Trace_AutoScale($AgNA_Handle,\"Channel1\",\"Measurement1\");\n\n\n\n\n\nAgNA_Chan_Meas_Trace_SetProperty\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AgNA_Chan_Meas_Trace_SetProperty": {
  "prefix": "AgNA_Chan_Meas_Trace_SetProperty",
  "body": [
   "AgNA_Chan_Meas_Trace_SetProperty($$AgNA_Handle,$$ChannelName,$$MeasurementName,$$Property,$$PropertyValue);"
  ],
  "description": "\n\nThis function requires Agilent network analyzer IVI drivers to be installed on the system.\n\nThis function sets a selected property of a channel measurement trace to the provided value.\n\n\n\nResult:\n\nAgNA_Chan_Meas_Trace_SetProperty($AgNA_Handle,$ChannelName,$MeasurementName,$Property,$PropertyValue);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AgNA_Handle\n\nobject\n\nThe object representing the instance of the Agilent network analyzer.\n\n\n\n$ChannelName\n\nstring\n\nThe name of the channel.\n\n\n\n$MeasurementName\n\nstring\n\nThe name of the measurement.\n\n\n\n$Property\n\nstring\n\nThe channel measurement trace property you want to update.\n\nValid values:\n\n\u00b7 REFERENCE_VALUE (double)\n\n\u00b7 REFERENCE_POSITION (double)\n\n\u00b7 Y_SCALE (double)\n\n\n\n$PropertyValue\n\nobject\n\nThe property value for the corresponding property.\n\n\n\n\n\nThe property REFERENCE_VALUE: sets the reference value for the trace.\n\nThe property REFERENCE_POSITION: sets the reference position for the trace.\n\nThe property Y_SCALE: sets the Y scale for the trace.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n\n\nExample:\n\nAgNA_Chan_Meas_Trace_SetProperty($AgNAObj,\"Channel1\",\"Measurement1\",\"REFERENCE_VALUE\",-24.0);\n\nAgNA_Chan_Meas_Trace_SetProperty($AgNAObj,\"Channel1\",\"Measurement1\",\"REFERENCE_POSITION\",5.0);\n\nAgNA_Chan_Meas_Trace_SetProperty($AgNAObj,\"Channel1\",\"Measurement1\",\"Y_SCALE\",2.0);\n\n\n\n\n\nAgNA_Chan_SetProperty\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AgNA_Chan_SetProperty": {
  "prefix": "AgNA_Chan_SetProperty",
  "body": [
   "AgNA_Chan_SetProperty($$AgNA_Handle,$$ChannelName,$$Property,$$PropertyValue);"
  ],
  "description": "\n\nThis function requires Agilent network analyzer IVI drivers to be installed on the system.\n\nThis function sets a selected property of a channel to the provided value.\n\n\n\nResult:\n\nAgNA_Chan_SetProperty($AgNA_Handle,$ChannelName,$Property,$PropertyValue);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AgNA_Handle\n\nobject\n\nThe object representing the instance of the Agilent network analyzer.\n\n\n\n$ChannelName\n\nstring\n\nThe name of the channel.\n\n\n\n$Property\n\nstring\n\nThe channel property you want to update.\n\nValid values:\n\n\u00b7 AVERAGING (boolean)\n\n\u00b7 AVERAGING_FACTOR (integer)\n\n\u00b7 CORRECTION (boolean)\n\n\u00b7 CW_FREQUENCY (double)\n\n\u00b7 IF_BANDWIDTH (double)\n\n\u00b7 POINTS (integer)\n\n\u00b7 PORT_EXTENSION_STATUS (boolean)\n\n\u00b7 SWEEP_TIME (double)\n\n\u00b7 SWEEP_TIME_AUTO (boolean)\n\n\u00b7 SWEEP_TYPE (string)\n\n\u00b7 TRIGGER_MODE (string)\n\n\n\n$PropertyValue\n\nobject\n\nThe property value for the corresponding property.\n\n\n\n\n\nThe property AVERAGING: this turns the trace averaging on or off.\n\nThe property AVERAGING_FACTOR: Sets the number of measurement sweeps to combine for an average.\n\nThe property CORRECTION: Sets the correction state for all measurements on the channel.\n\nThe property CW_FREQUENCY: Sets the Continuous Wave frequency.\n\nThe property IF_BANDWIDTH: Sets the bandwidth of the digital IF filter to be used in the measurement.\n\nThe property POINTS: Sets the number of data points for the measurement.\n\nThe property PORT_EXTENSION_STATUS: Turns port extensions ON or OFF.\n\nThe property SWEEP_TIME: Sets the time, the analyzer takes to complete one sweep.\n\nThe property SWEEP_TYPE: Sets the sweep type of channel. Valid values: CW_TIME, LIN_FREQUENCY, LOG_FREQUENCY, POWER, SEGMENT.\n\nThe property TRIGGER_MODE: Sets the trigger mode for the specified channel. Valid values: CONTINUOUS, HOLD.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n\n\nExample:\n\nAgNA_Chan_SetProperty($AgNAObj,\"Channel1\",\"DISPLAY_FORMAT\",\"LOG_MAG\");\n\n\n\n\n\nAgNA_Chan_Stimulus_ConfigureCenterSpan\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AgNA_Chan_Stimulus_ConfigureCenterSpan": {
  "prefix": "AgNA_Chan_Stimulus_ConfigureCenterSpan",
  "body": [
   "AgNA_Chan_Stimulus_ConfigureCenterSpan($$AgNA_Handle,$$ChannelName,$$MeasurementName,$$CenterValue,$$SpanValue);"
  ],
  "description": "\n\nThis function requires Agilent network analyzer IVI drivers to be installed on the system.\n\nSets the sweep range for the channel using center and span value of the frequencies.\n\n\n\nResult:\n\nAgNA_Chan_Stimulus_ConfigureCenterSpan($AgNA_Handle,$ChannelName,$MeasurementName,$CenterValue,$SpanValue);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AgNA_Handle\n\nobject\n\nThe object representing the instance of the Agilent network analyzer.\n\n\n\n$ChannelName\n\nstring\n\nThe name of the channel.\n\n\n\n$MeasurementName\n\nstring\n\nTHIS ARGUMENT IS NOT NECESSARY FOR THIS FUNCTION. Use a blank or dummy value.\n\n\n\n$CenterValue\n\ndouble\n\nThe center frequency value of the sweep for the channel\n\n\n\n$SpanValue\n\ndouble\n\nThe span value of the sweep for the channel\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n\n\nExample:\n\nAgNA_Chan_Stimulus_ConfigureCenterSpan($AgNA_Handle,\"Channel1\", \"\",63870000,5000000);\n\n\n\n\n\nAgNA_Chan_Stimulus_ConfigureStartStop\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AgNA_Chan_Stimulus_ConfigureStartStop": {
  "prefix": "AgNA_Chan_Stimulus_ConfigureStartStop",
  "body": [
   "AgNA_Chan_Stimulus_ConfigureStartStop($$AgNA_Handle,$$ChannelName,$$MeasurementName,$$StartValue,$$StopValue);"
  ],
  "description": "\n\nThis function requires Agilent network analyzer IVI drivers to be installed on the system.\n\nSets the sweep range for the channel using start and stop value of the frequencies.\n\n\n\nResult:\n\nAgNA_Chan_Stimulus_ConfigureStartStop($AgNA_Handle,$ChannelName,$MeasurementName,$StartValue,$StopValue);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AgNA_Handle\n\nobject\n\nThe object representing the instance of the Agilent network analyzer.\n\n\n\n$ChannelName\n\nstring\n\nThe name of the channel.\n\n\n\n$MeasurementName\n\nstring\n\nTHIS ARGUMENT IS NOT NECESSARY FOR THIS FUNCTION. Use a blank or dummy value.\n\n\n\n$StartValue\n\ndouble\n\nThe start value of the sweep range of channel.\n\n\n\n$StopValue\n\ndouble\n\nThe stop value of the sweep range of channel.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n\n\nExample:\n\nAgNA_Chan_Stimulus_ConfigureStartStop($AgNAObj,\"Channel1\",\"\",61370000,66370000);\n\n\n\n\n\nAgNA_Clear\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AgNA_Clear": {
  "prefix": "AgNA_Clear",
  "body": [
   "AgNA_Clear($$AgNA_Handle);"
  ],
  "description": "\n\nThis function requires Agilent network analyzer IVI drivers to be installed on the system.\n\nClear event registers and error que.\n\n\n\nResult:\n\nAgNA_Clear($AgNA_Handle);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AgNA_Handle\n\nobject\n\nThe object representing the instance of the Agilent network analyzer.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n\n\nExample:\n\nAgNA_Clear($AgNA_Handle);\n\n\n\n\n\nAgNA_Close\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AgNA_Close": {
  "prefix": "AgNA_Close",
  "body": [
   "AgNA_Close($$AgNA_Handle);"
  ],
  "description": "\n\nThis function requires Agilent network analyzer IVI drivers to be installed on the system.\n\nCloses the I/O session to the instrument.\n\n\n\nResult:\n\nAgNA_Close($AgNA_Handle);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AgNA_Handle\n\nobject\n\nThe object representing the instance of the Agilent network analyzer.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n\n\nExample:\n\nAgNA_Close($AgNA_Handle);\n\n\n\n\n\nAgNA_Disable\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AgNA_Disable": {
  "prefix": "AgNA_Disable",
  "body": [
   "AgNA_Disable($$AgNA_Handle);"
  ],
  "description": "\n\nThis function requires Agilent network analyzer IVI drivers to be installed on the system.\n\nQuickly places the instrument in a state where it has no, or minimal, effect on the external system to which it is connected. This state is not necessarily a known state.\n\n\n\nResult:\n\nAgNA_Disable($AgNA_Handle);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AgNA_Handle\n\nobject\n\nThe object representing the instance of the Agilent network analyzer.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n\n\nExample:\n\nAgNA_Disable($AgNA_Handle);\n\n\n\n\n\nAgNA_FetchFormattedData\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AgNA_FetchFormattedData": {
  "prefix": "AgNA_FetchFormattedData",
  "body": [
   "AgNA_FetchFormattedData($$AgNA_Handle,$$channelName,$$measurementName);"
  ],
  "description": "\n\nReturns measurement data in the current format as set by the Measurement.Format property. Smith and Polar formats are not supported.\n\n\n\n\n\nEquivalent SCPI commands\n\n:CALCulate{[1]|2|3|4}[:SELected]:DATA:FDATa?\n\n\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AgNA_Handle\n\nObject\n\nHandle to instrument created with the AgNA_Init() function.\n\n\n\n$channelName\n\nString\n\nName of channel trace exists on (usually \"Channel1\" - \"Channel4\")\n\n\n\n$measurementName\n\nString\n\nName of measurement (trace) to save\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariably Type\n\nDescription\n\n\n\n$traceData\n\nArray\n\nArray of Float trace values in whatever format instrument is currently set to.\n\n\n\n\n\nExample:\n\n//grab trace data of trace #1 of channel #1\n\n$lossArray = AgNA_FetchFormattedData($AgNA_Handle,$Channel1,$Trace1);\n\n\n\n\n\nAgNA_Init\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AgNA_Init": {
  "prefix": "AgNA_Init",
  "body": [
   "$$AgNA_Handle=AgNA_Init($$ResourceName,$$ID_Query,$$Reset,$$OptionString);"
  ],
  "description": "\n\nThis function requires Agilent network analyzer IVI drivers to be installed on the system.\n\nOpens the I/O session to the instrument. Driver methods and properties that access the instrument are only accessible after this function is called. This function optionally performs a Reset and queries the instrument to validate the instrument model.\n\n\n\nResult:\n\n$AgNA_Handle = AgNA_Init($ResourceName,$ID_Query,$Reset,$OptionString);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ResourceName\n\nstring\n\nAn IVI logical name or an instrument specific string that identifies the address of the instrument, such as a VISA resource descriptor string.\n\n\n\n$ID_Query\n\nboolean\n\nSpecifies whether to verify the ID of the instrument.\n\n\n\n$Reset\n\nboolean\n\nSpecifies whether to reset the instrument.\n\n\n\n$OptionString\n\nstring\n\nThe user can use the OptionsString parameter to specify the initial values of certain IVI inherent attributes for the session. The format of an assignment in the OptionsString parameteris 'Name=Value', where Name is one of: RangeCheck, QuerytInstrStatus, Cache, Simulate, RecordCoercions, InterchangeCheck,or DriverSetup. Value is either true or false except for DriverSetup. If the Options String parameter contains an assignment for the Driver Setup attribute, the Initialize function assumes that everything following 'DriverSetup=' is part of the assignment.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AgNA_Handle\n\nobject\n\nThe object representing the instance of the Agilent network analyzer.\n\n\n\n\n\nExample:\n\n$AgNAObj = AgNA_Init(\"GPIB0\",true,true,\"Simulate=true, DriverSetup= Model=E5062A\");\n\n\n\n\n\nAgNA_Limit_AddLine\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AgNA_Limit_AddLine": {
  "prefix": "AgNA_Limit_AddLine",
  "body": [
   "AgNA_Limit_AddLine($$AgNA_Handle,$$channelNum,$$traceNum,$$limitTypeVal,$$beginXVal,$$endXVal,$$beginYVal,$$endYVal);"
  ],
  "description": "\n\nCreates a limit line segment of the selected type using provided start and stop points.\n\n\n\n\n\nEquivalent SCPI commands\n\n:CALCulate{[1]|2|3|4}:PARameter{[1]|2|3|4}:SELect\n\n:CALCulate{[1]|2|3|4}[:SELected]:LIMit:DATA <numeric 1>,\u2026,<numeric 1+(N\u00d75)>\n\n\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AgNA_Handle\n\nObject\n\nHandle to instrument created with the AgNA_Init() function.\n\n\n\n$channelNum\n\nInteger\n\nChannel number to create limit line on.\n\n\n\n$traceNum\n\nString\n\nTrace number on the channel selected to create limit line on.\n\n\n\n$limitTypeVal\n\nString\n\nType of limit line:\n\nOFF\n\nMINIMUM\n\nMAXIMUM\n\n\n\n$beginXVal\n\nFloat\n\nStart frequency\n\n\n\n$endXVal\n\nFloat\n\nStop frequency\n\n\n\n$beginYVal\n\nFloat\n\nY-value at start frequency (units depends on display mode).\n\n\n\n$endYVal\n\nFloat\n\nY-value at stop frequency (units depends on display mode).\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariably Type\n\nDescription\n\n\n\nNone\n\n--\n\n\n\n\n\nExample:\n\n//add a limit line on trace 1 of CH1 from 500MHz to 2GHz with a maximum value allowed of 10dB\n\nAgNA_Limit_AddLine($AgNA_Handle, 1, 1, \"MAXIMUM\", 0.500, 2, 10, 10);\n\n\n\n\n\nAgNA_Limit_DeleteAll\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AgNA_Limit_DeleteAll": {
  "prefix": "AgNA_Limit_DeleteAll",
  "body": [
   "AgNA_Limit_DeleteAll($$AgNA_Handle,$$channelNum,$$traceNum);"
  ],
  "description": "\n\nDeletes all limit lines for selected trace.\n\n\n\n\n\nEquivalent SCPI commands\n\n:CALCulate{[1]|2|3|4}:PARameter{[1]|2|3|4}:SELect\n\n:CALCulate{[1]|2|3|4}[:SELected]:LIMit[:STATe] {OFF|0}\n\n\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AgNA_Handle\n\nObject\n\nHandle to instrument created with the AgNA_Init() function.\n\n\n\n$channelNum\n\nInteger\n\nChannel number.\n\n\n\n$traceNum\n\nString\n\nTrace number on the channel selected.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariably Type\n\nDescription\n\n\n\nNone\n\n--\n\n\n\n\n\nExample:\n\nAgNA_Limit_DeleteAll($AgNA_Handle, 1, 1); //delete all limit lines on trace 1 of CH1\n\n\n\n\n\nAgNA_Limit_Enable\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AgNA_Limit_Enable": {
  "prefix": "AgNA_Limit_Enable",
  "body": [
   "AgNA_Limit_Enable($$AgNA_Handle,$$channelNum,$$traceNum,$$limitEnable);"
  ],
  "description": "\n\nTurns limit testing on/off.\n\n\n\n\n\nEquivalent SCPI commands\n\n:CALCulate{[1]|2|3|4}:PARameter{[1]|2|3|4}:SELect\n\n:CALCulate{[1]|2|3|4}[:SELected]:LIMit[:STATe] {ON|OFF|1|0}\n\n\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AgNA_Handle\n\nObject\n\nHandle to instrument created with the AgNA_Init() function.\n\n\n\n$channelNum\n\nInteger\n\nChannel number.\n\n\n\n$traceNum\n\nString\n\nTrace number on the channel selected.\n\n\n\n$limitEnable\n\nBoolean\n\nState of limit testing.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariably Type\n\nDescription\n\n\n\nNone\n\n--\n\n\n\n\n\nExample:\n\nAgNA_Limit_Enable($AgNA_Handle, 1, 1, true); //turn on limit test for trace 1 of CH1\n\n\n\n\n\nAgNA_Limit_FailCount\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AgNA_Limit_FailCount": {
  "prefix": "AgNA_Limit_FailCount",
  "body": [
   "$$numFailures=AgNA_Limit_FailCount($$AgNA_Handle,$$channelNum,$$traceNum);"
  ],
  "description": "\n\nReturns the # of points failing the limit test for the selected trace.\n\n\n\n\n\nEquivalent SCPI commands\n\n:CALCulate{[1]|2|3|4}:PARameter{[1]|2|3|4}:SELect\n\n:CALCulate{[1]|2|3|4}[:SELected]:LIMit:REPort:POINts?\n\n\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AgNA_Handle\n\nObject\n\nHandle to instrument created with the AgNA_Init() function.\n\n\n\n$channelNum\n\nInteger\n\nChannel number.\n\n\n\n$traceNum\n\nString\n\nTrace number on the channel selected.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariably Type\n\nDescription\n\n\n\n$numFailures\n\nInteger\n\nNumber of points failing the limit test for the specified trace.\n\n\n\n\n\nExample:\n\n//check # points failing limit test on trace 1 of CH1\n\n$numPointsFailing = AgNA_Limit_FailCount($AgNA_Handle, 1, 1);\n\n$measurementUnits = \"Failing points\";\n\n$measurementName = \"VSWR measurement\";\n\n$VSWR_points_failing_LL = 0;\n\n$VSWR_points_failing_UL = 10; /allow up to 10 failing points\n\nRecordMeasurementWithLimits($measurementName,$numPointsFailing,$measurementUnits,$ParametricMeasurement,$VSWR_points_failing_LL,$VSWR_points_failing_UL,$FailOnLimits);\n\n\n\n\n\nAgNA_Limit_IsPassing\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AgNA_Limit_IsPassing": {
  "prefix": "AgNA_Limit_IsPassing",
  "body": [
   "$$limitTestPass=AgNA_Limit_IsPassing($$AgNA_Handle,$$channelNum,$$traceNum);"
  ],
  "description": "\n\nReturns the status of the limit test for selected trace.\n\n\n\n\n\nEquivalent SCPI commands\n\n:CALCulate{[1]|2|3|4}:PARameter{[1]|2|3|4}:SELect\n\n:CALCulate{[1]|2|3|4}[:SELected]:LIMit:FAIL?\n\n\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AgNA_Handle\n\nObject\n\nHandle to instrument created with the AgNA_Init() function.\n\n\n\n$channelNum\n\nInteger\n\nChannel number.\n\n\n\n$traceNum\n\nString\n\nTrace number on the channel selected.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariably Type\n\nDescription\n\n\n\n$limitTestPass\n\nBoolean\n\nStatus of limit test.\n\n\n\n\n\nExample:\n\n//check limit test pass/fail status of trace 1 on CH1\n\n$limitTestPassing = AgNA_Limit_IsPassing($AgNA_Handle, 1, 1);\n\nRecordMeasurementPassFail(\"Limit test\", $limitTestPassing, \" \", $ParametricMeasurement, $limitTestPassing);\n\n\n\n\n\nAgNA_Limit_LineDisplay\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AgNA_Limit_LineDisplay": {
  "prefix": "AgNA_Limit_LineDisplay",
  "body": [
   "AgNA_Limit_LineDisplay($$AgNA_Handle,$$channelNum,$$traceNum,$$lineDisplayEnable);"
  ],
  "description": "\n\nTurns limit line display on/off.\n\n\n\n\n\nEquivalent SCPI commands\n\n:CALCulate{[1]|2|3|4}:PARameter{[1]|2|3|4}:SELect\n\n:CALCulate{[1]|2|3|4}[:SELected]:LIMit:DISPlay[:STATe] {ON|OFF|1|0}\n\n\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AgNA_Handle\n\nObject\n\nHandle to instrument created with the AgNA_Init() function.\n\n\n\n$channelNum\n\nInteger\n\nChannel number.\n\n\n\n$traceNum\n\nString\n\nTrace number on the channel selected.\n\n\n\n$lineDisplayEnable\n\nBoolean\n\nState of line display.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariably Type\n\nDescription\n\n\n\nNone\n\n--\n\n\n\n\n\nExample:\n\nAgNA_Limit_ LineDisplay($AgNA_Handle, 1, 1, true); //turn on limit line display for trace 1 of CH1\n\n\n\n\n\nAgNA_Preset\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AgNA_Preset": {
  "prefix": "AgNA_Preset",
  "body": [
   "AgNA_Preset($$AgNA_Handle);"
  ],
  "description": "\n\nThis function requires Agilent network analyzer IVI drivers to be installed on the system.\n\nDefaults bits in most of the enable and transition registers. It presets all the Transition Filters, Enable Registers, and the Error/Event Queue Enable.\n\n\n\nResult:\n\nAgNA_Preset($AgNA_Handle);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AgNA_Handle\n\nobject\n\nThe object representing the instance of the Agilent network analyzer.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n\n\nExample:\n\nAgNA_Preset($AgNA_Handle);\n\n\n\n\n\nAgNA_RecallState\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AgNA_RecallState": {
  "prefix": "AgNA_RecallState",
  "body": [
   "AgNA_RecallState($$AgNA_Handle,$$stateName);"
  ],
  "description": "\n\nRecalls the specified instrument state file (file with the .STA extension saved with the AgNA_SaveState() function). If you want to specify a file on the floppy disk drive, you need to add \u201cA:\u201d at the beginning of the file name. When you use directory names and file name, separate them with \u201c/\u201d (slash) or \u201c\\\u201d (backslash). If the specified file does not exist, an error occurs and the command is ignored. (No query).\n\n\n\n\n\nEquivalent SCPI commands\n\n:MMEMory:LOAD[:STATe] <string>\n\n\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AgNA_Handle\n\nObject\n\nHandle to instrument created with the AgNA_Init() function.\n\n\n\n$stateName\n\nString\n\nFilename of state to load.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariably Type\n\nDescription\n\n\n\nNone\n\n--\n\n\n\n\n\nExample:\n\n//load the cal state saved in slot 1\n\nAgNA_RecallState($AgNA_Handle, \"STATE01\");\n\n\n\n\n\nAgNA_Reset\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AgNA_Reset": {
  "prefix": "AgNA_Reset",
  "body": [
   "AgNA_Reset($$AgNA_Handle);"
  ],
  "description": "\n\nThis function requires Agilent network analyzer IVI drivers to be installed on the system.\n\nPlaces the instrument in a known state and configures instrument options on which the IVI specific driver depends.\n\n\n\nResult:\n\nAgNA_Reset($AgNA_Handle);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AgNA_Handle\n\nobject\n\nThe object representing the instance of the Agilent network analyzer.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n\n\nExample:\n\nAgNA_Reset($AgNA_Handle);\n\n\n\n\n\nAgNA_ResetWithDefaults\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AgNA_ResetWithDefaults": {
  "prefix": "AgNA_ResetWithDefaults",
  "body": [
   "AgNA_ResetWithDefaults($$AgNA_Handle);"
  ],
  "description": "\n\nThis function requires Agilent network analyzer IVI drivers to be installed on the system.\n\nDoes the equivalent of Reset and then, disables class extension capability groups, sets attributes to initial values defined by class specs, and configures the driver to option string settings used when Initialize was last executed.\n\n\n\nResult:\n\nAgNA_ResetWithDefaults($AgNA_Handle);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AgNA_Handle\n\nobject\n\nThe object representing the instance of the Agilent network analyzer.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n\n\nExample:\n\nAgNA_ResetWithDefaults($AgNA_Handle);\n\n\n\n\n\nAgNA_SCPI_Read\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AgNA_SCPI_Read": {
  "prefix": "AgNA_SCPI_Read",
  "body": [
   "$$Data=AgNA_SCPI_Read($$AgNA_Handle);"
  ],
  "description": "\n\nThis function requires Agilent network analyzer IVI drivers to be installed on the system.\n\nRetrieves string from instrument. Used to get the response from a SCPI query sent with the AgNA_SCPI_Write function.\n\n\n\nResult:\n\n$Data = AgNA_SCPI_Read($AgNA_Handle);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AgNA_Handle\n\nobject\n\nThe object representing the instance of the Agilent network analyzer.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Data\n\nstring\n\nReturn string from instrument.\n\n\n\n\n\nExample:\n\n$Data = AgNA_SCPI_Read($AgNA_Handle);\n\n\n\n\n\nAgNA_SCPI_Write\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AgNA_SCPI_Write": {
  "prefix": "AgNA_SCPI_Write",
  "body": [
   "AgNA_SCPI_Write($$AgNA_Handle,$$Data,$$FlushAndEnd);"
  ],
  "description": "\n\nThis function requires Agilent network analyzer IVI drivers to be installed on the system.\n\nSends a string directly to instrument. Used to communicate with and control instrument using SCPI commands.\n\n\n\nResult:\n\nAgNA_SCPI_Write($AgNA_Handle,$Data,$FlushAndEnd);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AgNA_Handle\n\nobject\n\nThe object representing the instance of the Agilent network analyzer.\n\n\n\n$Data\n\nstring\n\nSCPI command to write to the instrument.\n\n\n\n$FlushAndEnd\n\nboolean\n\nFlush and end\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n\n\nExample:\n\nAgNA_SCPI_Write($AgNA_Handle,\"RST\",true); // Reset instrument\n\nAgNA_SCPI_Write($AgNAObj,\"SOUR1:POW:ATT 0\",true); // Set power ranges\n\n\n\n\n\nAgNA_SaveState\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AgNA_SaveState": {
  "prefix": "AgNA_SaveState",
  "body": [
   "AgNA_SaveState($$AgNA_Handle,$$stateName);"
  ],
  "description": "\n\nSaves the instrument state (data to be saved specified with the :MMEM:STOR:STYP command) into a file. Filename will automatically add the .STA file extension, if missing. Default directory is the D: drive. If you want to specify a file on the floppy disk drive, you need to add \u201cA:\u201d at the beginning of the file name. When you use directory names and file name, separate them with \u201c/\u201d (slash) or \u201c\\\u201d (backslash). Notice that if a file with the specified file name exists, its contents are overwritten. (No query).\n\n\n\n\n\nEquivalent SCPI commands\n\n:MMEMory:STORe[:STATe] <string>\n\n\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AgNA_Handle\n\nObject\n\nHandle to instrument created with the AgNA_Init() function.\n\n\n\n$stateName\n\nString\n\nFilename to save state to.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariably Type\n\nDescription\n\n\n\nNone\n\n--\n\n\n\n\n\nExample:\n\n//save the cal state into slot 1\n\n$state01 = \"STATE01.STA\";\n\nAgNA_SaveState($AgNA_Handle, $state01);\n\n\n\n\n\nAgNA_SetTimeout\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AgNA_SetTimeout": {
  "prefix": "AgNA_SetTimeout",
  "body": [
   "AgNA_SetTimeout($$AgNA_Handle,$$timeoutms);"
  ],
  "description": "\n\nSets the instrument communication timeout value, in ms. Raise this if some commands are throwing IO timeout errors.\n\n\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AgNA_Handle\n\nObject\n\nHandle to instrument created with the AgNA_Init() function.\n\n\n\n$timeoutms\n\nInteger\n\nInstrument communication timeout in ms.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariably Type\n\nDescription\n\n\n\nNone\n\n--\n\n\n\n\n\nExample:\n\nAgNA_SetTimeout($AgNA_Handle, 5000); //set command timeout to 5s\n\n\n\n\n\nAgNA_SetTriggerSource\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AgNA_SetTriggerSource": {
  "prefix": "AgNA_SetTriggerSource",
  "body": [
   "AgNA_SetTriggerSource($$AgNA_Handle,$$sourceString);"
  ],
  "description": "\n\nSelects trigger source from one of four sources - internal, external, manual (front panel) or bus (programmatic).\n\n\n\n\n\nEquivalent SCPI commands\n\n:TRIGger[:SEQuence]:SOURce {INTernal|EXTernal|MANual|BUS}\n\n\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AgNA_Handle\n\nObject\n\nHandle to instrument created with the AgNA_Init() function.\n\n\n\n$sourceString\n\nString\n\nTrigger source. Valid values are:\n\n? INTERNAL\n\n? EXTERNAL\n\n? MANUAL\n\n? BUS\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariably Type\n\nDescription\n\n\n\nNone\n\n--\n\n\n\n\n\nExample:\n\n//set trigger source to internal (automatic) stimulus\n\nAgNA_SetTriggerSource($AgNA_Handle, \"INTERNAL\");\n\n\n\n\n\nAgNA_TriggerSweep\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AgNA_TriggerSweep": {
  "prefix": "AgNA_TriggerSweep",
  "body": [
   "AgNA_TriggerSweep($$AgNA_Handle,$$channelName,$$timeoutms);"
  ],
  "description": "\n\nThis will trigger the sweeps on a channel. Method does not return until sweep complete or timeout value exceeded.\n\n\n\n\n\nEquivalent SCPI commands\n\n:TRIGger[:SEQuence]:SINGle ; "
 }
,
 "JTS AgNA_WaitForOperationComplete": {
  "prefix": "AgNA_WaitForOperationComplete",
  "body": [
   "AgNA_WaitForOperationComplete($$AgNA_Handle,$$timeoutms);"
  ],
  "description": "\n\nWaits for the execution of all commands sent before this command to be completed.\n\n\n\n\n\nEquivalent SCPI commands\n\n"
 }
,
 "JTS AgDSO1000A_AutoScale": {
  "prefix": "AgDSO1000A_AutoScale",
  "body": [
   "$$ErrorCode=AgDSO1000A_AutoScale($$Handle);"
  ],
  "description": "\n\nThis function requires Agilent IO Libraries Suite (Agilent VISA-COM) to be installed on the system.\n\nAuto scales the oscilloscope settings according to the input signals.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with the Agilent DSO1022A.\n\n\u00b7 All 1000 Series oscilloscope models can be controlled by this library.\n\n\n\nResult:\n\n$ErrorCode = AgDSO1000A_AutoScale($Handle);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nThe handle of the instrument created by the initialization function.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\nInteger\n\nThe return value of the function execution.\n\nValues:\n\n\u00b7 $ErrorCode == 0 : successful\n\n\u00b7 $ErrorCode <> 0 : an error occurred.\n\n\n\n\n\nExample:\n\n$ErrorCode = AgDSO1000A_AutoScale($Handle);\n\n\n\n\n\nAgDSO1000A_ClearStatus\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AgDSO1000A_ClearStatus": {
  "prefix": "AgDSO1000A_ClearStatus",
  "body": [
   "$$ErrorCode=AgDSO1000A_ClearStatus($$Handle);"
  ],
  "description": "\n\nThis function requires Agilent IO Libraries Suite (Agilent VISA-COM) to be installed on the system.\n\nClears all status and error registers.of the oscilloscope.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with the Agilent DSO1022A.\n\n\u00b7 All 1000 Series oscilloscope models can be controlled by this library.\n\n\n\nResult:\n\n$ErrorCode = AgDSO1000A_ClearStatus($Handle);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nThe handle of the instrument created by the initialization function.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\nInteger\n\nThe return value of the function execution.\n\nValues:\n\n\u00b7 $ErrorCode == 0 : successful\n\n\u00b7 $ErrorCode <> 0 : an error occurred.\n\n\n\n\n\nExample:\n\n$ErrorCode = AgDSO1000A_ClearStatus($Handle);\n\n\n\n\n\nAgDSO1000A_Close\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AgDSO1000A_Close": {
  "prefix": "AgDSO1000A_Close",
  "body": [
   "AgDSO1000A_Close($$Handle);"
  ],
  "description": "\n\nThis function requires Agilent IO Libraries Suite (Agilent VISA-COM) to be installed on the system.\n\nCloses the session to the specified device.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with the Agilent DSO1022A.\n\n\u00b7 All 1000 Series oscilloscope models can be controlled by this library.\n\n\n\nResult:\n\nAgDSO1000A_Close($Handle);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nThe handle of the instrument created by the initialization function.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n\n\nExample:\n\nAgDSO1000A_Close($Handle);\n\n\n\n\n\nAgDSO1000A_CounterEnable\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AgDSO1000A_CounterEnable": {
  "prefix": "AgDSO1000A_CounterEnable",
  "body": [
   "$$ErrorCode=AgDSO1000A_CounterEnable($$Handle,$$OnOff);"
  ],
  "description": "\n\nThis function requires Agilent IO Libraries Suite (Agilent VISA-COM) to be installed on the system.\n\nTurns the hardware frequency counter on or off.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with the Agilent DSO1022A.\n\n\u00b7 All 1000 Series oscilloscope models can be controlled by this library.\n\n\n\nResult:\n\n$ErrorCode = AgDSO1000A_CounterEnable($Handle,$OnOff);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nThe handle of the instrument created by the initialization function.\n\n\n\n$OnOff\n\nBoolean\n\nSpecifies whether the hardware counter needs to be enabled or not.\n\nValues:\n\n\u00b7 true : hardware counter enabled\n\n\u00b7 true : hardware counter disabled\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\nInteger\n\nThe return value of the function execution.\n\nValues:\n\n\u00b7 $ErrorCode == 0 : successful\n\n\u00b7 $ErrorCode <> 0 : an error occurred.\n\n\n\n\n\nExample:\n\n$ErrorCode = AgDSO1000A_CounterEnable($Handle,true);\n\n$ErrorCode = AgDSO1000A_CounterEnable($Handle,false);\n\n\n\n\n\nAgDSO1000A_Init\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AgDSO1000A_Init": {
  "prefix": "AgDSO1000A_Init",
  "body": [
   "($$Handle,$$ErrorCode)=AgDSO1000A_Init($$ResourceString);"
  ],
  "description": "\n\nThis function requires Agilent IO Libraries Suite (Agilent VISA-COM) to be installed on the system.\n\nOpens a session to the specified device using the interface and address specified in the variable ResourceString.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with the Agilent DSO1022A.\n\n\u00b7 All 1000 Series oscilloscope models can be controlled by this library.\n\n\n\nResult:\n\n($Handle,$ErrorCode) = AgDSO1000A_Init($ResourceString);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ResourceString\n\nString\n\nThe VISA address of the oscilloscope. Get the VISA address from the Agilent Connection Expert installed with the Agilent IO Libraries Suite.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nA handle to the instrument\n\n\n\n$ErrorCode\n\nInteger\n\nThe return value of the function execution.\n\nValues:\n\n\u00b7 $ErrorCode == 0 : successful\n\n\u00b7 $ErrorCode <> 0 : an error occurred.\n\n\n\n\n\nExample:\n\n($Handle,$ErrorCode) = AgDSO1000A_Init(\"USB0::0x0957::0x0588::CN49424291::0::INSTR\");\n\n\n\n\n\nAgDSO1000A_LoadSystemSetup\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AgDSO1000A_LoadSystemSetup": {
  "prefix": "AgDSO1000A_LoadSystemSetup",
  "body": [
   "$$ErrorCode=AgDSO1000A_LoadSystemSetup($$Handle,$$BinFile);"
  ],
  "description": "\n\nThis function requires Agilent IO Libraries Suite (Agilent VISA-COM) to be installed on the system.\n\nSets up the oscilloscope as defined by the data in the binary file. The binary file can be crreated using the function AgDSO1000A_SaveSystemSetup.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with the Agilent DSO1022A.\n\n\u00b7 All 1000 Series oscilloscope models can be controlled by this library.\n\n\n\nResult:\n\n$ErrorCode = AgDSO1000A_LoadSystemSetup($Handle,$BinFile);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nThe handle of the instrument created by the initialization function.\n\n\n\n$BinFile\n\nString\n\nThe path and name of the binary setup file to load to the oscilloscope.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\nInteger\n\nThe return value of the function execution.\n\nValues:\n\n\u00b7 $ErrorCode == 0 : successful\n\n\u00b7 $ErrorCode <> 0 : an error occurred.\n\n\n\n\n\nExample:\n\n$ErrorCode = AgDSO1000A_LoadSystemSetup($Handle,\"C:\\\\27MHz.stp\");\n\n\n\n\n\nAgDSO1000A_Lock\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AgDSO1000A_Lock": {
  "prefix": "AgDSO1000A_Lock",
  "body": [
   "$$ErrorCode=AgDSO1000A_Lock($$Handle);"
  ],
  "description": "\n\nThis function requires Agilent IO Libraries Suite (Agilent VISA-COM) to be installed on the system.\n\nDisables the front panel of the oscilloscope.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with the Agilent DSO1022A.\n\n\u00b7 All 1000 Series oscilloscope models can be controlled by this library.\n\n\n\nResult:\n\n$ErrorCode = AgDSO1000A_Lock($Handle);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nThe handle of the instrument created by the initialization function.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\nInteger\n\nThe return value of the function execution.\n\nValues:\n\n\u00b7 $ErrorCode == 0 : successful\n\n\u00b7 $ErrorCode <> 0 : an error occurred.\n\n\n\n\n\nExample:\n\n$ErrorCode = AgDSO1000A_Lock($Handle);\n\n\n\n\n\nAgDSO1000A_ManualCursorAPosX\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AgDSO1000A_ManualCursorAPosX": {
  "prefix": "AgDSO1000A_ManualCursorAPosX",
  "body": [
   "$$ErrorCode=AgDSO1000A_ManualCursorAPosX($$Handle,$$Position);"
  ],
  "description": "\n\nThis function requires Agilent IO Libraries Suite (Agilent VISA-COM) to be installed on the system.\n\nSets the manual cursor A horizontal position.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with the Agilent DSO1022A.\n\n\u00b7 All 1000 Series oscilloscope models can be controlled by this library.\n\n\n\nResult:\n\n$ErrorCode = AgDSO1000A_ManualCursorAPosX($Handle,$Position);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nThe handle of the instrument created by the initialization function.\n\n\n\n$Position\n\nInteger\n\nThe horizontal position.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\nInteger\n\nThe return value of the function execution.\n\nValues:\n\n\u00b7 $ErrorCode == 0 : successful\n\n\u00b7 $ErrorCode <> 0 : an error occurred.\n\n\n\n\n\nExample:\n\n$ErrorCode = AgDSO1000A_ManualCursorAPosX($Handle,15);\n\n\n\n\n\nAgDSO1000A_ManualCursorType\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AgDSO1000A_ManualCursorType": {
  "prefix": "AgDSO1000A_ManualCursorType",
  "body": [
   "$$ErrorCode=AgDSO1000A_ManualCursorType($$Handle,$$CursorType);"
  ],
  "description": "\n\nThis function requires Agilent IO Libraries Suite (Agilent VISA-COM) to be installed on the system.\n\nSelects between horizontal and vertical measurement manual cursors.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with the Agilent DSO1022A.\n\n\u00b7 All 1000 Series oscilloscope models can be controlled by this library.\n\n\n\nResult:\n\n$ErrorCode = AgDSO1000A_ManualCursorType($Handle,$CursorType);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nThe handle of the instrument created by the initialization function.\n\n\n\n$CursorType\n\nString\n\nThe cursor type to use.\n\nValues:\n\n\u00b7 AMPLITUDE : Selects vertical measurement manual cursors.\n\n\u00b7 TIME : Selects horizontal measurement manual cursors.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\nInteger\n\nThe return value of the function execution.\n\nValues:\n\n\u00b7 $ErrorCode == 0 : successful\n\n\u00b7 $ErrorCode <> 0 : an error occurred.\n\n\n\n\n\nExample:\n\n$ErrorCode = AgDSO1000A_ManualCursorType($Handle,\"AMPLITUDE\");\n\n\n\n\n\nAgDSO1000A_QueryNumber\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AgDSO1000A_QueryNumber": {
  "prefix": "AgDSO1000A_QueryNumber",
  "body": [
   "$$ErrorCode=AgDSO1000A_QueryNumber($$Handle,$$Command);"
  ],
  "description": "\n\nThis function requires Agilent IO Libraries Suite (Agilent VISA-COM) to be installed on the system.\n\nQueries the measurement using the measurement command.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with the Agilent DSO1022A.\n\n\u00b7 All 1000 Series oscilloscope models can be controlled by this library.\n\n\n\nResult:\n\n$ErrorCode = AgDSO1000A_QueryNumber($Handle,$Command);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nThe handle of the instrument created by the initialization function.\n\n\n\n$Command\n\nString\n\nA measure command defined by the IEEE 488.2 standard.\n\nI refer to the Agilent 1000 Series Oscilloscopes programmer's guide for the complete command set.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Result\n\nFloat\n\nThe measurement value.\n\nIf an error occurs, the value zero is returned.\n\n\n\n\n\nExample:\n\n$Result = AgDSO1000A_QueryNumber($Handle,\":MEASure:VMIN?\");\n\n$result = AgDSO1000A_QueryNumber($ScopeHandle,\":MEASure:PDELay? CHANnel2,CHANnel1\");\n\n\n\n\n\nAgDSO1000A_QueryString\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AgDSO1000A_QueryString": {
  "prefix": "AgDSO1000A_QueryString",
  "body": [
   "$$ErrorCode=AgDSO1000A_QueryString($$Handle,$$Command);"
  ],
  "description": "\n\nThis function requires Agilent IO Libraries Suite (Agilent VISA-COM) to be installed on the system.\n\nQueries the string using the measurement command.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with the Agilent DSO1022A.\n\n\u00b7 All 1000 Series oscilloscope models can be controlled by this library.\n\n\n\nResult:\n\n$ErrorCode = AgDSO1000A_QueryString($Handle,$Command);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nThe handle of the instrument created by the initialization function.\n\n\n\n$Command\n\nString\n\nA measure command defined by the IEEE 488.2 standard.\n\nI refer to the Agilent 1000 Series Oscilloscopes programmer's guide for the complete command set.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Result\n\nFloat\n\nThe measurement value.\n\nIf an error occurs, an empty string is returned.\n\n\n\n\n\nExample:\n\n$Data = AgDSO1000A_QueryString($ScopeHandle,\""
 }
,
 "JTS AgDSO1000A_Reset": {
  "prefix": "AgDSO1000A_Reset",
  "body": [
   "$$ErrorCode=AgDSO1000A_Reset($$Handle);"
  ],
  "description": "\n\nThis function requires Agilent IO Libraries Suite (Agilent VISA-COM) to be installed on the system.\n\nPlaces the oscilloscope in the factory default setup state.\n\nThe reset conditions are:\n\nAcquire Menu\n\nMode: Normal\n\n\n\nAnalog Channel Menu\n\nChannel 1: On\n\nChannel 2: Off\n\nChannel 3: Off\n\nChannel 4: Off\n\nVolts/division: 100 mV/div\n\nOffset: 0.00\n\nCoupling: DC\n\nProbe attenuation: 10X\n\nInvert: Off\n\nBW limit: Off\n\nUnits: Volts\n\n\n\n\n\nCursor Menu\n\nCursors: Off\n\n\n\n\n\nDisplay Menu\n\nInfinite persistence: Off\n\nGrid: Grid and coordinates displayed.\n\nVectors: On\n\n\n\n\n\nQuick Meas Menu\n\nSource: Channel 1\n\n\n\n\n\nRun Control\n\nScope is running\n\n\n\n\n\nTime Base Menu\n\nMain time/division: 1 us/div\n\nMain time base delay: 0.00 s\n\nZoom time/division: 500 ns/div\n\nZoom time base delay: 0.00 s\n\nMode: Y-T\n\n\n\n\n\nTrigger Menu\n\nType: Edge\n\nSweep: Auto\n\nCoupling: DC\n\nSource Channel: 1\n\nLevel: 0.0 V\n\nSlope: Rising\n\nHF Reject: Off\n\nHoldoff: 100 ns\n\n\n\n\n\nRemarks:\n\n\u00b7 This function is tested with the Agilent DSO1022A.\n\n\u00b7 All 1000 Series oscilloscope models can be controlled by this library.\n\n\n\nResult:\n\n$ErrorCode = AgDSO1000A_Reset($Handle);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nThe handle of the instrument created by the initialization function.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\nInteger\n\nThe return value of the function execution.\n\nValues:\n\n\u00b7 $ErrorCode == 0 : successful\n\n\u00b7 $ErrorCode <> 0 : an error occurred.\n\n\n\n\n\nExample:\n\n$ErrorCode = AgDSO1000A_Reset($Handle);\n\n\n\n\n\nAgDSO1000A_SaveSystemSetup\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AgDSO1000A_SaveSystemSetup": {
  "prefix": "AgDSO1000A_SaveSystemSetup",
  "body": [
   "$$ErrorCode=AgDSO1000A_SaveSystemSetup($$Handle,$$BinFile);"
  ],
  "description": "\n\nThis function requires Agilent IO Libraries Suite (Agilent VISA-COM) to be installed on the system.\n\nGets the oscilloscope setup and saves it in the binary file.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with the Agilent DSO1022A.\n\n\u00b7 All 1000 Series oscilloscope models can be controlled by this library.\n\n\n\nResult:\n\n$ErrorCode = AgDSO1000A_SaveSystemSetup($Handle,$BinFile);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nThe handle of the instrument created by the initialization function.\n\n\n\n$BinFile\n\nString\n\nThe path and name of the binary setup file to save the oscilloscope settings.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\nInteger\n\nThe return value of the function execution.\n\nValues:\n\n\u00b7 $ErrorCode == 0 : successful\n\n\u00b7 $ErrorCode <> 0 : an error occurred.\n\n\n\n\n\nExample:\n\n$ErrorCode = AgDSO1000A_SaveSystemSetup($Handle,$BinFile);\n\n\n\n\n\nAgDSO1000A_SetCursorMode\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AgDSO1000A_SetCursorMode": {
  "prefix": "AgDSO1000A_SetCursorMode",
  "body": [
   "$$ErrorCode=AgDSO1000A_SetCursorMode($$Handle,$$CursorMode);"
  ],
  "description": "\n\nThis function requires Agilent IO Libraries Suite (Agilent VISA-COM) to be installed on the system.\n\nSets the cursor mode.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with the Agilent DSO1022A.\n\n\u00b7 All 1000 Series oscilloscope models can be controlled by this library.\n\n\n\nResult:\n\n$ErrorCode = AgDSO1000A_SetCursorMode($Handle,$CursorMode);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nThe handle of the instrument created by the initialization function.\n\n\n\n$CursorMode\n\nString\n\nThe cursor mode to use.\n\nValues:\n\n\u00b7 OFF : Turns off cursors.\n\n\u00b7 MANUAL : turns on the manual cursor mode\n\n\u00b7 TRACK : turns on the tracking cursor mode\n\n\u00b7 AUTO : turns on the mode where cursors for the latest automatic measurement are displayed.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\nInteger\n\nThe return value of the function execution.\n\nValues:\n\n\u00b7 $ErrorCode == 0 : successful\n\n\u00b7 $ErrorCode <> 0 : an error occurred.\n\n\n\n\n\nExample:\n\n$ErrorCode = AgDSO1000A_SetCursorMode($Handle,\"OFF\");\n\n\n\n\n\nAgDSO1000A_Unlock\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AgDSO1000A_Unlock": {
  "prefix": "AgDSO1000A_Unlock",
  "body": [
   "$$ErrorCode=AgDSO1000A_Unlock($$Handle);"
  ],
  "description": "\n\nThis function requires Agilent IO Libraries Suite (Agilent VISA-COM) to be installed on the system.\n\nEnables the front panel of the oscilloscope.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with the Agilent DSO1022A.\n\n\u00b7 All 1000 Series oscilloscope models can be controlled by this library.\n\n\n\nResult:\n\n$ErrorCode = AgDSO1000A_Unlock($Handle);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nThe handle of the instrument created by the initialization function.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\nInteger\n\nThe return value of the function execution.\n\nValues:\n\n\u00b7 $ErrorCode == 0 : successful\n\n\u00b7 $ErrorCode <> 0 : an error occurred.\n\n\n\n\n\nExample:\n\n$ErrorCode = AgDSO1000A_Unlock($Handle);\n\n\n\n\n\nAgDSO1000A_WriteCommand\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AgDSO1000A_WriteCommand": {
  "prefix": "AgDSO1000A_WriteCommand",
  "body": [
   "$$ErrorCode=AgDSO1000A_WriteCommand($$Handle,$$Command);"
  ],
  "description": "\n\nThis function requires Agilent IO Libraries Suite (Agilent VISA-COM) to be installed on the system.\n\nSets the cursor mode.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with the Agilent DSO1022A.\n\n\u00b7 All 1000 Series oscilloscope models can be controlled by this library.\n\n\n\nResult:\n\n$ErrorCode = AgDSO1000A_WriteCommand($Handle,$Command);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nThe handle of the instrument created by the initialization function.\n\n\n\n$Command\n\nString\n\nA command defined by the IEEE 488.2 standard.\n\nI refer to the Agilent 1000 Series Oscilloscopes programmer's guide for the complete command set.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\nInteger\n\nThe return value of the function execution.\n\nValues:\n\n\u00b7 $ErrorCode == 0 : successful\n\n\u00b7 $ErrorCode <> 0 : an error occurred.\n\n\n\n\n\nExample:\n\n$ErrorCode = AgDSO1000A_WriteCommand($Handle,\":CHANnel1:SCALe 1\");\n\n\n\n\n\nDSO6102A_Close\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS DSO6102A_Close": {
  "prefix": "DSO6102A_Close",
  "body": [
   "DSO6102A_Close($$AgInstance);"
  ],
  "description": "\n\nThis function uses the Agilent IVI Instrument drivers, in order to use the DSO6102A functions in JabilTest, you need to have the Agilent COM components installed.\n\nThis function closes the DSO6102A and recovers used resources. It does not reset the unit or change it's existing settings. This function returns a passing result if the instrument can be closed successfully, otherwise a failure is generated by the script function.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AgInstance\n\nObject\n\nThe COM Object representing the instance of the DSO6102A to be closed. Closing the instrument releases all resources.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nDSO6102A_ConfigureChannel\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS DSO6102A_ConfigureChannel": {
  "prefix": "DSO6102A_ConfigureChannel",
  "body": [
   "DSO6102A_ConfigureChannel($$AgInstance,$$ChannelNumber,$$Range,$$Offset,$$Coupling,$$ProbeAtten,$$Enabled);"
  ],
  "description": "\n\nThis function uses the Agilent IVI Instrument drivers, in order to use the DSO6102A functions in JabilTest, you need to have the Agilent COM components installed.\n\nThis function configures the specified channel. In the case of instrument communication failure, or an invalid channel specified, a failure is generated by the function.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AgInstance\n\nObject\n\nThe COM Object representing the instance of the DSO6102A to be used.\n\n\n\n$ChannelNumber\n\nString\n\nThe channel on which to take the measurement.\n\n\n\n$Range\n\nFloat\n\nThe full screen range for the channel.\n\n\n\n$Offset\n\nFloat\n\nThe offset for the channel.\n\n\n\n$Coupling\n\nString\n\nThe input coupling for the channel. AC or DC.\n\n\n\n$ProbeAtten\n\nFloat\n\nThe input probe attenuation for the channel\n\n\n\n$Enabled\n\nBoolean\n\nThe enable/disable state for the channel.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nDSO6102A_ConfigureEdgeTrigger\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS DSO6102A_ConfigureEdgeTrigger": {
  "prefix": "DSO6102A_ConfigureEdgeTrigger",
  "body": [
   "DSO6102A_ConfigureEdgeTrigger($$AgInstance,$$SourceChannel,$$Level,$$Slope,$$Coupling,$$Holdoff);"
  ],
  "description": "\n\nThis function uses the Agilent IVI Instrument drivers, in order to use the DSO6102A functions in JabilTest, you need to have the Agilent COM components installed.\n\nThis function configures the scope for edge triggering. In the case of instrument communication failure, or an invalid channel specified, a failure is generated by the function.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AgInstance\n\nObject\n\nThe COM Object representing the instance of the DSO6102A to be used.\n\n\n\n$SourceChannel\n\nString\n\nThe trigger source channel\n\n\n\n$Level\n\nFloat\n\nThe trigger level.\n\n\n\n$Slope\n\nString\n\nThe trigger slope. RISING or FALLING.\n\n\n\n$Coupling\n\nString\n\nThe trigger coupling. AC or DC.\n\n\n\n$Holdoff\n\nFloat\n\nThe triggering holdoff time.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nDSO6102A_ConfigureRecord\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS DSO6102A_ConfigureRecord": {
  "prefix": "DSO6102A_ConfigureRecord",
  "body": [
   "DSO6102A_ConfigureRecord($$AgInstance,$$TimePerRecord,$$MinNumberOfPoints,$$StartTime);"
  ],
  "description": "\n\nThis function uses the Agilent IVI Instrument drivers, in order to use the DSO6102A functions in JabilTest, you need to have the Agilent COM components installed.\n\nThis function configures the record. In the case of instrument communication failure, a failure is generated by the function.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AgInstance\n\nObject\n\n\n\n\n\n$TimePerRecord\n\nFloat\n\nThe full screen time of the sweep in seconds.\n\n\n\n$MinNumberOfPoints\n\nInt\n\nThe minimum number of point in the record.\n\n\n\n$StartTime\n\nFloat\n\nThe start time relative to the trigger point for the record.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nDSO6102A_Init\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS DSO6102A_Init": {
  "prefix": "DSO6102A_Init",
  "body": [
   "$$AgInstance=DSO6102A_Init($$ResourceString);"
  ],
  "description": "\n\nThis function uses the Agilent IVI Instrument drivers, in order to use the DSO6102A functions in JabilTest, you need to have the Agilent COM components installed.\n\nThis function initializes the DSO6102A for operation. It does not reset the unit or change it's existing settings. It simply grabs an instance of the COM component to use in further test script operations. This function returns a passing result if the instrument can be initialized successfully, otherwise a failure is generated by the script function.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ResourceString\n\nString\n\nThe resource string identifying the instrument. For example, \"GPIB0::9::Instr\".\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AgInstance\n\nObject\n\nThe COM object representing the instance of the DSO6102A.\n\n\n\n\n\nDSO6102A_MeasureP2P\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS DSO6102A_MeasureP2P": {
  "prefix": "DSO6102A_MeasureP2P",
  "body": [
   "$$Measurement=DSO6102A_MeasureP2P($$AgInstance,$$ChannelNumber);"
  ],
  "description": "\n\nThis function uses the Agilent IVI Instrument drivers, in order to use the DSO6102A functions in JabilTest, you need to have the Agilent COM components installed.\n\nThis function takes a peak to peak voltage measurement on the specified channel and returns the measurement. In the case of instrument communication failure, or an invalid channel specified, a failure is generated by the function.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AgInstance\n\nObject\n\nThe COM Object representing the instance of the DSO6102A to be used.\n\n\n\n$ChannelNumber\n\nString\n\nThe channel on which to take the measurement.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Measurement\n\nFloat\n\nThe peak to peak voltage measurement from the specified channel.\n\n\n\n\n\nDSO6102A_MeasurePeriod\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS DSO6102A_MeasurePeriod": {
  "prefix": "DSO6102A_MeasurePeriod",
  "body": [
   "$$Measurement=DSO6102A_MeasurePeriod($$AgInstance,$$ChannelNumber);"
  ],
  "description": "\n\nThis function uses the Agilent IVI Instrument drivers, in order to use the DSO6102A functions in JabilTest, you need to have the Agilent COM components installed.\n\nThis function takes a Period measurement on the specified channel and returns the measurement. In the case of instrument communication failure, or an invalid channel specified, a failure is generated by the function.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AgInstance\n\nObject\n\nThe COM Object representing the instance of the DSO6102A to be used.\n\n\n\n$ChannelNumber\n\nString\n\nThe channel on which to take the measurement.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Measurement\n\nFloat\n\nThe Period measurement from the specified channel.\n\n\n\n\n\nDS06102A_ConfigureAverage\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS DSO6102A_ConfigureAverage": {
  "prefix": "DSO6102A_ConfigureAverage",
  "body": [
   "DSO6102A_ConfigureAverage($$AgInstance,$$Averages);"
  ],
  "description": "\n\nThis function uses the Agilent IVI Instrument drivers, in order to use the DSO6102A functions in JabilTest, you need to have the Agilent COM components installed.\n\nThis function configures the scope for averaging.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AgInstance\n\nObject\n\nThe COM Object representing the instance of the DSO6102A to be closed. Closing the instrument releases all resources.\n\n\n\n$Averages\n\nInteger\n\nThe number of average samples.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nDSO6102a_MeasureAverage\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS DSO6102A_MeasureAverage": {
  "prefix": "DSO6102A_MeasureAverage",
  "body": [
   "$$Measurement=DSO6102A_MeasureAverage($$AgInstance,$$ChannelNumber);"
  ],
  "description": "\n\nThis function uses the Agilent IVI Instrument drivers, in order to use the DSO6102A functions in JabilTest, you need to have the Agilent COM components installed.\n\nThis function takes an average voltage measurement on the specified channel and returns the measurement. In the case of instrument communication failure, or an invalid channel specified, a failure is generated by the function.\n\n\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AgInstance\n\nObject\n\nThe COM Object representing the instance of the DSO6102A to be closed. Closing the instrument releases all resources.\n\n\n\n$ChannelNumber\n\nString\n\nThe channel on which to take the measurement.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Measurement\n\nFloat\n\nThe average voltage measurement from the specified channel.\n\n\n\n\n\nA546XX_AcquisitionType\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS A546XX_AquisitionType": {
  "prefix": "A546XX_AquisitionType",
  "body": [
   "A546XX_AquisitionType($$A546XX_handle,$$type);"
  ],
  "description": "\n\nSpecifies how the oscilloscope acquires data and fills the waveform record.\n\nEquivalent instrument command: :ACQuire:TYPE <NORMal | AVERage | HRESolution | PEAK>\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$A546XX_handle\n\nObject\n\nHandle created by the A546XX_Initialize() function.\n\n\n\n$type\n\nString\n\nSelects the type of data acquisition that is to take place. Valid values:\n\n\u00b7 \u201cNORMAL\u201d - sets the oscilloscope in the normal mode.\n\n\u00b7 \u201cAVERAGE\u201d - sets the oscilloscope in the averaging mode. The # of averages is set by the A546XX_AverageCount function.\n\n\u00b7 \u201cHIRES\u201d - sets the oscilloscope in the high-resolution mode (also known as smoothing). This mode is used to reduce noise at slower sweep speeds where the digitizer samples faster than needed to fill memory for the displayed time range. For example, if the digitizer samples at 200 MSa/s, but the effective sample rate is 1 MSa/s (because of a slower sweep speed), only 1 out of every 200 samples needs to be stored. Instead of storing one sample (and throwing others away), the 200 samples are averaged together to provide the value for one display point. The slower the sweep speed, the greater the number of samples that are averaged together for each display point. This command is functionally equivalent to \u201cAVERAGE\u201d with a count of 1.\n\n\u00b7 \u201cPEAKDETECT\u201d - sets the oscilloscope in the peak detect mode.\n\n\u00b7 \u201cENVELOPE\u201d - sets the oscilloscope to the envelope acquisition mode. Not applicable to currently-supported models.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n-\n\n-\n\n\n\n\n\nA546XX_AquisitionRecordTime\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS A546XX_AquisitionRecordTime": {
  "prefix": "A546XX_AquisitionRecordTime",
  "body": [
   "A546XX_AquisitionRecordTime($$A546XX_handle,$$timePerRecord);"
  ],
  "description": "\n\nThe length of time in seconds that corresponds to the record length.\n\nEquivalent instrument command: :TIMebase:RANGe <range_value>\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$A546XX_handle\n\nObject\n\nHandle created by the A546XX_Initialize() function.\n\n\n\n$timePerRecord\n\nFloat\n\nLength of the full-scale horizontal time in seconds for the main window. The range is 10 times the current time-per-division setting.\n\nValid ranges are 10ns through 500s.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n-\n\n-\n\n\n\n\n\nA546XX_AquisitionStartTime\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS A546XX_AquisitionStartTime": {
  "prefix": "A546XX_AquisitionStartTime",
  "body": [
   "A546XX_AquisitionStartTime($$A546XX_handle,$$startTime);"
  ],
  "description": "\n\nThe length of time from the trigger event to the first point in the waveform record in seconds.\n\nEquivalent instrument command: : TIMebase:POSition <pos_value>\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$A546XX_handle\n\nObject\n\nHandle created by the A546XX_Initialize() function.\n\n\n\n$startTime\n\nFloat\n\nThe horizontal position in the delayed view of the main sweep. The main sweep range and the main sweep horizontal position determine the range for this command. The value for this command must keep the delayed view window within the main sweep range.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n-\n\n-\n\n\n\n\n\nA546XX_AverageCount\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS A546XX_AverageCount": {
  "prefix": "A546XX_AverageCount",
  "body": [
   "A546XX_AverageCount($$A546XX_handle,$$numAverages);"
  ],
  "description": "\n\nWhen A546XX_AquisitionType is set to \u201cAVERAGE\u201d, this sets the number of values to be averaged for each time bucket before the acquisition is considered to be complete for that time bucket.\n\nEquivalent instrument command: :ACQuire:COUNt <count>\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$A546XX_handle\n\nObject\n\nHandle created by the A546XX_Initialize() function.\n\n\n\n$numAverages\n\nFloat\n\nNumber of averages. Valid ranges are any value from 1 (smoothing) to 65536.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n-\n\n-\n\n\n\n\n\nA546XX_InitiateAcquisition\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS A546XX_InitiateAquisition": {
  "prefix": "A546XX_InitiateAquisition",
  "body": [
   "A546XX_InitiateAquisition($$A546XX_handle);"
  ],
  "description": "\n\nInitiates a waveform acquisition. After you call this function, the oscilloscope leaves the Idle state and waits for a trigger. The oscilloscope acquires a waveform for each channel you have enabled (If no channels are displayed, all channels are acquired).\n\nEquivalent instrument command: :DIGitize;"
 }
,
 "JTS A546XX_SetHorzScale": {
  "prefix": "A546XX_SetHorzScale",
  "body": [
   "A546XX_SetHorzScale($$A546XX_handle,$$secsPerDiv);"
  ],
  "description": "\n\nSets the horizontal scale or units per division for the main window (1/10th the full acquisition range).\n\nEquivalent instrument command: :TIMebase:SCALe <scale_value>\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$A546XX_handle\n\nObject\n\nHandle created by the A546XX_Initialize() function.\n\n\n\n$secsPerDiv\n\nFloat\n\nSeconds per division.\n\nValid ranges are 1ns through 50s.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n-\n\n-\n\n\n\n\n\nA546XX_ChannelConfig\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS A546XX_ChannelConfig": {
  "prefix": "A546XX_ChannelConfig",
  "body": [
   "A546XX_ChannelConfig($$A546XX_handle,$$chanNum,$$range,$$offset,$$coupling,$$probeAtten,$$enabled);"
  ],
  "description": "\n\nConfigures the most common properties of the channel (range, offset, coupling, probe attenuation, and enable) at once.\n\nEquivalent instrument command: :CHANnel<n>:RANGe <range>;\n\n:CHANnel<n>:OFFSet <offset>;\n\n:CHANnel<n>:COUPling <coupling>;\n\n:CHANnel<n>:PROBe <attenuation>;\n\n:CHANnel<n>:DISPlay <1 | 0>\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$A546XX_handle\n\nObject\n\nHandle created by the A546XX_Initialize() function.\n\n\n\n$chanNum\n\nInteger\n\nThe channel # to configure.\n\nValid ranges are 1 - 4.\n\n\n\n$range\n\nFloat\n\nThe absolute value in Volts of the full-scale input range for a channel.\n\nValid range is 16mV to 40V (using 1:1 probe attenuation)\n\n\n\n$offset\n\nFloat\n\nThe location of the center of the range that the Vertical Range attribute specifies for the selected channel. The value is with respect to ground and is in volts.\n\nValid range varies with the value set by the $range setting. If you set the offset to a value outside of the legal range, the offset value is automatically set to the nearest legal value. Legal values are affected by the probe attenuation setting.\n\n\n\n$coupling\n\nString\n\nHow the oscilloscope couples the input signal for the channel.\n\nValid values:\n\n\u00b7 \u201cAC\u201d\n\n\u00b7 \u201cDC\u201d\n\n\u00b7 \u201cGND\u201d\n\n\n\n$probeAtten\n\nFloat\n\nThe attenuation factor of the connected probe. If the oscilloscope is auto sensing the probe attenuation, setting this attribute to a positive value configures the oscilloscope to use the specified manual probe attenuation.\n\nA setting of zero will use the auto sensing value.\n\n\n\n$enabled\n\nBoolean\n\nIf True, the oscilloscope acquires a waveform for the channel.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n-\n\n-\n\n\n\n\n\nExample:\n\nA546XX_ChannelConfig($A546XX_handle, 1, 20, 0, \"AC\", 0, \"TRUE\");\n\n\n\n\n\nA546XX_ChannelEnabled\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS A546XX_ChannelEnabled": {
  "prefix": "A546XX_ChannelEnabled",
  "body": [
   "A546XX_ChannelEnabled($$A546XX_handle,$$chanNum,$$enabled);"
  ],
  "description": "\n\nIf True, the oscilloscope acquires a waveform for the channel.\n\nEquivalent instrument command: :CHANnel<n>:DISPlay <0 | 1>\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$A546XX_handle\n\nObject\n\nHandle created by the A546XX_Initialize() function.\n\n\n\n$chanNum\n\nInteger\n\nThe channel # to enable/disable.\n\nValid ranges are 1 - 4.\n\n\n\n$enabled\n\nBoolean\n\nControls display of the specified channel.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n-\n\n-\n\n\n\n\n\nA546XX_ChannelLabel\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS A546XX_ChannelLabel": {
  "prefix": "A546XX_ChannelLabel",
  "body": [
   "A546XX_ChannelLabel($$A546XX_handle,$$chanNum,$$chanLabel);"
  ],
  "description": "\n\nThe label to be displayed for a specific channel when such labels are enabled.\n\nEquivalent instrument command: :CHANnel<n>:LABel <string>\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$A546XX_handle\n\nObject\n\nHandle created by the A546XX_Initialize() function.\n\n\n\n$chanNum\n\nInteger\n\nThe channel # to label.\n\nValid ranges are 1 - 4.\n\n\n\n$chanLabel\n\nString\n\nLabel strings are six characters or less, and may contain any commonly used ASCII characters. Labels with more than 6 characters are truncated to six characters. Lower case characters are converted to upper case.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n-\n\n-\n\n\n\n\n\nA546XX_ChannelRange\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS A546XX_ChannelRange": {
  "prefix": "A546XX_ChannelRange",
  "body": [
   "A546XX_ChannelRange($$A546XX_handle,$$chanNum,$$chanRange);"
  ],
  "description": "\n\nThe absolute value in Volts of the full-scale input range for a channel (equals 8 times the volts per division setting). If the probe attenuation is changed, the range value is multiplied by the probe attenuation factor.\n\nEquivalent instrument command: :CHANnel<n>:RANGe <range>\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$A546XX_handle\n\nObject\n\nHandle created by the A546XX_Initialize() function.\n\n\n\n$chanNum\n\nInteger\n\nThe channel # to set the range for.\n\nValid ranges are 1 - 4.\n\n\n\n$chanRange\n\nFloat\n\nThe channel range defines the full-scale vertical axis of the selected channel. When using 1:1 probe attenuation, the range can be set to any value from:\n\n\u00b7 16 mV to 40 V\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n-\n\n-\n\n\n\n\n\nA546XX_SetVertScale\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS A546XX_SetVertScale": {
  "prefix": "A546XX_SetVertScale",
  "body": [
   "A546XX_SetVertScale($$A546XX_handle,$$chanNum,$$voltsPerDiv);"
  ],
  "description": "\n\nSets the vertical scale, or units per division, of the selected channel. If the probe attenuation is changed, the scale value is multiplied by the probe's attenuation factor.\n\nEquivalent instrument command: :CHANnel<n>:RANGe <range>\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$A546XX_handle\n\nObject\n\nHandle created by the A546XX_Initialize() function.\n\n\n\n$chanNum\n\nInteger\n\nThe channel # to set the scale for.\n\nValid ranges are 1 - 4.\n\n\n\n$voltsPerDiv\n\nFloat\n\nVolts per division. When using 1:1 probe attenuation, legal values for the scale range from:\n\n\u00b7 2mV to 5V\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n-\n\n-\n\n\n\n\n\nA546XX_DisplayErase\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS A546XX_DisplayErase": {
  "prefix": "A546XX_DisplayErase",
  "body": [
   "A546XX_DisplayErase($$A546XX_handle);"
  ],
  "description": "\n\nClears the display and resets all associated measurements. If the oscilloscope is stopped, all currently displayed data is erased. If the oscilloscope is running, all the data in active channels and functions is erased.\n\nEquivalent instrument command: :CDISplay\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$A546XX_handle\n\nObject\n\nHandle created by the A546XX_Initialize() function.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n-\n\n-\n\n\n\n\n\nA546XX_Simulate\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS A546XX_Simulate": {
  "prefix": "A546XX_Simulate",
  "body": [
   "A546XX_Simulate($$A546XX_handle,$$sim);"
  ],
  "description": "\n\nIf True, the driver does not perform I/O to the instrument, and returns simulated values for output parameters. Used for testing when instrument is not available.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$A546XX_handle\n\nObject\n\nHandle created by the A546XX_Initialize() function.\n\n\n\n$sim\n\nBoolean\n\nSimulate status.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n-\n\n-\n\n\n\n\n\nA546XX_Close\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS A546XX_Close": {
  "prefix": "A546XX_Close",
  "body": [
   "A546XX_Close($$A546XX_handle);"
  ],
  "description": "\n\nCloses the I/O session to the instrument. Driver methods and properties that access the instrument are not accessible after Close is called.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$A546XX_handle\n\nObject\n\nHandle created by the A546XX_Initialize() function.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n-\n\n-\n\n\n\n\n\nA546XX_Initialize\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS A546XX_Initialize": {
  "prefix": "A546XX_Initialize",
  "body": [
   "$$A546XX_handle=A546XX_Initialize($$resourceName,$$IDQuery,$$resetDevice,$$optionString);"
  ],
  "description": "\n\nCreates a new IVI instrument driver session.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$resourceName\n\nString\n\nOpens a session to the specified device using the interface and address you specify for the resourceName parameter.\n\n\n\n$IDQuery\n\nBoolean\n\nValid values are True or False.\n\nSpecifies whether to verify the ID of the instrument.\n\n\n\n$resetDevice\n\nBoolean\n\nValid values are True or False.\n\nSpecifies whether to reset the instrument.\n\n\n\n$optionString\n\nString\n\nThe user can use the $optionString parameter to specify the initial values of certain IVI inherent attributes for the session. The format of an assignment in the $optionString parameter is 'Name=Value', where Name is one of:\n\n\n\n\n\n\u00b7 RangeCheck\n\n\u00b7 QuerytInstrStatus\n\n\u00b7 Cache\n\n\u00b7 Simulate\n\n\u00b7 RecordCoercions\n\n\u00b7 InterchangeCheck\n\n\u00b7 DriverSetup\n\n\n\n\n\nValue is either true or false except for DriverSetup. If the Options String parameter contains an assignment for the Driver Setup attribute, the Initialize function assumes that everything following 'DriverSetup=' is part of the assignment.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$A546XX_handle\n\nObject\n\nReturns a handle that you use to identify the instrument in all subsequent instrument driver function calls.\n\n\n\n\n\nExample:\n\n$A546XX_handle = A546XX_Initialize(\"USB0::1689::871::C051871::0::INSTR\", False, True, \"RangeCheck=true,QueryInstrStatus=true\");\n\n\n\n\n\nA546XX_AutoScale\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS A546XX_AutoScale": {
  "prefix": "A546XX_AutoScale",
  "body": [
   "A546XX_AutoScale($$A546XX_handle);"
  ],
  "description": "\n\nPerforms an auto-setup on the instrument.\n\nEquivalent instrument command: :AUToscale\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$A546XX_handle\n\nObject\n\nHandle created by the A546XX_Initialize() function.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n-\n\n-\n\n\n\n\n\nA546XX_FetchWaveformMeasurement\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS A546XX_FetchWaveformMeasurement": {
  "prefix": "A546XX_FetchWaveformMeasurement",
  "body": [
   "$$measurement=A546XX_FetchWaveformMeasurement($$A546XX_handle,$$chanNum,$$function);"
  ],
  "description": "\n\nFetches a specified waveform measurement for a specific channel from a previously initiated waveform acquisition.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$A546XX_handle\n\nObject\n\nHandle created by the A546XX_Initialize() function.\n\n\n\n$chanNum\n\nInteger\n\nThe channel # to take a measurement from.\n\nValid ranges are 1 - 4.\n\n\n\n$function\n\nString\n\nMeasurement to perform. Valid measurements are:\n\n\u00b7 \"AMPLITUDE\" \u2013 The VOLTAGE_HIGH less the VOLTAGE_LOW in volts over the entire waveform.\n\n\u00b7 \u201cDELAY\u201d \u2013 This measure the delay between any two user specified edges. The edges can be from the same waveform or different waveform. Currently only valid between channels 1 and 2.\n\n\u00b7 \u201cDUTYCYCLENEG\u201d - The ratio of the WIDTH_NEG to the PERIOD of an integer number of cycles in the waveform expressed as a percentage.\n\n\u00b7 \u201cDUTYCYCLEPOS\u201d - The ratio of the WIDTH_POS width to the PERIOD of an integer number of cycles in the waveform expressed as a percentage.\n\n\u00b7 \u201cFALLTIME\u201d \u2013 The length of time for a falling edge of the signal to fall from the high reference level to the low reference level. The units are seconds.\n\n\u00b7 \u201cFREQUENCY\u201d \u2013 The frequency of one complete cycle in the waveform. The units are hertz.\n\n\u00b7 \u201cFREQUENCYCOUNTER\u201d \u2013 The High precision frequency measurement made with an internal frequency counter.\n\n\u00b7 \u201cOVERSHOOT\u201d \u2013 The relative waveform distortion which follows an edge transition.\n\n\u00b7 \u201cPERIOD\u201d \u2013 The length of time of one complete cycle in the waveform. The units are seconds.\n\n\u00b7 \u201cPHASE\u201d \u2013 This measures the relative phase of one waveform with respect to the period on another waveform. Currently only valid between channels 1 and 2.\n\n\u00b7 \u201cPRESHOOT\u201d \u2013 The relative waveform distortion which precedes an edge transition.\n\n\u00b7 \u201cRISETIME\u201d \u2013 The length of time for a rising edge of the signal to rise from the low reference level to the high reference level. The units are seconds.\n\n\u00b7 \u201cTIMEATMAX\u201d \u2013 The time of the maximum amplitude found in the entire waveform. The units are seconds.\n\n\u00b7 \u201cTIMEATMIN\u201d \u2013 The time of the minimum amplitude found in the entire waveform. The units are seconds.\n\n\u00b7 \u201cTIMEATVALUE\u201d \u2013 This returns the Time at the vertical value specified by the A546XX_TimeAtValueConfig function.\n\n\u00b7 \u201cTIMEOFEDGE\u201d \u2013 This returns the Time at the edge crossing specified by the A546XX_TimeOfEdgeConfig function.\n\n\u00b7 \u201cVALUEATTIME\u201d \u2013 This returns the Value at the time specified by the A546XX_ValueAtTimeConfig function.\n\n\u00b7 \u201cVOLTAGEAVG\u201d \u2013 The arithmetic average in volts measured over the entire waveform. The units are volts. Note: The oscilloscope automatically switches between this and Voltage Cycle Average.\n\n\u00b7 \u201cVOLTCYCLEAVG\u201d \u2013 The arithmetic average in volts over an integer number of cycles in the waveform. The units are volts. Note: The oscilloscope automatically switches between this and Voltage Average.\n\n\u00b7 \u201cVOLTCYCLERMS\u201d \u2013 The true Root Mean Square voltage over an integer number of cycles in the waveform. The units are volts. The oscilloscope automatically switches between this and Voltage RMS if there is a cyclic waveform on the screen.\n\n\u00b7 \u201cVOLTHIGH\u201d \u2013 The voltage that corresponds to 100% when using the reference levels. The oscilloscope calculates this value using either the min/max or histogram methods. The units are Volts.\n\n\u00b7 \u201cVOLTLOW\u201d \u2013 The voltage that corresponds to 0% when using the reference levels. The oscilloscope calculates this value using either the min/max or histogram methods. The units are Volts.\n\n\u00b7 \u201cVOLTMAX\u201d \u2013 The maximum amplitude found in the entire waveform. The units are volts.\n\n\u00b7 \u201cVOLTMIN\u201d \u2013 The minimum amplitude found in the entire waveform. The units are volts.\n\n\u00b7 \u201cVOLTPKTOPK\u201d \u2013 Peak-to-Peak voltage; the absolute difference between the VOLTAGE_MAX and the VOLTAGE_MIN. The units are volts.\n\n\u00b7 \u201cVOLTRMS\u201d \u2013 The true Root Mean Square voltage of the entire waveform. The units are volts.Note: The oscilloscope automatically switches between this and Voltage Cycle RMS.\n\n\u00b7 \u201cWIDTHNEG\u201d \u2013 The length of time between the mid reference level points of a negative pulse in the waveform. The units are seconds.\n\n\u00b7 \u201cWIDTHPOS\u201d - The length of time between the mid reference level points of a positive pulse in the waveform. The units are seconds.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$measurement\n\nFloat\n\nMeasured/calculated value returned by function.\n\n\n\n\n\nA546XX_ReadWaveformMeasurement\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS A546XX_ReadWaveformMeasurement": {
  "prefix": "A546XX_ReadWaveformMeasurement",
  "body": [
   "$$measurement=A546XX_ReadWaveformMeasurement($$A546XX_handle,$$chanNum,$$function,$$timeout);"
  ],
  "description": "\n\nInitiates a waveform acquisition, and returns a specified waveform measurement from a specific channel.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$A546XX_handle\n\nObject\n\nHandle created by the A546XX_Initialize() function.\n\n\n\n$chanNum\n\nInteger\n\nThe channel # to take a measurement from.\n\nValid ranges are 1 - 4.\n\n\n\n$function\n\nString\n\nMeasurement to perform. Valid measurements are:\n\n\u00b7 \"AMPLITUDE\" \u2013 The VOLTAGE_HIGH less the VOLTAGE_LOW in volts over the entire waveform.\n\n\u00b7 \u201cDELAY\u201d \u2013 This measure the delay between any two user specified edges. The edges can be from the same waveform or different waveform. Currently only valid between channels 1 and 2.\n\n\u00b7 \u201cDUTYCYCLENEG\u201d - The ratio of the WIDTH_NEG to the PERIOD of an integer number of cycles in the waveform expressed as a percentage.\n\n\u00b7 \u201cDUTYCYCLEPOS\u201d - The ratio of the WIDTH_POS width to the PERIOD of an integer number of cycles in the waveform expressed as a percentage.\n\n\u00b7 \u201cFALLTIME\u201d \u2013 The length of time for a falling edge of the signal to fall from the high reference level to the low reference level. The units are seconds.\n\n\u00b7 \u201cFREQUENCY\u201d \u2013 The frequency of one complete cycle in the waveform. The units are hertz.\n\n\u00b7 \u201cFREQUENCYCOUNTER\u201d \u2013 The High precision frequency measurement made with an internal frequency counter.\n\n\u00b7 \u201cOVERSHOOT\u201d \u2013 The relative waveform distortion which follows an edge transition.\n\n\u00b7 \u201cPERIOD\u201d \u2013 The length of time of one complete cycle in the waveform. The units are seconds.\n\n\u00b7 \u201cPHASE\u201d \u2013 This measures the relative phase of one waveform with respect to the period on another waveform. Currently only valid between channels 1 and 2.\n\n\u00b7 \u201cPRESHOOT\u201d \u2013 The relative waveform distortion which precedes an edge transition.\n\n\u00b7 \u201cRISETIME\u201d \u2013 The length of time for a rising edge of the signal to rise from the low reference level to the high reference level. The units are seconds.\n\n\u00b7 \u201cTIMEATMAX\u201d \u2013 The time of the maximum amplitude found in the entire waveform. The units are seconds.\n\n\u00b7 \u201cTIMEATMIN\u201d \u2013 The time of the minimum amplitude found in the entire waveform. The units are seconds.\n\n\u00b7 \u201cTIMEATVALUE\u201d \u2013 This returns the Time at the vertical value specified by the A546XX_TimeAtValueConfig function.\n\n\u00b7 \u201cTIMEOFEDGE\u201d \u2013 This returns the Time at the edge crossing specified by the A546XX_TimeOfEdgeConfig function.\n\n\u00b7 \u201cVALUEATTIME\u201d \u2013 This returns the Value at the time specified by the A546XX_ValueAtTimeConfig function.\n\n\u00b7 \u201cVOLTAGEAVG\u201d \u2013 The arithmetic average in volts measured over the entire waveform. The units are volts. Note: The oscilloscope automatically switches between this and Voltage Cycle Average.\n\n\u00b7 \u201cVOLTCYCLEAVG\u201d \u2013 The arithmetic average in volts over an integer number of cycles in the waveform. The units are volts. Note: The oscilloscope automatically switches between this and Voltage Average.\n\n\u00b7 \u201cVOLTCYCLERMS\u201d \u2013 The true Root Mean Square voltage over an integer number of cycles in the waveform. The units are volts. The oscilloscope automatically switches between this and Voltage RMS if there is a cyclic waveform on the screen.\n\n\u00b7 \u201cVOLTHIGH\u201d \u2013 The voltage that corresponds to 100% when using the reference levels. The oscilloscope calculates this value using either the min/max or histogram methods. The units are Volts.\n\n\u00b7 \u201cVOLTLOW\u201d \u2013 The voltage that corresponds to 0% when using the reference levels. The oscilloscope calculates this value using either the min/max or histogram methods. The units are Volts.\n\n\u00b7 \u201cVOLTMAX\u201d \u2013 The maximum amplitude found in the entire waveform. The units are volts.\n\n\u00b7 \u201cVOLTMIN\u201d \u2013 The minimum amplitude found in the entire waveform. The units are volts.\n\n\u00b7 \u201cVOLTPKTOPK\u201d \u2013 Peak-to-Peak voltage; the absolute difference between the VOLTAGE_MAX and the VOLTAGE_MIN. The units are volts.\n\n\u00b7 \u201cVOLTRMS\u201d \u2013 The true Root Mean Square voltage of the entire waveform. The units are volts.Note: The oscilloscope automatically switches between this and Voltage Cycle RMS.\n\n\u00b7 \u201cWIDTHNEG\u201d \u2013 The length of time between the mid reference level points of a negative pulse in the waveform. The units are seconds.\n\n\u00b7 \u201cWIDTHPOS\u201d - The length of time between the mid reference level points of a positive pulse in the waveform. The units are seconds.\n\n\n\n$timeout\n\nBoolean\n\nSets instrument-specific values for timeout times. TRUE for immediate timeout times or FALSE for infinite timeout times.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$measurement\n\nFloat\n\nMeasured/calculated value returned by function.\n\n\n\n\n\nA546XX_TimeAtValueConfig\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS A546XX_TimeAtValueConfig": {
  "prefix": "A546XX_TimeAtValueConfig",
  "body": [
   "A546XX_TimeAtValueConfig($$A546XX_handle,$$value,$$occurrence,$$slope);"
  ],
  "description": "\n\nConfigures instrument-specific options for the TimeAtValue measurement.\n\nEquivalent instrument command: :MEASure:TVALue? <value>\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$A546XX_handle\n\nObject\n\nHandle created by the A546XX_Initialize() function.\n\n\n\n$value\n\nFloat\n\nThe voltage for the TimeAtValue measurement.\n\n\n\n$occurrence\n\nInteger\n\nThe occurrence count for the TimeAtValue measurement.\n\n\n\n$slope\n\nString\n\nThe edge slope for a TimeAtValue measurement.\n\nValid values:\n\n\u00b7 \u201cPOSITIVE\u201d\n\n\u00b7 \u201cNEGATIVE\u201d\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n-\n\n-\n\n\n\n\n\nA546XX_TimeOfEdgeConfig\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS A546XX_TimeOfEdgeConfig": {
  "prefix": "A546XX_TimeOfEdgeConfig",
  "body": [
   "A546XX_TimeOfEdgeConfig($$A546XX_handle,$$occurrence,$$slope);"
  ],
  "description": "\n\nConfigures instrument-specific options for the TimeOfEdge measurement.\n\nEquivalent instrument command: :MEASure:TEDGe?<slope><occurrence>\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$A546XX_handle\n\nObject\n\nHandle created by the A546XX_Initialize() function.\n\n\n\n$occurrence\n\nInteger\n\nThe occurrence count for the TimeAtEdge measurement.\n\n\n\n$slope\n\nString\n\nThe edge slope for a TimeAtEdge measurement.\n\nValid values:\n\n\u00b7 \u201cPOSITIVE\u201d\n\n\u00b7 \u201cNEGATIVE\u201d\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n-\n\n-\n\n\n\n\n\nA546XX_ValueAtTimeConfig\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS A546XX_ValueAtTimeConfig": {
  "prefix": "A546XX_ValueAtTimeConfig",
  "body": [
   "A546XX_ValueAtTimeConfig($$A546XX_handle,$$time);"
  ],
  "description": "\n\nConfigures instrument-specific options for the ValueAtTime measurement.\n\nEquivalent instrument command: :MEASure:VTIMe? <time >\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$A546XX_handle\n\nObject\n\nHandle created by the A546XX_Initialize() function.\n\n\n\n$time\n\nFloat\n\nThe time (in seconds) used to make the ValueAtTime measurement.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n-\n\n-\n\n\n\n\n\nA546XX_RefLevel\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS A546XX_RefLevel": {
  "prefix": "A546XX_RefLevel",
  "body": [
   "A546XX_RefLevel($$A546XX_handle,$$low,$$mid,$$high);"
  ],
  "description": "\n\nConfigures the low, mid, and high reference levels for waveform measurements.\n\nEquivalent instrument command: :MEAS:DEF THR, <Low>,<Mid>,<High>\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$A546XX_handle\n\nObject\n\nHandle created by the A546XX_Initialize() function.\n\n\n\n$low\n\nFloat\n\nThe low reference level the oscilloscope uses for waveform measurements.\n\n\n\n$mid\n\nFloat\n\nThe middle reference level the oscilloscope uses for waveform measurements.\n\n\n\n$high\n\nFloat\n\nThe high reference level the oscilloscope uses for waveform measurements.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n-\n\n-\n\n\n\n\n\nA546XX_Clear\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS A546XX_Clear": {
  "prefix": "A546XX_Clear",
  "body": [
   "A546XX_Clear($$A546XX_handle);"
  ],
  "description": "\n\nClears all event registers and error queue. The enable registers are unaffected.\n\nEquivalent instrument command: "
 }
,
 "JTS A546XX_OPC": {
  "prefix": "A546XX_OPC",
  "body": [
   "A546XX_OPC($$A546XX_handle,$$timeout);"
  ],
  "description": "\n\nDoes not return until previously started operations complete or $timeout milliseconds of time have expired. Use after an operation that takes a variable amount of time instead of a Sleep() function.\n\nEquivalent instrument command: "
 }
,
 "JTS A546XX_RecallState": {
  "prefix": "A546XX_RecallState",
  "body": [
   "A546XX_RecallState($$A546XX_handle,$$memloc);"
  ],
  "description": "\n\nRestore the instrument to a state previously stored in the instrument's internal memory.\n\nEquivalent instrument command: "
 }
,
 "JTS A546XX_SCPI_Read": {
  "prefix": "A546XX_SCPI_Read",
  "body": [
   "$$message=A546XX_SCPI_Read($$A546XX_handle);"
  ],
  "description": "\n\nRetrieves string from instrument. Used to get the response from a SCPI query sent with the A546XX_SCPI_Write function.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$A546XX_handle\n\nObject\n\nHandle created by the A546XX_Initialize() function.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$message\n\nString\n\nReturn string from instrument.\n\n\n\n\n\nA546XX_SCPI_Write\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS A546XX_SCPI_Write": {
  "prefix": "A546XX_SCPI_Write",
  "body": [
   "A546XX_SCPI_Write($$A546XX_handle,$$command);"
  ],
  "description": "\n\nSends a string directly to instrument. Used to communicate with and control instrument using SCPI commands.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$A546XX_handle\n\nObject\n\nHandle created by the A546XX_Initialize() function.\n\n\n\n$command\n\nString\n\nSCPI command to send to instrument. See \"SCPI Command Reference\" from Agilent for a list of valid commands.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n-\n\n-\n\n\n\n\n\nExample:\n\n\n\n\n\nA546XX_SCPI_Write($InstrHandle, \""
 }
,
 "JTS A546XX_SaveState": {
  "prefix": "A546XX_SaveState",
  "body": [
   "A546XX_SaveState($$A546XX_handle,$$memloc);"
  ],
  "description": "\n\nSave the instrument's state the instrument's internal memory.\n\nEquivalent instrument command: "
 }
,
 "JTS A546XX_TrigEdgeSource": {
  "prefix": "A546XX_TrigEdgeSource",
  "body": [
   "A546XX_TrigEdgeSource($$A546XX_handle,$$trigSource$$overrideString]);"
  ],
  "description": "\n\nThe source the oscilloscope monitors for the trigger event.\n\nEquivalent instrument command: : TRIGger:EDGE:SOURce <Source>\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$A546XX_handle\n\nObject\n\nHandle created by the A546XX_Initialize() function.\n\n\n\n$trigSource\n\nString\n\nSource of trigger.\n\nValid values:\n\n\u00b7 \u201cCHAN1\u201d\n\n\u00b7 \u201cCHAN2\u201d\n\n\u00b7 \"CHAN3\"\n\n\u00b7 \"CHAN4\"\n\n\u00b7 \u201cEXT\u201d\n\n\u00b7 \u201cLINE\u201d\n\n\u00b7 \"OVERRIDE\"1\n\n\n\n\n\n1Used to manually specify a SCPI string for command\n\n\n\n$overrideString\n\nString\n\nOptional string sent when OVERRIDE source is specified.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n-\n\n-\n\n\n\n\n\nEx : A546XX_TrigEdgeSource($A546XX_handle, \"CHAN1\");\n\n\n\n\n\nEx: A546XX_TrigEdgeSource($A546XX_handle, \"OVERRIDE\", \"UserChannel1\");\n\n\n\n\n\nA546XX_TrigCont\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS A546XX_TrigCont": {
  "prefix": "A546XX_TrigCont",
  "body": [
   "A546XX_TrigCont($$A546XX_handle,$$continuous);"
  ],
  "description": "\n\nIf True, the oscilloscope continuously initiates waveform acquisition.\n\nEquivalent instrument command: :RUN\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$A546XX_handle\n\nObject\n\nHandle created by the A546XX_Initialize() function.\n\n\n\n$continuous\n\nBoolean\n\nTurns continuous mode on when True, off when False.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n-\n\n-\n\n\n\n\n\nA546XX_TrigCoupling\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS A546XX_TrigCoupling": {
  "prefix": "A546XX_TrigCoupling",
  "body": [
   "A546XX_TrigCoupling($$A546XX_handle,$$couplingType);"
  ],
  "description": "\n\nHow the oscilloscope couples the trigger source.\n\nEquivalent instrument command: :TRIGger:COUPling\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$A546XX_handle\n\nObject\n\nHandle created by the A546XX_Initialize() function.\n\n\n\n$couplingType\n\nString\n\nHow to couple to the trigger source.\n\nValid values:\n\n\u00b7 \u201cAC\u201d\n\n\u00b7 \u201cDC\u201d\n\n\u00b7 \"HFREJECT\"\n\n\u00b7 \"LFREJECT\"\n\n\u00b7 \"NOISEREJECT\"\n\n\u00b7 \u201cTV\u201d\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n-\n\n-\n\n\n\n\n\nA546XX_TrigEdgeSlope\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS A546XX_TrigEdgeSlope": {
  "prefix": "A546XX_TrigEdgeSlope",
  "body": [
   "A546XX_TrigEdgeSlope($$A546XX_handle,$$trigSlope);"
  ],
  "description": "\n\nWhether a rising or a falling edge triggers the oscilloscope.\n\nEquivalent instrument command: :TRIGger:EDGE:SLOPe <Slope>\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$A546XX_handle\n\nObject\n\nHandle created by the A546XX_Initialize() function.\n\n\n\n$trigSlope\n\nString\n\nSlope type that causes trigger.\n\nValid values:\n\n\u00b7 \u201cNEGATIVE\u201d\n\n\u00b7 \u201cPOSITIVE\u201d\n\n\u00b7 \"EITHER\"1\n\n\u00b7 \"ALTERNATE\" 2\n\n\n\n\n\n1Not supported by 5000 series.\n\n2 Triggers will occur alternately on the rising and falling edges.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n-\n\n-\n\n\n\n\n\nA546XX_TrigHoldoff\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS A546XX_TrigHoldoff": {
  "prefix": "A546XX_TrigHoldoff",
  "body": [
   "A546XX_TrigHoldoff($$A546XX_handle,$$holdoff);"
  ],
  "description": "\n\nThe length of time to wait after detecting a trigger before enabling the trigger subsystem again.\n\nEquivalent instrument command: :TRIGger:HOLDoff <holdoff_time>\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$A546XX_handle\n\nObject\n\nHandle created by the A546XX_Initialize() function.\n\n\n\n$holdoff\n\nFloat\n\nWait time.\n\nValid ranges are 60ns to 10s.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n-\n\n-\n\n\n\n\n\nA546XX_TrigLevel\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS A546XX_TrigLevel": {
  "prefix": "A546XX_TrigLevel",
  "body": [
   "A546XX_TrigLevel($$A546XX_handle,$$trigLevel);"
  ],
  "description": "\n\nThe voltage threshold for the trigger sub-system.\n\nEquivalent instrument command: :TRIGger:LEVel <Level>\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$A546XX_handle\n\nObject\n\nHandle created by the A546XX_Initialize() function.\n\n\n\n$trigLevel\n\nFloat\n\nVoltage level of trigger.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n-\n\n-\n\n\n\n\n\nA546XX_Reset\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS A546XX_Reset": {
  "prefix": "A546XX_Reset",
  "body": [
   "A546XX_Reset($$A546XX_handle);"
  ],
  "description": "\n\nPlaces the instrument in a known state and configures instrument options on which the IVI specific driver depends (for example, enabling/disabling headers). For an IEEE 488.2 instrument, Reset sends the command string "
 }
,
 "JTS LeCroyDSO_CaptureScopeImageToFile": {
  "prefix": "LeCroyDSO_CaptureScopeImageToFile",
  "body": [
   "$$status=LeCroyDSO_CaptureScopeImageToFile($$lecroyObject,$$imageFormat,$$pathAndFileName);"
  ],
  "description": "\n\nThis function transfers a screen image from the instrument and stores it in a file on the PC.\n\n\n\nRemarks:\n\n\u00b7 This function requires the LeCroy Digital Storage Oscilloscope ActiveX libraries (activeDSO) to be installed on the system.\n\n\u00b7 Communication with the instrument must already have been established using the LeCroyDSO_Connect function.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$lecroyObject\n\nObject\n\nThe handle of the instrument returned from the LeCroyDSO_Connect function.\n\n\n\n$imageFormat\n\nString\n\nThe file format for the image. Select BMP, TIFF, JPG, etc. If the selected format is not supported, the image will be stored as a bitmap.\n\n\n\n$pathAndFileName\n\nString\n\nThe path AND file name for the image file.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$status\n\nBoolean\n\nThe return status of the function.\n\n\n\n\n\nExample:\n\n// Connect to the instrument.\n\n$scope = \"IP:10.1.1.2\";\n\n$lecroyObject = LeCroyDSO_Connect($scope);\n\n\n\n\n\n// Get and save the screen image.\n\n$imageFormat = \"JPG\";\n\n$pathAndFileName = \"C:\\Images\\ScopeImage.jpg\";\n\nLeCroyDSO_CaptureScopeImageToFile($lecroyObject, $imageFormat, $pathAndFileName);\n\n\n\n\n\nLeCroyDSO_Connect\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS LeCroyDSO_Connect": {
  "prefix": "LeCroyDSO_Connect",
  "body": [
   "$$lecroyObject=LeCroyDSO_Connect($$lecroyAddress);"
  ],
  "description": "\n\nThis function creates a connection to the LeCroy instrument via IP, GPIB or serial port.\n\n\n\nRemarks:\n\n\u00b7 This function requires the LeCroy Digital Storage Oscilloscope ActiveX libraries (activeDSO) to be installed on the system.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$lecroyAddress\n\nString\n\nThe GPIB,IP, or RS232 address of the Lecroy scope. Prefix with either GPIB: IP: COM1: etc. Note that you must use a colon between the connection type and the actual address.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$lecroyObject\n\nObject\n\nThe ActiveDSO object for use in other functions.\n\n\n\n\n\nExample:\n\n// Connect to the instrument.\n\n$scope = \"IP:10.1.1.2\";\n\n$lecroyObject = LeCroyDSO_Connect($scope);\n\n\n\n\n\nLeCroyDSO_DeviceClear\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS LeCroyDSO_DeviceClear": {
  "prefix": "LeCroyDSO_DeviceClear",
  "body": [
   "$$status=LeCroyDSO_DeviceClear($$lecroyObject,$$rebootDevice);"
  ],
  "description": "\n\nThis function will send a device clear signal to the instrument.\n\n\n\nRemarks:\n\n\u00b7 This function requires the LeCroy Digital Storage Oscilloscope ActiveX libraries (activeDSO) to be installed on the system.\n\n\u00b7 Any unread response in the device's output buffer will be cleared.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$lecroyObject\n\nObject\n\nThe handle of the instrument returned from the LeCroyDSO_Connect function.\n\n\n\n$rebootDevice\n\nBoolean\n\nIf this argument is true then the instrument will reboot. This can take up to 20 seconds to complete depending on the instrument.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$status\n\nBoolean\n\nThe return status of the function.\n\n\n\n\n\nExample:\n\n// Connect to the instrument.\n\n$scope = \"IP:10.1.1.2\";\n\n$lecroyObject = LeCroyDSO_Connect($scope);\n\n\n\n\n\n// Clear and reboot the instrument.\n\n$status = LeCroyDSO_DeviceClear($lecroyObject, true);\n\n\n\n\n\nLeCroyDSO_Disconnect\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS LeCroyDSO_Disconnect": {
  "prefix": "LeCroyDSO_Disconnect",
  "body": [
   "$$status=LeCroyDSO_Disconnect($$lecroyObject);"
  ],
  "description": "\n\nThis function will perform necessary termination functions and disconnect from the instrument.\n\n\n\n\n\nRemarks:\n\n\u00b7 This function requires the LeCroy Digital Storage Oscilloscope ActiveX libraries (activeDSO) to be installed on the system.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$lecroyObject\n\nObject\n\nThe handle of the instrument returned from the LeCroyDSO_Connect function.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$status\n\nBoolean\n\nThe return status of the function.\n\n\n\n\n\nExample:\n\n// Connect to the instrument.\n\n$scope = \"IP:10.1.1.2\";\n\n$lecroyObject = LeCroyDSO_Connect($scope);\n\n\n\n\n\n// Work with the instrument here.\n\n\n\n\n\n// Disconnect from the instrument.\n\n$status = LeCroyDSO_Disconnect($lecroyObject);\n\n\n\n\n\nLeCroyDSO_GetAllProperties\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS LeCroyDSO_GetAllProperties": {
  "prefix": "LeCroyDSO_GetAllProperties",
  "body": [
   "($$prop1,$$prop2,$$prop3,...,$$prop9)=LeCroyDSO_GetAllProperties($$lecroyObject);"
  ],
  "description": "\n\nThis function will return all of the properties of the connected instrument.\n\n\n\nRemarks:\n\n\u00b7 This function requires the LeCroy Digital Storage Oscilloscope ActiveX libraries (activeDSO) to be installed on the system.\n\n\u00b7 This was tested on a Waverunner Oscilloscope. Other instruments may not return all of the properties. Check the instrument manual for number of properties and order.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$lecroyObject\n\nObject\n\nThe handle of the instrument returned from the LeCroyDSO_Connect function.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$prop1, $prop2, $prop3, ... , $prop9\n\nString\n\nEach property returned as a string.\n\n\n\n\n\nExample:\n\n// Connect to the instrument.\n\n$scope = \"IP:10.1.1.2\";\n\n$lecroyObject = LeCroyDSO_Connect($scope);\n\n\n\n\n\n// Clear and reboot the instrument.\n\n($prop1, $prop2, $prop3, $prop4, $prop5, $prop6, $prop7, $prop8, $prop9) = LeCroyDSO_GetAllProperties($lecroyObject);\n\n\n\n\n\n// The properties of a LeCroy Waverunner oscilloscope are returned in the following order:\n\n// BinTransferSupport\n\n// BytesRead\n\n// ConnectionType\n\n// DeviceModel\n\n// ErrorFlag\n\n// ErrorString\n\n// NumberOfChannels\n\n// ScreenType\n\n// SerialNumber\n\n\n\n\n\nLeCroyDSO_GetByteWaveform\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS LeCroyDSO_GetByteWaveform": {
  "prefix": "LeCroyDSO_GetByteWaveform",
  "body": [
   "$$waveform=LeCroyDSO_GetByteWaveform($$lecroyObject,$$traceName,$$maxBytes,$$arrayChosen);"
  ],
  "description": "\n\nThis function will read a raw 8-bit waveform from the instrument into a Byte array.\n\n\n\n\n\nRemarks:\n\n\u00b7 This function requires the LeCroy Digital Storage Oscilloscope ActiveX libraries (activeDSO) to be installed on the system.\n\n\u00b7 The trace name may vary depending on the instrument. Check the manual for valid trace names.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$lecroyObject\n\nObject\n\nThe handle of the instrument returned from the LeCroyDSO_Connect function.\n\n\n\n$traceName\n\nString\n\nThe name of the trace to return. Typical trace names include: C1, C2, C3, C4, M1, M2, M3, M4, TA, TB, TC, TD TD, F1, Z1, ...\n\n\n\n$maxBytes\n\nInteger\n\nThe maximum number of bytes to read.\n\n\n\n$arrayChosen\n\nInteger\n\nFor dual array waveform: 0 = first array, 1 = second array.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$waveform\n\nArray\n\nThe array of bytes representing the selected waveform.\n\n\n\n\n\nExample:\n\n// Connect to the instrument.\n\n$scope = \"IP:10.1.1.2\";\n\n$lecroyObject = LeCroyDSO_Connect($scope);\n\n\n\n\n\n// Return the first 100 bytes of channel 1.\n\n$traceName = \"C1\";\n\n$maxBytes = 100;\n\n$arrayChosen = 0;\n\n$waveform = LeCroyDSO_GetByteWaveform($lecroyObject, $traceName, $maxBytes, $arrayChosen);\n\n\n\n\n\nLeCroyDSO_GetCommaDelimString\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS LeCroyDSO_GetCommaDelimString": {
  "prefix": "LeCroyDSO_GetCommaDelimString",
  "body": [
   "$$returnData=LeCroyDSO_GetCommaDelimString($$lecroyObject,$$commandString,$$index);"
  ],
  "description": "\n\nThis function will send a command to the instrument, read the result and return the specified element from the comma delimited string the instrument sends back.\n\n\n\n\n\nRemarks:\n\n\u00b7 This function requires the LeCroy Digital Storage Oscilloscope ActiveX libraries (activeDSO) to be installed on the system.\n\n\u00b7 The command string can be SCPI VB Script commands as outlined in the instrument command reference manual.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$lecroyObject\n\nObject\n\nThe handle of the instrument returned from the LeCroyDSO_Connect function.\n\n\n\n$commandString\n\nString\n\nThe command string to send to the instrument.\n\n\n\n$index\n\nInteger\n\nThe element number to return. The first element is 0.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$returnData\n\nString\n\nThe element returned from the string.\n\n\n\n\n\nExample:\n\n// Connect to the instrument.\n\n$scope = \"IP:10.1.1.2\";\n\n$lecroyObject = LeCroyDSO_Connect($scope);\n\n\n\n\n\n// Return the amplitude of the signal on channel 1 of a Waverunner oscilloscope.\n\n$commandString = \"CH1:AMPL?\";\n\n$index = 1;\n\n$returnData = LeCroyDSO_GetCommaDelimString($lecroyObject, $commandString, $index);\n\n\n\n\n\n// For example, if the instrument returned: AMPL,1.02V,OK\n\n// This function would return 1.02V\n\n\n\n\n\nLeCroyDSO_GetIntegerWaveform\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS LeCroyDSO_GetIntegerWaveform": {
  "prefix": "LeCroyDSO_GetIntegerWaveform",
  "body": [
   "$$waveform=LeCroyDSO_GetIntegerWaveform($$lecroyObject,$$traceName,$$maxInts,$$arrayChosen);"
  ],
  "description": "\n\nThis function will read a raw 16-bit waveform from the instrument into an integer array.\n\n\n\n\n\nRemarks:\n\n\u00b7 This function requires the LeCroy Digital Storage Oscilloscope ActiveX libraries (activeDSO) to be installed on the system.\n\n\u00b7 The trace name may vary depending on the instrument. Check the manual for valid trace names.\n\n\u00b7 The waveforms read by this function cannot be sent back to the instrument.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$lecroyObject\n\nObject\n\nThe handle of the instrument returned from the LeCroyDSO_Connect function.\n\n\n\n$traceName\n\nString\n\nThe name of the trace to return. Typical trace names include: C1, C2, C3, C4, M1, M2, M3, M4, TA, TB, TC, TD TD, F1, Z1, ...\n\n\n\n$maxInts\n\nInteger\n\nThe maximum number of integers to read.\n\n\n\n$arrayChosen\n\nInteger\n\nFor dual array waveform: 0 = first array, 1 = second array.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$waveform\n\nArray\n\nThe array of integers representing the selected waveform.\n\n\n\n\n\nExample:\n\n// Connect to the instrument.\n\n$scope = \"IP:10.1.1.2\";\n\n$lecroyObject = LeCroyDSO_Connect($scope);\n\n\n\n\n\n// Return the first 100 integers of channel 1.\n\n$traceName = \"C1\";\n\n$maxInts = 100;\n\n$arrayChosen = 0;\n\n$waveform = LeCroyDSO_GetIntegerWaveform($lecroyObject, $traceName, $maxInts, $arrayChosen);\n\n\n\n\n\nLeCroyDSO_GetNativeWaveform\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS LeCroyDSO_GetNativeWaveform": {
  "prefix": "LeCroyDSO_GetNativeWaveform",
  "body": [
   "$$waveform=LeCroyDSO_GetNativeWaveform($$lecroyObject,$$traceName,$$maxBytes,$$xferAsWords,$$blockName);"
  ],
  "description": "\n\nThis function will read a waveform from the instrument in its native binary form.\n\n\n\n\n\nRemarks:\n\n\u00b7 This function requires the LeCroy Digital Storage Oscilloscope ActiveX libraries (activeDSO) to be installed on the system.\n\n\u00b7 The trace name may vary depending on the instrument. Check the manual for valid trace names.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$lecroyObject\n\nObject\n\nThe handle of the instrument returned from the LeCroyDSO_Connect function.\n\n\n\n$traceName\n\nString\n\nThe name of the trace to return. Typical trace names include: C1, C2, C3, C4, M1, M2, M3, M4, TA, TB, TC, TD TD, F1, Z1, ...\n\n\n\n$maxBytes\n\nInteger\n\nThe maximum number of bytes to read.\n\n\n\n$xferAsWords\n\nBoolean\n\nSet true to transmit data as 16-bit words, false to transfer as 8-bit bytes.\n\n\n\n$blockName\n\nString\n\nThe name of the block of data to return. Valid names:\n\n\u00b7 DESC\n\n\u00b7 TEXT\n\n\u00b7 TIME\n\n\u00b7 DAT1\n\n\u00b7 DAT2\n\n\u00b7 ALL\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$waveform\n\nArray\n\nThe array of bytes or integers representing the selected waveform.\n\n\n\n\n\nExample:\n\n// Connect to the instrument.\n\n$scope = \"IP:10.1.1.2\";\n\n$lecroyObject = LeCroyDSO_Connect($scope);\n\n\n\n\n\n// Return the first 100 bytes of channel 1.\n\n$traceName = \"C1\";\n\n$maxBytes = 100;\n\n$xferAsWords = true;\n\n$blockName = \"ALL\";\n\n$waveform = LeCroyDSO_GetNativeWaveform($lecroyObject, $traceName, $maxBytes, $xferAsWords, $blockName);\n\n\n\n\n\nLeCroyDSO_GetParameterValue\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS LeCroyDSO_GetParameterValue": {
  "prefix": "LeCroyDSO_GetParameterValue",
  "body": [
   "$$paramValue=LeCroyDSO_GetParameterValue($$lecroyObject);"
  ],
  "description": "\n\nThis function must be called after the LeCroyDSO_WriteString function as it will not take a command string. Essentially it will perform the same task as the LeCroyDSO_GetCommaDelimString, but only return the value at index 1.\n\n\n\nRemarks:\n\n\u00b7 This function requires the LeCroy Digital Storage Oscilloscope ActiveX libraries (activeDSO) to be installed on the system.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$lecroyObject\n\nObject\n\nThe handle of the instrument returned from the LeCroyDSO_Connect function.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$paramValue\n\nString\n\nThe value at index 1 of the return string.\n\n\n\n\n\nExample:\n\n// Connect to the instrument.\n\n$scope = \"IP:10.1.1.2\";\n\n$lecroyObject = LeCroyDSO_Connect($scope);\n\n\n\n\n\n// Send query to the instrument.\n\n$query = \"CH1:AMPL?\";\n\n$status = LeCroyDSO_WriteString($lecroyObject, $query, true);\n\n\n\n\n\n// Get the returned value.\n\n$paramValue = LeCroyDSO_GetParameterValue($lecroyObject);\n\n\n\n\n\nLeCroyDSO_GetScaledWaveform\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS LeCroyDSO_GetScaledWaveform": {
  "prefix": "LeCroyDSO_GetScaledWaveform",
  "body": [
   "$$waveform=LeCroyDSO_GetScaledWaveform($$lecroyObject,$$traceName,$$maxInts,$$arrayChosen);"
  ],
  "description": "\n\nThis function will read a scaled 16-bit waveform from the instrument into an array.\n\n\n\n\n\nRemarks:\n\n\u00b7 This function requires the LeCroy Digital Storage Oscilloscope ActiveX libraries (activeDSO) to be installed on the system.\n\n\u00b7 The trace name may vary depending on the instrument. Check the manual for valid trace names.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$lecroyObject\n\nObject\n\nThe handle of the instrument returned from the LeCroyDSO_Connect function.\n\n\n\n$traceName\n\nString\n\nThe name of the trace to return. Typical trace names include: C1, C2, C3, C4, M1, M2, M3, M4, TA, TB, TC, TD TD, F1, Z1, ...\n\n\n\n$maxInts\n\nInteger\n\nThe maximum number of integers to read.\n\n\n\n$arrayChosen\n\nInteger\n\nFor dual array waveform: 0 = first array, 1 = second array.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$waveform\n\nArray\n\nThe array of integers representing the selected waveform.\n\n\n\n\n\nExample:\n\n// Connect to the instrument.\n\n$scope = \"IP:10.1.1.2\";\n\n$lecroyObject = LeCroyDSO_Connect($scope);\n\n\n\n\n\n// Return the first 100 integers of channel 1.\n\n$traceName = \"C1\";\n\n$maxInts = 100;\n\n$arrayChosen = 0;\n\n$waveform = LeCroyDSO_GetScaledWaveform($lecroyObject, $traceName, $maxInts, $arrayChosen);\n\n\n\n\n\nLeCroyDSO_GetScaledWaveformWithTimes\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS LeCroyDSO_GetScaledWaveformWithTimes": {
  "prefix": "LeCroyDSO_GetScaledWaveformWithTimes",
  "body": [
   "$$waveform=LeCroyDSO_GetScaledWaveformWithTimes($$lecroyObject,$$traceName,$$maxInts,$$arrayChosen);"
  ],
  "description": "\n\nThis function will read a scaled 16-bit waveform from the instrument into an array with the time and amplitude for each point.\n\n\n\n\n\nRemarks:\n\n\u00b7 This function requires the LeCroy Digital Storage Oscilloscope ActiveX libraries (activeDSO) to be installed on the system.\n\n\u00b7 The trace name may vary depending on the instrument. Check the manual for valid trace names.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$lecroyObject\n\nObject\n\nThe handle of the instrument returned from the LeCroyDSO_Connect function.\n\n\n\n$traceName\n\nString\n\nThe name of the trace to return. Typical trace names include: C1, C2, C3, C4, M1, M2, M3, M4, TA, TB, TC, TD TD, F1, Z1, ...\n\n\n\n$maxInts\n\nInteger\n\nThe maximum number of integers to read.\n\n\n\n$arrayChosen\n\nInteger\n\nFor dual array waveform: 0 = first array, 1 = second array.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$waveform\n\nArray\n\nThe array of integers representing the selected waveform.\n\n\n\n\n\nExample:\n\n// Connect to the instrument.\n\n$scope = \"IP:10.1.1.2\";\n\n$lecroyObject = LeCroyDSO_Connect($scope);\n\n\n\n\n\n// Return the first 1000 points of channel 1.\n\n$traceName = \"C1\";\n\n$maxInts = 1000;\n\n$arrayChosen = 0;\n\n$waveform = LeCroyDSO_GetScaledWaveformWithTimes($lecroyObject, $traceName, $maxInts, $arrayChosen);\n\n\n\n\n\nLeCroyDSO_ReadBinary\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS LeCroyDSO_ReadBinary": {
  "prefix": "LeCroyDSO_ReadBinary",
  "body": [
   "$$data=LeCroyDSO_ReadBinary($$lecroyObject,$$maxBytes);"
  ],
  "description": "\n\nThis function must be called after the LeCroyDSO_WriteString function as it will not take a command string. This function will read a binary response from the instrument.\n\n\n\n\n\nRemarks:\n\n\u00b7 This function requires the LeCroy Digital Storage Oscilloscope ActiveX libraries (activeDSO) to be installed on the system.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$lecroyObject\n\nObject\n\nThe handle of the instrument returned from the LeCroyDSO_Connect function.\n\n\n\n$maxBytes\n\nInteger\n\nThe maximum number of bytes to read.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$data\n\nInteger\n\nThat data returned from the function converted to an integer.\n\n\n\n\n\nExample:\n\n// Connect to the instrument.\n\n$scope = \"IP:10.1.1.2\";\n\n$lecroyObject = LeCroyDSO_Connect($scope);\n\n\n\n\n\n// Return the first 5 bytes.\n\n$maxBytes = 5;\n\n$waveform = LeCroyDSO_ReadBinary($lecroyObject, $maxBytes);\n\n\n\n\n\nLeCroyDSO_ReadString\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS LeCroyDSO_ReadString": {
  "prefix": "LeCroyDSO_ReadString",
  "body": [
   "$$returnString=LeCroyDSO_ReadString($$lecroyObject,$$maxStringLength);"
  ],
  "description": "\n\nThis function will read a string response from the instrument.\n\n\n\n\n\nRemarks:\n\n\u00b7 This function requires the LeCroy Digital Storage Oscilloscope ActiveX libraries (activeDSO) to be installed on the system.\n\n\u00b7 If there are more characters to be read than the indicated $maxStringLength, the remaining characters will be left unread in the instrument buffer.\n\n\u00b7 You need to execute a command with LeCroyDSO_WriteString before executing this function. Otherwise, you will get a null or the results from the last command.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$lecroyObject\n\nObject\n\nThe handle of the instrument returned from the LeCroyDSO_Connect function.\n\n\n\n$maxStringLength\n\nInteger\n\nThe maximum number of bytes to read.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$returnString\n\nString\n\nThat data returned from the function converted to an integer.\n\n\n\n\n\nExample:\n\n// Connect to the instrument.\n\n$scope = \"IP:10.1.1.2\";\n\n$lecroyObject = LeCroyDSO_Connect($scope);\n\n\n\n\n\n// Get the results from a PK-PK command from a Waverunner o'scope.\n\n$command = \"CH1:VPP?\";\n\nLeCroyDSO_WriteString($lecroyObject, $command, true);\n\n\n\n\n\n// Return the first 5 bytes.\n\n$maxStringLength = 5;\n\n$waveform = LeCroyDSO_ReadString($lecroyObject, $maxStringLength);\n\n\n\n\n\nLeCroyDSO_RefreshImage\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS LeCroyDSO_RefreshImage": {
  "prefix": "LeCroyDSO_RefreshImage",
  "body": [
   "$$status=LeCroyDSO_RefreshImage($$lecroyObject);"
  ],
  "description": "\n\nThis function will update the control's image with the current contents of the instrument's display.\n\n\n\nRemarks:\n\n\u00b7 This function requires the LeCroy Digital Storage Oscilloscope ActiveX libraries (activeDSO) to be installed on the system.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$lecroyObject\n\nObject\n\nThe handle of the instrument returned from the LeCroyDSO_Connect function.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$status\n\nBoolean\n\nThe return status of the function.\n\n\n\n\n\nExample:\n\n// Connect to the instrument.\n\n$scope = \"IP:10.1.1.2\";\n\n$lecroyObject = LeCroyDSO_Connect($scope);\n\n\n\n\n\n// Update the Image\n\n$status = LeCroyDSO_RefreshImage($lecroyObject);\n\n\n\n\n\nLeCroyDSO_SetRemoteMode\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS LeCroyDSO_SetRemoteMode": {
  "prefix": "LeCroyDSO_SetRemoteMode",
  "body": [
   "$$status=LeCroyDSO_SetRemoteMode($$lecroyObject,$$remoteMode);"
  ],
  "description": "\n\nThis function will set the instrument into remote or local mode.\n\n\n\n\n\nRemarks:\n\n\u00b7 This function requires the LeCroy Digital Storage Oscilloscope ActiveX libraries (activeDSO) to be installed on the system.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$lecroyObject\n\nObject\n\nThe handle of the instrument returned from the LeCroyDSO_Connect function.\n\n\n\n$remoteMode\n\nInteger\n\nThe mode to set the instrument to: 0 = Local Mode, 1 = Remote Mode.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$status\n\nBoolean\n\nThe return status of the function.\n\n\n\n\n\nExample:\n\n// Connect to the instrument.\n\n$scope = \"IP:10.1.1.2\";\n\n$lecroyObject = LeCroyDSO_Connect($scope);\n\n\n\n\n\n// Set instrument to remote mode\n\n$status = LeCroyDSO_SetRemoteMode($lecroyObject, 1);\n\n\n\n\n\nLeCroyDSO_SetWaveformTransfer\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS LeCroyDSO_SetWaveformTransfer": {
  "prefix": "LeCroyDSO_SetWaveformTransfer",
  "body": [
   "$$status=LeCroyDSO_SetWaveformTransfer($$lecroyObject,$$firstIndexPoint,$$sparsingFactor,$$segmentNumber);"
  ],
  "description": "\n\nThis function will configure various parameters that control the transfer of waveforms from the instrument to the PC.\n\n\n\n\n\nRemarks:\n\n\u00b7 This function requires the LeCroy Digital Storage Oscilloscope ActiveX libraries (activeDSO) to be installed on the system.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$lecroyObject\n\nObject\n\nThe handle of the instrument returned from the LeCroyDSO_Connect function.\n\n\n\n$firstIndexPoint\n\nInteger\n\nThe index of the first point to transfer (0 = first point).\n\n\n\n$sparsingFactor\n\nInteger\n\nThe sparsing factor (0 = all points, 2 = skip every other point).\n\n\n\n$segmentNumber\n\nInteger\n\nSegment number to transfer (0 = all segments).\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$status\n\nBoolean\n\nThe return status of the function.\n\n\n\n\n\nExample:\n\n// Connect to the instrument.\n\n$scope = \"IP:10.1.1.2\";\n\n$lecroyObject = LeCroyDSO_Connect($scope);\n\n\n\n\n\n// Set instrument to start at index 10, transfer all points of all segments.\n\n$firstIndexPoint = 10;\n\n$sparsingFactor = 0;\n\n$segmentNumber = 0;\n\n$status = LeCroyDSO_SetWaveformTransfer($lecroyObject, $firstIndexPoint, $sparsingFactor, $segmentNumber);\n\n\n\n\n\nLeCroyDSO_TransferFile\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS LeCroyDSO_TransferFile": {
  "prefix": "LeCroyDSO_TransferFile",
  "body": [
   "$$status=LeCroyDSO_TransferFile($$lecroyObject,$$remoteDevice,$$destinationFileWithPath,$$sourceFileWithPath);"
  ],
  "description": "\n\nThis function will transfer a file from the PC to a mass storage device on the instrument.\n\n\n\n\n\nRemarks:\n\n\u00b7 This function requires the LeCroy Digital Storage Oscilloscope ActiveX libraries (activeDSO) to be installed on the system.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$lecroyObject\n\nObject\n\nThe handle of the instrument returned from the LeCroyDSO_Connect function.\n\n\n\n$remoteDevice\n\nString\n\nThe device name on the instrument. Choices:\n\n\u00b7 CARD\n\n\u00b7 HDD\n\n\u00b7 FLPY\n\n\n\n$destinationFileWithPath\n\nString\n\nThe name and path of the destination file on the instrument.\n\n\n\n$sourceFileWithPath\n\nString\n\nThe name and path of the source file on the PC.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$status\n\nBoolean\n\nThe return status of the function.\n\n\n\n\n\nExample:\n\n// Connect to the instrument.\n\n$scope = \"IP:10.1.1.2\";\n\n$lecroyObject = LeCroyDSO_Connect($scope);\n\n\n\n\n\n// Send a file from the PC to the Instrument.\n\n$device = \"HDD\";\n\n$dest = \"D:\\\\dso\\\\dest.txt\";\n\n$source = \"C:\\\\pc\\\\src.txt\";\n\n$status = LeCroyDSO_TransferFile($lecroyObject, $device, $dest, $source);\n\n\n\n\n\nLeCroyDSO_TransferFileToPC\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS LeCroyDSO_TransferFileToPC": {
  "prefix": "LeCroyDSO_TransferFileToPC",
  "body": [
   "$$status=LeCroyDSO_TransferFileToPC($$lecroyObject,$$remoteDevice,$$remoteFilePath,$$localFilePath);"
  ],
  "description": "\n\nThis function will transfer a file from a mass storage device on the instrument to the PC.\n\n\n\n\n\nRemarks:\n\n\u00b7 This function requires the LeCroy Digital Storage Oscilloscope ActiveX libraries (activeDSO) to be installed on the system.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$lecroyObject\n\nObject\n\nThe handle of the instrument returned from the LeCroyDSO_Connect function.\n\n\n\n$remoteDevice\n\nString\n\nThe device name on the instrument. Choices:\n\n\u00b7 CARD\n\n\u00b7 HDD\n\n\u00b7 FLPY\n\n\n\n$remoteFilePath\n\nString\n\nThe name and path of the source file on the instrument.\n\n\n\n$localFilePath\n\nString\n\nThe name and path of the destination file on the PC.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$status\n\nBoolean\n\nThe return status of the function.\n\n\n\n\n\nExample:\n\n// Connect to the instrument.\n\n$scope = \"IP:10.1.1.2\";\n\n$lecroyObject = LeCroyDSO_Connect($scope);\n\n\n\n\n\n// Send a file from the Instrument to the PC.\n\n$device = \"HDD\";\n\n$remoteFile = \"D:\\\\dso\\\\remotefile.txt\";\n\n$localFile = \"C:\\\\pc\\\\localfile.txt\";\n\n$status = LeCroyDSO_TransferFileToPC($lecroyObject, $device, $remoteFile, $localFile);\n\n\n\n\n\nLeCroyDSO_WriteBinary\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS LeCroyDSO_WriteBinary": {
  "prefix": "LeCroyDSO_WriteBinary",
  "body": [
   "$$status=LeCroyDSO_WriteBinary($$lecroyObject,$$command,$$eoi);"
  ],
  "description": "\n\nThis function will send a string command to the instrument.\n\n\n\n\n\nRemarks:\n\n\u00b7 This function requires the LeCroy Digital Storage Oscilloscope ActiveX libraries (activeDSO) to be installed on the system.\n\n\u00b7 Commands can be sent in SCPI or VBS syntax. See the instrument manual for a list of available commands.\n\nThe syntax for VBS commands can be found using LeCroy's Xstream browser. Please refer to the automation manual for details as this library is extensive and offers tremendous flexibility. For queries you MUST use the variable Return in the command. The LeCroy libraries will only return a value to this variable. It can be retrieved with the LecroyDSO_ReadString function.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$lecroyObject\n\nObject\n\nThe handle of the instrument returned from the LeCroyDSO_Connect function.\n\n\n\n$command\n\nString\n\nText string to send to the instrument.\n\n\n\n$eoi\n\nBoolean\n\nWhether to send EOI at the end of the command. If $eoi is true, the instrument will start to interpret the command immediately. This is normally the desired behavior.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$status\n\nBoolean\n\nThe return status of the function.\n\n\n\n\n\nExample:\n\n// Connect to the instrument.\n\n$scope = \"IP:10.1.1.2\";\n\n$lecroyObject = LeCroyDSO_Connect($scope);\n\n\n\n\n\n//Send a command with SCPI syntax setting CH 1 to 5 volts per division.\n\n$status = LeCroyDSO_WriteString($lecroyObject, \u201dCH1:VDIV = 5\u201d, true);\n\n\n\n\n\n//Send a command with VBS syntax setting CH 1 to 5 volts per division.\n\n$status = LeCroyDSO_WriteString($lecroyObject, \u201dVBS app.channel1.voltsdiv = 5\u201d, true);\n\n\n\n\n\n//Send a command with VBS syntax querying Channel one\u2019s volts per div.\n\n$status = LeCroyDSO_WriteString($lecroyObject, \u201dVBS? Return = app.channel1.voltsdiv\u201d, true);\n\n$voltsPerDiv = LeCroyDSO_ReadString($lecroyObject, $maxStringLength);\n\n\n\n\n\nLeCWJ300A_AutoSetup\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS LeCWJ300A_AutoSetup": {
  "prefix": "LeCWJ300A_AutoSetup",
  "body": [
   "LeCWJ300A_AutoSetup($$Handle);"
  ],
  "description": "\n\nThis function requires the LeCroy Digital Storage Oscilloscope ActiveX libraries (activeDSO) to be installed on the system.\n\n\n\nThis function performs and automatic setup on the oscilloscope.\n\n\n\n\n\nRemarks:\n\n\u00b7 Automatic Setup will clear out any user specified setups on the oscilloscope.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nThe handle of the instrument returned from the initialization function.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\nLeCWJ300A_AutoSetup($Handle);\n\n\n\n\n\nLeCWJ300A_ChannelCouple\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS LeCWJ300A_ChannelCouple": {
  "prefix": "LeCWJ300A_ChannelCouple",
  "body": [
   "LeCWJ300A_ChannelCouple($$Handle,$$channelName,$$coupleType);"
  ],
  "description": "\n\nThis function requires the LeCroy Digital Storage Oscilloscope ActiveX libraries (activeDSO) to be installed on the system.\n\n\n\nThis function sets the coupling mode for the specified channel on the oscilloscope.\n\n\n\n\n\nRemarks:\n\n\u00b7 Some coupling modes are not available on all models in the WaveJet 300A series.\n\n\u00b7 The coupling mode and channel names are not case sensitive. Upper or lower case will work.\n\n\u00b7 Channels 3 and 4 are not available on all models in the WaveJet 300A series.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nThe handle of the instrument returned from the initialization function.\n\n\n\n$channelName\n\nString\n\nThe name of the channel to set the vertical resolution of.\n\nValues: CH1, CH2, CH3, CH4\n\n\n\n$coupleType\n\nString\n\nThe coupling mode for the specified channel.\n\nValues: AC1M, GND, DC1M, DC50\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\nLeCWJ300A_ChannelCouple($Handle, \"CH1\", \"AC1M\");\n\n\n\n\n\nLeCWJ300A_ChannelVertical\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS LeCWJ300A_ChannelVertical": {
  "prefix": "LeCWJ300A_ChannelVertical",
  "body": [
   "LeCWJ300A_ChannelVertical($$Handle,$$channelName,$$resolution,$$unit);"
  ],
  "description": "\n\nThis function requires the LeCroy Digital Storage Oscilloscope ActiveX libraries (activeDSO) to be installed on the system.\n\n\n\nThis function sets the vertical resolution for the specified channel on the screen of the oscilloscope.\n\n\n\n\n\nRemarks:\n\n\u00b7 The resolution is set in volts / division.\n\n\u00b7 The units and channel names are not case sensitive. Upper or lower case will work.\n\n\u00b7 Channels 3 and 4 are not available on all models in the WaveJet 300A series.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nThe handle of the instrument returned from the initialization function.\n\n\n\n$channelName\n\nString\n\nThe name of the channel to set the vertical resolution of.\n\nValues: CH1, CH2, CH3, CH4\n\n\n\n$resolution\n\nInteger\n\nThe number of units for each vertical division on the screen. Must be a whole number.\n\n\n\n$unit\n\nString\n\nThe voltage units to use for the vertical divisions.\n\nValues: uV, mV, V\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\nLeCWJ300A_ChannelVertical($Handle, \"CH1\", 500, \"mV\");\n\n\n\n\n\nLeCWJ300A_Close\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS LeCWJ300A_Close": {
  "prefix": "LeCWJ300A_Close",
  "body": [
   "LeCWJ300A_Close($$Handle);"
  ],
  "description": "\n\nThis function requires the LeCroy Digital Storage Oscilloscope ActiveX libraries (activeDSO) to be installed on the system.\n\n\n\nThis function closes and releases the instrument driver session. It also deallocates any memory resources the driver uses.\n\n\n\n\n\nRemarks:\n\n\u00b7 After closing, communications must be re-initialized before any more commands can be sent.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nThe handle of the instrument returned from the initialization function.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\nLeCWJ300A_Close($Handle);\n\n\n\n\n\nLeCWJ300A_HorizResolution\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS LeCWJ300A_HorizResolution": {
  "prefix": "LeCWJ300A_HorizResolution",
  "body": [
   "LeCWJ300A_HorizResolution($$Handle,$$resolution,$$unit);"
  ],
  "description": "\n\nThis function requires the LeCroy Digital Storage Oscilloscope ActiveX libraries (activeDSO) to be installed on the system.\n\n\n\nThis function sets the horizontal resolution (timebase) for the screen of the oscilloscope.\n\n\n\n\n\nRemarks:\n\n\u00b7 The resolution is set in time / division.\n\n\u00b7 The units are not case sensitive. Upper or lower case will work.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nThe handle of the instrument returned from the initialization function.\n\n\n\n$resolution\n\nInteger\n\nThe number of units for each horizontal division on the screen. Must be a whole number.\n\n\n\n$unit\n\nString\n\nThe time units to use for the horizontal divisions.\n\nValues: NS, US, MS, S\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\nLeCWJ300A_HorizResolution($Handle, 10, \"ms\");\n\n\n\n\n\nLeCWJ300A_Init\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS LeCWJ300A_Init(COM#,$baudRate,$dataBits,$parity,$stopBits);$Handle=LeCWJ300A_Init(GPIB[#],$GPIBAddress);$Handle=LeCWJ300A_Init": {
  "prefix": "LeCWJ300A_Init(COM#,$baudRate,$dataBits,$parity,$stopBits);$Handle=LeCWJ300A_Init(GPIB[#],$GPIBAddress);$Handle=LeCWJ300A_Init",
  "body": [
   "$$Handle=LeCWJ300A_Init(COM#,$$baudRate,$$dataBits,$$parity,$$stopBits);$$Handle=LeCWJ300A_Init(GPIB[#],$$GPIBAddress);$$Handle=LeCWJ300A_Init(IP,$$IPAddress);"
  ],
  "description": "\n\nThis function requires the LeCroy Digital Storage Oscilloscope ActiveX libraries (activeDSO) to be installed on the system.\n\n\n\nThis function opens the instrument for communication.\n\n\n\n\n\nRemarks:\n\n\u00b7 This function was tested with a LeCroy WaveJet 324A oscilloscope.\n\n\u00b7 All WaveJet 300A series oscilloscopes can be controlled with this library.\n\n\u00b7 Different arguments are used depending on type of communication bus:\n\n\u00b7 Serial Port\n\n\u00b7 GPIB bus\n\n\u00b7 Ethernet.\n\n\n\n\n\nSerial Bus: Function arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nCOM#\n\nString\n\nThe COM port number the instrument is connected to. Replace the \"#\" with the number.\n\n\n\n$baudRate\n\nString\n\nThe baud rate of the serial port.\n\nValues: 300, 1200, 2400, 4800, 9600, 19200, 57600, 115000\n\n\n\n$dataBits\n\nString\n\nThe number of data bits in the data.\n\nValues: 7, 8\n\n\n\n$parity\n\nString\n\nThe parity of the data.\n\nValues: N, O, E\n\n\n\n$stopBits\n\nString\n\nThe number of stop bits for the data.\n\nValues: 1, 1.5, 2\n\n\n\n\n\nGBIP Bus: Function arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nGPIB[#]\n\nString\n\nThe GPIB bus to connect to. The # is the bus number and is optional if there is only one GPIB adapter.\n\n\n\n$GPIBAddress\n\nString\n\nThe bus address of the oscilloscope.\n\n\n\n\n\nEthernet: Function arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nIP\n\nString\n\nInforms the driver to use an ethernet connection.\n\n\n\n$IPAddress\n\nString\n\nThe IP address of the oscilloscope.\n\nFormat: aaa.bbb.ccc.ddd\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nReturns a session handle that is used to identify the device in all subsequent function calls.\n\n\n\n\n\nExample:\n\n$Handle = LeCWJ300A_Init(\"COM6\", \"19200\", \"8\", \"N\", \"1\");\n\n$Handle = LeCWJ300A_Init(\"GPIB1\", \"14\");\n\n$Handle = LeCWJ300A_Init(\"IP\", \"192.168.10.5\");\n\n\n\n\n\nLeCWJ300A_MeasureAuto\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS LeCWJ300A_MeasureAuto": {
  "prefix": "LeCWJ300A_MeasureAuto",
  "body": [
   "LeCWJ300A_MeasureAuto($$Handle,$$autoMeasureStatus);"
  ],
  "description": "\n\nThis function requires the LeCroy Digital Storage Oscilloscope ActiveX libraries (activeDSO) to be installed on the system.\n\n\n\nThis function turns on or off the automatic measurement display on the oscilloscope.\n\n\n\n\n\nRemarks:\n\n\u00b7 The automatic measurement status is not case sensitive. Upper or lower case will work.\n\n\u00b7 Setting up a measurement or stopping all measurements (using the LeCWJ300A_MeasureSelect command) will also change whether the automatic measurement display is visible.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nThe handle of the instrument returned from the initialization function.\n\n\n\n$autoMeasureStatus\n\nString\n\nThe setting of the auto measurement display visibility.\n\nValues: OFF, ON\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\nLeCWJ300A_MeasureAuto($Handle, \"ON\");\n\n\n\n\n\nLeCWJ300A_MeasureRead\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS LeCWJ300A_MeasureRead": {
  "prefix": "LeCWJ300A_MeasureRead",
  "body": [
   "$$Reading=LeCWJ300A_MeasureRead($$Handle,$$measurementLetter);"
  ],
  "description": "\n\nThis function requires the LeCroy Digital Storage Oscilloscope ActiveX libraries (activeDSO) to be installed on the system.\n\n\n\nThis function returns one automatic measurement value from the oscilloscope.\n\n\n\n\n\nRemarks:\n\n\u00b7 The measurement letter is not case sensitive. Upper or lower case will work.\n\n\u00b7 The measurements are set up using the LeCWJ300A_MeasureSelect command.\n\n\u00b7 The units of the measurement depend on the type of measurement and are not returned.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nThe handle of the instrument returned from the initialization function.\n\n\n\n$measurementLetter\n\nString\n\nThe letter of the automatic measurement to return the value from.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Reading\n\nFloat\n\nThe value of the automatic measurement in floating point mode.\n\n\n\n\n\nExample:\n\n$Reading = LeCWJ300A_MeasureRead($Handle, \"A\");\n\n\n\n\n\nLeCWJ300A_MeasureSelect\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS LeCWJ300A_MeasureSelect": {
  "prefix": "LeCWJ300A_MeasureSelect",
  "body": [
   "LeCWJ300A_MeasureSelect($$Handle,$$measureLetter,$$channelName,$$measureType);"
  ],
  "description": "\n\nThis function requires the LeCroy Digital Storage Oscilloscope ActiveX libraries (activeDSO) to be installed on the system.\n\n\n\nThis function sets up one automatic measurement on the oscilloscope.\n\n\n\n\n\nRemarks:\n\n\u00b7 The measurement letter, channel name and measurement type are not case sensitive. Upper or lower case will work.\n\n\u00b7 The measurement unit is specific to the type of measurement being made and will not be returned.\n\n\u00b7 A maximum of four measurements can be set up.\n\n\u00b7 Defining an automatic measurement will automatically turn on the measurements display on the oscilloscope screen.\n\n\u00b7 If all measurements are set to OFF, the measurements display on the oscilloscope screen will be turned off.\n\n\u00b7 Turning off a channel will also clear any measurements that are made on that channel.\n\n\u00b7 Once a measurement is set up, its value can be read using the LeCWJ300A_MeasureRead command.\n\n\u00b7 Channels 3 and 4 are not available on all models in the WaveJet 300A series.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nThe handle of the instrument returned from the initialization function.\n\n\n\n$tmeasureLetter\n\nString\n\nThe letter to assign this measurement to.\n\nValues: A, B, C, D\n\n\n\n$channelName\n\nString\n\nThe channel to use for the defined measurement.\n\nAlso used to turn a measurement OFF.\n\nValues: OFF, CH1, CH2, CH3, CH4, MATH\n\n\n\n$measureType\n\nString\n\nWhat to measure on the specified channel.\n\nValues: MAX, MIN, P-P, VRMS, CVRMS, VMEAN, CVMEAN, TOP, BASE, T-B, +OSHOT, -OSHOT, TR20-80, TF80-20, TR10-90, TF90-10, FREQ, PERIOD, +PULSE, -PULSE, +WIDTH, -WIDTH, DUTY, INTEGRAL, SKEW, DELTAT\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\nLeCWJ300A_MeasureSelect($Handle, \"A\", \"CH1\", \"FREQ\");\n\nLeCWJ300A_MeasureSelect($Handle, \"A\", \"OFF\", \"MIN\");\n\n\n\n\n\nLeCWJ300A_Reset\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS LeCWJ300A_Reset": {
  "prefix": "LeCWJ300A_Reset",
  "body": [
   "LeCWJ300A_Reset($$Handle);"
  ],
  "description": "\n\nThis function requires the LeCroy Digital Storage Oscilloscope ActiveX libraries (activeDSO) to be installed on the system.\n\n\n\nThis function resets the oscilloscope.\n\n\n\n\n\nRemarks:\n\n\u00b7 Resetting the oscilloscope will lose all current settings.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nThe handle of the instrument returned from the initialization function.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\nLeCWJ300A_Reset($Handle);\n\n\n\n\n\nLeCWJ300A_StringRead\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS LeCWJ300A_StringRead": {
  "prefix": "LeCWJ300A_StringRead",
  "body": [
   "$$Reading=LeCWJ300A_StringRead($$Handle);"
  ],
  "description": "\n\nThis function requires the LeCroy Digital Storage Oscilloscope ActiveX libraries (activeDSO) to be installed on the system.\n\n\n\nThis function returns one string from the oscilloscope.\n\n\n\n\n\nRemarks:\n\n\u00b7 A previous command must have been sent to cause the oscilloscope to send a string. Use the LeCWJ300A_StringWrite function to send a command.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nThe handle of the instrument returned from the initialization function.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Reading\n\nString\n\nThe string read from the oscilloscope.\n\n\n\n\n\nExample:\n\n$Reading = LeCWJ300A_MeasureRead($Handle);\n\n\n\n\n\nLeCWJ300A_StringWrite\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS LeCWJ300A_StringWrite": {
  "prefix": "LeCWJ300A_StringWrite",
  "body": [
   "LeCWJ300A_StringWrite($$Handle,$$writeString);"
  ],
  "description": "\n\nThis function requires the LeCroy Digital Storage Oscilloscope ActiveX libraries (activeDSO) to be installed on the system.\n\n\n\nThis function sends a string to the oscilloscope.\n\n\n\n\n\nRemarks:\n\n\u00b7 The string must be correctly formatted for the oscilloscope.\n\n\u00b7 If the string is a command that will return data, use the LeCWJ300A_StringRead function to get the data.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nThe handle of the instrument returned from the initialization function.\n\n\n\n$writeString\n\nString\n\nThe string to send to the oscilloscope.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\nLeCWJ300A_StringWrite($Handle, \""
 }
,
 "JTS LeCWJ300A_TraceMode": {
  "prefix": "LeCWJ300A_TraceMode",
  "body": [
   "LeCWJ300A_TraceMode($$Handle,$$channelName,$$traceMode);"
  ],
  "description": "\n\nThis function requires the LeCroy Digital Storage Oscilloscope ActiveX libraries (activeDSO) to be installed on the system.\n\n\n\nThis function turns the specified trace OFF or ON on the oscilloscope display.\n\n\n\n\n\nRemarks:\n\n\u00b7 The channel name and trace mode are not case sensitive. Upper or lower case will work.\n\n\u00b7 Turning off a channel that has automatic measurements performed on it will also turn off those automatic measurements.\n\n\u00b7 Channels 3 and 4 are not available on all models in the WaveJet 300A series.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nThe handle of the instrument returned from the initialization function.\n\n\n\n$channelName\n\nString\n\nThe channel name of the trace to turn off.\n\nValues: CH1, CH2, CH3, CH4, MATH\n\n\n\n$traceMode\n\nString\n\nThe mode for the specified channel trace on the display.\n\nValues: OFF, ON\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\nLeCWJ300A_TraceMode($Handle, \"CH2\", \"OFF\");\n\n\n\n\n\nLeCWJ300A_TriggerCouple\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS LeCWJ300A_TriggerCouple": {
  "prefix": "LeCWJ300A_TriggerCouple",
  "body": [
   "LeCWJ300A_TriggerCouple($$Handle,$$triggerCouple);"
  ],
  "description": "\n\nThis function requires the LeCroy Digital Storage Oscilloscope ActiveX libraries (activeDSO) to be installed on the system.\n\n\n\nThis function sets the trigger coupling on the oscilloscope.\n\n\n\n\n\nRemarks:\n\n\u00b7 The trigger coupling is not case sensitive. Upper or lower case will work.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nThe handle of the instrument returned from the initialization function.\n\n\n\n$triggerCouple\n\nString\n\nThe coupling mode for the trigger.\n\nValues: AC, DC, HF, LF\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\nLeCWJ300A_TriggerCouple($Handle, \"AC\");\n\n\n\n\n\nLeCWJ300A_TriggerLevel\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS LeCWJ300A_TriggerLevel": {
  "prefix": "LeCWJ300A_TriggerLevel",
  "body": [
   "LeCWJ300A_TriggerLevel($$Handle,$$triggerLevel,$$triggerUnit);"
  ],
  "description": "\n\nThis function requires the LeCroy Digital Storage Oscilloscope ActiveX libraries (activeDSO) to be installed on the system.\n\n\n\nThis function sets the trigger level on the oscilloscope.\n\n\n\n\n\nRemarks:\n\n\u00b7 The trigger units are not case sensitive. Upper or lower case will work.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nThe handle of the instrument returned from the initialization function.\n\n\n\n$triggerLevel\n\nInteger\n\nThe voltage level to set the trigger to. Must be a whole number.\n\n\n\n$triggerUnit\n\nString\n\nThe voltage units to use for the trigger level.\n\nValues: uV, mV, V\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\nLeCWJ300A_TriggerLevel($Handle, 2, \"V\");\n\n\n\n\n\nLeCWJ300A_TriggerMode\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS LeCWJ300A_TriggerMode": {
  "prefix": "LeCWJ300A_TriggerMode",
  "body": [
   "LeCWJ300A_TriggerMode($$Handle,$$triggerMode);"
  ],
  "description": "\n\nThis function requires the LeCroy Digital Storage Oscilloscope ActiveX libraries (activeDSO) to be installed on the system.\n\n\n\nThis function sets the trigger mode on the oscilloscope.\n\n\n\n\n\nRemarks:\n\n\u00b7 The trigger mode is not case sensitive. Upper or lower case will work.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nThe handle of the instrument returned from the initialization function.\n\n\n\n$triggerMode\n\nString\n\nThe mode for the trigger.\n\nValues: AUTO, NORMAL, SINGLE, STOP\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\nLeCWJ300A_TriggerMode($Handle, \"NORMAL\");\n\n\n\n\n\nLeCWJ300A_TriggerType\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS LeCWJ300A_TriggerType": {
  "prefix": "LeCWJ300A_TriggerType",
  "body": [
   "LeCWJ300A_TriggerType($$Handle,$$triggerType);"
  ],
  "description": "\n\nThis function requires the LeCroy Digital Storage Oscilloscope ActiveX libraries (activeDSO) to be installed on the system.\n\n\n\nThis function sets the trigger type on the oscilloscope.\n\n\n\n\n\nRemarks:\n\n\u00b7 The trigger type is not case sensitive. Upper or lower case will work.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nThe handle of the instrument returned from the initialization function.\n\n\n\n$triggerType\n\nString\n\nThe type for the trigger.\n\nValues: EDGE, PULSE, PERIOD, COUNT, TV\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\nLeCWJ300A_TriggerType($Handle, \"EDGE\");\n\n\n\n\n\nNI-SCOPE\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_Scope_Abort": {
  "prefix": "NI_Scope_Abort",
  "body": [
   "$$ErrorCode=NI_Scope_Abort($$NI_ScopeHandle);"
  ],
  "description": "\n\nThis function requires NI Scope drivers to be installed on the system.\n\nThis function aborts an acquisition and returns the digitizer to the Idle state. Call this function if the digitizer times out waiting for a trigger.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PCI-5122 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Scope functions, Jabil Test will fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\n$ErrorCode = NI_Scope_Abort($NI_ScopeHandle);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_ScopeHandle\n\nObject\n\nThe instrument handle you obtain from NI_Scope_Initialize that identifies a particular instrument's session.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\nInteger\n\nReports the status of this operation. To obtain a text description of the status code, call NI_Scope_ErrorMessage. To obtain additional information concerning the error condition, use NI_Scope_GetError and NI_Scope_ClearError. The general meaning of the status code is as:\n\n\u00b7 0: success\n\n\u00b7 Positive value: warning\n\n\u00b7 Negative value: errors\n\n\n\n\n\nExample:\n\n$ErrorCode = NI_Scope_Abort($NI_ScopeHandle);\n\n\n\n\n\nNI_Scope_AcquisitionStatus\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_Scope_AcquisitionStatus": {
  "prefix": "NI_Scope_AcquisitionStatus",
  "body": [
   "($$ErrorCode,$$acquisitionStatus,$$Status)=NI_Scope_AcquisitionStatus($$NI_ScopeHandle);"
  ],
  "description": "\n\nThis function requires NI Scope drivers to be installed on the system.\n\nThis function returns the status information about the acquisition.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PCI-5122 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Scope functions, Jabil Test will fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\n($ErrorCode, $acquisitionStatus, $Status) = NI_Scope_AcquisitionStatus($NI_ScopeHandle);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_ScopeHandle\n\nObject\n\nThe instrument handle you obtain from NI_Scope_Initialize that identifies a particular instrument's session.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\nInteger\n\nReports the status of this operation. To obtain a text description of the status code, call NI_Scope_ErrorMessage. To obtain additional information concerning the error condition, use NI_Scope_GetError and NI_Scope_ClearError. The general meaning of the status code is as:\n\n\u00b7 0: success\n\n\u00b7 Positive value: warning\n\n\u00b7 Negative value: errors\n\n\n\n$Status\n\nInteger\n\n\u00b7 1 (means acquisition completed)\n\n\u00b7 0 (means acquisition in progress)\n\n-1 (means acquisition status unknown)\n\n\n\n$acquisitionStatus\n\nString\n\nIs the status of the acquisition.\n\nPossible return values:\n\n\u00b7 Acquisition completed\n\n\u00b7 Acquisition in progress\n\n\u00b7 Acquisition status unknown\n\n\n\n\n\nExample:\n\n($ErrorCode,$Status, $acquisitionStatus) = NI_Scope_AcquisitionStatus($NI_ScopeHandle);\n\n\n\n\n\nNI_Scope_Commit\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_Scope_Commit": {
  "prefix": "NI_Scope_Commit",
  "body": [
   "$$ErrorCode=NI_Scope_Commit($$NI_ScopeHandle);"
  ],
  "description": "\n\nThis function requires NI Scope drivers to be installed on the system.\n\nThis function commits to hardware all the parameter settings associated with the task. Use this function if you want a parameter change to be immediately reflected in the hardware. This function is supported for the NI 5122/5124 only.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PCI-5122 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Scope functions, Jabil Test will fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\n$ErrorCode = NI_Scope_Commit($NI_ScopeHandle);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_ScopeHandle\n\nObject\n\nThe instrument handle you obtain from NI_Scope_Initialize that identifies a particular instrument's session.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\nInteger\n\nReports the status of this operation. To obtain a text description of the status code, call NI_Scope_ErrorMessage. To obtain additional information concerning the error condition, use NI_Scope_GetError and NI_Scope_ClearError. The general meaning of the status code is as:\n\n\u00b7 0: success\n\n\u00b7 Positive value: warning\n\n\u00b7 Negative value: errors\n\n\n\n\n\nExample:\n\n$ErrorCode = NI_Scope_Commit($NI_ScopeHandle);\n\n\n\n\n\nNI_Scope_ConfigureAcquisitionRecord\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_Scope_ConfigureAcquisitionRecord": {
  "prefix": "NI_Scope_ConfigureAcquisitionRecord",
  "body": [
   "$$ErrorCode=NI_Scope_ConfigureAcquisitionRecord($$NI_ScopeHandle,$$TimePerRecord,$$MinNumPoints,$$AcquisitionStartTime);"
  ],
  "description": "\n\nThis function requires NI Scope drivers to be installed on the system.\n\nThis function configures the most commonly configured attributes of the instrument acquisition subsystem.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PCI-5122 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Scope functions, Jabil Test will fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\n$ErrorCode = NI_Scope_ConfigureAcquisitionRecord($NI_ScopeHandle, $TimePerRecord, $MinNumPoints, $AcquisitionStartTime);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_ScopeHandle\n\nObject\n\nThe instrument handle you obtain from NI_Scope_Initialize that identifies a particular instrument's session.\n\n\n\n$timePerRecord\n\nDouble\n\nSpecifies the time per record in seconds.\n\n\n\n$minNumPoints\n\nInteger\n\nPass the minimum number of points you require in the record for each channel. Call NI_Scope_ActualRecordLength to obtain the actual record length used.\n\n\n\n$acquisitionStartTime\n\nDouble\n\nSpecifies the position of the first point in the waveform record relative to the trigger event.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\nInteger\n\nReports the status of this operation. To obtain a text description of the status code, call NI_Scope_ErrorMessage. To obtain additional information concerning the error condition, use NI_Scope_GetError and NI_Scope_ClearError. The general meaning of the status code is as:\n\n\u00b7 0: success\n\n\u00b7 Positive value: warning\n\n\u00b7 Negative value: errors\n\n\n\n\n\nExample:\n\n$timePerRecord = New(\"Float\", 1.0);\n\n$minNumPoints = New(\"Integer\", 6000);\n\n$acquisitionStartTime = New(\"Float\", 0.0);\n\n$ErrorCode = NI_Scope_ConfigureAcquisitionRecord($NI_ScopeHandle, $timePerRecord, $minNumPoints, $acquisitionStartTime);\n\n\n\n\n\nNI_Scope_Fetch\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_Scope_Fetch": {
  "prefix": "NI_Scope_Fetch",
  "body": [
   "($$ErrorCode,$$WaveForms,$$NumberOfWaveforms,$$WaveFormsInfo)=NI_Scope_Fetch($$NI_ScopeHandle,$$measureChannel,$$measureTimeOut,$$ActualRecordLength);"
  ],
  "description": "\n\nThis function requires NI Scope drivers to be installed on the system.\n\nReturns the waveform from a previously initiated acquisition that the digitizer acquires for the specified channel. This function returns scaled voltage waveforms. This function may return multiple waveforms depending on the number of channels, the acquisition type, and the number of records you specify.\n\nUnlike Read functions, Fetch functions (NI_Scope_Fetch and NI_Scope_FetchMeasurement) acquire data asynchronously. That means these functions store data on your digitizer until you need it, which frees up your computer to perform other tasks and allows for better system performance. However, fetching requires additional functions that initiate waveform acquisitions and query your board to see if the acquisition is complete.\n\n\n\nTo fetch data, write a program that follows these general steps:\n\n\u00b7 Create a new instrument session using NI_Scope_Initialize.\n\n\u00b7 Configure your digitizer with NI-SCOPE Configuration functions.\n\n\u00b7 Call NI_Scope_ActualRecordLength to find the actual number of points your digitizer acquires for each channel.\n\n\u00b7 Call NI_Scope_InitiateAcquisition to initiate a waveform acquisition. Data will be acquired simultaneously on all enabled channels.\n\n\u00b7 Call NI_Scope_AcquisitionStatus in a loop to check if the acquisition is complete or in progress. This step is useful if you want to perform other tasks during the acquisition. The Fetch functions can also accept a timeout to force NI-SCOPE to wait until the acquisition is complete.\n\n\u00b7 Call the Fetch function you need. You can call multiple fetches if you are acquiring data from more than one channel or measurement.\n\n\u00b7 Call NI_Scope_Close to close the current session.\n\n\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PCI-5122 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Scope functions, Jabil Test will fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\n($ErrorCode, $WaveForms, $NumberOfWaveforms, $WaveFormsInfo) = NI_Scope_Fetch($NI_ScopeHandle, $measureChannel, $measureTimeOut, $ActualRecordLength);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_ScopeHandle\n\nObject\n\nThe instrument handle you obtain from NI_Scope_Initialize that identifies a particular instrument's session.\n\n\n\n$measureChannel\n\nString\n\nThe channel you will acquire data from; it may be a single channel, such as \"0\" or \"1\", or a list of channels such as \"0,1\".\n\n\n\n$measureTimeOut\n\nDouble\n\nThe time to wait in seconds for data to be acquired. Using 0 for this parameter tells NI-SCOPE to fetch whatever is currently available.\n\n\n\n$ActualRecordLength\n\nInteger\n\nThe maximum number of samples to fetch for each waveform. If the acquisition finishes with fewer points than requested, partial data will be returned.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\nInteger\n\nReports the status of this operation. To obtain a text description of the status code, call NI_Scope_ErrorMessage. To obtain additional information concerning the error condition, use NI_Scope_GetError and NI_Scope_ClearError. The general meaning of the status code is as:\n\n\u00b7 0: success\n\n\u00b7 Positive value: warning\n\n\u00b7 Negative value: errors\n\n\n\n$WaveForms\n\nArray\n\nReturns an array whose length is the numSamples times number of waveforms. Call NI_Scope_ActualNumWfms to determine the number of waveforms.\n\nNI-SCOPE returns this data sequentially, so all record 0 waveforms are first.\n\nFor example, with a channel list of 0,1, you would have the following index values:\n\n\u00b7 index 0 = record 0, channel 0\n\n\u00b7 index x = record 0, channel 1\n\n\u00b7 index 2x = record 1, channel 0\n\n\u00b7 index 3x = record 1, channel 1\n\n\u00b7 Where x = the record length\n\nCall NI_Scope_ActualNumWfms to determine the number of waveforms. Call NI_Scope_ActualMeasWfmSize to determine the size of each waveform.\n\n\n\n$NumberOfWaveforms\n\nInteger\n\nReturns the number of records times the number of channels\n\n\n\n$WaveFormsInfo\n\nArray\n\nReturns an array of structures with the following timing and scaling information about each waveform:\n\n\u00b7 relativeInitialX: the time (in seconds) from the trigger to the first sample in the fetched waveform\n\n\u00b7 absoluteInitialX: timestamp (in seconds) of the first fetched sample that is comparable between records and acquisitions; your digitizer must support continuous acquisition\n\n\u00b7 xIncrement: the time between points in the acquired waveform in seconds\n\n\u00b7 actualSamples: the actual number of samples fetched and placed in the waveform array\n\n\u00b7 gain: the gain factor of the given channel; useful for scaling binary data with the following formula: voltage = binary data "
 }
,
 "JTS NI_Scope_Analyze": {
  "prefix": "NI_Scope_Analyze",
  "body": [
   "($$MeasureData,$$ArrayOffsetMeasurePosition,$$ArrayOffsetMeasureDuration,$$NumberRecords,$$RecordLength,$$HorizontalTimePerRecord,$$SampleRate,$$ReferencePosition)=NI_Scope_Analyze($$NI_ScopeHandle,$$WaveForms,$$Index,$$StartMeasurePosition,$$MeasureDuration);"
  ],
  "description": "\n\nThis function requires NI Scope drivers to be installed on the system.\n\nThis function gets a specific part of a waveform array and returns that part as an array. That array can then be analyzed. (get the mean value of the array, get the maximum value of the array, get the minimum value of the array, filtering, ...)\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PCI-5122 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Scope functions, Jabil Test will fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\n($MeasureData, $ArrayOffsetMeasurePosition, $ArrayOffsetMeasureDuration, $NumberRecords, $RecordLength, $HorizontalTimePerRecord, $SampleRate, $ReferencePosition) = NI_Scope_Analyze($NI_ScopeHandle, $WaveForms, $Index, $StartMeasurePosition , $MeasureDuration);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_ScopeHandle\n\nObject\n\nThe instrument handle you obtain from NI_Scope_Initialize that identifies a particular instrument's session.\n\n\n\n$WaveForms\n\nArray\n\nThe fetched waveform data returned from NI_Scope_Fetch or other acquisition functions. This array should be of the type Double[]. If not, Jabil Test will return an error.\n\n\n\n$Index\n\nInteger\n\nThe fetched waveform is returned sequentially. This means that all record 0 waveforms are first. For example, with a channel list 0,1, you would have the following index values:\n\nindex 0 = record 0, channel 0\n\nindex x = record 0, channel 1\n\nindex 2x = record 1, channel 0\n\nindex 3x = record 1, channel 1\n\nwhere x is the record length\n\n\n\n$StartMeasurePosition\n\nFloat\n\nThe start measure position in the fetched waveform.\n\nUnit: Seconds.\n\n\n\n$MeasureDuration\n\nFloat\n\nThe measure duration of the fetched waveform.\n\nUnit: Seconds.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$MeasureData\n\nArray\n\nAn array containing the selected array range of the fetched waveform.\n\n\n\n$ArrayOffsetMeasurePosition\n\nInteger\n\nThe waveform index number of the start measure position.\n\n\n\n$ArrayOffsetMeasureDuration\n\nInteger\n\nThe array length of the measure duration\n\n\n\n$NumberRecords\n\nInteger\n\nReturns the number of records the digitizer acquires.\n\n\n\n$RecordLength\n\nInteger\n\nReturns the actual number of points the digitizer acquires\n\n\n\n$HorizontalTimePerRecord\n\nFloat\n\nSpecifies the length of time that corresponds to the record length.\n\nUnit: seconds.\n\n\n\n$SampleRate\n\nFloat\n\nReturns the sampling rate for the acquisition.\n\n\n\n$ReferencePosition\n\nFloat\n\nReturns the position of the Reference Event in the waveform record as a percentage of the record.\n\n\n\n\n\nExample:\n\n($MeasureData, $ArrayOffsetMeasurePosition, $ArrayOffsetMeasureDuration, $NumberRecords, $RecordLength, $HorizontalTimePerRecord, $SampleRate, $ReferencePosition) = NI_Scope_Analyze($NI_ScopeHandle, $WaveForms, 0, 0.000000, 0.000040);\n\n\n\n\n\nNI_Scope_GetWaveformInfo\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_Scope_GetWaveformInfo": {
  "prefix": "NI_Scope_GetWaveformInfo",
  "body": [
   "$$Result=NI_Scope_GetWaveformInfo($$WaveformIndex,$$WaveformInfo,$$WaveformInfoElement);"
  ],
  "description": "\n\nThis function requires NI Scope drivers to be installed on the system.\n\nThis function get the needed value out of the WaveformInfo structure returned from a fetch or a read function.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PCI-5122 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Scope functions, Jabil Test will fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\n$Result = NI_Scope_GetWaveformInfo($WaveformIndex, $WaveformInfo, $WaveformInfoElement);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$WaveformIndex\n\nInteger\n\nThe waveform index where you want to get the element value from. The size of the WaveformInfo object is returned by the function NI_Scope_Fetch. You also can get the size by NI_Scope_ActualNumWfms.\n\n\n\n$WaveformInfo\n\nObject\n\nThis object is returned by a fetch or read function. This object is of the type struct niScopeWfmInfo. This structure is containing:\n\n\u00b7 relativeInitialX: the time (in seconds) from the trigger to the first sample in the fetched waveform\n\n\u00b7 absoluteInitialX: timestamp (in seconds) of the first fetched sample that is comparable between records and acquisitions; your digitizer must support continuous acquisition\n\n\u00b7 xIncrement: the time between points in the acquired waveform in seconds\n\n\u00b7 actualSamples: the actual number of samples fetched and placed in the waveform array\n\n\u00b7 gain: the gain factor of the given channel; useful for scaling binary data with the following formula: voltage = binary data "
 }
,
 "JTS NI_Scope_InitiateAcquisition": {
  "prefix": "NI_Scope_InitiateAcquisition",
  "body": [
   "$$ErrorCode=NI_Scope_InitiateAcquisition($$NI_ScopeHandle);"
  ],
  "description": "\n\nThis function requires NI Scope drivers to be installed on the system.\n\nInitiates a waveform acquisition.\n\nAfter calling this function, the digitizer leaves the Idle state and waits for a trigger. The digitizer acquires a waveform for each channel you enable with NI_Scope_ConfigureVertical.\n\nInitiate Acquisition tells the digitizer to start acquiring data. During this function, the hardware is programmed with the configuration that you have chosen, and the digitizer begins sampling data and storing it to onboard memory. First, the digitizer samples the requested number of pretrigger points, ignoring any triggers that may occur. After the requested number of pretrigger points are stored, the digitizer waits for a trigger. While waiting, it continues to sample and store data into the circular, onboard memory. The trigger signals the digitizer to sample the exact number of posttrigger samples that you requested. After the posttrigger points are stored, the digitizer either stops sampling data or restarts this process for the next record. The digitizer stores the memory location of the first posttrigger sample, which allows it to calculate where the first pretrigger sample is located in memory when you fetch the waveform.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PCI-5122 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Scope functions, Jabil Test will fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\n$ErrorCode = NI_Scope_InitiateAcquisition($NI_ScopeHandle);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_ScopeHandle\n\nObject\n\nThe instrument handle you obtain from NI_Scope_Initialize that identifies a particular instrument's session.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\nInteger\n\nReports the status of this operation. To obtain a text description of the status code, call NI_Scope_ErrorMessage. To obtain additional information concerning the error condition, use NI_Scope_GetError and NI_Scope_ClearError. The general meaning of the status code is as:\n\n\u00b7 0: success\n\n\u00b7 Positive value: warning\n\n\u00b7 Negative value: errors\n\n\n\n\n\nExample:\n\n$ErrorCode = NI_Scope_InitiateAcquisition($NI_ScopeHandle);\n\n\n\n\n\nNI_Scope_Read\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_Scope_Read": {
  "prefix": "NI_Scope_Read",
  "body": [
   "($$ErrorCode,$$WaveForms,$$NumberOfWaveforms,$$WaveFormsInfo)=NI_Scope_Read($$NI_ScopeHandle,$$measureChannel,$$measureTimeOut,$$ActualRecordLength);"
  ],
  "description": "\n\nThis function requires NI Scope drivers to be installed on the system.\n\nThis function initiates an acquisition, waits for it to complete, and retrieves the data. The process is similar to calling NI_Scope_InitiateAcquisition, NI_Scope_AcquisitionStatus, and NI_Scope_Fetch. The only difference is that with NI_Scope_Read, you enable all channels specified with channelList before the acquisition; in the other method, you enable the channels with NI_Scope_ConfigureVertical.\n\nThis function may return multiple waveforms depending on the number of channels, the acquisition type, and the number of records you specify.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PCI-5122 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Scope functions, Jabil Test will fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\n($ErrorCode, $WaveForms, $NumberOfWaveforms, $WaveFormsInfo) = NI_Scope_Read($NI_ScopeHandle, $measureChannel, $measureTimeOut, $ActualRecordLength);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_ScopeHandle\n\nObject\n\nThe instrument handle you obtain from NI_Scope_Initialize that identifies a particular instrument's session.\n\n\n\n$measureChannel\n\nString\n\nThe channel you will acquire data from; it may be a single channel, such as \"0\" or \"1\", or a list of channels such as \"0,1\".\n\n\n\n$measureTimeOut\n\nDouble\n\nThe time to wait in seconds for data to be acquired. Using 0 for this parameter tells NI-SCOPE to fetch whatever is currently available.\n\n\n\n$ActualRecordLength\n\nInteger\n\nThe maximum number of samples to fetch for each waveform. If the acquisition finishes with fewer points than requested, partial data will be returned.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\nInteger\n\nReports the status of this operation. To obtain a text description of the status code, call NI_Scope_ErrorMessage. To obtain additional information concerning the error condition, use NI_Scope_GetError and NI_Scope_ClearError. The general meaning of the status code is as:\n\n\u00b7 0: success\n\n\u00b7 Positive value: warning\n\n\u00b7 Negative value: errors\n\n\n\n$WaveForms\n\nArray\n\nReturns an array whose length is the numSamples times number of waveforms. Call NI_Scope_ActualNumWfms to determine the number of waveforms.\n\nNI-SCOPE returns this data sequentially, so all record 0 waveforms are first.\n\nFor example, with a channel list of 0,1, you would have the following index values:\n\n\u00b7 index 0 = record 0, channel 0\n\n\u00b7 index x = record 0, channel 1\n\n\u00b7 index 2x = record 1, channel 0\n\n\u00b7 index 3x = record 1, channel 1\n\n\u00b7 Where x = the record length\n\nCall NI_Scope_ActualNumWfms to determine the number of waveforms. Call NI_Scope_ActualMeasWfmSize to determine the size of each waveform.\n\n\n\n$NumberOfWaveforms\n\nInteger\n\nReturns the number of records times the number of channels\n\n\n\n$WaveFormsInfo\n\nArray\n\nReturns an array of structures with the following timing and scaling information about each waveform:\n\n\u00b7 relativeInitialX: the time (in seconds) from the trigger to the first sample in the fetched waveform\n\n\u00b7 absoluteInitialX: timestamp (in seconds) of the first fetched sample that is comparable between records and acquisitions; your digitizer must support continuous acquisition\n\n\u00b7 xIncrement: the time between points in the acquired waveform in seconds\n\n\u00b7 actualSamples: the actual number of samples fetched and placed in the waveform array\n\n\u00b7 gain: the gain factor of the given channel; useful for scaling binary data with the following formula: voltage = binary data "
 }
,
 "JTS NI_Scope_CalSelfCalibrate": {
  "prefix": "NI_Scope_CalSelfCalibrate",
  "body": [
   "$$ErrorCode=NI_Scope_CalSelfCalibrate($$NI_ScopeHandle,$$channelName,$$Options);"
  ],
  "description": "\n\nThis function requires NI Scope drivers to be installed on the system.\n\nThis function self-calibrates the digitizer. To verify that your digitizer supports self-calibration, refer to Features Supported by Device.\n\n\n\nFor the NI 5114/5122/5124/5922, if the self-calibration is performed successfully in a regular session, the calibration constants are immediately stored in the self-calibration area of the EEPROM. If the self-calibration is performed in an external calibration session, the calibration constants take effect immediately for the duration of the session. However, they are not stored in the EEPROM until NI_Scope_CalEnd is called with action set to action store and no errors occur.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PCI-5122 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Scope functions, Jabil Test will fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\n$ErrorCode = NI_Scope_CalSelfCalibrate($NI_ScopeHandle, $channelName, $Options);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_ScopeHandle\n\nObject\n\nThe instrument handle you obtain from NI_Scope_Initialize that identifies a particular instrument's session.\n\n\n\n$channelName\n\nString\n\nThis parameter is ignored.\n\n\n\n$Options\n\nString\n\nPossible values:\n\n\u00b7 SELF CALIBRATION\n\n\u00b7 RESTORE FACTORY CALIBRATION\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\nInteger\n\nReports the status of this operation. To obtain a text description of the status code, call NI_Scope_ErrorMessage. To obtain additional information concerning the error condition, use NI_Scope_GetError and NI_Scope_ClearError. The general meaning of the status code is as:\n\n\u00b7 0: success\n\n\u00b7 Positive value: warning\n\n\u00b7 Negative value: errors\n\n\n\n\n\nExample:\n\n$ErrorCode = NI_Scope_CalSelfCalibrate($NI_ScopeHandle, \"0\", \"SELF CALIBRATION\");\n\n\n\n\n\nConfiguration Functions\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_Scope_ActualMeasWfmSize": {
  "prefix": "NI_Scope_ActualMeasWfmSize",
  "body": [
   "($$ErrorCode,$$MeasWaveformSize)=NI_Scope_ActualMeasWfmSize($$NI_ScopeHandle,$$ArrayMeasurementFunction);"
  ],
  "description": "\n\nThis function requires NI Scope drivers to be installed on the system.\n\nThis function returns the total available size of an array measurement acquisition.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PCI-5122 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Scope functions, Jabil Test will fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\n($ErrorCode, $MeasWaveformSize) = NI_Scope_ActualMeasWfmSize($NI_ScopeHandle, $ArrayMeasurementFunction);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_ScopeHandle\n\nObject\n\nThe instrument handle you obtain from NI_Scope_Initialize that identifies a particular instrument's session.\n\n\n\n$ArrayMeasurementFunction\n\nString\n\nThe array measurement to perform:\n\n\u00b7 NO MEASUREMENT\n\n\u00b7 LAST ACQ HISTORGRAM\n\n\u00b7 MULTI ACQ TIME HISTOGRAM\n\n\u00b7 MULTI ACQ VOLTAGE HISTOGRAM\n\n\u00b7 BLACKMAN WINDOW\n\n\u00b7 HANNING WINDOW\n\n\u00b7 FLAT TOP WINDOW\n\n\u00b7 TRIANGLE WINDOW\n\n\u00b7 HAMMING WINDOW\n\n\u00b7 BESSEL FILTER\n\n\u00b7 WINDOWED FIR FILTER\n\n\u00b7 BUTTERWORTH FILTER\n\n\u00b7 CHEBYSHEV FILTER\n\n\u00b7 ADD CHANNELS\n\n\u00b7 MULTIPLY CHANNELS\n\n\u00b7 DIVIDE CHANNELS\n\n\u00b7 SUBTRACT CHANNELS\n\n\u00b7 DERIVATIVE\n\n\u00b7 MULTI ACQ AVERAGE\n\n\u00b7 ARRAY INTEGRAL\n\n\u00b7 INVERSE\n\n\u00b7 ARRAY GAIN\n\n\u00b7 ARRAY OFFSET\n\n\u00b7 FFT AMP SPECTRUM DB\n\n\u00b7 FFT PHASE SPECTRUM\n\n\u00b7 FFT AMP SPECTRUM VOLTS RMS\n\n\u00b7 POLYNOMIAL INTERPOLATION\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\nInteger\n\nReports the status of this operation. To obtain a text description of the status code, call NI_Scope_ErrorMessage. To obtain additional information concerning the error condition, use NI_Scope_GetError and NI_Scope_ClearError. The general meaning of the status code is as:\n\n\u00b7 0: success\n\n\u00b7 Positive value: warning\n\n\u00b7 Negative value: errors\n\n\n\n$ActualRecordLength\n\nInteger\n\nReturns the actual number of points the digitizer acquires for each channel.\n\n\n\n\n\nExample:\n\n$ArrayMeasurementFunction = New(String, \"no measurement\");\n\n\n\n($ErrorCode, $MeasWaveformSize) = NI_Scope_ActualMeasWfmSize($NI_ScopeHandle, $ArrayMeasurementFunction);\n\n\n\n\n\nNI_Scope_ActualNumWfms\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_Scope_ActualNumWfms": {
  "prefix": "NI_Scope_ActualNumWfms",
  "body": [
   "($$ErrorCode,$$numWfms)=NI_Scope_ActualNumWfms($$NI_ScopeHandle,$$channelName);"
  ],
  "description": "\n\nThis function requires NI Scope drivers to be installed on the system.\n\nThis function helps you to declare appropriately sized waveforms.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PCI-5122 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Scope functions, Jabil Test will fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\n($ErrorCode, $numWfms) = NI_Scope_ActualNumWfms($NI_ScopeHandle, $channelName);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_ScopeHandle\n\nObject\n\nThe instrument handle you obtain from NI_Scope_Initialize that identifies a particular instrument's session.\n\n\n\n$channelName\n\nString\n\nThe channel to acquire data from; it may be a single channel, such as \"0\" or \"1\" or a list of channels such as \"0,1\".\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\nInteger\n\nReports the status of this operation. To obtain a text description of the status code, call NI_Scope_ErrorMessage. To obtain additional information concerning the error condition, use NI_Scope_GetError and NI_Scope_ClearError. The general meaning of the status code is as:\n\n\u00b7 0: success\n\n\u00b7 Positive value: warning\n\n\u00b7 Negative value: errors\n\n\n\n$numWfms\n\nInteger\n\nReturns the number of records times the number of channels; if you are operating in DDC mode (NI 5620/5621 only), this value is multiplied by two.\n\n\n\n\n\nExample:\n\n($ErrorCode, $numWfms) = NI_Scope_ActualNumWfms($NI_ScopeHandle, \"0\");\n\n\n\n\n\nNI_Scope_ActualRecordLength\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_Scope_ActualRecordLength": {
  "prefix": "NI_Scope_ActualRecordLength",
  "body": [
   "($$ErrorCode,$$ActualRecordLength)=NI_Scope_ActualRecordLength($$NI_ScopeHandle);"
  ],
  "description": "\n\nThis function requires NI Scope drivers to be installed on the system.\n\nThis function returns the actual number of points the digitizer acquires for each channel. After configuring the digitizer for an acquisition, call this function to determine the size of the waveforms that the digitizer acquires. The value is equal to or greater than the minimum number of points specified in any of the Configure Horizontal functions.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PCI-5122 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Scope functions, Jabil Test will fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\n($ErrorCode, $ActualRecordLength) = NI_Scope_ActualRecordLength($NI_ScopeHandle);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_ScopeHandle\n\nObject\n\nThe instrument handle you obtain from NI_Scope_Initialize that identifies a particular instrument's session.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\nInteger\n\nReports the status of this operation. To obtain a text description of the status code, call NI_Scope_ErrorMessage. To obtain additional information concerning the error condition, use NI_Scope_GetError and NI_Scope_ClearError. The general meaning of the status code is as:\n\n\u00b7 0: success\n\n\u00b7 Positive value: warning\n\n\u00b7 Negative value: errors\n\n\n\n$ActualRecordLength\n\nInteger\n\nReturns the actual number of points the digitizer acquires for each channel.\n\n\n\n\n\nExample:\n\n($ErrorCode, $ActualRecordLength) = NI_Scope_ActualRecordLength($NI_ScopeHandle);\n\n\n\n\n\nNI_Scope_SampleMode\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_Scope_SampleMode": {
  "prefix": "NI_Scope_SampleMode",
  "body": [
   "($$ErrorCode,$$sampleMode)=NI_Scope_SampleMode($$NI_ScopeHandle);"
  ],
  "description": "\n\nThis function requires NI Scope drivers to be installed on the system.\n\nThis function returns the sample mode the oscilloscope is currently using.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PCI-5122 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Scope functions, Jabil Test will fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\n($ErrorCode, $sampleMode) = NI_Scope_SampleMode($NI_ScopeHandle);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_ScopeHandle\n\nObject\n\nThe instrument handle you obtain from NI_Scope_Initialize that identifies a particular instrument's session.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\nInteger\n\nReports the status of this operation. To obtain a text description of the status code, call NI_Scope_ErrorMessage. To obtain additional information concerning the error condition, use NI_Scope_GetError and NI_Scope_ClearError. The general meaning of the status code is as:\n\n\u00b7 0: success\n\n\u00b7 Positive value: warning\n\n\u00b7 Negative value: errors\n\n\n\n$sampleMode\n\nString\n\nReturns the sample mode the digitizer is currently using. Possible values:\n\n\u00b7 Real time sample mode: Indicates that the digitizer is using real-time sampling.\n\n\u00b7 Equivalent time sample mode: Indicates that the digitizer is using equivalent-time sampling.\n\n\n\n\n\nExample:\n\n($ErrorCode, $sampleMode) = NI_Scope_SampleMode($NI_ScopeHandle);\n\n\n\n\n\nNI_Scope_SampleRate\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_Scope_SampleRate": {
  "prefix": "NI_Scope_SampleRate",
  "body": [
   "($$ErrorCode,$$sampleRate)=NI_Scope_SampleRate($$NI_ScopeHandle);"
  ],
  "description": "\n\nThis function requires NI Scope drivers to be installed on the system.\n\nThis function returns the effective sample rate of the acquired waveform using the current configuration in samples per second.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PCI-5122 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Scope functions, Jabil Test will fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\n($ErrorCode, $sampleRate) = NI_Scope_SampleRate($NI_ScopeHandle);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_ScopeHandle\n\nObject\n\nThe instrument handle you obtain from NI_Scope_Initialize that identifies a particular instrument's session.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\nInteger\n\nReports the status of this operation. To obtain a text description of the status code, call NI_Scope_ErrorMessage. To obtain additional information concerning the error condition, use NI_Scope_GetError and NI_Scope_ClearError. The general meaning of the status code is as:\n\n\u00b7 0: success\n\n\u00b7 Positive value: warning\n\n\u00b7 Negative value: errors\n\n\n\n$sampleRate\n\nDouble\n\nReturns the effective sample rate of the acquired waveform the digitizer acquires for each channel.\n\n\n\n\n\nExample:\n\n($ErrorCode, $sampleRate) = NI_Scope_SampleRate($NI_ScopeHandle);\n\n\n\n\n\nNI_Scope_ConfigureHorizontalTiming\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_Scope_ConfigureHorizontalTiming": {
  "prefix": "NI_Scope_ConfigureHorizontalTiming",
  "body": [
   "$$ErrorCode=NI_Scope_ConfigureHorizontalTiming($$NI_ScopeHandle,$$minSampleRate,$$minNumPts,$$refPosition,$$numRecords,$$enforceRealTime);"
  ],
  "description": "\n\nThis function requires NI Scope drivers to be installed on the system.\n\nThis function configures the common properties of the horizontal subsystem for a multirecord acquisition in terms of minimum sample rate.\n\n\n\nThe horizontal timing parameters apply to all enabled channels of the digitizer, which means that both channels of a two-channel digitizer sample the same amount of data at the same rate. Some digitizers support acquiring multirecords. multirecord acquisitions allow you to acquire multiple, triggered waveforms very quickly. Because the triggering and timing are done in hardware, multirecord acquisitions eliminate the possibility of the operating system interrupting your program and causing the digitizer to miss triggers. To find out if your digitizer supports multirecord acquisitions, refer to Features Supported by Device. The horizontal settings include the num records, sample rate, min record length, and reference position parameters.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PCI-5122 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Scope functions, Jabil Test will fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\n$ErrorCode = NI_Scope_ConfigureHorizontalTiming($NI_ScopeHandle, $minSampleRate, $minNumPts, $refPosition, $numRecords, $enforceRealTime);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_ScopeHandle\n\nObject\n\nThe instrument handle you obtain from NI_Scope_Initialize that identifies a particular instrument's session.\n\n\n\n$minSampleRate\n\nDouble\n\nThe sampling rate for the acquisition. The sample rate parameter is the frequency at which digitized samples are stored. This parameter is rounded up to the next legal sampling rate that your device supports. If the enforce realtime parameter is set to TRUE, the sampling rate must be set lower than the maximum real-time sampling rate of the digitizer, so data can be digitized at the requested rate. If you set the enforce realtime parameter to FALSE, NI-SCOPE allows you to specify sampling rates higher than the maximum real-time sampling rate of the digitizer. When you do this, NI-SCOPE enters random interleaved sampling (RIS) mode, where it acquires multiple waveforms at the maximum real-time sampling rate and reconstructs a periodic waveform.\n\nUnit : Hertz (Samples / Second)\n\n\n\n$minNumPts\n\nInteger\n\nThe minimum number of points you need in the record for each channel. Call NI_Scope_ActualRecordLength to obtain the actual record length used.\n\nThe min record length parameter is the minimum number of samples to store for each record in the acquisition. This parameter can also be rounded up. NI-SCOPE maintains a constant time per record, which is the min record length divided by the requested sampling rate. Because the sampling rate is rounded up to a legal value, the min record length can also be rounded up. You can fetch this resulting actual record length by calling Actual Record Length. Similarly, you can call Sample Rate to find the true sample rate used or Actual Sample Mode to determine if NI-SCOPE is using RIS or real-time sampling.\n\n\n\n$refPosition\n\nDouble\n\nThe position of the Reference Event in the waveform record specified as a percentage.\n\nThe reference position parameter determines the number of pretrigger versus posttrigger points that are stored. Reference position is expressed as a percent of the record, from 0 to 100. For example, a 0% reference position means that you have the actual record length points stored after the trigger occurs, while 100% reference position means that all the samples are stored before the trigger.\n\nValid Range: 0.0 - 100.0\n\n\n\n$numRecords\n\nInteger\n\nThis parameter allows you to configure a multirecord acquisition. For a single record acquisition, set this parameter to 1.\n\n\n\n$enforceRealTime\n\nBoolean\n\nIndicates whether the digitizer enforces real-time measurements or allows equivalent-time (RIS) measurements. Not all digitizers support RIS. Refer to Features Supported by Device\n\nValid values:\n\n\u00b7 True : Allow real-time acquisitions only\n\n\u00b7 False : Allow real-time and equivalent-time acquisitions\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\nInteger\n\nReports the status of this operation. To obtain a text description of the status code, call NI_Scope_ErrorMessage. To obtain additional information concerning the error condition, use NI_Scope_GetError and NI_Scope_ClearError. The general meaning of the status code is as:\n\n\u00b7 0: success\n\n\u00b7 Positive value: warning\n\n\u00b7 Negative value: errors\n\n\n\n\n\nExample:\n\n$sampleRate = New(\"Float\", 100000000);\n\n$numPts = New(\"Integer\", 6000);\n\n$refPosition = New(\"Float\", 1.0);\n\n$numRecords = New(\"Integer\", 1);\n\n$enforceRealTime = New(\"Boolean\", \"TRUE\");\n\n\n\n$ErrorCode = NI_Scope_ConfigureHorizontalTiming($NI_ScopeHandle, $sampleRate, $numPts, $refPosition, $numRecords, $enforceRealTime);\n\n\n\n\n\nNI_Scope_AutoSetup\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_Scope_AutoSetup": {
  "prefix": "NI_Scope_AutoSetup",
  "body": [
   "$$ErrorCode=NI_Scope_AutoSetup($$NI_ScopeHandle);"
  ],
  "description": "\n\nThis function requires NI Scope drivers to be installed on the system.\n\nThis function automatically configures the instrument. When you call this function, the digitizer senses the input signal and automatically configures many of the instrument settings. If no signal is found on any analog input channel, Jabil Test will fail. A channel is considered to have a signal present if the signal is at least 10% of the smallest vertical range available for that channel.\n\n\n\nThe following settings are changed: General\n\n\n\nAcquisition mode\n\nNormal\n\n\n\nReference clock\n\nInternal\n\n\n\n\n\nVertical\n\n\n\nVertical coupling\n\nAC (DC for NI 5621)\n\n\n\nVertical bandwidth\n\nFull\n\n\n\nVertical range\n\nChanged by auto setup\n\n\n\nVertical offset\n\n0 V\n\n\n\nProbe attenuation\n\nUnchanged by auto setup\n\n\n\nInput impedance\n\nUnchanged by auto setup\n\n\n\n\n\nHorizontal\n\n\n\nSample rate\n\nChanged by auto setup\n\n\n\nMin record length\n\nChanged by auto setup\n\n\n\nEnforce realtime\n\nTrue\n\n\n\nNumber of Records\n\nChanged to 1\n\n\n\n\n\nTriggering\n\n\n\nTrigger mode\n\nEdge if signal present, otherwise immediate\n\n\n\nTrigger channel\n\nLowest numbered channel with a signal present\n\n\n\nTrigger slope\n\nPositive\n\n\n\nTrigger coupling\n\nDC\n\n\n\nReference position\n\n50%\n\n\n\nTrigger level\n\n50% of signal on trigger channel\n\n\n\nTrigger delay\n\n0\n\n\n\nTrigger holdoff\n\n0\n\n\n\nTrigger output\n\nNone\n\n\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PCI-5122 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Scope functions, Jabil Test will fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\n$ErrorCode = NI_Scope_AutoSetup($NI_ScopeHandle);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_ScopeHandle\n\nObject\n\nThe instrument handle you obtain from NI_Scope_Initialize that identifies a particular instrument's session.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\nInteger\n\nReports the status of this operation. To obtain a text description of the status code, call NI_Scope_ErrorMessage. To obtain additional information concerning the error condition, use NI_Scope_GetError and NI_Scope_ClearError. The general meaning of the status code is as:\n\n\u00b7 0: success\n\n\u00b7 Positive value: warning\n\n\u00b7 Negative value: errors\n\n\n\n\n\nExample:\n\n$ErrorCode = NI_Scope_AutoSetup($NI_ScopeHandle);\n\n\n\n\n\nNI_Scope_ConfigureAcquisition\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_Scope_ConfigureAcquisition": {
  "prefix": "NI_Scope_ConfigureAcquisition",
  "body": [
   "$$ErrorCode=NI_Scope_ConfigureAcquisition($$NI_ScopeHandle,$$acquisitionType);"
  ],
  "description": "\n\nThis function requires NI Scope drivers to be installed on the system.\n\nThis function configures how the oscilloscope acquires data.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PCI-5122 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Scope functions, Jabil Test will fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\n$ErrorCode = NI_Scope_ConfigureAcquisition($NI_ScopeHandle, $acquisitionType);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_ScopeHandle\n\nObject\n\nThe instrument handle you obtain from NI_Scope_Initialize that identifies a particular instrument's session.\n\n\n\n$acquisitionType\n\nString\n\nSpecify the resolution the oscilloscope uses when acquiring data.\n\n\u00b7 NORMAL : Sets the oscilloscope to normal resolution mode. The oscilloscope can use real-time sampling or equivalent-time sampling.\n\n\u00b7 FLEXIBLE RESOLUTION MODE : Sets the oscilloscope to flexible resolution mode if supported. The oscilloscope uses different hardware configurations to change the resolution depending on the sampling rate used.\n\n\u00b7 DDC MODE : Sets the acquisition mode to DDC (NI 5620 only)\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\nInteger\n\nReports the status of this operation. To obtain a text description of the status code, call NI_Scope_ErrorMessage. To obtain additional information concerning the error condition, use NI_Scope_GetError and NI_Scope_ClearError. The general meaning of the status code is as:\n\n\u00b7 0: success\n\n\u00b7 Positive value: warning\n\n\u00b7 Negative value: errors\n\n\n\n\n\nExample:\n\nacquisitionType = New(\"String\", \"normal\");\n\n$ErrorCode = NI_Scope_ConfigureAcquisition($NI_ScopeHandle, $acquisitionType);\n\n\n\n\n\nNI_Scope_AdjustSampleClockRelativeDelay\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_Scope_AdjustSampleClockRelativeDelay": {
  "prefix": "NI_Scope_AdjustSampleClockRelativeDelay",
  "body": [
   "$$ErrorCode=NI_Scope_AdjustSampleClockRelativeDelay($$NI_ScopeHandle,$$Delay);"
  ],
  "description": "\n\nThis function requires NI Scope drivers to be installed on the system.\n\nThis function configures the relative sample clock delay (in seconds) when using the internal clock. Each time this function is called, the sample clock is delayed by the specified amount of time.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PCI-5122 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Scope functions, Jabil Test will fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\n$ErrorCode = NI_Scope_AdjustSampleClockRelativeDelay($NI_ScopeHandle, $Delay);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_ScopeHandle\n\nObject\n\nThe instrument handle you obtain from NI_Scope_Initialize that identifies a particular instrument's session.\n\n\n\n$Delay\n\nFloat\n\nThe amount of time in seconds to delay the sample clock. This is a relative value, so repeated calls to this function delays the sample clock by this amount every time.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\nInteger\n\nReports the status of this operation. To obtain a text description of the status code, call NI_Scope_ErrorMessage. To obtain additional information concerning the error condition, use NI_Scope_GetError and NI_Scope_ClearError. The general meaning of the status code is as:\n\n\u00b7 0: success\n\n\u00b7 Positive value: warning\n\n\u00b7 Negative value: errors\n\n\n\n\n\nExample:\n\n$Delay = New(\"Float\", 0.0);\n\n\n\n\n\n$ErrorCode = NI_Scope_AdjustSampleClockRelativeDelay($NI_ScopeHandle, $Delay);\n\n\n\n\n\nNI_Scope_ConfigureClock\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_Scope_ConfigureClock": {
  "prefix": "NI_Scope_ConfigureClock",
  "body": [
   "$$ErrorCode=NI_Scope_ConfigureClock($$NI_ScopeHandle,$$InputClockSource,$$OutputClockSource,$$ClockSyncPulseSource,$$MasterEnabled);"
  ],
  "description": "\n\nThis function requires NI Scope drivers to be installed on the system.\n\nThis function configures the attributes for synchronizing the digitizer to a reference or sending the digitizer's reference clock output to be used as a synchronizing clock for other digitizers.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PCI-5122 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Scope functions, Jabil Test will fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\n$ErrorCode = NI_Scope_ConfigureClock($NI_ScopeHandle, $InputClockSource, $OutputClockSource, $ClockSyncPulseSource, $MasterEnabled);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_ScopeHandle\n\nObject\n\nThe instrument handle you obtain from NI_Scope_Initialize that identifies a particular instrument's session.\n\n\n\n$InputClockSource\n\nString\n\nSpecifies the input source for the reference clock to which the 100 MHz sample clock is phase-locked.\n\nPossible values:\n\n\u00b7 NO SOURCE\n\n\u00b7 RTSI CLOCK\n\n\u00b7 PFI 1\n\n\u00b7 PFI 2\n\n\u00b7 PXI CLOCK\n\n\u00b7 EXTERNAL\n\n\u00b7 CLOCK IN\n\n\n\n$OutputClockSource\n\nString\n\nSpecifies the output source for the reference clock to which another scope's sample clock can be phased-locked. Possible values:\n\n\u00b7 NO SOURCE\n\n\u00b7 RTSI CLOCK\n\n\u00b7 PFI 0\n\n\u00b7 PFI 1\n\n\u00b7 PFI 2\n\n\u00b7 RTSI 0\n\n\u00b7 RTSI 1\n\n\u00b7 RTSI 2\n\n\u00b7 RTSI 3\n\n\u00b7 RTSI 4\n\n\u00b7 RTSI 5\n\n\u00b7 RTSI 6\n\n\u00b7 CLOCK OUT\n\n\n\n$ClockSyncPulseSource\n\nString\n\nFor the NI 5102, specifies the line on which the sample clock is sent or received. For the NI 5112/5620/5621/5911, specifies the line on which the one time sync pulse is sent or received. This line should be the same for all devices to be synchronized. Possible values:\n\n\u00b7 NO SOURCE\n\n\u00b7 RTSI 0\n\n\u00b7 RTSI 1\n\n\u00b7 RTSI 2\n\n\u00b7 RTSI 3\n\n\u00b7 RTSI 4\n\n\u00b7 RTSI 5\n\n\u00b7 RTSI 6\n\n\u00b7 PFI 1\n\n\u00b7 PFI 2\n\n\n\n$MasterEnabled\n\nBoolean\n\nSpecifies whether you want the device to be a master or a slave. The master device is typically the originator of the trigger signal and clock sync pulse.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\nInteger\n\nReports the status of this operation. To obtain a text description of the status code, call NI_Scope_ErrorMessage. To obtain additional information concerning the error condition, use NI_Scope_GetError and NI_Scope_ClearError. The general meaning of the status code is as:\n\n\u00b7 0: success\n\n\u00b7 Positive value: warning\n\n\u00b7 Negative value: errors\n\n\n\n\n\nExample:\n\n$InputClockSource = New(\"String\", \"NO SOURCE\");\n\n$OutputClockSource = New(\"String\", \"NO SOURCE\");\n\n$ClockSyncPulseSource = New(\"String\", \"NO SOURCE\");\n\n$MasterEnabled = New(\"Boolean\", \"FALSE\");\n\n\n\n\n\n$ErrorCode = NI_Scope_ConfigureClock($NI_ScopeHandle, $InputClockSource, $OutputClockSource, $ClockSyncPulseSource, $MasterEnabled);\n\n\n\n\n\nNI_Scope_ConfigureTriggerOutput\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_Scope_ConfigureTriggerOutput": {
  "prefix": "NI_Scope_ConfigureTriggerOutput",
  "body": [
   "$$ErrorCode=NI_Scope_ConfigureTriggerOutput($$NI_ScopeHandle,$$triggerEvent,$$TriggerOutput);"
  ],
  "description": "\n\nThis function requires NI Scope drivers to be installed on the system.\n\nThis function configures the digitizer to generate a signal pulse that other digitizers can detect when configured for digital triggering.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PCI-5122 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Scope functions, Jabil Test will fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\n$ErrorCode = NI_Scope_ConfigureTriggerOutput($NI_ScopeHandle, $triggerEvent, $TriggerOutput);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_ScopeHandle\n\nObject\n\nThe instrument handle you obtain from NI_Scope_Initialize that identifies a particular instrument's session.\n\n\n\n$triggerEvent\n\nString\n\nSpecifies the condition in which this device generates a digital pulse. Possible values:\n\n\u00b7 NO EVENT\n\n\u00b7 START TRIGGER\n\n\u00b7 STOP TRIGGER\n\n\u00b7 END OF ACQUISITION\n\n\u00b7 END OF RECORD\n\n\n\n$TriggerOutput\n\nString\n\nSpecifies the hardware signal line on which the digital pulse is generated. Possible values:\n\n\u00b7 NONE\n\n\u00b7 RTSI 0\n\n\u00b7 RTSI 1\n\n\u00b7 RTSI 2\n\n\u00b7 RTSI 3\n\n\u00b7 RTSI 4\n\n\u00b7 RTSI 5\n\n\u00b7 RTSI 6\n\n\u00b7 PFI 0\n\n\u00b7 PFI 1\n\n\u00b7 PFI 2\n\n\u00b7 PXI STAR\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\nInteger\n\nReports the status of this operation. To obtain a text description of the status code, call NI_Scope_ErrorMessage. To obtain additional information concerning the error condition, use NI_Scope_GetError and NI_Scope_ClearError. The general meaning of the status code is as:\n\n\u00b7 0: success\n\n\u00b7 Positive value: warning\n\n\u00b7 Negative value: errors\n\n\n\n\n\nExample:\n\n$triggerEvent = New(\"String\", \"NO EVENT\");\n\n$TriggerOutput = New(\"String\", \"NONE\");\n\n\n\n$ErrorCode = NI_Scope_ConfigureTriggerOutput($NI_ScopeHandle, $triggerEvent, $TriggerOutput);\n\n\n\n\n\nNI_Scope_ExportSignal\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_Scope_ExportSignal": {
  "prefix": "NI_Scope_ExportSignal",
  "body": [
   "$$ErrorCode=NI_Scope_ExportSignal($$NI_ScopeHandle,$$signal,$$signalIdentifier,$$outputTerminal);"
  ],
  "description": "\n\nThis function requires NI Scope drivers to be installed on the system.\n\nThis function configures the digitizer to generate a signal that other devices can detect when configured for digital triggering or sharing clocks. The signal parameter specifies what condition causes the digitizer to generate the signal. The outputTerminal parameter specifies where to send the signal on the hardware.\n\nIn cases where multiple instances of a particular signal exist, use the parameter signalIdentifier to specify which instance to control. For normal signals, only one instance exists and you should leave this parameter set to the empty string. You can call this function multiple times and set each available line to a different signal.\n\nTo unprogram a specific line on device, call this function with the signal you no longer want to export and set outputTerminal to none.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PCI-5122 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Scope functions, Jabil Test will fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\n$ErrorCode = NI_Scope_ExportSignal($NI_ScopeHandle, $signal, $signalIdentifier, $outputTerminal);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_ScopeHandle\n\nObject\n\nThe instrument handle you obtain from NI_Scope_Initialize that identifies a particular instrument's session.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\nInteger\n\nReports the status of this operation. To obtain a text description of the status code, call NI_Scope_ErrorMessage. To obtain additional information concerning the error condition, use NI_Scope_GetError and NI_Scope_ClearError. The general meaning of the status code is as:\n\n\u00b7 0: success\n\n\u00b7 Positive value: warning\n\n\u00b7 Negative value: errors\n\n\n\n\n\nExample:\n\n$signal = New(\"String\", \"START TRIGGER\");\n\n$signalIdentifier = New(\"String\", \"test case\");\n\n$outputTerminal = New(\"String\", \"RTSI 0\");\n\n\n\n\n\n$ErrorCode = NI_Scope_ExportSignal($NI_ScopeHandle, $signal, $signalIdentifier, $outputTerminal);\n\n\n\n\n\nNI_Scope_ConfigureEdgeTriggerSource\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_Scope_ConfigureEdgeTriggerSource": {
  "prefix": "NI_Scope_ConfigureEdgeTriggerSource",
  "body": [
   "$$ErrorCode=NI_Scope_ConfigureEdgeTriggerSource($$NI_ScopeHandle,$$triggerSource,$$triggerLevel,$$triggerSlope);"
  ],
  "description": "\n\nThis function requires NI Scope drivers to be installed on the system.\n\nThis function sets the edge triggering attributes. An edge trigger occurs when the trigger signal specified with the source parameter passes through the voltage threshold specified with the level parameter and has the slope specified with the slope parameter.\n\nThis function affects instrument behavior only if the triggerType is edge trigger. Set the trigger type and trigger coupling before calling this function.\n\nIf the trigger source is one of the analog input channels, you must configure the vertical range, vertical offset, vertical coupling, probe attenuation, and the maximum input frequency before calling this function.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PCI-5122 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Scope functions, Jabil Test will fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\n$ErrorCode = NI_Scope_ConfigureEdgeTriggerSource($NI_ScopeHandle, $triggerSource, $triggerLevel, $triggerSlope);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_ScopeHandle\n\nObject\n\nThe instrument handle you obtain from NI_Scope_Initialize that identifies a particular instrument's session.\n\n\n\n$triggerSource\n\nString\n\nPass the source you want the instrument to monitor for a trigger.\n\n\n\n$triggerLevel\n\nDouble\n\nPass the voltage threshold you want the instrument to use for edge triggering. The digitizer triggers when the trigger signal passes through the threshold you specify with this parameter and has the slope you specify with the Slope parameter.\n\nUnits: volts\n\n\n\n$triggerSlope\n\nString\n\nSpecify whether you want a rising edge or a falling edge passing through the Trigger Level to trigger the instrument.\n\nPossible values:\n\n\u00b7 NEGATIVE\n\n\u00b7 POSITIVE\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\nInteger\n\nReports the status of this operation. To obtain a text description of the status code, call NI_Scope_ErrorMessage. To obtain additional information concerning the error condition, use NI_Scope_GetError and NI_Scope_ClearError. The general meaning of the status code is as:\n\n\u00b7 0: success\n\n\u00b7 Positive value: warning\n\n\u00b7 Negative value: errors\n\n\n\n\n\nExample:\n\n$triggerSource = New(\"String\", \"VAL_EXTERNAL\");\n\n$triggerLevel = New(\"Float\", -0.3);\n\n$triggerSlope = New(\"String\", \"negative\");\n\n$ErrorCode = NI_Scope_ConfigureEdgeTriggerSource($NI_ScopeHandle, $triggerSource, $triggerLevel, $triggerSlope);\n\n\n\n\n\nNI_Scope_ConfigureRefLevels\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_Scope_ConfigureRefLevels": {
  "prefix": "NI_Scope_ConfigureRefLevels",
  "body": [
   "$$ErrorCode=NI_Scope_ConfigureRefLevels($$NI_ScopeHandle,$$unit,$$low,$$mid,$$high);"
  ],
  "description": "\n\nThis function requires NI Scope drivers to be installed on the system.\n\nThis function configures the reference levels for all channels of the digitizer.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PCI-5122 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Scope functions, Jabil Test will fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\n$ErrorCode = NI_Scope_ConfigureRefLevels($NI_ScopeHandle, $unit, $low, $mid, $high);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_ScopeHandle\n\nObject\n\nThe instrument handle you obtain from NI_Scope_Initialize that identifies a particular instrument's session.\n\n\n\n$unit\n\nString\n\nSpecifies the units of the reference levels.\n\nPossible values:\n\n\u00b7 PERCENT\n\n\u00b7 VOLTAGE\n\n\n\n$low\n\nDouble\n\nPass the low reference you want the digitizer to use for waveform measurements.\n\n\n\n$mid\n\nDouble\n\nPass the mid reference you want the digitizer to use for waveform measurements.\n\n\n\n$high\n\nDouble\n\nPass the high reference you want the digitizer to use for waveform measurements.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\nInteger\n\nReports the status of this operation. To obtain a text description of the status code, call NI_Scope_ErrorMessage. To obtain additional information concerning the error condition, use NI_Scope_GetError and NI_Scope_ClearError. The general meaning of the status code is as:\n\n\u00b7 0: success\n\n\u00b7 Positive value: warning\n\n\u00b7 Negative value: errors\n\n\n\n\n\nExample:\n\n$unit = New(\"String\", \"PERCENT\");\n\n$low = New(\"Float\", 10.0);\n\n$mid = New(\"Float\", 20.0);\n\n$high = New(\"Float\", 30.0);\n\n$ErrorCode = NI_Scope_ConfigureRefLevels($NI_ScopeHandle, $unit, $low, $mid, $high);\n\n\n\n\n\nNI_Scope_ConfigureTVTriggerLineNumber\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_Scope_ConfigureTVTriggerLineNumber": {
  "prefix": "NI_Scope_ConfigureTVTriggerLineNumber",
  "body": [
   "$$ErrorCode=NI_Scope_ConfigureTVTriggerLineNumber($$NI_ScopeHandle,$$lineNumber);"
  ],
  "description": "\n\nThis function requires NI Scope drivers to be installed on the system.\n\nThis function configures the TV line upon which the instrument triggers. The line number is absolute and not relative to the field of the TV signal.\n\nThis function affects instrument behavior only if the trigger type is set to TV trigger and the TV trigger event is set to line number. Call NI_Scope_ConfigureTVTriggerSource to set the TV trigger event before calling this function.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PCI-5122 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Scope functions, Jabil Test will fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\n$ErrorCode = NI_Scope_ConfigureTVTriggerLineNumber($NI_ScopeHandle, $lineNumber);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_ScopeHandle\n\nObject\n\nThe instrument handle you obtain from NI_Scope_Initialize that identifies a particular instrument's session.\n\n\n\n$lineNumber\n\nInteger\n\nSpecify the line number of the signal you want to trigger off of. The valid ranges of the attribute depend on the signal format configured.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\nInteger\n\nReports the status of this operation. To obtain a text description of the status code, call NI_Scope_ErrorMessage. To obtain additional information concerning the error condition, use NI_Scope_GetError and NI_Scope_ClearError. The general meaning of the status code is as:\n\n\u00b7 0: success\n\n\u00b7 Positive value: warning\n\n\u00b7 Negative value: errors\n\n\n\n\n\nExample:\n\n$lineNumber = New(\"Integer\", 42);\n\n$ErrorCode = NI_Scope_ConfigureTVTriggerLineNumber($NI_ScopeHandle, $lineNumber);\n\n\n\n\n\nNI_Scope_ConfigureTVTriggerSource\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_Scope_ConfigureTVTriggerSource": {
  "prefix": "NI_Scope_ConfigureTVTriggerSource",
  "body": [
   "$$ErrorCode=NI_Scope_ConfigureTVTriggerSource($$NI_ScopeHandle,$$triggerSource,$$signalFormat,$$triggerEvent,$$polarity);"
  ],
  "description": "\n\nThis function requires NI Scope drivers to be installed on the system.\n\nConfigures the instrument for TV triggering. It configures the TV signal format, the event, and the signal polarity. Call the NI_Scope_ConfigureTrigger and NI_Scope_ConfigureTriggerCoupling functions to set the trigger type and trigger coupling before calling this function.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PCI-5122 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Scope functions, Jabil Test will fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\n$ErrorCode = NI_Scope_ConfigureTVTriggerSource($NI_ScopeHandle, $triggerSource, $signalFormat, $triggerEvent, $polarity);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_ScopeHandle\n\nObject\n\nThe instrument handle you obtain from NI_Scope_Initialize that identifies a particular instrument's session.\n\n\n\n$triggerSource\n\nString\n\nSpecifies the source the digitizer monitors for the trigger event. Trigger sources vary for each digitizer model. Valid values:\n\n\u00b7 0\n\n\u00b7 1\n\n\u00b7 VAL_EXTERNAL\n\n\n\n$signalFormat\n\nString\n\nSpecifies the Video/TV signal format. Possible values:\n\n\u00b7 NTSC\n\n\u00b7 PAL\n\n\u00b7 SECAM\n\n\u00b7 M_PAL\n\n\u00b7 480I_59_94_FIELDS_PER_SECOND\n\n\u00b7 480I_60_FIELDS_PER_SECOND\n\n\u00b7 480P_59_94_FRAMES_PER_SECOND\n\n\u00b7 480P_60_FRAMES_PER_SECOND\n\n\u00b7 576I_50_FIELDS_PER_SECOND\n\n\u00b7 576P_50_FRAMES_PER_SECOND\n\n\u00b7 720P_50_FRAMES_PER_SECOND\n\n\u00b7 720P_59_94_FRAMES_PER_SECOND\n\n\u00b7 720P_60_FRAMES_PER_SECOND\n\n\u00b7 1080I_50_FIELDS_PER_SECOND\n\n\u00b7 1080I_59_94_FIELDS_PER_SECOND\n\n\u00b7 1080I_60_FIELDS_PER_SECOND\n\n\u00b7 1080P_24_FRAMES_PER_SECOND\n\n\n\n$triggerEvent\n\nString\n\nVideo/TV event to trigger off of. Possible values:\n\n\u00b7 FIELD1\n\n\u00b7 FIELD2\n\n\u00b7 ANY FIELD\n\n\u00b7 ANY LINE\n\n\u00b7 LINE NUMBER\n\n\n\n$triggerPolarity\n\nString\n\nSpecifies the polarity of the video signal to trigger off of.\n\nPossible values:\n\n\u00b7 NEGATIVE\n\n\u00b7 POSITIVE\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\nInteger\n\nReports the status of this operation. To obtain a text description of the status code, call NI_Scope_ErrorMessage. To obtain additional information concerning the error condition, use NI_Scope_GetError and NI_Scope_ClearError. The general meaning of the status code is as:\n\n\u00b7 0: success\n\n\u00b7 Positive value: warning\n\n\u00b7 Negative value: errors\n\n\n\n\n\nExample:\n\n$triggerSource = New(\"String\", \"0\");\n\n$signalFormat = New(\"String\", \"pal\");\n\n$triggerEvent = New(\"String\", \"line number\");\n\n$polarity = New(\"String\", \"negative\");\n\n$ErrorCode = NI_Scope_ConfigureTVTriggerSource($NI_ScopeHandle, $triggerSource, $signalFormat, $triggerEvent, $polarity);\n\n\n\n\n\nNI_Scope_ConfigureTrigger\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_Scope_ConfigureTrigger": {
  "prefix": "NI_Scope_ConfigureTrigger",
  "body": [
   "$$ErrorCode=NI_Scope_ConfigureTrigger($$NI_ScopeHandle,$$triggerType,$$triggerHoldOff);"
  ],
  "description": "\n\nThis function requires NI Scope drivers to be installed on the system.\n\nThis function configures the common attributes of the trigger subsystem.\n\nWhen you use NI_Scope_ReadWaveform, the instrument waits for a trigger. You specify the type of trigger for which the instrument waits with the Trigger Type parameter.\n\nIf the instrument requires multiple waveform acquisitions to build a complete waveform, it waits for the length of time you specify with the holdoff parameter to elapse since the previous trigger. The instrument then waits for the next trigger.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PCI-5122 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Scope functions, Jabil Test will fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\n$ErrorCode = NI_Scope_ConfigureTrigger($NI_ScopeHandle, $triggerType, $triggerHoldOff);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_ScopeHandle\n\nObject\n\nThe instrument handle you obtain from NI_Scope_Initialize that identifies a particular instrument's session.\n\n\n\n$triggerType\n\nString\n\nSpecifies the type of trigger for which the digitizer waits. Possible values:\n\n\u00b7 TV\n\n\u00b7 EDGE\n\n\u00b7 IMMEDIATE\n\n\n\n$triggerHoldOff\n\nString\n\nSpecifies the trigger holdoff, which is the length of time that elapses before the digitizer waits for the next trigger.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\nInteger\n\nReports the status of this operation. To obtain a text description of the status code, call NI_Scope_ErrorMessage. To obtain additional information concerning the error condition, use NI_Scope_GetError and NI_Scope_ClearError. The general meaning of the status code is as:\n\n\u00b7 0: success\n\n\u00b7 Positive value: warning\n\n\u00b7 Negative value: errors\n\n\n\n\n\nExample:\n\n$triggerType = New(\"String\", \"IMMEDIATE\");\n\n$triggerHoldOff = New(\"Float\", 0.0);\n\n\n\n$ErrorCode = NI_Scope_ConfigureTrigger($NI_ScopeHandle, $triggerType, $triggerHoldOff);\n\n\n\n\n\nNI_Scope_ConfigureTriggerCoupling\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_Scope_ConfigureTriggerCoupling": {
  "prefix": "NI_Scope_ConfigureTriggerCoupling",
  "body": [
   "$$ErrorCode=NI_Scope_ConfigureTriggerCoupling($$NI_ScopeHandle,$$triggerCoupling);"
  ],
  "description": "\n\nThis function requires NI Scope drivers to be installed on the system.\n\nThis function sets the trigger coupling attribute.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PCI-5122 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Scope functions, Jabil Test will fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\n$ErrorCode = NI_Scope_ConfigureTriggerCoupling($NI_ScopeHandle, $triggerCoupling);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_ScopeHandle\n\nObject\n\nThe instrument handle you obtain from NI_Scope_Initialize that identifies a particular instrument's session.\n\n\n\n$triggerCoupling\n\nInteger\n\nSpecifies how you want the digitizer to couple the trigger signal.\n\nPossible values:\n\n\u00b7 AC\n\n\u00b7 DC\n\n\u00b7 HF REJECT\n\n\u00b7 LF REJECT\n\nAC PLUS HF REJECT\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\nInteger\n\nReports the status of this operation. To obtain a text description of the status code, call NI_Scope_ErrorMessage. To obtain additional information concerning the error condition, use NI_Scope_GetError and NI_Scope_ClearError. The general meaning of the status code is as:\n\n\u00b7 0: success\n\n\u00b7 Positive value: warning\n\n\u00b7 Negative value: errors\n\n\n\n\n\nExample:\n\n$triggerCoupling = New(\"String\", \"dc\");\n\n$ErrorCode = NI_Scope_ConfigureTriggerCoupling($NI_ScopeHandle, $triggerCoupling);\n\n\n\n\n\nNI_Scope_ConfigureTriggerDigital\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_Scope_ConfigureTriggerDigital": {
  "prefix": "NI_Scope_ConfigureTriggerDigital",
  "body": [
   "$$ErrorCode=NI_Scope_ConfigureTriggerDigital($$NI_ScopeHandle,$$triggerSource,$$triggerPolarity,$$triggerHoldOff,$$triggerDelay);"
  ],
  "description": "\n\nThis function requires NI Scope drivers to be installed on the system.\n\nA digital trigger occurs on either a rising edge or falling edge of a digital signal. Digital triggering is possible on the RTSI lines, PFI lines, and the PXI Star Trigger line.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PCI-5122 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Scope functions, Jabil Test will fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\n$ErrorCode = NI_Scope_ConfigureTriggerDigital($NI_ScopeHandle, $triggerSource, $triggerLevel, $triggerPolarity, $triggerCoupling, $triggerHoldOff, $triggerDelay);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_ScopeHandle\n\nObject\n\nThe instrument handle you obtain from NI_Scope_Initialize that identifies a particular instrument's session.\n\n\n\n$triggerSource\n\nString\n\nSpecifies the source the digitizer monitors for the trigger event. Trigger sources vary for each digitizer model. Valid values:\n\n\u00b7 0\n\n\u00b7 1\n\n\u00b7 VAL_IMMEDIATE\n\n\u00b7 VAL_EXTERNAL\n\n\u00b7 VAL_SW_TRIG_FUNC\n\n\u00b7 VAL_RTSI_0\n\n\u00b7 VAL_RTSI_1\n\n\u00b7 VAL_RTSI_2\n\n\u00b7 VAL_RTSI_3\n\n\u00b7 VAL_RTSI_4\n\n\u00b7 VAL_RTSI_5\n\n\u00b7 VAL_RTSI_6\n\n\u00b7 VAL_PFI_0\n\n\u00b7 VAL_PFI_1\n\n\u00b7 VAL_PFI_2\n\n\u00b7 VAL_PXI_STAR\n\n\n\n$triggerPolarity\n\nString\n\nSpecifies the polarity of the video signal sync. Possible values:\n\n\u00b7 NEGATIVE\n\n\u00b7 POSITIVE\n\n\n\n$triggerHoldOff\n\nDouble\n\nSpecifies the length of time (in seconds) the digitizer waits after detecting a trigger before enabling the trigger subsystem to detect another trigger. This attribute affects instrument operation only when the digitizer requires multiple acquisitions to build a complete waveform. The digitizer requires multiple waveform acquisitions when it uses equivalent-time sampling or when the digitizer is configured for a multirecord acquisition through a call to NI_Scope_ConfigureHorizontalTiming.\n\nUnit : Seconds.\n\nValid range : 0.0 \u2013 171.8\n\n\n\n$triggerDelay\n\nDouble\n\nSpecifies the trigger delay time in seconds. The trigger delay time is the length of time the digitizer waits after receiving the trigger. The event that occurs when the trigger delay elapses is the Reference Event.\n\nUnit : Seconds.\n\nValid range : 0.0 \u2013 171.8\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\nInteger\n\nReports the status of this operation. To obtain a text description of the status code, call NI_Scope_ErrorMessage. To obtain additional information concerning the error condition, use NI_Scope_GetError and NI_Scope_ClearError. The general meaning of the status code is as:\n\n\u00b7 0: success\n\n\u00b7 Positive value: warning\n\n\u00b7 Negative value: errors\n\n\n\n\n\nExample:\n\n$triggerSource = New(\"String\", \"0\");\n\n$triggerPolarity = New(\"String\", \"negative\");\n\n$triggerHoldOff = New(\"Float\", 0.0);\n\n$triggerDelay = New(\"Float\", 0.0);\n\n\n\n\n\n$ErrorCode = NI_Scope_ConfigureTriggerDigital($NI_ScopeHandle, $triggerSource, $triggerPolarity, $triggerHoldOff, $triggerDelay);\n\n\n\n\n\nNI_Scope_ConfigureTriggerEdge\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_Scope_ConfigureTriggerEdge": {
  "prefix": "NI_Scope_ConfigureTriggerEdge",
  "body": [
   "$$ErrorCode=NI_Scope_ConfigureTriggerEdge($$NI_ScopeHandle,$$triggerSource,$$triggerLevel,$$triggerPolarity,$$triggerCoupling,$$triggerHoldOff,$$triggerDelay);"
  ],
  "description": "\n\nThis function requires NI Scope drivers to be installed on the system.\n\nAn edge trigger occurs when a signal crosses a trigger threshold that you specify. You can specify the slope as either positive (on the rising edge) or negative (on the falling edge) to the trigger. Edge triggering is possible on all analog trigger channels, such as 0, 1, or the external trigger channel.\n\n\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PCI-5122 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Scope functions, Jabil Test will fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\n$ErrorCode = NI_Scope_ConfigureTriggerEdge($NI_ScopeHandle, $triggerSource, $triggerLevel, $triggerPolarity, $triggerCoupling, $triggerHoldOff, $triggerDelay);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_ScopeHandle\n\nObject\n\nThe instrument handle you obtain from NI_Scope_Initialize that identifies a particular instrument's session.\n\n\n\n$triggerSource\n\nString\n\nThe trigger source. Valid trigger sources vary depending on your digitizer. Possible values:\n\n\u00b7 0\n\n\u00b7 1\n\n\u00b7 VAL_IMMEDIATE\n\n\u00b7 VAL_EXTERNAL\n\n\u00b7 VAL_SW_TRIG_FUNC\n\n\u00b7 VAL_RTSI_0\n\n\u00b7 VAL_RTSI_1\n\n\u00b7 VAL_RTSI_2\n\n\u00b7 VAL_RTSI_3\n\n\u00b7 VAL_RTSI_4\n\n\u00b7 VAL_RTSI_5\n\n\u00b7 VAL_RTSI_6\n\n\u00b7 VAL_PFI_0\n\n\u00b7 VAL_PFI_1\n\n\u00b7 VAL_PFI_2\n\n\u00b7 VAL_PXI_STAR\n\n\n\n$triggerLevel\n\nDouble\n\nThe voltage threshold for the trigger.\n\n\n\n$triggerPolarity\n\nString\n\nSpecifies whether you want a rising edge or a falling edge to trigger. Possible values:\n\n\u00b7 NEGATIVE\n\n\u00b7 POSITIVE\n\n\n\n$triggerCoupling\n\nString\n\nSpecifies how you want the digitizer to couple the trigger signal. Possible values:\n\n\u00b7 AC\n\n\u00b7 DC\n\n\u00b7 HF REJECT\n\n\u00b7 LF REJECT\n\n\u00b7 AC PLUS HF REJECT\n\n\n\n$triggerHoldOff\n\nDouble\n\nSpecifies the length of time the digitizer waits after detecting a trigger before enabling NI-SCOPE to detect another trigger. Use the trigger holdoff to skip a specific number of frames between acquisitions. For example, to acquire a specific line number multiple times and repeat the same chroma phase, skip 1 frame in M-NTSC (35 ms < holdoff < 60 ms), 3 frames in PAL (121 ms < holdoff < 159 ms) and 5 frames in SECAM (201 ms < holdoff < 239 ms).\n\n\n\n$triggerDelay\n\nDouble\n\nSpecifies how long the digitizer waits after receiving the trigger to start acquiring data.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\nInteger\n\nReports the status of this operation. To obtain a text description of the status code, call NI_Scope_ErrorMessage. To obtain additional information concerning the error condition, use NI_Scope_GetError and NI_Scope_ClearError. The general meaning of the status code is as:\n\n\u00b7 0: success\n\n\u00b7 Positive value: warning\n\n\u00b7 Negative value: errors\n\n\n\n\n\nExample:\n\n$triggerSource = New(\"String\", \"0\");\n\n$triggerLevel = New(\"Float\", -0.3);\n\n$triggerPolarity = New(\"String\", \"negative\");\n\n$triggerCoupling = New(\"String\", \"dc\");\n\n$triggerHoldOff = New(\"Float\", 0.0);\n\n$triggerDelay = New(\"Float\", 0.0);\n\n\n\n$ErrorCode = NI_Scope_ConfigureTriggerEdge($NI_ScopeHandle, $triggerSource, $triggerLevel, $triggerPolarity, $triggerCoupling, $triggerHoldOff, $triggerDelay);\n\n\n\n\n\nNI_Scope_ConfigureTriggerHysteresis\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_Scope_ConfigureTriggerHysteresis": {
  "prefix": "NI_Scope_ConfigureTriggerHysteresis",
  "body": [
   "$$ErrorCode=NI_Scope_ConfigureTriggerHysteresis($$NI_ScopeHandle,$$triggerSource,$$level,$$hysteresisLevel,$$triggerSlope,$$triggerCoupling,$$triggerHoldOff,$$triggerDelay);"
  ],
  "description": "\n\nThis function requires NI Scope drivers to be installed on the system.\n\nConfigures common properties for analog hysteresis triggering. This kind of trigger specifies an additional value, specified in the hysteresis parameter, that a signal must pass through before a trigger can occur. This additional value acts as a kind of buffer zone that keeps noise from triggering an acquisition.\n\nHysteresis triggers eliminate incorrect triggers caused by noisy signals. For example, if your signal contains two rising edges of different amplitudes, you can use hysteresis triggering to trigger on one of the edges. Although NI-SCOPE uses a default amount of hysteresis for edge triggering, which is typically 2.5% of the vertical range, you can override that value by setting your own hysteresis values. The Configure Trigger Hysteresis function or VI allows you to choose the trigger coupling, trigger level, hysteresis value, and trigger slope.\n\nHysteresis triggering is possible on all analog trigger channels, such as 0, 1, or the external trigger input.\n\n\n\nA positive slope hysteresis trigger is generated when the signal crosses below the voltage specified by the trigger level parameter minus the hysteresis value, and then crosses the trigger level.\n\n\n\n\n\nA negative slope hysteresis trigger is generated when a signal crosses above the voltage specified by the trigger level parameter plus the hysteresis value, and then crosses the trigger level.\n\n\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PCI-5122 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Scope functions, Jabil Test will fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\n$ErrorCode = NI_Scope_ConfigureTriggerHysteresis($NI_ScopeHandle, $triggerSource, $level, $hysteresisLevel, $triggerSlope, $triggerCoupling, $triggerHoldOff, $triggerDelay);\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_ScopeHandle\n\nObject\n\nThe instrument handle you obtain from NI_Scope_Initialize that identifies a particular instrument's session.\n\n\n\n$triggerSource\n\nString\n\nThe trigger source. Valid trigger sources vary depending on your digitizer. Possible values:\n\n\u00b7 0\n\n\u00b7 1\n\n\u00b7 VAL_IMMEDIATE\n\n\u00b7 VAL_EXTERNAL\n\n\u00b7 VAL_SW_TRIG_FUNC\n\n\u00b7 VAL_RTSI_0\n\n\u00b7 VAL_RTSI_1\n\n\u00b7 VAL_RTSI_2\n\n\u00b7 VAL_RTSI_3\n\n\u00b7 VAL_RTSI_4\n\n\u00b7 VAL_RTSI_5\n\n\u00b7 VAL_RTSI_6\n\n\u00b7 VAL_PFI_0\n\n\u00b7 VAL_PFI_1\n\n\u00b7 VAL_PFI_2\n\n\u00b7 VAL_PXI_STAR\n\n\n\n$level\n\nDouble\n\nThe voltage threshold for the trigger.\n\n\n\n$hysteresisLevel\n\nDouble\n\nThe size of the hysteresis window on either side of the level in volts. The digitizer triggers when the trigger signal passes through the hysteresis value you specify with this parameter, has the slope you specify with slope, and passes through the level.\n\n\n\n$triggerSlope\n\nString\n\nSpecifies the polarity of the video signal sync. Possible values:\n\n\u00b7 NEGATIVE\n\n\u00b7 POSITIVE\n\n\n\n$triggerCoupling\n\nString\n\nSpecifies how you want the digitizer to couple the trigger signal. Possible values:\n\n\u00b7 AC\n\n\u00b7 DC\n\n\u00b7 HF REJECT\n\n\u00b7 LF REJECT\n\n\u00b7 AC PLUS HF REJECT\n\n\n\n$triggerHoldOff\n\nDouble\n\nSpecifies the length of time the digitizer waits after detecting a trigger before enabling NI-SCOPE to detect another trigger. Use the trigger hold off to skip a specific number of frames between acquisitions. For example, to acquire a specific line number multiple times and repeat the same chroma phase, skip 1 frame in M-NTSC (35 ms < holdoff < 60 ms), 3 frames in PAL (121 ms < holdoff < 159 ms) and 5 frames in SECAM (201 ms < holdoff < 239 ms).\n\n\n\n$triggerDelay\n\nDouble\n\nSpecifies how long the digitizer waits after receiving the trigger to start acquiring data.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\nInteger\n\nReports the status of this operation. To obtain a text description of the status code, call NI_Scope_ErrorMessage. To obtain additional information concerning the error condition, use NI_Scope_GetError and NI_Scope_ClearError. The general meaning of the status code is as:\n\n\u00b7 0: success\n\n\u00b7 Positive value: warning\n\n\u00b7 Negative value: errors\n\n\n\n\n\nExample:\n\n$triggerSource = New(\"String\", \"0\");\n\n$level = New(\"Float\", -0.3);\n\n$hysteresisLevel = New(\"Float\", 0.3);\n\n$triggerSlope= New(\"String\", \"negative\");\n\n$triggerCoupling = New(\"String\", \"ac\");\n\n$triggerHoldOff = New(\"Float\", 0.0);\n\n$triggerDelay = New(\"Float\", 0.0);\n\n$ErrorCode = NI_Scope_ConfigureTriggerHysteresis($NI_ScopeHandle, $triggerSource, $level, $hysteresisLevel, $triggerSlope, $triggerCoupling, $triggerHoldOff, $triggerDelay);\n\n\n\n\n\nNI_Scope_ConfigureTriggerImmediate\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_Scope_ConfigureTriggerImmediate": {
  "prefix": "NI_Scope_ConfigureTriggerImmediate",
  "body": [
   "$$ErrorCode=NI_Scope_ConfigureTriggerImmediate($$NI_ScopeHandle);"
  ],
  "description": "\n\nThis function requires NI Scope drivers to be installed on the system.\n\n\n\nThis function configures common properties for immediate triggering. Immediate triggering means the digitizer triggers itself. There is no external signal that triggers the acquisition. The acquisition simply begins immediately after being configured by the driver software.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PCI-5122 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Scope functions, Jabil Test will fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\n$ErrorCode = NI_Scope_ConfigureTriggerImmediate($NI_ScopeHandle);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_ScopeHandle\n\nObject\n\nThe instrument handle you obtain from NI_Scope_Initialize that identifies a particular instrument's session.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\nInteger\n\nReports the status of this operation. To obtain a text description of the status code, call NI_Scope_ErrorMessage. To obtain additional information concerning the error condition, use NI_Scope_GetError and NI_Scope_ClearError. The general meaning of the status code is as:\n\n\u00b7 0: success\n\n\u00b7 Positive value: warning\n\n\u00b7 Negative value: errors\n\n\n\n\n\nExample:\n\n$ErrorCode = NI_Scope_ConfigureTriggerImmediate($NI_ScopeHandle);\n\n\n\n\n\nNI_Scope_ConfigureTriggerSoftware\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_Scope_ConfigureTriggerSoftware": {
  "prefix": "NI_Scope_ConfigureTriggerSoftware",
  "body": [
   "$$ErrorCode=NI_Scope_ConfigureTriggerSoftware($$NI_ScopeHandle,$$triggerHoldOff,$$triggerDelay);"
  ],
  "description": "\n\nThis function requires NI Scope drivers to be installed on the system.\n\nThis function configures common properties for software triggering.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PCI-5122 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Scope functions, Jabil Test will fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\nResult:\n\n$ErrorCode = NI_Scope_ConfigureTriggerSoftware($NI_ScopeHandle, $triggerHoldOff, $triggerDelay);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_ScopeHandle\n\nObject\n\nThe instrument handle you obtain from NI_Scope_Initialize that identifies a particular instrument's session.\n\n\n\n$triggerHoldOff\n\nDouble\n\nSpecifies the length of time (in seconds) the digitizer waits after detecting a trigger before enabling the trigger subsystem to detect another trigger. This attribute affects instrument operation only when the digitizer requires multiple acquisitions to build a complete waveform. The digitizer requires multiple waveform acquisitions when it uses equivalent-time sampling or when the digitizer is configured for a multirecord acquisition through a call to NI_Scope_ConfigureHorizontalTiming.\n\nUnit : Seconds.\n\n\n\n$triggerDelay\n\nDouble\n\nSpecifies the trigger delay time in seconds. The trigger delay time is the length of time the digitizer waits after receiving the trigger. The event that occurs when the trigger delay elapses is the Reference Event.\n\nUnit : Seconds.\n\nValid range : 0.0 \u2013 171.8\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\nInteger\n\nReports the status of this operation. To obtain a text description of the status code, call NI_Scope_ErrorMessage. To obtain additional information concerning the error condition, use NI_Scope_GetError and NI_Scope_ClearError. The general meaning of the status code is as:\n\n\u00b7 0: success\n\n\u00b7 Positive value: warning\n\n\u00b7 Negative value: errors\n\n\n\n\n\nExample:\n\n$triggerHoldOff = New(\"Float\", 0.0);\n\n$triggerDelay = New(\"Float\", 0.0);\n\n$ErrorCode = NI_Scope_ConfigureTriggerSoftware($NI_ScopeHandle, $triggerHoldOff, $triggerDelay);\n\n\n\n\n\nNI_Scope_ConfigureTriggerVideo\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_Scope_ConfigureTriggerVideo": {
  "prefix": "NI_Scope_ConfigureTriggerVideo",
  "body": [
   "$$ErrorCode=NI_Scope_ConfigureTriggerVideo($$NI_ScopeHandle,$$triggerSource,$$enableDCRestore,$$signalFormat,$$triggerEvent,$$lineNumber,$$triggerPolarity,$$triggerCoupling,$$triggerHoldOff,$$triggerDelay);"
  ],
  "description": "\n\nThis function requires NI Scope drivers to be installed on the system.\n\nConfigures the common properties for video triggering, including the signal format, TV event, line number, polarity, and enable DC restore. A video trigger occurs when the digitizer finds a valid video signal sync.\n\n\n\nThe NI 5122/5124 includes a mode for triggering on NTSC, PAL, and SECAM format video signals. The NI 5122/5124 supports triggering on any line, a specific line number, or a specific field. The NI 5122/5124 supports negative trigger polarity in video mode, which means that the synchronization pulses must go to a negative voltage with respect to the back porch level. Using a vertical range that is too high may cause the digitizer to not trigger correctly on the video signal. NI 5122/5124 digitizers support DC restoration, which adjusts the back porch level of the video signal to 0 V. DC restore is performed on the digital data, rather than with an analog clamping circuit. When using DC restore, set the input voltage range to approximately twice the expected signal amplitude to prevent signal clipping as the amplitude and offset of the video signal change. DC restore measures the voltage of the back porch during the interval between the end of the color burst and before the start of the active line, then subtracts this value from the signal for the remainder of the active video line. Excess noise on the back porch portion of the video signal may cause inconsistent level restoration between lines.\n\n\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PCI-5122 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Scope functions, Jabil Test will fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\n$ErrorCode = NI_Scope_ConfigureTriggerVideo($NI_ScopeHandle, $triggerSource, $enableDCRestore, $signalFormat, $triggerEvent, $lineNumber, $triggerPolarity, $triggerCoupling, $triggerHoldOff, $triggerDelay);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_ScopeHandle\n\nObject\n\nThe instrument handle you obtain from NI_Scope_Initialize that identifies a particular instrument's session.\n\n\n\n$triggerSource\n\nString\n\nThe trigger source. Valid trigger sources vary depending on your digitizer. Possible values:\n\n\u00b7 \"0\"\n\n\u00b7 \"1\"\n\n\u00b7 \"VAL_IMMEDIATE\"\n\n\u00b7 \"VAL_EXTERNAL\"\n\n\u00b7 \"VAL_SW_TRIG_FUNC\"\n\n\u00b7 \"VAL_RTSI_0\"\n\n\u00b7 \"VAL_RTSI_1\"\n\n\u00b7 \"VAL_RTSI_2\"\n\n\u00b7 \"VAL_RTSI_3\"\n\n\u00b7 \"VAL_RTSI_4\"\n\n\u00b7 \"VAL_RTSI_5\"\n\n\u00b7 \"VAL_RTSI_6\"\n\n\u00b7 \"VAL_PFI_0\"\n\n\u00b7 \"VAL_PFI_1\"\n\n\u00b7 \"VAL_PFI_2\"\n\n\u00b7 \"VAL_PXI_STAR\"\n\n\n\n$enableDCRestore\n\nBoolean\n\nOffsets each video line so the clamping level (the portion of the video line between the end of the color burst and the beginning of the active image) is moved to zero volt.\n\n\n\n$signalFormat\n\nString\n\nSpecifies the type of video signal sync the digitizer should look for. Possible values:\n\n\u00b7 NTSC\n\n\u00b7 PAL\n\n\u00b7 SECAM\n\n\u00b7 M_PAL\n\n\u00b7 480I_59_94_FIELDS_PER_SECOND\n\n\u00b7 480I_60_FIELDS_PER_SECOND\n\n\u00b7 480P_59_94_FRAMES_PER_SECOND\n\n\u00b7 480P_60_FRAMES_PER_SECOND\n\n\u00b7 576I_50_FIELDS_PER_SECOND\n\n\u00b7 576P_50_FRAMES_PER_SECOND\n\n\u00b7 720P_50_FRAMES_PER_SECOND\n\n\u00b7 720P_59_94_FRAMES_PER_SECOND\n\n\u00b7 720P_60_FRAMES_PER_SECOND\n\n\u00b7 1080I_50_FIELDS_PER_SECOND\n\n\u00b7 1080I_59_94_FIELDS_PER_SECOND\n\n\u00b7 1080I_60_FIELDS_PER_SECOND\n\n\u00b7 1080P_24_FRAMES_PER_SECOND\n\n\n\n$triggerEvent\n\nString\n\nSpecifies the TV event you want to trigger on. You can trigger on a specific or on the next coming line or field of the signal. Possible values:\n\n\u00b7 FIELD1\n\n\u00b7 FIELD2\n\n\u00b7 ANY FIELD\n\n\u00b7 ANY LINE\n\n\u00b7 LINE NUMBER\n\n\n\n$lineNumber\n\nDouble\n\nSelects the line number to trigger on. The line number range covers an entire frame.\n\n\n\n$triggerPolarity\n\nString\n\nSpecifies the polarity of the video signal sync. Possible values:\n\n\u00b7 NEGATIVE\n\n\u00b7 POSITIVE\n\n\n\n$triggerCoupling\n\nString\n\nSpecifies how you want the digitizer to couple the trigger signal. Possible values:\n\n\u00b7 AC\n\n\u00b7 DC\n\n\u00b7 HF REJECT\n\n\u00b7 LF REJECT\n\n\u00b7 AC PLUS HF REJECT\n\n\n\n$triggerHoldOff\n\nDouble\n\nSpecifies the length of time the digitizer waits after detecting a trigger before enabling NI-SCOPE to detect another trigger. Use the trigger holdoff to skip a specific number of frames between acquisitions. For example, to acquire a specific line number multiple times and repeat the same chroma phase, skip 1 frame in M-NTSC (35 ms < holdoff < 60 ms), 3 frames in PAL (121 ms < holdoff < 159 ms) and 5 frames in SECAM (201 ms < holdoff < 239 ms).\n\n\n\n$triggerDelay\n\nDouble\n\nSpecifies how long the digitizer waits after receiving the trigger to start acquiring data.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\nInteger\n\nReports the status of this operation. To obtain a text description of the status code, call NI_Scope_ErrorMessage. To obtain additional information concerning the error condition, use NI_Scope_GetError and NI_Scope_ClearError. The general meaning of the status code is as:\n\n\u00b7 0: success\n\n\u00b7 Positive value: warning\n\n\u00b7 Negative value: errors\n\n\n\n\n\nExample:\n\n$triggerSource = New(\"String\", \"0\");\n\n$enableDCRestore = New(\"Boolean\", \"TRUE\");\n\n$signalFormat = New(\"String\", \"pal\");\n\n$triggerEvent = New(\"String\", \"line number\");\n\n$lineNumber = New(\"Integer\", 25);\n\n$triggerPolarity = New(\"String\", \"negative\");\n\n$triggerCoupling = New(\"String\", \"dc\");\n\n$triggerHoldOff = New(\"Float\", 0.0);\n\n$triggerDelay = New(\"Float\", 0.0);\n\n$ErrorCode = NI_Scope_ConfigureTriggerVideo($NI_ScopeHandle, $triggerSource, $enableDCRestore, $signalFormat, $triggerEvent, $lineNumber, $triggerPolarity, $triggerCoupling, $triggerHoldOff, $triggerDelay);\n\n\n\n\n\nNI_Scope_ConfigureTriggerWindow\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_Scope_ConfigureTriggerWindow": {
  "prefix": "NI_Scope_ConfigureTriggerWindow",
  "body": [
   "$$ErrorCode=NI_Scope_ConfigureTriggerWindow($$NI_ScopeHandle,$$triggerSource,$$lowLevel,$$highLevel,$$windowMode,$$triggerCoupling,$$triggerHoldOff,$$triggerDelay);"
  ],
  "description": "\n\nThis function requires NI Scope drivers to be installed on the system.\n\nA window trigger occurs when a signal either enters or leaves a window you specify with the window mode parameters in the function. Window triggering is possible on all analog trigger channels, such as 0, 1, or the external trigger input.\n\nConfigures common properties for analog window triggering. A window trigger occurs when a signal enters or leaves a window you specify with the high level or low level parameters.\n\nThe following figure shows an entering window trigger.\n\n\n\n\n\nThe following figure shows a leaving window trigger.\n\n\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PCI-5122 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Scope functions, Jabil Test will fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\n$ErrorCode = NI_Scope_ConfigureTriggerWindow($NI_ScopeHandle, $triggerSource, $lowLevel, $highLevel, $windowMode, $triggerCoupling, $triggerHoldOff, $triggerDelay);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_ScopeHandle\n\nObject\n\nThe instrument handle you obtain from NI_Scope_Initialize that identifies a particular instrument's session.\n\n\n\n$triggerSource\n\nString\n\nThe trigger source. Valid trigger sources vary depending on your digitizer. Possible values:\n\n\u00b7 0\n\n\u00b7 1\n\n\u00b7 VAL_IMMEDIATE\n\n\u00b7 VAL_EXTERNAL\n\n\u00b7 VAL_SW_TRIG_FUNC\n\n\u00b7 VAL_RTSI_0\n\n\u00b7 VAL_RTSI_1\n\n\u00b7 VAL_RTSI_2\n\n\u00b7 VAL_RTSI_3\n\n\u00b7 VAL_RTSI_4\n\n\u00b7 VAL_RTSI_5\n\n\u00b7 VAL_RTSI_6\n\n\u00b7 VAL_PFI_0\n\n\u00b7 VAL_PFI_1\n\n\u00b7 VAL_PFI_2\n\n\u00b7 VAL_PXI_STAR\n\n\n\n$lowWindowLevel\n\nDouble\n\nPasses the voltage threshold you want the digitizer to use for low triggering.\n\n\n\n$highWindowLevel\n\nDouble\n\nPasses the voltage threshold you want the digitizer to use for high triggering.\n\n\n\n$windowMode\n\nString\n\nSpecifies whether you want the trigger to occur when the signal enters or leaves a window. Possible values:\n\n\u00b7 \"ENTERING WINDOW\"\n\n\u00b7 \"LEAVING WINDOW\"\n\n\n\n$triggerCoupling\n\nString\n\nSpecifies how you want the digitizer to couple the trigger signal. Possible values:\n\n\u00b7 AC\n\n\u00b7 DC\n\n\u00b7 HF REJECT\n\n\u00b7 LF REJECT\n\n\u00b7 AC PLUS HF REJECT\n\n\n\n$triggerHoldOff\n\nDouble\n\nSpecifies the length of time the digitizer waits after detecting a trigger before enabling NI-SCOPE to detect another trigger. Use the trigger hold off to skip a specific number of frames between acquisitions. For example, to acquire a specific line number multiple times and repeat the same chroma phase, skip 1 frame in M-NTSC (35 ms < holdoff < 60 ms), 3 frames in PAL (121 ms < holdoff < 159 ms) and 5 frames in SECAM (201 ms < holdoff < 239 ms).\n\n\n\n$triggerDelay\n\nDouble\n\nSpecifies how long the digitizer waits after receiving the trigger to start acquiring data.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\nInteger\n\nReports the status of this operation. To obtain a text description of the status code, call NI_Scope_ErrorMessage. To obtain additional information concerning the error condition, use NI_Scope_GetError and NI_Scope_ClearError. The general meaning of the status code is as:\n\n\u00b7 0: success\n\n\u00b7 Positive value: warning\n\n\u00b7 Negative value: errors\n\n\n\n\n\nExample:\n\n$triggerSource = New(\"String\", \"0\");\n\n$lowLevel = New(\"Float\", -0.3);\n\n$highLevel = New(\"Float\", 0.2);\n\n$windowMode = New(\"String\", \"entering window\");\n\n$triggerCoupling = New(\"String\", \"ac\");\n\n$triggerHoldOff = New(\"Float\", 0.0);\n\n$triggerDelay = New(\"Float\", 0.0);\n\n$ErrorCode = NI_Scope_ConfigureTriggerWindow($NI_ScopeHandle, $triggerSource, $lowLevel, $highLevel, $windowMode, $triggerCoupling, $triggerHoldOff, $triggerDelay);\n\n\n\n\n\nNI_Scope_SendSWTrigger\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_Scope_SendSWTrigger": {
  "prefix": "NI_Scope_SendSWTrigger",
  "body": [
   "$$ErrorCode=NI_Scope_SendSWTrigger($$NI_ScopeHandle);"
  ],
  "description": "\n\nThis function requires NI Scope drivers to be installed on the system.\n\nSends a command to trigger the digitizer. Call this function after you call NI_Scope_ConfigureTriggerSoftware.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PCI-5122 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Scope functions, Jabil Test will fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\n$ErrorCode = NI_Scope_SendSWTrigger($NI_ScopeHandle);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_ScopeHandle\n\nObject\n\nThe instrument handle you obtain from NI_Scope_Initialize that identifies a particular instrument's session.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\nInteger\n\nReports the status of this operation. To obtain a text description of the status code, call NI_Scope_ErrorMessage. To obtain additional information concerning the error condition, use NI_Scope_GetError and NI_Scope_ClearError. The general meaning of the status code is as:\n\n\u00b7 0: success\n\n\u00b7 Positive value: warning\n\n\u00b7 Negative value: errors\n\n\n\n\n\nExample:\n\n$ErrorCode = NI_Scope_SendSWTrigger($NI_ScopeHandle);\n\n\n\n\n\nNI_Scope_SendSoftwareTriggerEdge\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_Scope_SendSoftwareTriggerEdge": {
  "prefix": "NI_Scope_SendSoftwareTriggerEdge",
  "body": [
   "$$ErrorCode=NI_Scope_SendSoftwareTriggerEdge($$NI_ScopeHandle,$$triggerName);"
  ],
  "description": "\n\nThis function requires NI Scope drivers to be installed on the system.\n\nSends the selected trigger to the digitizer. Call this function if you called NI_Scope_ConfigureTriggerSoftware when you want the Reference trigger to occur. You can also call this function to override a misused edge, digital, or hysteresis trigger.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PCI-5122 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Scope functions, Jabil Test will fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\n$ErrorCode = NI_Scope_SendSoftwareTriggerEdge($NI_ScopeHandle, $triggerName);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_ScopeHandle\n\nObject\n\nThe instrument handle you obtain from NI_Scope_Initialize that identifies a particular instrument's session.\n\n\n\n$triggerName\n\nString\n\nSpecifies the type of trigger to send to the digitizer. Possible values:\n\n\u00b7 START TRIGGER\n\n\u00b7 ARM REFERENCE TRIGGER\n\n\u00b7 REFERENCE TRIGGER\n\n\u00b7 ADVANCE TRIGGER\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\nInteger\n\nReports the status of this operation. To obtain a text description of the status code, call NI_Scope_ErrorMessage. To obtain additional information concerning the error condition, use NI_Scope_GetError and NI_Scope_ClearError. The general meaning of the status code is as:\n\n\u00b7 0: success\n\n\u00b7 Positive value: warning\n\n\u00b7 Negative value: errors\n\n\n\n\n\nExample:\n\n$triggerName = New(\"String\", \"START TRIGGER\");\n\n$ErrorCode = NI_Scope_SendSoftwareTriggerEdge($NI_ScopeHandle, $triggerName);\n\n\n\n\n\nNI_Scope_ConfigureChanCharacteristics\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_Scope_ConfigureChanCharacteristics": {
  "prefix": "NI_Scope_ConfigureChanCharacteristics",
  "body": [
   "$$ErrorCode=NI_Scope_ConfigureChanCharacteristics($$NI_ScopeHandle,$$channelName,$$inputImpedance,$$maxInputFrequency);"
  ],
  "description": "\n\nThis function requires NI Scope drivers to be installed on the system.\n\nConfigures the attributes input impedance and the bandwidth that control the electrical characteristics of the channel.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PCI-5122 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Scope functions, Jabil Test will fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\n$ErrorCode = NI_Scope_ConfigureChanCharacteristics($NI_ScopeHandle, $channelName, $inputImpedance, $maxInputFrequency);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_ScopeHandle\n\nObject\n\nThe instrument handle you obtain from NI_Scope_Initialize that identifies a particular instrument's session.\n\n\n\n$channelName\n\nString\n\nThe name of the channel to configure.\n\n\n\n$inputImpedance\n\nString\n\nThe input impedance parameter allows you to switch between 50 \u03a9 and 1 M\u03a9 input impedance, depending on your digitizer. The allowed vertical ranges may vary depending on the input impedance. If you measure a signal from a 50 \u03a9 output function generator, set the digitizer for 50 \u03a9 input to match your source. Impedance matching becomes much more important with higher frequency signals to avoid reflections of the signal that may distort your measurements. Alternatively, if you probe a circuit, it is best to use the high impedance setting on the digitizer to avoid changing the characteristics of the circuit.\n\nPossible values:\n\n\u00b7 50 OHM\n\n\u00b7 1 MEGA OHM\n\n\n\n$maxInputFrequency\n\nDouble\n\nThe max input frequency parameter sets the \u20133 dB cutoff frequency for a hardware analog filter. Setting this parameter to zero uses the default bandwidth of the digitizer. The filter attenuates signals greater than the cutoff frequency, which is useful for minimizing high-frequency noise when sampling at lower rates. For example, if you sample at 100 MS/s, you can resolve frequencies up to 50 MHz according to the Nyquist theorem. Any noise in the signal above 50 MHz, such as harmonics of the input signal, are aliased onto a frequency below 50 MHz. The solution is to filter this noise before the signal is digitized. This hardware filter is not available in all digitizers.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\nInteger\n\nReports the status of this operation. To obtain a text description of the status code, call NI_Scope_ErrorMessage. To obtain additional information concerning the error condition, use NI_Scope_GetError and NI_Scope_ClearError. The general meaning of the status code is as:\n\n\u00b7 0: success\n\n\u00b7 Positive value: warning\n\n\u00b7 Negative value: errors\n\n\n\n\n\nExample:\n\n$channelName = New(\"String\", \"0\");\n\n$inputImpedance = New(\"String\", \"50 ohm\");\n\n$maxInputFrequency = New(\"Float\", 0.0);\n\n$ErrorCode = NI_Scope_ConfigureChanCharacteristics($NI_ScopeHandle, $channelName, $inputImpedance, $maxInputFrequency);\n\n\n\n\n\nNI_Scope_ConfigureChannel\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_Scope_ConfigureChannel": {
  "prefix": "NI_Scope_ConfigureChannel",
  "body": [
   "$$ErrorCode=NI_Scope_ConfigureChannel($$NI_ScopeHandle,$$channelName,$$voltageRange,$$DCOffset,$$verticalCoupling,$$probeAttenuation,$$channelEnabled);"
  ],
  "description": "\n\nThis function requires NI Scope drivers to be installed on the system.\n\nThis function configures the most commonly configured attributes of the instrument's channel subsystem.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PCI-5122 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Scope functions, Jabil Test will fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\n$ErrorCode = NI_Scope_ConfigureChannel($NI_ScopeHandle, $channelName, $voltageRange, $DCOffset, $verticalCoupling, $probeAttenuation, $channelEnabled);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_ScopeHandle\n\nObject\n\nThe instrument handle you obtain from NI_Scope_Initialize that identifies a particular instrument's session.\n\n\n\n$channelName\n\nString\n\nThe name of the digitizer channel to configure.\n\n\n\n$voltageRange\n\nDouble\n\nSpecifies the absolute value of the input range for a channel in volts. For example, to acquire a sine wave that spans between \u20135 and +5 V, set this attribute to 10.0 V.\n\n\n\nConfigure Vertical adjusts the vertical range for the digitizer. The vertical range is the full-scale (peak-to-peak) voltage range at the probe or the input to the digitizer. For example, a 10 V vertical range means the digitizer can measure a signal between \u20135 V and 5 V. The signal may be clipped if it exceeds this range, which means the analog-to-digital converter (ADC) is saturated, so all values above 5 V or below \u20135 V are mapped to approximately 5 V or \u20135 V, respectively. For optimum resolution, choose the smallest vertical range that completely covers your input signal and avoids clipping. For example, if your signal is 2 Vp-p and your vertical range is 10 Vp-p, you are only using one-fifth of the range of the ADC. With an 8-bit digitizer, you have 256 unique voltage levels, but if you only use one-fifth of the range, you only have 51 unique voltage levels. This results in a noisy signal from the quantization of the ADC.\n\n\n\n$DCOffset\n\nDouble\n\nSelects the DC offset added to the specified channel(s).\n\n\n\n$verticalCoupling\n\nString\n\nSpecifies how the digitizer couples the input signal for the channel. When input coupling changes, the input stage takes a finite amount of time to settle.\n\n\n\nWhen you need to measure a small AC signal on top of a large DC component, you can use AC-coupling by setting the vertical coupling parameter in the Configure Vertical function. AC-coupling rejects any DC component in your signal before it is digitized. Activating AC-coupling inserts a capacitor in series with the input.\n\nValid values :\n\n\u00b7 \"AC\"\n\n\u00b7 \"DC\"\n\n\u00b7 \"GND\"\n\n\n\n$probeAttenuation\n\nDouble\n\nSpecifies the probe attenuation for the input channel. For example, for a 10:1 probe, set this attribute to 10.0.\n\n\n\nProbe attenuation scales your data to compensate for the attenuation of the probe. The voltage measured by the digitizer is multiplied by the probe attenuation parameter in the Configure Vertical function. The vertical range parameter is the voltage range you want after the probe compensation scaling. For example, if your probe attenuation is 10 and your vertical range is 10 V, the digitizer is set to measure a 1 Vp-p signal. The data returned with the Fetch function is 10 Vp-p.\n\nValid Values: Any positive real number. Typical values are 1, 10, and 100.\n\n\n\n$channelEnabled\n\nBoolean\n\nSpecifies whether the digitizer acquires a waveform for the channel.\n\n\u00b7 True : Acquire data on this channel.\n\n\u00b7 False : Do not acquire data on this channel.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\nInteger\n\nReports the status of this operation. To obtain a text description of the status code, call NI_Scope_ErrorMessage. To obtain additional information concerning the error condition, use NI_Scope_GetError and NI_Scope_ClearError. The general meaning of the status code is as:\n\n\u00b7 0: success\n\n\u00b7 Positive value: warning\n\n\u00b7 Negative value: errors\n\n\n\n\n\nExample:\n\n$channelName = New(\"String\", \"0\");\n\n$voltageRange = New(\"Float\", 2.0);\n\n$DCOffset = New(\"Float\", 0.0);\n\n$verticalCoupling = New(\"String\", \"dc\");\n\n$probeAttenuation = New(\"Float\", 1.0);\n\n$channelEnabled = New(\"Boolean\", \"TRUE\");\n\n\n\n\n\n$ErrorCode = NI_Scope_ConfigureChannel($NI_ScopeHandle, $channelName, $voltageRange, $DCOffset, $verticalCoupling, $probeAttenuation, $channelEnabled);\n\n\n\n\n\nNI_Scope_ConfigureVertical\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_Scope_ConfigureVertical": {
  "prefix": "NI_Scope_ConfigureVertical",
  "body": [
   "$$ErrorCode=NI_Scope_ConfigureVertical($$NI_ScopeHandle,$$channelName,$$verticalRange,$$verticalOffset,$$verticalCoupling,$$probeAttenuation,$$enabled);"
  ],
  "description": "\n\nThis function requires NI Scope drivers to be installed on the system.\n\nConfigures the most commonly configured attributes of the digitizer vertical subsystem, such as the range, offset, coupling, probe attenuation, and the channel.\n\nThe Configure Vertical function is necessary in almost every program because it allows you to enable a channel. By default, all channels are disabled. To acquire data, you must enable a channel either with Configure Vertical or a Read function. As a convenience, Read functions automatically enable the channels passed into them.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PCI-5122 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Scope functions, Jabil Test will fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\n$ErrorCode = NI_Scope_ConfigureVertical($NI_ScopeHandle, $channelName, $verticalRange, $verticalOffset, $verticalCoupling, $probeAttenuation, $enabled);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_ScopeHandle\n\nObject\n\nThe instrument handle you obtain from NI_Scope_Initialize that identifies a particular instrument's session.\n\n\n\n$channelName\n\nString\n\nThe name of the digitizer channel to configure.\n\n\n\n$verticalRange\n\nDouble\n\nSpecifies the absolute value of the input range for a channel in volts. For example, to acquire a sine wave that spans between \u20135 and +5 V, set this attribute to 10.0 V.\n\n\n\nConfigure Vertical adjusts the vertical range for the digitizer. The vertical range is the full-scale (peak-to-peak) voltage range at the probe or the input to the digitizer. For example, a 10 V vertical range means the digitizer can measure a signal between \u20135 V and 5 V. The signal may be clipped if it exceeds this range, which means the analog-to-digital converter (ADC) is saturated, so all values above 5 V or below \u20135 V are mapped to approximately 5 V or \u20135 V, respectively. For optimum resolution, choose the smallest vertical range that completely covers your input signal and avoids clipping. For example, if your signal is 2 Vp-p and your vertical range is 10 Vp-p, you are only using one-fifth of the range of the ADC. With an 8-bit digitizer, you have 256 unique voltage levels, but if you only use one-fifth of the range, you only have 51 unique voltage levels. This results in a noisy signal from the quantization of the ADC.\n\n\n\n$verticalOffset\n\nDouble\n\nSpecifies the location of the center of the range with respect to ground in volts. For example, to acquire a sine wave that spans between 0.0 and 10.0 V, set this attribute to 5.0 V.\n\nThe vertical offset parameter in the Configure Vertical function adjusts the middle of your vertical range. For example, if you set the vertical offset to 2 V with a vertical range of 10 V, your signal must be between \u20133 V and 7 V. Vertical offset allows you to adjust the range when analyzing signals with a DC offset. By centering the vertical offset on the DC level of your signal, you can use a smaller vertical range and optimize the resolution of your measurement.\n\n\n\n$verticalCoupling\n\nString\n\nSpecifies how the digitizer couples the input signal for the channel. When input coupling changes, the input stage takes a finite amount of time to settle.\n\n\n\nWhen you need to measure a small AC signal on top of a large DC component, you can use AC-coupling by setting the vertical coupling parameter in the Configure Vertical function. AC-coupling rejects any DC component in your signal before it is digitized. Activating AC-coupling inserts a capacitor in series with the input.\n\nValid values :\n\n\u00b7 AC\n\n\u00b7 DC\n\n\u00b7 GND\n\n\n\n$probeAttenuation\n\nDouble\n\nSpecifies the probe attenuation for the input channel. For example, for a 10:1 probe, set this attribute to 10.0.\n\n\n\nProbe attenuation scales your data to compensate for the attenuation of the probe. The voltage measured by the digitizer is multiplied by the probe attenuation parameter in the Configure Vertical function. The vertical range parameter is the voltage range you want after the probe compensation scaling. For example, if your probe attenuation is 10 and your vertical range is 10 V, the digitizer is set to measure a 1 Vp-p signal. The data returned with the Fetch function is 10 Vp-p.\n\nValid Values: Any positive real number. Typical values are 1, 10, and 100.\n\n\n\n$enabled\n\nBoolean\n\nSpecifies whether the digitizer acquires a waveform for the channel.\n\n\u00b7 True : Acquire data on this channel.\n\n\u00b7 False : Do not acquire data on this channel.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\nInteger\n\nReports the status of this operation. To obtain a text description of the status code, call NI_Scope_ErrorMessage. To obtain additional information concerning the error condition, use NI_Scope_GetError and NI_Scope_ClearError. The general meaning of the status code is as:\n\n\u00b7 0: success\n\n\u00b7 Positive value: warning\n\n\u00b7 Negative value: errors\n\n\n\n\n\nExample:\n\n\n\n\n\n$measureChannel = New(\"String\", \"0\");\n\n$verticalRange = New(\"Float\", 2.0);\n\n$verticalOffset = New(\"Float\", 0.0);\n\n$verticalCoupling = New(\"String\", \"ac\");\n\n$probeAttenuation = New(\"Float\", 1.0);\n\n$channelEnabled = New(\"Boolean\", \"TRUE\");\n\n$ErrorCode = NI_Scope_ConfigureVertical($NI_ScopeHandle, $measureChannel, $verticalRange, $verticalOffset, $verticalCoupling, $probeAttenuation, $channelEnabled);\n\n\n\n\n\nNI_Scope_ClearError\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_Scope_ClearError": {
  "prefix": "NI_Scope_ClearError",
  "body": [
   "$$ErrorCode=NI_Scope_ClearError($$NI_ScopeHandle);"
  ],
  "description": "\n\nThis function requires NI Scope drivers to be installed on the system.\n\nClears the error information for the current execution thread and the IVI session you specify.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PCI-5122 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Scope functions, Jabil Test will fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\n$ErrorCode = NI_Scope_ClearError($NI_ScopeHandle);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_ScopeHandle\n\nObject\n\nThe instrument handle you obtain from NI_Scope_Initialize that identifies a particular instrument's session.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\nInteger\n\nReports the status of this operation. To obtain a text description of the status code, call NI_Scope_ErrorMessage. To obtain additional information concerning the error condition, use NI_Scope_GetError and NI_Scope_ClearError. The general meaning of the status code is as:\n\n\u00b7 0: success\n\n\u00b7 Positive value: warning\n\n\u00b7 Negative value: errors\n\n\n\n\n\nExample:\n\n$ErrorCode = NI_Scope_ClearError($NI_ScopeHandle);\n\n\n\n\n\nNI_Scope_ErrorHandler\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_Scope_ErrorHandler": {
  "prefix": "NI_Scope_ErrorHandler",
  "body": [
   "($$ErrorCode,$$ErrorMessage,$$ErrorSource)=NI_Scope_ErrorHandler($$NI_ScopeHandle,$$ErrorCode);"
  ],
  "description": "\n\nThis function requires NI Scope drivers to be installed on the system.\n\nThis function takes the error code returned by NI-SCOPE functions and returns the interpretation as a user-readable string.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PCI-5122 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Scope functions, Jabil Test will fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\n($ErrorCode, $ErrorMessage, $ErrorSource) = NI_Scope_ErrorHandler($NI_ScopeHandle, $ErrorCode);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_ScopeHandle\n\nObject\n\nThe instrument handle you obtain from NI_Scope_Initialize that identifies a particular instrument's session.\n\n\n\n$ErrorCode\n\nInteger\n\nThe error code that is returned from any of the instrument driver functions.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\nInteger\n\nReports the status of this operation. To obtain a text description of the status code, call NI_Scope_ErrorHandler. To obtain additional information concerning the error condition, use NI_Scope_ErrorHandler and NI_Scope_ClearError. The general meaning of the status code is as:\n\n\u00b7 0: success\n\n\u00b7 Positive value: warning\n\n\u00b7 Negative value: errors\n\n\n\n$ErrorMessage\n\nString\n\nReturns the interpreted error code as a user-readable string.\n\n\n\n$ErrorSource\n\nString\n\nReturns the interpreted error code as a user-readable string.\n\n\n\n\n\nExample:\n\n($ErrorCode, $ErrorMessage, $ErrorSource) = NI_Scope_ErrorHandler($NI_ScopeHandle, $ErrorCode);\n\n\n\n\n\nNI_Scope_ErrorMessage\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_Scope_ErrorMessage": {
  "prefix": "NI_Scope_ErrorMessage",
  "body": [
   "($$ErrorCode,$$ErrorMessage)=NI_Scope_ErrorMessage($$NI_ScopeHandle,$$ErrorCode);"
  ],
  "description": "\n\nThis function requires NI Scope drivers to be installed on the system.\n\nThis function takes the error code returned by NI-SCOPE functions and returns the interpretation as a user-readable string.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PCI-5122 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Scope functions, Jabil Test will fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\n($ErrorCode, $ErrorMessage) = NI_Scope_ErrorMessage($NI_ScopeHandle, $ErrorCode);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_ScopeHandle\n\nObject\n\nThe instrument handle you obtain from NI_Scope_Initialize that identifies a particular instrument's session.\n\n\n\n$ErrorCode\n\nInteger\n\nThe error code that is returned from any of the instrument driver functions.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\nInteger\n\nReports the status of this operation. To obtain a text description of the status code, call NI_Scope_ErrorMessage. To obtain additional information concerning the error condition, use NI_Scope_ErrorMessage and NI_Scope_ClearError. The general meaning of the status code is as:\n\n\u00b7 0: success\n\n\u00b7 Positive value: warning\n\n\u00b7 Negative value: errors\n\n\n\n$ErrorMessage\n\nString\n\nReturns the interpreted error code as a user-readable string.\n\n\n\n\n\nExample:\n\n($ErrorCode, $ErrorMessage) = NI_Scope_ErrorMessage($NI_ScopeHandle, $ErrorCode);\n\n\n\n\n\nNI_Scope_GetError\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_Scope_GetError": {
  "prefix": "NI_Scope_GetError",
  "body": [
   "($$ErrorCode,$$functionErrorCode,$$ErrorMessage)=NI_Scope_GetError($$NI_ScopeHandle);"
  ],
  "description": "\n\nThis function requires NI Scope drivers to be installed on the system.\n\nThis function reads an error code and message from the error queue. National Instruments digitizers do not contain an error queue. Errors are reported as they occur. Therefore, this function does not detect errors.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PCI-5122 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Scope functions, Jabil Test will fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\n($ErrorCode, $functionErrorCode, $ErrorMessage) = NI_Scope_GetError($NI_ScopeHandle);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_ScopeHandle\n\nObject\n\nThe instrument handle you obtain from NI_Scope_Initialize that identifies a particular instrument's session.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\nInteger\n\nReports the status of this operation. To obtain a text description of the status code, call NI_Scope_ErrorMessage. To obtain additional information concerning the error condition, use NI_Scope_GetError and NI_Scope_ClearError. The general meaning of the status code is as:\n\n\u00b7 0: success\n\n\u00b7 Positive value: warning\n\n\u00b7 Negative value: errors\n\n\n\n$functionErrorCode\n\nInteger\n\nPass the Error Code that is returned from any of the instrument driver functions.\n\n\n\n$ErrorMessage\n\nString\n\nPass the Error Code that is returned from any of the instrument driver functions.\n\n\n\n\n\nExample:\n\n($ErrorCode, $functionErrorCode, $ErrorMessage) = NI_Scope_GetError($NI_ScopeHandle);\n\n\n\n\n\nNI_Scope_AddWaveformProcessing\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_Scope_AddWaveformProcessing": {
  "prefix": "NI_Scope_AddWaveformProcessing",
  "body": [
   "$$ErrorCode=NI_Scope_AddWaveformProcessing($$NI_ScopeHandle,$$channelList,$$ArrayMeasurementFunction);"
  ],
  "description": "\n\nThis function requires NI Scope drivers to be installed on the system.\n\nThis function adds one measurement to the list of processing steps that are completed before the measurement. The processing is added on a per channel basis, and the processing measurements are completed in the same order they are registered. The processing measurements are streamed, so the result of the first processing step is used as the input for the next step. The processing is done before any other measurements.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PCI-5122 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Scope functions, Jabil Test will fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\n$ErrorCode = NI_Scope_AddWaveformProcessing($NI_ScopeHandle, $channelList, $ArrayMeasurementFunction);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_ScopeHandle\n\nObject\n\nThe instrument handle you obtain from NI_Scope_Initialize that identifies a particular instrument's session.\n\n\n\n$channelList\n\nString\n\nThe channel name you want to add a processing function to\n\n\n\n$ArrayMeasurementFunction\n\nString\n\nThe array measurement to add:\n\n\u00b7 NO MEASUREMENT\n\n\u00b7 LAST ACQ HISTORGRAM\n\n\u00b7 MULTI ACQ TIME HISTOGRAM\n\n\u00b7 MULTI ACQ VOLTAGE HISTOGRAM\n\n\u00b7 BLACKMAN WINDOW\n\n\u00b7 HANNING WINDOW\n\n\u00b7 FLAT TOP WINDOW\n\n\u00b7 TRIANGLE WINDOW\n\n\u00b7 HAMMING WINDOW\n\n\u00b7 BESSEL FILTER\n\n\u00b7 WINDOWED FIR FILTER\n\n\u00b7 BUTTERWORTH FILTER\n\n\u00b7 CHEBYSHEV FILTER\n\n\u00b7 ADD CHANNELS\n\n\u00b7 MULTIPLY CHANNELS\n\n\u00b7 DIVIDE CHANNELS\n\n\u00b7 SUBTRACT CHANNELS\n\n\u00b7 DERIVATIVE\n\n\u00b7 MULTI ACQ AVERAGE\n\n\u00b7 ARRAY INTEGRAL\n\n\u00b7 INVERSE\n\n\u00b7 ARRAY GAIN\n\n\u00b7 ARRAY OFFSET\n\n\u00b7 FFT AMP SPECTRUM DB\n\n\u00b7 FFT PHASE SPECTRUM\n\n\u00b7 FFT AMP SPECTRUM VOLTS RMS\n\n\u00b7 POLYNOMIAL INTERPOLATION\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\nInteger\n\nReports the status of this operation. To obtain a text description of the status code, call NI_Scope_ErrorMessage. To obtain additional information concerning the error condition, use NI_Scope_GetError and NI_Scope_ClearError. The general meaning of the status code is as:\n\n\u00b7 0: success\n\n\u00b7 Positive value: warning\n\n\u00b7 Negative value: errors\n\n\n\n\n\nExample:\n\n$channelList = New(String, \"0\");\n\n$ArrayMeasurementFunction = New(String, \"NO MEASUREMENT\");\n\n\n\n\n\n$ErrorCode = NI_Scope_AddWaveformProcessing($NI_ScopeHandle, $channelList, $ArrayMeasurementFunction);\n\n\n\n\n\nNI_Scope_ClearWaveformMeasurementStats\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_Scope_ClearWaveformMeasurementStats": {
  "prefix": "NI_Scope_ClearWaveformMeasurementStats",
  "body": [
   "$$ErrorCode=NI_Scope_ClearWaveformMeasurementStats($$NI_ScopeHandle,$$channelName,$$measurementFunction);"
  ],
  "description": "\n\nThis function requires NI Scope drivers to be installed on the system.\n\nThis function clears the waveform stats on the channel and measurement you specify.\n\nEvery time a measurement is called, the statistics information is updated, including the min, max, mean, standard deviation, and number of updates. This information is fetched with NI_Scope_FetchMeasurementStats. The multi-acquisition array measurements are also cleared with this function.\n\n\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PCI-5122 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Scope functions, Jabil Test will fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\n$ErrorCode = NI_Scope_ClearWaveformMeasurementStats($NI_ScopeHandle, $channelName, $measurementFunction);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_ScopeHandle\n\nObject\n\nThe instrument handle you obtain from NI_Scope_Initialize that identifies a particular instrument's session.\n\n\n\n$channelName\n\nString\n\nThe channel for the measurements you want to clear, such as 0 or 1.\n\n\n\n$measurementFunction\n\nString\n\nThe scalar measurement or array measurement to clear the stats for. Possible values:\n\n\u00b7 AC ESTIMATE\n\n\u00b7 DC ESTIMATE\n\n\u00b7 FFT AMPLITUDE\n\n\u00b7 VOLTAGE CYCLE RMS\n\n\u00b7 VOLTAGE RMS\n\n\u00b7 VOLTAGE AVERAGE\n\n\u00b7 VOLTAGE CYCLE AVERAGE\n\n\u00b7 AREA\n\n\u00b7 INTEGRAL\n\n\u00b7 CYCLE AREA\n\n\u00b7 VOLTAGE MIN\n\n\u00b7 VOLTAGE LOW\n\n\u00b7 VOLTAGE MAX\n\n\u00b7 VOLTAGE HIGH\n\n\u00b7 VOLTAGE PEAK TO PEAK\n\n\u00b7 VOLTAGE AMPLITUDE\n\n\u00b7 VOLTAGE BASE\n\n\u00b7 VOLTAGE TOP\n\n\u00b7 VOLTAGE BASE TO TOP\n\n\u00b7 OVERSHOOT\n\n\u00b7 PRESHOOT\n\n\u00b7 LOW REF VOLTAGE\n\n\u00b7 MID REF VOLTAGE\n\n\u00b7 HIGH REF VOLTAGE\n\n\u00b7 FALL TIME\n\n\u00b7 DUTY CYCLE POS\n\n\u00b7 DUTY CYCLE NEG\n\n\u00b7 FALL SLEW RATE\n\n\u00b7 RISE TIME\n\n\u00b7 WIDTH NEG\n\n\u00b7 RISE SLEW RATE\n\n\u00b7 WIDTH POS\n\n\u00b7 PHASE DELAY\n\n\u00b7 TIME DELAY\n\n\u00b7 AVERAGE FREQUENCY\n\n\u00b7 FFT FREQUENCY\n\n\u00b7 AVERAGE PERIOD\n\n\u00b7 FREQUENCY\n\n\u00b7 PERIOD\n\n\u00b7 TIME HISTOGRAM HITS\n\n\u00b7 TIME HISTOGRAM MEAN PLUS 3 STDEV\n\n\u00b7 TIME HISTOGRAM MAX\n\n\u00b7 TIME HISTOGRAM MEDIAN\n\n\u00b7 TIME HISTOGRAM MEAN\n\n\u00b7 TIME HISTOGRAM MIN\n\n\u00b7 TIME HISTOGRAM PEAK TO PEAK\n\n\u00b7 TIME HISTOGRAM MODE\n\n\u00b7 TIME HISTOGRAM MEAN PLUS STDEV\n\n\u00b7 TIME HISTOGRAM NEW HITS\n\n\u00b7 TIME HISTOGRAM MEAN PLUS 2 STDEV\n\n\u00b7 TIME HISTOGRAM STDEV\n\n\u00b7 VOLTAGE HISTOGRAM HITS\n\n\u00b7 VOLTAGE HISTOGRAM MEAN PLUS 3 STDEV\n\n\u00b7 VOLTAGE HISTOGRAM MAX\n\n\u00b7 VOLTAGE HISTOGRAM MEDIAN\n\n\u00b7 VOLTAGE HISTOGRAM MEAN\n\n\u00b7 VOLTAGE HISTOGRAM MIN\n\n\u00b7 VOLTAGE HISTOGRAM PEAK TO PEAK\n\n\u00b7 VOLTAGE HISTOGRAM MODE\n\n\u00b7 VOLTAGE HISTOGRAM MEAN PLUS STDEV\n\n\u00b7 VOLTAGE HISTOGRAM NEW HITS\n\n\u00b7 VOLTAGE HISTOGRAM MEAN PLUS 2 STDEV\n\n\u00b7 VOLTAGE HISTOGRAM STDEV\n\n\u00b7 NO MEASUREMENT\n\n\u00b7 LAST ACQ HISTORGRAM\n\n\u00b7 MULTI ACQ TIME HISTOGRAM\n\n\u00b7 MULTI ACQ VOLTAGE HISTOGRAM\n\n\u00b7 BLACKMAN WINDOW\n\n\u00b7 HANNING WINDOW\n\n\u00b7 FLAT TOP WINDOW\n\n\u00b7 TRIANGLE WINDOW\n\n\u00b7 HAMMING WINDOW\n\n\u00b7 BESSEL FILTER\n\n\u00b7 WINDOWED FIR FILTER\n\n\u00b7 BUTTERWORTH FILTER\n\n\u00b7 CHEBYSHEV FILTER\n\n\u00b7 ADD CHANNELS\n\n\u00b7 MULTIPLY CHANNELS\n\n\u00b7 DIVIDE CHANNELS\n\n\u00b7 SUBTRACT CHANNELS\n\n\u00b7 DERIVATIVE\n\n\u00b7 MULTI ACQ AVERAGE\n\n\u00b7 ARRAY INTEGRAL\n\n\u00b7 INVERSE\n\n\u00b7 ARRAY GAIN\n\n\u00b7 ARRAY OFFSET\n\n\u00b7 FFT AMP SPECTRUM DB\n\n\u00b7 FFT PHASE SPECTRUM\n\n\u00b7 FFT AMP SPECTRUM VOLTS RMS\n\n\u00b7 POLYNOMIAL INTERPOLATION\n\n\u00b7 ALL MEASUREMENTS\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\nInteger\n\nReports the status of this operation. To obtain a text description of the status code, call NI_Scope_ErrorMessage. To obtain additional information concerning the error condition, use NI_Scope_GetError and NI_Scope_ClearError. The general meaning of the status code is as:\n\n\u00b7 0: success\n\n\u00b7 Positive value: warning\n\n\u00b7 Negative value: errors\n\n\n\n\n\nExample:\n\n$channelName = New(String, \"0\");\n\n$measurementFunction = New(String, \"ALL MEASUREMENTS\");\n\n$ErrorCode = NI_Scope_ClearWaveformMeasurementStats($NI_ScopeHandle, $channelName, $measurementFunction);\n\n\n\n\n\nNI_Scope_ClearWaveformProcessing\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_Scope_ClearWaveformProcessing": {
  "prefix": "NI_Scope_ClearWaveformProcessing",
  "body": [
   "$$ErrorCode=NI_Scope_ClearWaveformProcessing($$NI_ScopeHandle,$$channelList);"
  ],
  "description": "\n\nThis function requires NI Scope drivers to be installed on the system.\n\nThis function clears the list of processing steps assigned to the given channel. The processing is added with the NI_Scope_AddWaveformProcessing function, where the processing steps are completed in the same order in which they are registered. The processing measurements are streamed, so the result of the first processing step is used as the input for the next step. The processing is also done before any other measurements.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PCI-5122 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Scope functions, Jabil Test will fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\n$ErrorCode = NI_Scope_ClearWaveformProcessing($NI_ScopeHandle, $channelList);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_ScopeHandle\n\nObject\n\nThe instrument handle you obtain from NI_Scope_Initialize that identifies a particular instrument's session.\n\n\n\n$channelList\n\nString\n\nThe channel name you want to add a processing function to\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\nInteger\n\nReports the status of this operation. To obtain a text description of the status code, call NI_Scope_ErrorMessage. To obtain additional information concerning the error condition, use NI_Scope_GetError and NI_Scope_ClearError. The general meaning of the status code is as:\n\n\u00b7 0: success\n\n\u00b7 Positive value: warning\n\n\u00b7 Negative value: errors\n\n\n\n\n\nExample:\n\n$channelList = New(\"String\", \"0\");\n\n$ErrorCode = NI_Scope_ClearWaveformProcessing($NI_ScopeHandle, $channelList);\n\n\n\n\n\nNI_Scope_FetchMeasurement\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_Scope_FetchMeasurement": {
  "prefix": "NI_Scope_FetchMeasurement",
  "body": [
   "($$ErrorCode,$$resultArray,$$numWfms)=NI_Scope_FetchMeasurement($$NI_ScopeHandle,$$channelName,$$timeOut,$$scalarMeasureType);"
  ],
  "description": "\n\nThis function requires NI Scope drivers to be installed on the system.\n\nThis function fetches a waveform from the digitizer and performs the specified waveform measurement.\n\nUnlike Read functions, Fetch functions (NI_Scope_Fetch and NI_Scope_FetchMeasurement) acquire data asynchronously. That means these functions store data on your digitizer until you need it, which frees up your computer to perform other tasks and allows for better system performance. However, fetching requires additional functions that initiate waveform acquisitions and query your board to see if the acquisition is complete.\n\nTo fetch data, write a program that follows these general steps:\n\n\u00b7 Create a new instrument session using NI_Scope_Initialize.\n\n\u00b7 Configure your digitizer with NI-SCOPE Configuration functions.\n\n\u00b7 Call NI_Scope_ActualRecordLength to find the actual number of points your digitizer acquires for each channel.\n\n\u00b7 Call NI_Scope_InitiateAcquisition to initiate a waveform acquisition. Data will be acquired simultaneously on all enabled channels.\n\n\u00b7 Call NI_Scope_AcquisitionStatus in a loop to check if the acquisition is complete or in progress. This step is useful if you want to perform other tasks during the acquisition. The Fetch functions can also accept a timeout to force NI-SCOPE to wait until the acquisition is complete.\n\n\u00b7 Call the Fetch function you need. You can call multiple fetches if you are acquiring data from more than one channel or measurement.\n\n\u00b7 Call NI_Scope_Close to close the current session.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PCI-5122 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Scope functions, Jabil Test will fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\n($ErrorCode, $resultArray, $numWfms) = NI_Scope_FetchMeasurement($NI_ScopeHandle, $channelName, $timeOut, $scalarMeasureType);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_ScopeHandle\n\nObject\n\nThe instrument handle you obtain from NI_Scope_Initialize that identifies a particular instrument's session.\n\n\n\n$measureChannel\n\nString\n\nThe channel you will acquire data from; it may be a single channel, such as \"0\" or \"1\", or a list of channels such as \"0,1\".\n\n\n\n$measureTimeOut\n\nDouble\n\nThe time to wait in seconds for data to be acquired. Using 0 for this parameter tells NI-SCOPE to fetch whatever is currently available.\n\n\n\n$scalarMeasureType\n\nString\n\nThe scalar measurement to be performed (see below for more information). Possible values:\n\n\u00b7 AC ESTIMATE\n\n\u00b7 DC ESTIMATE\n\n\u00b7 FFT AMPLITUDE\n\n\u00b7 VOLTAGE CYCLE RMS\n\n\u00b7 VOLTAGE RMS\n\n\u00b7 VOLTAGE AVERAGE\n\n\u00b7 VOLTAGE CYCLE AVERAGE\n\n\u00b7 AREA\n\n\u00b7 INTEGRAL\n\n\u00b7 CYCLE AREA\n\n\u00b7 VOLTAGE MIN\n\n\u00b7 VOLTAGE LOW\n\n\u00b7 VOLTAGE MAX\n\n\u00b7 VOLTAGE HIGH\n\n\u00b7 VOLTAGE PEAK TO PEAK\n\n\u00b7 VOLTAGE AMPLITUDE\n\n\u00b7 VOLTAGE BASE\n\n\u00b7 VOLTAGE TOP\n\n\u00b7 VOLTAGE BASE TO TOP\n\n\u00b7 OVERSHOOT\n\n\u00b7 PRESHOOT\n\n\u00b7 LOW REF VOLTAGE\n\n\u00b7 MID REF VOLTAGE\n\n\u00b7 HIGH REF VOLTAGE\n\n\u00b7 FALL TIME\n\n\u00b7 DUTY CYCLE POS\n\n\u00b7 DUTY CYCLE NEG\n\n\u00b7 FALL SLEW RATE\n\n\u00b7 RISE TIME\n\n\u00b7 WIDTH NEG\n\n\u00b7 RISE SLEW RATE\n\n\u00b7 WIDTH POS\n\n\u00b7 PHASE DELAY\n\n\u00b7 TIME DELAY\n\n\u00b7 AVERAGE FREQUENCY\n\n\u00b7 FFT FREQUENCY\n\n\u00b7 AVERAGE PERIOD\n\n\u00b7 FREQUENCY\n\n\u00b7 PERIOD\n\n\u00b7 TIME HISTOGRAM HITS\n\n\u00b7 TIME HISTOGRAM MEAN PLUS 3 STDEV\n\n\u00b7 TIME HISTOGRAM MAX\n\n\u00b7 TIME HISTOGRAM MEDIAN\n\n\u00b7 TIME HISTOGRAM MEAN\n\n\u00b7 TIME HISTOGRAM MIN\n\n\u00b7 TIME HISTOGRAM PEAK TO PEAK\n\n\u00b7 TIME HISTOGRAM MODE\n\n\u00b7 TIME HISTOGRAM MEAN PLUS STDEV\n\n\u00b7 TIME HISTOGRAM NEW HITS\n\n\u00b7 TIME HISTOGRAM MEAN PLUS 2 STDEV\n\n\u00b7 TIME HISTOGRAM STDEV\n\n\u00b7 VOLTAGE HISTOGRAM HITS\n\n\u00b7 VOLTAGE HISTOGRAM MEAN PLUS 3 STDEV\n\n\u00b7 VOLTAGE HISTOGRAM MAX\n\n\u00b7 VOLTAGE HISTOGRAM MEDIAN\n\n\u00b7 VOLTAGE HISTOGRAM MEAN\n\n\u00b7 VOLTAGE HISTOGRAM MIN\n\n\u00b7 VOLTAGE HISTOGRAM PEAK TO PEAK\n\n\u00b7 VOLTAGE HISTOGRAM MODE\n\n\u00b7 VOLTAGE HISTOGRAM MEAN PLUS STDEV\n\n\u00b7 VOLTAGE HISTOGRAM NEW HITS\n\n\u00b7 VOLTAGE HISTOGRAM MEAN PLUS 2 STDEV\n\n\u00b7 VOLTAGE HISTOGRAM STDEV\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\nInteger\n\nReports the status of this operation. To obtain a text description of the status code, call NI_Scope_ErrorMessage. To obtain additional information concerning the error condition, use NI_Scope_GetError and NI_Scope_ClearError. The general meaning of the status code is as:\n\n\u00b7 0: success\n\n\u00b7 Positive value: warning\n\n\u00b7 Negative value: errors\n\n\n\n$resultArray\n\nArray\n\nContains an array of all measurements acquired; call NI_Scope_ActualNumWfms to determine the array length.\n\n\n\n$numWfms\n\nInteger\n\nReturns the number of records times the number of channels.\n\n\n\n\n\nExtra information of the scalar measurement types:\n\nRMS Voltage Measurements\n\n\n\nMeasurement\n\nDescription\n\nUnits\n\n\n\nAC Estimate\n\nThe DC estimate is subtracted from the waveform, and a Hanning window is applied to give a \"processed waveform.\" The RMS voltage is calculated with the following equation:\n\nsqrt ( [\u03a3 processed waveform[i]^2] / [numPoints \u00d7 enbw \u00d7 cg^2] ),\n\nwhere the equivalent noise bandwidth (enbw) for the Hanning window is 1.5, and the coherent gain (cg) is 0.5.\n\nThis algorithm minimizes the effect of a noninteger number of waveform cycles in the measurement, which could arbitrarily increase or decrease the RMS value.\n\nVolts\n\nRMS\n\n\n\nVoltage Cycle RMS\n\nThe number of points in a period is calculated using the equation:\n\npointsPerPeriod = int (period / dt + 0.5),\n\nwhere dt is the time between two points and int is a function that returns the integer portion of a floating-point number.\n\nVolts\n\nRMS\n\n\n\nFFT Amplitude\n\nThe FFT amplitude spectrum is calculated using a split-radix real FFT, and the maximum amplitude is returned. If the input waveform size is not a power of two, the waveform is zero-padded to the next higher power of two. For best results, verify that your actual record length is a power of 2.\n\nVolts\n\nRMS\n\n\n\nVoltage RMS\n\nDetermined by the following True RMS equation:\n\nVoltage RMS = sqrt ( (\u03a3 waveform[i]^2) / numPoints)\n\nVolts\n\nRMS\n\n\n\n\n\nDC Voltage Measurements\n\n\n\nMeasurement\n\nDescription\n\nUnits\n\n\n\nVoltage Average\n\nDetermined by the following equation:\n\n\n\n\n\nVoltage Average = \u03a3 waveform[i] / numPoints\n\nVolts\n\n\n\n\n\nArea Measurements\n\n\n\nMeasurement\n\nDescription\n\nUnits\n\n\n\nArea\n\nDetermined by the following equation:\n\narea = voltage average \u00d7 numPoints \u00d7 delta time between two points\n\nVolt x seconds\n\n\n\nIntegral\n\nNumerical integration is done using Simpson's rule.\n\nVolt x seconds\n\n\n\nCycle area\n\nDetermined by the following equation:\n\nCycle area = voltage cycle average \u00d7 pointsPerPeriod \u00d7 dt\n\nwhere pointsPerPeriod is defined in the voltage cycle average description.\n\nVolt x seconds\n\n\n\n\n\nVoltage Extrema Measurements\n\n\n\nMeasurement\n\nDescription\n\nUnits\n\n\n\nVoltage Minimum\n\nThe waveform is searched for the minimum point.\n\nVolts\n\n\n\nVoltage Low\n\nThe last acquisition histogram method is used where the voltage low result is the voltage of the histogram bin with the maximum number of hits below 40% of the voltage peak-to-peak value of the waveform. This calculation is useful for ignoring the overshoot and preshoot on square waves.\n\nVolts\n\n\n\nVoltage Maximum\n\nThe waveform is searched for its maximum point.\n\nVolts\n\n\n\nVoltage High\n\nThe last histogram method is used where the voltage high result is the voltage of the histogram bin with the maximum number of hits above 60% of the voltage peak-to-peak value of the waveform. This calculation is useful for ignoring the overshoot and preshoot on square waves.\n\nVolts\n\n\n\nVoltage Peak to Peak\n\nThe maximum voltage minus the minimum voltage.\n\nVolts\n\n\n\nVoltage Amplitude\n\nThe voltage high minus the voltage low.\n\nVolts\n\n\n\nVoltage Base\n\nIf the histogram bin corresponding to voltage low has over 5% of the total hits, the voltage low result is returned. Otherwise, the voltage minimum calculation is returned. This allows using the voltage base to get a reasonable answer for either a square wave (ignoring the overshoot and preshoot) or a triangle wave (where a histogram fails).\n\nVolts\n\n\n\nVoltage Top\n\nIf the histogram bin corresponding to voltage high has over 5% of the total hits, the voltage high result is returned. Otherwise, the voltage maximum calculation is returned. This allows using the voltage top to get a reasonable answer for either a square wave (ignoring the overshoot and preshoot) or a triangle wave (where a histogram fails).\n\nVolts\n\n\n\nVoltage Base to Base\n\nVoltage top minus voltage base.\n\nVolts\n\n\n\nOvershoot\n\nThe measurement is done on the first edge of the waveform. If two edges exist, the algorithm finds the time interval from the first edge until one half the time to the second edge. The local maxima and minima are found in this interval. If only one edge is present in the waveform, the local maximum and minimum is found between the first edge and the end of the waveform.\n\nIf the first edge is positive sloped, overshoot = 100 \u00d7 (local maximum \u2013 voltage high) / voltage amplitude.\n\n\n\n\n\nIf the first edge is negative sloped, overshoot = 100 \u00d7 (voltage low \u2013 local minimum) / voltage amplitude.\n\n\n\nVolts\n\n\n\nPreshoot\n\nThe measurement is done on the second edge of the waveform if two edges exist. The algorithm finds the time interval from the middle time between the two edges until the second edge. The local maxima and minima are found in this interval. If only one edge is present in the waveform, the local maximum and minimum are found from the start of the waveform to the first edge.\n\nIf the edge is negative sloped, preshoot = 100 \u00d7 (local maximum \u2013 voltage high) / voltage amplitude.\n\n\n\n\n\nIf the edge is positive sloped, preshoot = 100 \u00d7 (voltage low \u2013 local minimum) / voltage amplitude.\n\n\n\nVolts\n\n\n\n\n\nReference Level Measurements\n\n\n\nMeasurement\n\nDescription\n\nUnits\n\n\n\nLow-Reference Voltage\n\nThe voltage corresponding to the low reference level.\n\nVolts\n\n\n\nMid-Reference Voltage\n\nThe voltage corresponding to the mid reference level.\n\nVolts\n\n\n\nHigh-Reference Voltage\n\nThe voltage corresponding to the high reference level.\n\nVolts\n\n\n\n\n\nTime Measurements\n\n\n\nMeasurement\n\nDescription\n\nUnits\n\n\n\nFall Time\n\nThe time span in seconds from when the waveform crosses the high reference level until it crosses the low reference level. The measurement starts at the left edge of the waveform and finds all high reference level crossings until a low reference level crossing. The final high reference level crossing is used in the calculation.\n\n\n\nSeconds\n\n\n\nPositive Duty Cycle\n\nThe positive width divided by the period times 100.\n\nPercentage\n\n\n\nFall Slew Rate\n\nThe low reference voltage minus the high reference voltage is divided by the fall-time calculation. The result is always negative.\n\nVolts/Second\n\n\n\nRise Time\n\nThe time span from when the waveform crosses the low reference level until it crosses the high reference level in seconds. The measurement starts at the left edge of the waveform and finds all low reference level crossings until a high reference level crossing. The final low reference level crossing is used in the calculation.\n\n\n\nSeconds\n\n\n\nNegative Width\n\nThe time difference between the first two mid reference level crossings, where the slopes are negative and positive, respectively. A digital hysteresis is used when finding the crosspoints.\n\nSeconds\n\n\n\nRising Slew Rate\n\nThe high reference voltage minus the low reference voltage is divided by the rise-time calculation.\n\nVolts/Second\n\n\n\nPositive Width\n\nThe time difference in seconds between the first two mid reference level crossings, where the slopes are positive and negative respectively. A digital hysteresis is used when finding the crosspoints.\n\nSeconds\n\n\n\nNegative Duty Cycle\n\nThe negative width divided by the period times 100.\n\nPercentage\n\n\n\n\n\nTwo-channel Measurements (scalar)\n\n\n\nMeasurement\n\nDescription\n\nUnits\n\n\n\nPhase Delay\n\nThe time delay divided by the period (of the waveform on the channel specified by the measurement function) times 360 degrees.\n\nDegrees\n\n\n\nTime Delay\n\nThe time delay is the time between two edges with the same slope. The mid reference level is stored on a per channel basis, and mid reference levels do not need to be the same. All reference levels use a digital hysteresis.\n\nSeconds\n\n\n\n\n\nPeriod and Frequency Measurements\n\n\n\nMeasurement\n\nDescription\n\nUnits\n\n\n\nFrequency\n\n1.0 divided by the period.\n\nHertz\n\n\n\nPeriod\n\nFinds the time between the first and third mid reference level crosspoints in seconds. A hysteresis window is applied when finding crosspoints. The mid reference level is 50% by default.\n\nSeconds\n\n\n\nAverage Frequency\n\n1.0 divided by the average period.\n\nHertz\n\n\n\nAverage Period\n\nUp to 256 mid reference level crossings are found on the waveform, using a digital hysteresis. The time difference between the last crossing and the first crossing is divided by the number of periods found in the waveform. The last crossing is defined as the last crossing in the waveform with the same slope as the first crossing, so an integer number of periods exist in the waveform.\n\nSeconds\n\n\n\nFFT Frequency\n\nThe FFT amplitude spectrum is calculated using a split-radix real FFT, and the frequency corresponding to the maximum amplitude is returned. If the input waveform size is not a power of two, the waveform is zero padded to the next higher power of two. The frequency resolution is sampling rate / number of points. The DC bin of the FFT is ignored when searching for the maximum amplitude, so the FFT frequency should ignore any DC offsets. However, the zero padding used in the FFT measurement can introduce other low-frequency components if the waveform has a large DC offset. To eliminate the effects of zero-padding, verify that your actual record length is a power of 2.\n\nHertz\n\n\n\n\n\nTime Histogram Measurements\n\n\n\nMeasurement\n\nDescription\n\nUnits\n\n\n\nHits\n\nNumber of points in the histogram.\n\n-\n\n\n\nNew Hits\n\nNumber of points added to the histogram by the most recent acquisition.\n\n-\n\n\n\nMaximum\n\nThe highest bin value with at least one hit.\n\nSeconds\n\n\n\nMinimum\n\nThe lowest bin value with at least one hit.\n\nSeconds\n\n\n\nMean\n\nHistogram Mean = [ \u03a3 (bin hits \u00d7 bin value) ] / total hits.\n\nThe bin value is the center time value of the histogram bin.\n\nSeconds\n\n\n\nMedian\n\nThe bin value where half the histogram hits are above it and half the histogram hits are below.\n\nSeconds\n\n\n\nMode\n\nThe bin value with the most hits. If there is a tie, the lower time value is returned.\n\nSeconds\n\n\n\nPeak-to-Peak\n\nHistogram maximum minus the histogram minimum.\n\nSeconds\n\n\n\nMean Plus 2 Standard Deviations\n\nThe percentage of hits in the histogram between the mean minus two times the standard deviation and the mean plus two times the standard deviation. The percentage is returned in the range 0\u2013100.\n\nPercentage\n\n\n\nMean Plus 3 Standard Deviations\n\nThe percentage of hits in the histogram between the mean minus three times the standard deviation and the mean plus three times the standard deviation. The percentage is returned in the range 0\u2013100.\n\nPercentage\n\n\n\nStandard Deviation\n\n\n\nSeconds\n\n\n\n\n\nVoltage Histogram Measurements\n\n\n\nMeasurement\n\nDescription\n\nUnits\n\n\n\nHits\n\nNumber of points in the histogram.\n\n-\n\n\n\nNew Hits\n\nNumber of points added to the histogram by the most recent acquisition.\n\n-\n\n\n\nMaximum\n\nThe highest bin value with at least one hit.\n\nSeconds\n\n\n\nMinimum\n\nThe lowest bin value with at least one hit.\n\nSeconds\n\n\n\nMean\n\nHistogram Mean = [ \u03a3 (bin hits \u00d7 bin value) ] / total hits.\n\nThe bin value is the center time value of the histogram bin.\n\nSeconds\n\n\n\nMedian\n\nThe bin value where half the histogram hits are above it and half the histogram hits are below.\n\nSeconds\n\n\n\nMode\n\nThe bin value with the most hits. If there is a tie, the lower voltage value is returned.\n\nSeconds\n\n\n\nPeak-to-Peak\n\nHistogram maximum minus the histogram minimum.\n\nSeconds\n\n\n\nStandard Deviation\n\n\n\n\n\nSeconds\n\n\n\nMean Plus 2 Standard Deviations\n\nThe percentage of hits in the histogram between the mean minus two times the standard deviation and the mean plus two times the standard deviation. The percentage is returned in the range 0\u2013100.\n\nPercentage\n\n\n\nMean Plus 3 Standard Deviations\n\nThe percentage of hits in the histogram between the mean minus three times the standard deviation and the mean plus three times the standard deviation. The percentage is returned in the range 0\u2013100.\n\nPercentage\n\n\n\n\n\nExample:\n\n$channelName = New(\"String\", \"0,1\");\n\n$timeOut = New(\"Float\", 5.0);\n\n$measureType = New(\"String\", \"FREQUENCY\");\n\n($ErrorCode, $resultArray, $numWfms) = NI_Scope_FetchMeasurement($NI_ScopeHandle, $channelName, $timeOut, $measureType);\n\n// Get desired array value\n\n$result = ArrayGetValue($resultArray, 0, 0);\n\nUpdateStatus($result);\n\n$result = ArrayGetValue($resultArray, 0, 1);\n\nUpdateStatus($result);\n\n\n\n\n\nNI_Scope_ReadMeasurement\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_Scope_ReadMeasurement": {
  "prefix": "NI_Scope_ReadMeasurement",
  "body": [
   "($$ErrorCode,$$resultArray)=NI_Scope_ReadMeasurement($$NI_ScopeHandle,$$measureChannel,$$measureTimeOut,$$scalarMeasureType);"
  ],
  "description": "\n\nThis function requires NI Scope drivers to be installed on the system.\n\nThis function initiates an acquisition, waits for it to complete, and performs the specified waveform measurement for a single channel and record or for multiple channels and records.\n\nMany of the measurements use the low, mid, and high reference levels.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PCI-5122 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Scope functions, Jabil Test will fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\n($ErrorCode, $resultArray) = NI_Scope_ReadMeasurement($NI_ScopeHandle, $measureChannel, $measureTimeOut, $scalarMeasureType);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_ScopeHandle\n\nObject\n\nThe instrument handle you obtain from NI_Scope_Initialize that identifies a particular instrument's session.\n\n\n\n$measureChannel\n\nString\n\nThe channel you will acquire data from; it may be a single channel, such as \"0\" or \"1\", or a list of channels such as \"0,1\".\n\n\n\n$measureTimeOut\n\nDouble\n\nThe time to wait in seconds for data to be acquired. Using 0 for this parameter tells NI-SCOPE to fetch whatever is currently available.\n\n\n\n$scalarMeasureType\n\nString\n\nThe scalar measurement to be performed (see below for more information). Possible values:\n\n\u00b7 \"AC ESTIMATE\"\n\n\u00b7 \"DC ESTIMATE\"\n\n\u00b7 \"FFT AMPLITUDE\"\n\n\u00b7 \"VOLTAGE CYCLE RMS\"\n\n\u00b7 \"VOLTAGE RMS\"\n\n\u00b7 \"VOLTAGE AVERAGE\"\n\n\u00b7 \"VOLTAGE CYCLE AVERAGE\"\n\n\u00b7 \"AREA\"\n\n\u00b7 \"INTEGRAL\"\n\n\u00b7 \"CYCLE AREA\"\n\n\u00b7 \"VOLTAGE MIN\"\n\n\u00b7 \"VOLTAGE LOW\"\n\n\u00b7 \"VOLTAGE MAX\"\n\n\u00b7 \"VOLTAGE HIGH\"\n\n\u00b7 \"VOLTAGE PEAK TO PEAK\"\n\n\u00b7 \"VOLTAGE AMPLITUDE\"\n\n\u00b7 \"VOLTAGE BASE\"\n\n\u00b7 \"VOLTAGE TOP\"\n\n\u00b7 \"VOLTAGE BASE TO TOP\"\n\n\u00b7 \"OVERSHOOT\"\n\n\u00b7 \"PRESHOOT\"\n\n\u00b7 \"LOW REF VOLTAGE\"\n\n\u00b7 \"MID REF VOLTAGE\"\n\n\u00b7 \"HIGH REF VOLTAGE\"\n\n\u00b7 \"FALL TIME\"\n\n\u00b7 \"DUTY CYCLE POS\"\n\n\u00b7 \"DUTY CYCLE NEG\"\n\n\u00b7 \"FALL SLEW RATE\"\n\n\u00b7 \"RISE TIME\"\n\n\u00b7 \"WIDTH NEG\"\n\n\u00b7 \"RISE SLEW RATE\"\n\n\u00b7 \"WIDTH POS\"\n\n\u00b7 \"PHASE DELAY\"\n\n\u00b7 \"TIME DELAY\"\n\n\u00b7 \"AVERAGE FREQUENCY\"\n\n\u00b7 \"FFT FREQUENCY\"\n\n\u00b7 \"AVERAGE PERIOD\"\n\n\u00b7 \"FREQUENCY\"\n\n\u00b7 \"PERIOD\"\n\n\u00b7 \"TIME HISTOGRAM HITS\"\n\n\u00b7 \"TIME HISTOGRAM MEAN PLUS 3 STDEV\"\n\n\u00b7 \"TIME HISTOGRAM MAX\"\n\n\u00b7 \"TIME HISTOGRAM MEDIAN\"\n\n\u00b7 \"TIME HISTOGRAM MEAN\"\n\n\u00b7 \"TIME HISTOGRAM MIN\"\n\n\u00b7 \"TIME HISTOGRAM PEAK TO PEAK\"\n\n\u00b7 \"TIME HISTOGRAM MODE\"\n\n\u00b7 \"TIME HISTOGRAM MEAN PLUS STDEV\"\n\n\u00b7 \"TIME HISTOGRAM NEW HITS\"\n\n\u00b7 \"TIME HISTOGRAM MEAN PLUS 2 STDEV\"\n\n\u00b7 \"TIME HISTOGRAM STDEV\"\n\n\u00b7 \"VOLTAGE HISTOGRAM HITS\"\n\n\u00b7 \"VOLTAGE HISTOGRAM MEAN PLUS 3 STDEV\"\n\n\u00b7 \"VOLTAGE HISTOGRAM MAX\"\n\n\u00b7 \"VOLTAGE HISTOGRAM MEDIAN\"\n\n\u00b7 \"VOLTAGE HISTOGRAM MEAN\"\n\n\u00b7 \"VOLTAGE HISTOGRAM MIN\"\n\n\u00b7 \"VOLTAGE HISTOGRAM PEAK TO PEAK\"\n\n\u00b7 \"VOLTAGE HISTOGRAM MODE\"\n\n\u00b7 \"VOLTAGE HISTOGRAM MEAN PLUS STDEV\"\n\n\u00b7 \"VOLTAGE HISTOGRAM NEW HITS\"\n\n\u00b7 \"VOLTAGE HISTOGRAM MEAN PLUS 2 STDEV\"\n\n\u00b7 \"VOLTAGE HISTOGRAM STDEV\"\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\nInteger\n\nReports the status of this operation. To obtain a text description of the status code, call NI_Scope_ErrorMessage. To obtain additional information concerning the error condition, use NI_Scope_GetError and NI_Scope_ClearError. The general meaning of the status code is as:\n\n\u00b7 0: success\n\n\u00b7 Positive value: warning\n\n\u00b7 Negative value: errors\n\n\n\n$resultArray\n\nArray\n\nContains an array of all measurements acquired; call NI_Scope_ActualNumWfms to determine the array length.\n\n\n\n\n\nExtra information of the scalar measurement types:\n\nRMS Voltage Measurements\n\n\n\nMeasurement\n\nDescription\n\nUnits\n\n\n\nAC Estimate\n\nThe DC estimate is subtracted from the waveform, and a Hanning window is applied to give a \"processed waveform.\" The RMS voltage is calculated with the following equation:\n\nsqrt ( [\u03a3 processed waveform[i]^2] / [numPoints \u00d7 enbw \u00d7 cg^2] ),\n\nwhere the equivalent noise bandwidth (enbw) for the Hanning window is 1.5, and the coherent gain (cg) is 0.5.\n\nThis algorithm minimizes the effect of a noninteger number of waveform cycles in the measurement, which could arbitrarily increase or decrease the RMS value.\n\nVolts\n\nRMS\n\n\n\nVoltage Cycle RMS\n\nThe number of points in a period is calculated using the equation:\n\npointsPerPeriod = int (period / dt + 0.5),\n\nwhere dt is the time between two points and int is a function that returns the integer portion of a floating-point number.\n\nVolts\n\nRMS\n\n\n\nFFT Amplitude\n\nThe FFT amplitude spectrum is calculated using a split-radix real FFT, and the maximum amplitude is returned. If the input waveform size is not a power of two, the waveform is zero-padded to the next higher power of two. For best results, verify that your actual record length is a power of 2.\n\nVolts\n\nRMS\n\n\n\nVoltage RMS\n\nDetermined by the following True RMS equation:\n\nVoltage RMS = sqrt ( (\u03a3 waveform[i]^2) / numPoints)\n\nVolts\n\nRMS\n\n\n\n\n\nDC Voltage Measurements\n\n\n\nMeasurement\n\nDescription\n\nUnits\n\n\n\nVoltage Average\n\nDetermined by the following equation:\n\n\n\n\n\nVoltage Average = \u03a3 waveform[i] / numPoints\n\nVolts\n\n\n\n\n\nArea Measurements\n\n\n\nMeasurement\n\nDescription\n\nUnits\n\n\n\nArea\n\nDetermined by the following equation:\n\narea = voltage average \u00d7 numPoints \u00d7 delta time between two points\n\nVolt x seconds\n\n\n\nIntegral\n\nNumerical integration is done using Simpson's rule.\n\nVolt x seconds\n\n\n\nCycle area\n\nDetermined by the following equation:\n\nCycle area = voltage cycle average \u00d7 pointsPerPeriod \u00d7 dt\n\nwhere pointsPerPeriod is defined in the voltage cycle average description.\n\nVolt x seconds\n\n\n\n\n\nVoltage Extrema Measurements\n\n\n\nMeasurement\n\nDescription\n\nUnits\n\n\n\nVoltage Minimum\n\nThe waveform is searched for the minimum point.\n\nVolts\n\n\n\nVoltage Low\n\nThe last acquisition histogram method is used where the voltage low result is the voltage of the histogram bin with the maximum number of hits below 40% of the voltage peak-to-peak value of the waveform. This calculation is useful for ignoring the overshoot and preshoot on square waves.\n\nVolts\n\n\n\nVoltage Maximum\n\nThe waveform is searched for its maximum point.\n\nVolts\n\n\n\nVoltage High\n\nThe last histogram method is used where the voltage high result is the voltage of the histogram bin with the maximum number of hits above 60% of the voltage peak-to-peak value of the waveform. This calculation is useful for ignoring the overshoot and preshoot on square waves.\n\nVolts\n\n\n\nVoltage Peak to Peak\n\nThe maximum voltage minus the minimum voltage.\n\nVolts\n\n\n\nVoltage Amplitude\n\nThe voltage high minus the voltage low.\n\nVolts\n\n\n\nVoltage Base\n\nIf the histogram bin corresponding to voltage low has over 5% of the total hits, the voltage low result is returned. Otherwise, the voltage minimum calculation is returned. This allows using the voltage base to get a reasonable answer for either a square wave (ignoring the overshoot and preshoot) or a triangle wave (where a histogram fails).\n\nVolts\n\n\n\nVoltage Top\n\nIf the histogram bin corresponding to voltage high has over 5% of the total hits, the voltage high result is returned. Otherwise, the voltage maximum calculation is returned. This allows using the voltage top to get a reasonable answer for either a square wave (ignoring the overshoot and preshoot) or a triangle wave (where a histogram fails).\n\nVolts\n\n\n\nVoltage Base to Base\n\nVoltage top minus voltage base.\n\nVolts\n\n\n\nOvershoot\n\nThe measurement is done on the first edge of the waveform. If two edges exist, the algorithm finds the time interval from the first edge until one half the time to the second edge. The local maxima and minima are found in this interval. If only one edge is present in the waveform, the local maximum and minimum is found between the first edge and the end of the waveform.\n\nIf the first edge is positive sloped, overshoot = 100 \u00d7 (local maximum \u2013 voltage high) / voltage amplitude.\n\n\n\n\n\nIf the first edge is negative sloped, overshoot = 100 \u00d7 (voltage low \u2013 local minimum) / voltage amplitude.\n\n\n\nVolts\n\n\n\nPreshoot\n\nThe measurement is done on the second edge of the waveform if two edges exist. The algorithm finds the time interval from the middle time between the two edges until the second edge. The local maxima and minima are found in this interval. If only one edge is present in the waveform, the local maximum and minimum are found from the start of the waveform to the first edge.\n\nIf the edge is negative sloped, preshoot = 100 \u00d7 (local maximum \u2013 voltage high) / voltage amplitude.\n\n\n\n\n\nIf the edge is positive sloped, preshoot = 100 \u00d7 (voltage low \u2013 local minimum) / voltage amplitude.\n\n\n\nVolts\n\n\n\n\n\nReference Level Measurements\n\n\n\nMeasurement\n\nDescription\n\nUnits\n\n\n\nLow-Reference Voltage\n\nThe voltage corresponding to the low reference level.\n\nVolts\n\n\n\nMid-Reference Voltage\n\nThe voltage corresponding to the mid reference level.\n\nVolts\n\n\n\nHigh-Reference Voltage\n\nThe voltage corresponding to the high reference level.\n\nVolts\n\n\n\n\n\nTime Measurements\n\n\n\nMeasurement\n\nDescription\n\nUnits\n\n\n\nFall Time\n\nThe time span in seconds from when the waveform crosses the high reference level until it crosses the low reference level. The measurement starts at the left edge of the waveform and finds all high reference level crossings until a low reference level crossing. The final high reference level crossing is used in the calculation.\n\n\n\nSeconds\n\n\n\nPositive Duty Cycle\n\nThe positive width divided by the period times 100.\n\nPercentage\n\n\n\nFall Slew Rate\n\nThe low reference voltage minus the high reference voltage is divided by the fall-time calculation. The result is always negative.\n\nVolts/Second\n\n\n\nRise Time\n\nThe time span from when the waveform crosses the low reference level until it crosses the high reference level in seconds. The measurement starts at the left edge of the waveform and finds all low reference level crossings until a high reference level crossing. The final low reference level crossing is used in the calculation.\n\n\n\nSeconds\n\n\n\nNegative Width\n\nThe time difference between the first two mid reference level crossings, where the slopes are negative and positive, respectively. A digital hysteresis is used when finding the crosspoints.\n\nSeconds\n\n\n\nRising Slew Rate\n\nThe high reference voltage minus the low reference voltage is divided by the rise-time calculation.\n\nVolts/Second\n\n\n\nPositive Width\n\nThe time difference in seconds between the first two mid reference level crossings, where the slopes are positive and negative respectively. A digital hysteresis is used when finding the crosspoints.\n\nSeconds\n\n\n\nNegative Duty Cycle\n\nThe negative width divided by the period times 100.\n\nPercentage\n\n\n\n\n\nTwo-channel Measurements (scalar)\n\n\n\nMeasurement\n\nDescription\n\nUnits\n\n\n\nPhase Delay\n\nThe time delay divided by the period (of the waveform on the channel specified by the measurement function) times 360 degrees.\n\nDegrees\n\n\n\nTime Delay\n\nThe time delay is the time between two edges with the same slope. The mid reference level is stored on a per channel basis, and mid reference levels do not need to be the same. All reference levels use a digital hysteresis.\n\nSeconds\n\n\n\n\n\nPeriod and Frequency Measurements\n\n\n\nMeasurement\n\nDescription\n\nUnits\n\n\n\nFrequency\n\n1.0 divided by the period.\n\nHertz\n\n\n\nPeriod\n\nFinds the time between the first and third mid reference level crosspoints in seconds. A hysteresis window is applied when finding crosspoints. The mid reference level is 50% by default.\n\nSeconds\n\n\n\nAverage Frequency\n\n1.0 divided by the average period.\n\nHertz\n\n\n\nAverage Period\n\nUp to 256 mid reference level crossings are found on the waveform, using a digital hysteresis. The time difference between the last crossing and the first crossing is divided by the number of periods found in the waveform. The last crossing is defined as the last crossing in the waveform with the same slope as the first crossing, so an integer number of periods exist in the waveform.\n\nSeconds\n\n\n\nFFT Frequency\n\nThe FFT amplitude spectrum is calculated using a split-radix real FFT, and the frequency corresponding to the maximum amplitude is returned. If the input waveform size is not a power of two, the waveform is zero padded to the next higher power of two. The frequency resolution is sampling rate / number of points. The DC bin of the FFT is ignored when searching for the maximum amplitude, so the FFT frequency should ignore any DC offsets. However, the zero padding used in the FFT measurement can introduce other low-frequency components if the waveform has a large DC offset. To eliminate the effects of zero-padding, verify that your actual record length is a power of 2.\n\nHertz\n\n\n\n\n\nTime Histogram Measurements\n\n\n\nMeasurement\n\nDescription\n\nUnits\n\n\n\nHits\n\nNumber of points in the histogram.\n\n-\n\n\n\nNew Hits\n\nNumber of points added to the histogram by the most recent acquisition.\n\n-\n\n\n\nMaximum\n\nThe highest bin value with at least one hit.\n\nSeconds\n\n\n\nMinimum\n\nThe lowest bin value with at least one hit.\n\nSeconds\n\n\n\nMean\n\nHistogram Mean = [ \u03a3 (bin hits \u00d7 bin value) ] / total hits.\n\nThe bin value is the center time value of the histogram bin.\n\nSeconds\n\n\n\nMedian\n\nThe bin value where half the histogram hits are above it and half the histogram hits are below.\n\nSeconds\n\n\n\nMode\n\nThe bin value with the most hits. If there is a tie, the lower time value is returned.\n\nSeconds\n\n\n\nPeak-to-Peak\n\nHistogram maximum minus the histogram minimum.\n\nSeconds\n\n\n\nMean Plus 2 Standard Deviations\n\nThe percentage of hits in the histogram between the mean minus two times the standard deviation and the mean plus two times the standard deviation. The percentage is returned in the range 0\u2013100.\n\nPercentage\n\n\n\nMean Plus 3 Standard Deviations\n\nThe percentage of hits in the histogram between the mean minus three times the standard deviation and the mean plus three times the standard deviation. The percentage is returned in the range 0\u2013100.\n\nPercentage\n\n\n\nStandard Deviation\n\n\n\nSeconds\n\n\n\n\n\nVoltage Histogram Measurements\n\n\n\nMeasurement\n\nDescription\n\nUnits\n\n\n\nHits\n\nNumber of points in the histogram.\n\n-\n\n\n\nNew Hits\n\nNumber of points added to the histogram by the most recent acquisition.\n\n-\n\n\n\nMaximum\n\nThe highest bin value with at least one hit.\n\nSeconds\n\n\n\nMinimum\n\nThe lowest bin value with at least one hit.\n\nSeconds\n\n\n\nMean\n\nHistogram Mean = [ \u03a3 (bin hits \u00d7 bin value) ] / total hits.\n\nThe bin value is the center time value of the histogram bin.\n\nSeconds\n\n\n\nMedian\n\nThe bin value where half the histogram hits are above it and half the histogram hits are below.\n\nSeconds\n\n\n\nMode\n\nThe bin value with the most hits. If there is a tie, the lower voltage value is returned.\n\nSeconds\n\n\n\nPeak-to-Peak\n\nHistogram maximum minus the histogram minimum.\n\nSeconds\n\n\n\nStandard Deviation\n\n\n\nSeconds\n\n\n\nMean Plus 2 Standard Deviations\n\nThe percentage of hits in the histogram between the mean minus two times the standard deviation and the mean plus two times the standard deviation. The percentage is returned in the range 0\u2013100.\n\nPercentage\n\n\n\nMean Plus 3 Standard Deviations\n\nThe percentage of hits in the histogram between the mean minus three times the standard deviation and the mean plus three times the standard deviation. The percentage is returned in the range 0\u2013100.\n\nPercentage\n\n\n\n\n\nExample:\n\n$channelName = New(\"String\", \"0,1\");\n\n$timeOut = New(\"Float\", 5.0);\n\n$measureType = New(\"String\", \"FREQUENCY\");\n\n($ErrorCode, $resultArray) = NI_Scope_ReadMeasurement($NI_ScopeHandle, $channelName, $timeOut, $measureType);\n\n($ErrorCode, $numWfms) = NI_Scope_ActualNumWfms($NI_ScopeHandle, $channelName);\n\nUpdateStatus($numWfms);\n\n// Get desired array value\n\n$result = ArrayGetValue($resultArray, 0, 0);\n\nUpdateStatus($result);\n\n$result = ArrayGetValue($resultArray, 0, 1);\n\nUpdateStatus($result);\n\n\n\n\n\nNI_Scope_Close\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_Scope_Close": {
  "prefix": "NI_Scope_Close",
  "body": [
   "$$ErrorCode=NI_Scope_Close($$NI_ScopeHandle);"
  ],
  "description": "\n\nThis function requires NI Scope drivers to be installed on the system.\n\nThis function closes the session and deallocates any resources the session used. Closing the session is important because it releases any temporary buffers that were created to transfer data between the digitizer and the host memory.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PCI-5122 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Scope functions, Jabil Test will fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\n$ErrorCode = NI_Scope_Close($NI_ScopeHandle);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_ScopeHandle\n\nObject\n\nThe instrument handle you obtain from NI_Scope_Initialize that identifies a particular instrument's session.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\nInteger\n\nReports the status of this operation. To obtain a text description of the status code, call NI_Scope_ErrorMessage. To obtain additional information concerning the error condition, use NI_Scope_GetError and NI_Scope_ClearError. The general meaning of the status code is as:\n\n\u00b7 0: success\n\n\u00b7 Positive value: warning\n\n\u00b7 Negative value: errors\n\n\n\n\n\nExample:\n\n$ErrorCode = NI_Scope_Close($NI_ScopeHandle);\n\n\n\n\n\nNI_Scope_Initialize\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_Scope_Initialize": {
  "prefix": "NI_Scope_Initialize",
  "body": [
   "($$ErrorCode,$$NI_ScopeHandle)=NI_Scope_Initialize($$resourceName,$$IDQuery,$$resetDevice);"
  ],
  "description": "\n\nThis function requires NI Scope drivers to be installed on the system.\n\nBecause you can have multiple digitizers connected to your computer, you must tell NI-SCOPE which digitizer to communicate with by opening a session to the digitizer with an Initialize function. A session establishes a connection between the digitizer and your application. After this connection is established, the digitizer can transmit data to your application. Sessions allow the driver to cache previous settings, which greatly improves performance.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PCI-5122 device.\n\n\u00b7 When you run your application, you must use the resource name assigned by Measurement & Automation Explorer (MAX). Find or set the resource name for your digitizer by launching MAX and selecting Devices and Interfaces.\n\n\u00b7 Setting the ID Query parameter to TRUE has no effect with NI-SCOPE. NI-SCOPE automatically verifies that the digitizer you initialize is a type it supports therefore, setting this parameter to TRUE is not necessary.\n\n\u00b7 Setting the Reset Device parameter to TRUE resets the digitizer during initialization.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Scope functions, Jabil Test will fail and return the error message.\n\n\n\nResult:\n\n($ErrorCode, $NI_ScopeHandle) = NI_Scope_Initialize($resourceName, $IDQuery, $resetDevice);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$resourceName\n\nString\n\nSpecifies the resource name of the device to initialize. This value has to be the same as the name in the Measurement & Automation Explorer.\n\n\n\n$IDQuery\n\nBoolean\n\nSpecify whether you want NI-SCOPE to perform an ID query.\n\nWhen you set this parameter to true, NI-SCOPE verifies that the device you initialize is a type that it supports. When you set this parameter to false, the function initializes the device without performing an ID query.\n\nValid values :\n\nTrue : Perform ID query.\n\nFalse : Do not perform ID query.\n\n\n\n$resetDevice\n\nBoolean\n\nSpecify whether you want to reset the device during the initialization procedure.\n\nValid values :\n\nTrue : Reset the device.\n\nFalse : Do not reset the device.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\nInteger\n\nReports the status of this operation. To obtain a text description of the status code, call NI_Scope_ErrorMessage. To obtain additional information concerning the error condition, use NI_Scope_GetError and NI_Scope_ClearError. The general meaning of the status code is as:\n\n\u00b7 0: success\n\n\u00b7 Positive value: warning\n\n\u00b7 Negative value: errors\n\n\n\n$NI_ScopeHandle\n\nObject\n\nReturns a session handle that you can use to identify the device in all subsequent NI-SCOPE function calls.\n\n\n\n\n\nExample:\n\n($ErrorCode, $NI_ScopeHandle) = NI_Scope_Initialize(\"Dev1\", \"false\", \"false\");\n\n\n\n\n\nNI_Scope_InitializeWithOptions\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_Scope_InitializeWithOptions": {
  "prefix": "NI_Scope_InitializeWithOptions",
  "body": [
   "($$ErrorCode,$$NI_ScopeHandle)=NI_Scope_InitializeWithOptions($$resourceName,$$IDQuery,$$resetDevice,$$options);"
  ],
  "description": "\n\nThis function requires NI Scope drivers to be installed on the system.\n\nBecause you can have multiple digitizers connected to your computer, you must tell NI-SCOPE which digitizer to communicate with by opening a session to the digitizer with an Initialize function. A session establishes a connection between the digitizer and your application. After this connection is established, the digitizer can transmit data to your application. Sessions allow the driver to cache previous settings, which greatly improves performance.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PCI-5122 device.\n\n\u00b7 When you run your application, you must use the resource name assigned by Measurement & Automation Explorer (MAX). Find or set the resource name for your digitizer by launching MAX and selecting Devices and Interfaces.\n\n\u00b7 Setting the ID Query parameter to TRUE has no effect with NI-SCOPE. NI-SCOPE automatically verifies that the digitizer you initialize is a type it supports therefore, setting this parameter to TRUE is not necessary.\n\n\u00b7 Setting the Reset Device parameter to TRUE resets the digitizer during initialization.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Scope functions, Jabil Test will fail and return the error message.\n\n\n\nResult:\n\n($ErrorCode, $NI_ScopeHandle) = NI_Scope_InitializeWithOptions($resourceName, $IDQuery, $resetDevice, $options);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$resourceName\n\nString\n\nSpecifies the resource name of the device to initialize. This value has to be the same as the name in the Measurement & Automation Explorer.\n\n\n\n$IDQuery\n\nBoolean\n\nSpecify whether you want NI-SCOPE to perform an ID query.\n\nWhen you set this parameter to true, NI-SCOPE verifies that the device you initialize is a type that it supports. When you set this parameter to false, the function initializes the device without performing an ID query.\n\nValid values :\n\nTrue : Perform ID query.\n\nFalse : Do not perform ID query.\n\n\n\n$resetDevice\n\nBoolean\n\nSpecify whether you want to reset the device during the initialization procedure.\n\nValid values :\n\nTrue : Reset the device.\n\nFalse : Do not reset the device.\n\n\n\n$options\n\nString\n\nSpecifies initialization commands, like:\n\n\u00b7 RangeCheck\n\n\u00b7 QueryInstrStatus\n\n\u00b7 Cache\n\n\u00b7 Simulate\n\n\n\n\n\nDefault value: \"Simulate=0,RangeCheck=1,QueryInstrStatus=1,Cache=1\"\n\n\n\n\n\n1 means true, 0 means fails.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\nInteger\n\nReports the status of this operation. To obtain a text description of the status code, call NI_Scope_ErrorMessage. To obtain additional information concerning the error condition, use NI_Scope_GetError and NI_Scope_ClearError. The general meaning of the status code is as:\n\n\u00b7 0: success\n\n\u00b7 Positive value: warning\n\n\u00b7 Negative value: errors\n\n\n\n$NI_ScopeHandle\n\nObject\n\nReturns a session handle that you can use to identify the device in all subsequent NI-SCOPE function calls.\n\n\n\n\n\nExample:\n\n($ErrorCode, $NI_ScopeHandle) = NI_Scope_InitializeWithOptions(\"Dev1\", \"false\", \"false\", \"Simulate=0,RangeCheck=1,QueryInstrStatus=1,Cache=1\");\n\n\n\n\n\nFetch PAL colorbar\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_Scope_ClearInterchangeWarnings": {
  "prefix": "NI_Scope_ClearInterchangeWarnings",
  "body": [
   "$$ErrorCode=NI_Scope_ClearInterchangeWarnings($$NI_ScopeHandle);"
  ],
  "description": "\n\nThis function requires NI Scope drivers to be installed on the system.\n\nThis function clears the list of current interchange warnings.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PCI-5122 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Scope functions, Jabil Test will fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\n$ErrorCode = NI_Scope_ClearInterchangeWarnings($NI_ScopeHandle);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_ScopeHandle\n\nObject\n\nThe instrument handle you obtain from NI_Scope_Initialize that identifies a particular instrument's session.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\nInteger\n\nReports the status of this operation. To obtain a text description of the status code, call NI_Scope_ErrorMessage. To obtain additional information concerning the error condition, use NI_Scope_GetError and NI_Scope_ClearError. The general meaning of the status code is as:\n\n\u00b7 0: success\n\n\u00b7 Positive value: warning\n\n\u00b7 Negative value: errors\n\n\n\n\n\nExample:\n\n$ErrorCode = NI_Scope_ClearInterchangeWarnings($NI_ScopeHandle);\n\n\n\n\n\nNI_Scope_Disable\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_Scope_Disable": {
  "prefix": "NI_Scope_Disable",
  "body": [
   "$$ErrorCode=NI_Scope_Disable($$NI_ScopeHandle);"
  ],
  "description": "\n\nThis function requires NI Scope drivers to be installed on the system.\n\nAborts any current operation, opens data channel relays, and releases RTSI and PFI lines. Places the instrument in a quiescent state where it has minimal or no impact on the system to which it is connected. If a measurement is in progress when Disable is called, the measurement is aborted.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PCI-5122 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Scope functions, Jabil Test will fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\n$ErrorCode = NI_Scope_Disable($NI_ScopeHandle);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_ScopeHandle\n\nObject\n\nThe instrument handle you obtain from NI_Scope_Initialize that identifies a particular instrument's session.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\nInteger\n\nReports the status of this operation. To obtain a text description of the status code, call NI_Scope_ErrorMessage. To obtain additional information concerning the error condition, use NI_Scope_GetError and NI_Scope_ClearError. The general meaning of the status code is as:\n\n\u00b7 0: success\n\n\u00b7 Positive value: warning\n\n\u00b7 Negative value: errors\n\n\n\n\n\nExample:\n\n$ErrorCode = NI_Scope_Disable($NI_ScopeHandle);\n\n\n\n\n\nNI_Scope_GetChannelName\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_Scope_GetChannelName": {
  "prefix": "NI_Scope_GetChannelName",
  "body": [
   "($$ErrorCode,$$channelString)=NI_Scope_GetChannelName($$NI_ScopeHandle,$$index);"
  ],
  "description": "\n\nThis function requires NI Scope drivers to be installed on the system.\n\nThis function returns the channel string that is in the channel table at an index you specify.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PCI-5122 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Scope functions, Jabil Test will fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\n($ErrorCode, $channelString) = NI_Scope_GetChannelName($NI_ScopeHandle, $index);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_ScopeHandle\n\nObject\n\nThe instrument handle you obtain from NI_Scope_Initialize that identifies a particular instrument's session.\n\n\n\n$index\n\nInteger\n\nA 1-based index into the channel table.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\nInteger\n\nReports the status of this operation. To obtain a text description of the status code, call NI_Scope_ErrorMessage. To obtain additional information concerning the error condition, use NI_Scope_GetError and NI_Scope_ClearError. The general meaning of the status code is as:\n\n\u00b7 0: success\n\n\u00b7 Positive value: warning\n\n\u00b7 Negative value: errors\n\n\n\n$channelString\n\nString\n\nReturns the channel string that is in the channel table at the index you specify. Do not modify the contents of the channel string.\n\n\n\n\n\nExample:\n\n($ErrorCode, $channelString) = NI_Scope_GetChannelName($NI_ScopeHandle, $index);\n\n\n\n\n\nNI_Scope_ProbeCompensationSignalStart\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_Scope_ProbeCompensationSignalStart": {
  "prefix": "NI_Scope_ProbeCompensationSignalStart",
  "body": [
   "$$ErrorCode=NI_Scope_ProbeCompensationSignalStart($$NI_ScopeHandle);"
  ],
  "description": "\n\nThis function requires NI Scope drivers to be installed on the system.\n\nStarts the 1 kHz square wave output on PFI 1 for probe compensation.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PCI-5122 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Scope functions, Jabil Test will fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\n$ErrorCode = NI_Scope_ProbeCompensationSignalStart($NI_ScopeHandle);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_ScopeHandle\n\nObject\n\nThe instrument handle you obtain from NI_Scope_Initialize that identifies a particular instrument's session.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\nInteger\n\nReports the status of this operation. To obtain a text description of the status code, call NI_Scope_ErrorMessage. To obtain additional information concerning the error condition, use NI_Scope_GetError and NI_Scope_ClearError. The general meaning of the status code is as:\n\n\u00b7 0: success\n\n\u00b7 Positive value: warning\n\n\u00b7 Negative value: errors\n\n\n\n\n\nExample:\n\n$ErrorCode = NI_Scope_ProbeCompensationSignalStart($NI_ScopeHandle);\n\n\n\n\n\nNI_Scope_ProbeCompensationSignalStop\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_Scope_ProbeCompensationSignalStop": {
  "prefix": "NI_Scope_ProbeCompensationSignalStop",
  "body": [
   "$$ErrorCode=NI_Scope_ProbeCompensationSignalStop($$NI_ScopeHandle);"
  ],
  "description": "\n\nThis function requires NI Scope drivers to be installed on the system.\n\nStops the 1 kHz square wave output on PFI 1 for probe compensation.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PCI-5122 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Scope functions, Jabil Test will fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\n$ErrorCode = NI_Scope_ProbeCompensationSignalStop($NI_ScopeHandle);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_ScopeHandle\n\nObject\n\nThe instrument handle you obtain from NI_Scope_Initialize that identifies a particular instrument's session.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\nInteger\n\nReports the status of this operation. To obtain a text description of the status code, call NI_Scope_ErrorMessage. To obtain additional information concerning the error condition, use NI_Scope_GetError and NI_Scope_ClearError. The general meaning of the status code is as:\n\n\u00b7 0: success\n\n\u00b7 Positive value: warning\n\n\u00b7 Negative value: errors\n\n\n\n\n\nExample:\n\n$ErrorCode = NI_Scope_ProbeCompensationSignalStop($NI_ScopeHandle);\n\n\n\n\n\nNI_Scope_Reset\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_Scope_Reset": {
  "prefix": "NI_Scope_Reset",
  "body": [
   "$$ErrorCode=NI_Scope_Reset($$NI_ScopeHandle);"
  ],
  "description": "\n\nThis function requires NI Scope drivers to be installed on the system.\n\nResets the digitizer to its default state. Refer to your device documentation for the default state.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PCI-5122 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Scope functions, Jabil Test will fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\n$ErrorCode = NI_Scope_Reset($NI_ScopeHandle);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_ScopeHandle\n\nObject\n\nThe instrument handle you obtain from NI_Scope_Initialize that identifies a particular instrument's session.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\nInteger\n\nReports the status of this operation. To obtain a text description of the status code, call NI_Scope_ErrorMessage. To obtain additional information concerning the error condition, use NI_Scope_GetError and NI_Scope_ClearError. The general meaning of the status code is as:\n\n\u00b7 0: success\n\n\u00b7 Positive value: warning\n\n\u00b7 Negative value: errors\n\n\n\n\n\nExample:\n\n$ErrorCode = NI_Scope_Reset($NI_ScopeHandle);\n\n\n\n\n\nNI_Scope_ResetDevice\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_Scope_ResetDevice": {
  "prefix": "NI_Scope_ResetDevice",
  "body": [
   "$$ErrorCode=NI_Scope_ResetDevice($$NI_ScopeHandle);"
  ],
  "description": "\n\nThis function requires NI Scope drivers to be installed on the system.\n\nPerforms a hard reset of the device. Acquisition stops, all routes are released, RTSI and PFI lines are tri-stated, hardware is configured to its default state, and all session attributes are reset to their default state.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PCI-5122 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Scope functions, Jabil Test will fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\n$ErrorCode = NI_Scope_ResetDevice($NI_ScopeHandle);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_ScopeHandle\n\nObject\n\nThe instrument handle you obtain from NI_Scope_Initialize that identifies a particular instrument's session.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\nInteger\n\nReports the status of this operation. To obtain a text description of the status code, call NI_Scope_ErrorMessage. To obtain additional information concerning the error condition, use NI_Scope_GetError and NI_Scope_ClearError. The general meaning of the status code is as:\n\n\u00b7 0: success\n\n\u00b7 Positive value: warning\n\n\u00b7 Negative value: errors\n\n\n\n\n\nExample:\n\n$ErrorCode = NI_Scope_ResetDevice($NI_ScopeHandle);\n\n\n\n\n\nNI_Scope_ResetInterchangeCheck\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_Scope_ResetInterchangeCheck": {
  "prefix": "NI_Scope_ResetInterchangeCheck",
  "body": [
   "$$ErrorCode=NI_Scope_ResetInterchangeCheck($$NI_ScopeHandle);"
  ],
  "description": "\n\nThis function requires NI Scope drivers to be installed on the system.\n\nWhen developing a complex test system that consists of multiple test modules, it is generally a good idea to design the test modules so that they can run in any order. To do so requires ensuring that each test module completely configures the state of each instrument it uses.\n\nIf a particular test module does not completely configure the state of an instrument, the state of the instrument depends on the configuration from a previously executed test module.\n\nIf you execute the test modules in a different order, the behavior of the instrument and therefore the entire test module is likely to change.\n\nThis change in behavior is generally instrument-specific and represents an interchangeability problem. You can use this function to test for such cases. After you call this function, the interchangeability checking algorithms in the specific driver ignore all previous configuration operations.\n\nBy calling this function at the beginning of a test module, you can determine whether the test module has dependencies on the operation of previously executed test modules.\n\nThis function does not clear the interchangeability warnings from the list of previously recorded interchangeability warnings. If you want to guarantee that NI_Scope_GetNextInterchangeWarning only returns those interchangeability warnings that are generated after calling this function, you must clear the list of interchangeability warnings.\n\nYou can clear the interchangeability warnings list by repeatedly calling NI_Scope_GetNextInterchangeWarning until no more interchangeability warnings are returned. If you are not interested in the content of those warnings, you can call NI_Scope_ClearInterchangeWarnings.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PCI-5122 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Scope functions, Jabil Test will fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\n$ErrorCode = NI_Scope_ResetInterchangeCheck($NI_ScopeHandle);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_ScopeHandle\n\nObject\n\nThe instrument handle you obtain from NI_Scope_Initialize that identifies a particular instrument's session.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\nInteger\n\nReports the status of this operation. To obtain a text description of the status code, call NI_Scope_ErrorMessage. To obtain additional information concerning the error condition, use NI_Scope_GetError and NI_Scope_ClearError. The general meaning of the status code is as:\n\n\u00b7 0: success\n\n\u00b7 Positive value: warning\n\n\u00b7 Negative value: errors\n\n\n\n\n\nExample:\n\n$ErrorCode = NI_Scope_ResetInterchangeCheck($NI_ScopeHandle);\n\n\n\n\n\nNI_Scope_ResetWithDefaults\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_Scope_ResetWithDefaults": {
  "prefix": "NI_Scope_ResetWithDefaults",
  "body": [
   "$$ErrorCode=NI_Scope_ResetWithDefaults($$NI_ScopeHandle);"
  ],
  "description": "\n\nThis function requires NI Scope drivers to be installed on the system.\n\nPerforms a software reset of the device, returning it to the default state and applying any initial default settings\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PCI-5122 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Scope functions, Jabil Test will fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\n$ErrorCode = NI_Scope_ResetWithDefaults($NI_ScopeHandle);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_ScopeHandle\n\nObject\n\nThe instrument handle you obtain from NI_Scope_Initialize that identifies a particular instrument's session.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\nInteger\n\nReports the status of this operation. To obtain a text description of the status code, call NI_Scope_ErrorMessage. To obtain additional information concerning the error condition, use NI_Scope_GetError and NI_Scope_ClearError. The general meaning of the status code is as:\n\n\u00b7 0: success\n\n\u00b7 Positive value: warning\n\n\u00b7 Negative value: errors\n\n\n\n\n\nExample:\n\n$ErrorCode = NI_Scope_ResetWithDefaults($NI_ScopeHandle);\n\n\n\n\n\nNI_Scope_RevisionQuery\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_Scope_RevisionQuery": {
  "prefix": "NI_Scope_RevisionQuery",
  "body": [
   "($$ErrorCode,$$instrumentDriverRevision,$$firmwareRevision)=NI_Scope_RevisionQuery($$NI_ScopeHandle);"
  ],
  "description": "\n\nThis function requires NI Scope drivers to be installed on the system.\n\nReturns the revision numbers of the instrument driver and instrument firmware.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PCI-5122 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Scope functions, Jabil Test will fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\n($ErrorCode, $InstrumentDriverRevision, $FirmwareRevision) = NI_Scope_RevisionQuery($NI_ScopeHandle);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_ScopeHandle\n\nObject\n\nThe instrument handle you obtain from NI_Scope_Initialize that identifies a particular instrument's session.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\nInteger\n\nReports the status of this operation. To obtain a text description of the status code, call NI_Scope_ErrorMessage. To obtain additional information concerning the error condition, use NI_Scope_GetError and NI_Scope_ClearError. The general meaning of the status code is as:\n\n\u00b7 0: success\n\n\u00b7 Positive value: warning\n\n\u00b7 Negative value: errors\n\n\n\n$instrumentDriverRevision\n\nString\n\nReturns the instrument driver software revision numbers.\n\n\n\n$firmwareRevision\n\nString\n\nReturns the instrument firmware revision numbers.\n\n\n\n\n\nExample:\n\n($ErrorCode, $instrumentDriverRevision, $firmwareRevision) = NI_Scope_RevisionQuery($NI_ScopeHandle);\n\n\n\n\n\nStringCompare($instrumentDriverRevision, \"Driver: NI-SCOPE 2.90, Model: NI PCI-5122, Compiler: MSVC 7.10, Engine: IVI 2.03, Compiler: MSVC 6.00, Components: VISA-Spec 3.00\");\n\n\n\n\n\nStringCompare($firmwareRevision, \"Product code: x28D0, product revision: 3, total memory bytes: 67108864, product serial: x00E39399, calibration map: 2, DFC FPGA: xDFCA00F6, mem 0 FPGA: x50419, mem 1 FPGA: x50419.\\n\");\n\n\n\n\n\nNI_Scope_SelfTest\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_Scope_SelfTest": {
  "prefix": "NI_Scope_SelfTest",
  "body": [
   "($$ErrorCode,$$SelfTestResult,$$selfTestMessage)=NI_Scope_SelfTest($$NI_ScopeHandle);"
  ],
  "description": "\n\nThis function requires NI Scope drivers to be installed on the system.\n\nRuns the instrument self-test routine and returns the test result(s).\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PCI-5122 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Scope functions, Jabil Test will fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\n($ErrorCode, $SelfTestResult, $selfTestMessage) = NI_Scope_SelfTest($NI_ScopeHandle);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_ScopeHandle\n\nObject\n\nThe instrument handle you obtain from NI_Scope_Initialize that identifies a particular instrument's session.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\nInteger\n\nReports the status of this operation. To obtain a text description of the status code, call NI_Scope_ErrorMessage. To obtain additional information concerning the error condition, use NI_Scope_GetError and NI_Scope_ClearError. The general meaning of the status code is as:\n\n\u00b7 0: success\n\n\u00b7 Positive value: warning\n\n\u00b7 Negative value: errors\n\n\n\n$SelfTestResult\n\nInteger\n\nThis control contains the value returned from the instrument self-test.\n\n\n\n$selfTestMessage\n\nString\n\nReturns the self-test response string from the instrument.\n\n\n\n\n\nExample:\n\n($ErrorCode, $SelfTestResult, $SelfTestString) = NI_Scope_SelfTest($NI_ScopeHandle);\n\n\n\nNumericLimitTest($SelfTestResult, 0, 0);\n\n\n\n\n\nStringCompare($SelfTestString, \"Scope Self Tests PASSED.\");\n\n\n\n\n\nTEKDPO4K_AutoProbeSenseValue\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS TEKDPO4K_AutoProbeSenseValue": {
  "prefix": "TEKDPO4K_AutoProbeSenseValue",
  "body": [
   "$$Attenuation=TEKDPO4K_AutoProbeSenseValue($$Handle,$$ChannelName);"
  ],
  "description": "\n\n\n\nThe function returns the probe attenuation value the oscilloscope senses.\n\n\n\n\n\nNote: If you disable the automatic probe sense capability, this function returns the manual probe attenuation setting.\n\n\n\n\n\nRequirements:\n\n\u00b7 This function requires the TekDPO4K IVI Driver as well as the National Instruments IVI Compliance Package to to be installed before using the instrument driver.\n\n\u00b7 This function requires NI-VISA version 3.5 or higher.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nThe handle of the instrument returned from the initialization function.\n\n\n\n$ChannelName\n\nString\n\nThe name of the channel to configure. Allowable values are:\n\n\u00b7 \"CH1\"\n\n\u00b7 \"CH2\"\n\n\u00b7 \"CH3\" (For 4 Channel Scopes)\n\n\u00b7 \"CH4\" (For 4 Channel Scopes)\n\n\u00b7 \"REF1\" Reference 1\n\n\u00b7 \"REF2\" Reference 2\n\n\u00b7 \"REF3\" Reference 3\n\n\u00b7 \"REF4\" Reference 4\n\n\u00b7 \"MATH\" Math\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Attenuation\n\nFloat\n\nThe attenuation level of the probe determined via the Oscilloscope's Autoprobe sensor. If Probe Autosense is disabled, this function returns the manual probe attenuation value.\n\n\n\n\n\nTEKDPO4K_AutoSetup\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS TEKDPO4K_AutoSetup": {
  "prefix": "TEKDPO4K_AutoSetup",
  "body": [
   "TEKDPO4K_AutoSetup($$Handle);"
  ],
  "description": "\n\n\n\nThis function automatically configures the instrument. When you call this function, the oscilloscope senses the input signal and automatically configures many of the instrument settings. The settings no longer match the cache values for the corresponding attributes. Therefore, this function invalidates all attribute cache values.This Function auto sets all active channels.\n\n\n\n\n\nNOTE: After Running Autosetup, you must pause the script for a few moments while the settings are applied. This function returns immediately after sending the autoscale command, and doesn't wait for it's completion.\n\n\n\n\n\nRequirements:\n\n\u00b7 This function requires the TekDPO4K IVI Driver as well as the National Instruments IVI Compliance Package to to be installed before using the instrument driver.\n\n\u00b7 This function requires NI-VISA version 3.5 or higher.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nThe handle of the instrument returned from the initialization function.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\nTEKDPO4K_AutoSetup($Handle);\n\n\n\n\n\nTEKDPO4K_Close\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS TEKDPO4K_Close": {
  "prefix": "TEKDPO4K_Close",
  "body": [
   "TEKDPO4K_Close($$Handle);"
  ],
  "description": "\n\n\n\nThis function closes and releases the instrument driver session. It also deallocates any memory resources the driver uses.\n\n\n\n\n\nRequirements:\n\n\u00b7 This function requires the TekDPO4K IVI Driver as well as the National Instruments IVI Compliance Package to to be installed before using the instrument driver.\n\n\u00b7 This function requires NI-VISA version 3.5 or higher.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nThe handle of the instrument returned from the initialization function.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\nTEKDPO4K_Close($Handle)\n\n\n\n\n\nTEKDPO4K_ConfigureAcquisitionRecord\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS TEKDPO4K_ConfigureAcquisitionRecord": {
  "prefix": "TEKDPO4K_ConfigureAcquisitionRecord",
  "body": [
   "TEKDPO4K_ConfigureAcquisitionRecord($$Handle,$$TimePerRecord,$$MinRecordLength,$$AcquisitonStartTime);"
  ],
  "description": "\n\n\n\nThis function configures the common attributes of the acquisition subsystem. These attributes are the time per record, minimum record length, and acquisition start time.\n\n\n\n\n\nRequirements:\n\n\u00b7 This function requires the TekDPO4K IVI Driver as well as the National Instruments IVI Compliance Package to to be installed before using the instrument driver.\n\n\u00b7 This function requires NI-VISA version 3.5 or higher.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nThe handle of the instrument returned from the initialization function.\n\n\n\n$TimePerRecord\n\nString\n\nThe time duration that corresponds to the record length. This is the horizontal time period.\n\n\n\n$MinRecordLength\n\nInteger\n\nThe minimum number of points you require in the waveform record for each channel.\n\n\n\n$AcquisitionStartTime\n\nFloat\n\nThe length of time from the trigger event to the first point in the waveform record. If the value is positive, the first point in the waveform occurs after the trigger event. If the value is negative, the first point in the waveform occurs before the trigger event.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\nTEKDPO4K_ConfigureAcquisitionRecord(0.000000001,10000,0);\n\n\n\n\n\nTEKDPO4K_ConfigureAcquisitionType\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS TEKDPO4K_ConfigureAcquisitionType": {
  "prefix": "TEKDPO4K_ConfigureAcquisitionType",
  "body": [
   "TEKDPO4K_ConfigureAcquisitionType($$Handle,$$AcquisitionType);"
  ],
  "description": "\n\n\n\nThis function configures how the oscilloscope acquires data and fills the waveform record.\n\n\n\nWhen you configure the acquisition type to Normal, HiRes or Average, the oscilloscope acquires only one waveform. To retrieve the waveform, you should use tkdpo4k_ReadWaveform or tkdpo4k_FetchWaveform functions.\n\n\n\nWhen you configure the acquisition type to Envelope or Peak Detect, the oscilloscope acquires minimum and maximum waveforms.\n\n\n\n\n\nRequirements:\n\n\u00b7 This function requires the TekDPO4K IVI Driver as well as the National Instruments IVI Compliance Package to to be installed before using the instrument driver.\n\n\u00b7 This function requires NI-VISA version 3.5 or higher.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nThe handle of the instrument returned from the initialization function.\n\n\n\n$AcquisitionType\n\nString\n\nThe acquisition type to configure. Allowable values are:\n\n\u00b7 \"NORMAL\"\n\n\u00b7 \"HIRES\"\n\n\u00b7 \"PEAKDETECT\"\n\n\u00b7 \"ENVELOPE\"\n\n\u00b7 \"AVERAGE\"\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\nTEKDPO4K_ConfigureNumAverages($TekScope,256);\n\n\n\n\n\nTEKDPO4K_ConfigureChannel\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS TEKDPO4K_ConfigureChannel": {
  "prefix": "TEKDPO4K_ConfigureChannel",
  "body": [
   "TEKDPO4K_ConfigureChannel($$Handle,$$ChannelName,$$VerticalRange,$$VerticalOffset,$$VerticalCoupling,$$ProbeAttenuation,$$ChannelEnabled);"
  ],
  "description": "\n\n\n\nThis function configures the common attributes of the channel subsystem for a particular channel. These attributes are the vertical range, vertical offset, coupling, probe attenuation, and channel enabled.\n\n\n\n\n\nRequirements:\n\n\u00b7 This function requires the TekDPO4K IVI Driver as well as the National Instruments IVI Compliance Package to to be installed before using the instrument driver.\n\n\u00b7 This function requires NI-VISA version 3.5 or higher.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nThe handle of the instrument returned from the initialization function.\n\n\n\n$ChannelName\n\nString\n\nThe name of the channel to configure. Allowable values are:\n\n\u00b7 \"CH1\"\n\n\u00b7 \"CH2\"\n\n\u00b7 \"CH3\" (For 4 Channel Scopes)\n\n\u00b7 \"CH4\" (For 4 Channel Scopes)\n\n\n\n$VerticalRange\n\nFloat\n\nThe value of the input range for the specified channel. To measure a sine wave that spans between 0 and 10 volts, pass 10.0 as the value of this parameter.\n\n\n\n$VerticalOffset\n\nFloat\n\nThe location of the center of the range that you specify with the vertical range parameter. Express the value relative to ground.\n\n\n\n$VerticalCoupling\n\nString\n\nSets the coupling mode. Allowable values are:\n\n\u00b7 \"AC\"\n\n\u00b7 \"DC\"\n\n\u00b7 \"GROUND\"\n\n\n\n$ProbeAttenuation\n\nFloat\n\nPasses the scaling factor by which the probe you attach to the channel attenuates the input. For example, when you use a 10:1 probe, set this parameter to 10.0.\n\n\n\n$ChannelEnabled\n\nBoolean\n\nSpecifies whether you want the oscillscope to acquire a waveform for the channel when you call the read measurement function.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n\n\n\n\nTEKDPO4K_ConfigureChannel($Handle,\"CH1\",10.0,0,\"GROUND\",1.0,\"TRUE\");\n\n\n\n\n\nTEKDPO4K_ConfigureChannelCharacteristics\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS TEKDPO4K_ConfigureChannelCharacteristics": {
  "prefix": "TEKDPO4K_ConfigureChannelCharacteristics",
  "body": [
   "TEKDPO4K_ConfigureChannelCharacteristics($$Handle,$$ChannelName,$$InputImpedance,MaxInputFrequency);"
  ],
  "description": "\n\n\n\nThis function configures the electrical characteristics of the channel subsystem for a particular channel. These attributes are the input impedance, and channel bandwidth.\n\n\n\n\n\nRequirements:\n\n\u00b7 This function requires the TekDPO4K IVI Driver as well as the National Instruments IVI Compliance Package to to be installed before using the instrument driver.\n\n\u00b7 This function requires NI-VISA version 3.5 or higher.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nThe handle of the instrument returned from the initialization function.\n\n\n\n$ChannelName\n\nString\n\nThe name of the channel to configure. Allowable values are:\n\n\u00b7 \"CH1\"\n\n\u00b7 \"CH2\"\n\n\u00b7 \"CH3\" (For 4 Channel Scopes)\n\n\u00b7 \"CH4\" (For 4 Channel Scopes)\n\n\n\n$InputImpedance\n\nFloat\n\nThe input impedance of the channel measured in OHMS. Valid values are:\n\n\u00b7 50\n\n\u00b7 1000000\n\n\n\n\n\n$MaxFrequency\n\nFloat\n\nThe maximum input frequency of the channel in Hertz. Any AC component above this frequency will be rolled off by a minimum of 3 Db.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n\n\n\n\nTEKDPO4K_ConfigureChannelCharacteristics($Handle,\"CH1\",50,20000000);\n\n\n\n\n\nTEKDPO4K_ConfigureEdgeTriggerSource\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS TEKDPO4K_ConfigureEdgeTriggerSource": {
  "prefix": "TEKDPO4K_ConfigureEdgeTriggerSource",
  "body": [
   "TEKDPO4K_ConfigureEdgeTriggerSource($$Handle,$$ChannelSource,$$TriggerVolts,$$TriggerSlope);"
  ],
  "description": "\n\n\n\nThis function configures the edge trigger. An edge trigger occurs when the trigger signal passes through the voltage threshold that you specify with the trigger level parameter, and has the slope that you specify with the trigger slope parameter.\n\n\n\n\n\nIf the current trigger mode is not set to \"EDGE\" mode, then this function has no effect on the trigger operation.\n\n\n\n\n\nRequirements:\n\n\u00b7 This function requires the TekDPO4K IVI Driver as well as the National Instruments IVI Compliance Package to to be installed before using the instrument driver.\n\n\u00b7 This function requires NI-VISA version 3.5 or higher.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nThe handle of the instrument returned from the initialization function.\n\n\n\n$ChannelSource\n\nInteger\n\nThe name of the channel to use for a trigger. Allowable values are:\n\n\u00b7 \"CH1\"\n\n\u00b7 \"CH2\"\n\n\u00b7 \"CH3\" (For 4 Channel Scopes)\n\n\u00b7 \"CH4\" (For 4 Channel Scopes)\n\n\n\n$TriggerVoltage\n\nFloat\n\nThe trigger voltage threshold.\n\n\n\n$TriggerSlope\n\nString\n\nThe slope for the trigger. Allowable values are:\n\n\u00b7 \"RISING\"\n\n\u00b7 \"FALLING\"\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\nTEKDPO4K_ConfigureEdgeTriggerSource($TekScope,\"CH1\",\"2.5\",\"RISING\");\n\n\n\n\n\nTEKDPO4K_ConfigureInitiateContinuous\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS TEKDPO4K_ConfigureInitiateContinuous": {
  "prefix": "TEKDPO4K_ConfigureInitiateContinuous",
  "body": [
   "TEKDPO4K_ConfigureInitiateContinuous($$Handle,$$Enabled);"
  ],
  "description": "\n\nThis function configures the oscilloscope to perform a continuous acquisition.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nThe handle of the instrument returned from the initialization function.\n\n\n\n$Enabled\n\nBoolean\n\nIf this variable is set to true, the scope will acquire continuously, otherwise the scope is set to the idle mode.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\nTEKDPO4K_ConfigureInitiateContinuous($Handle,\"TRUE\");\n\n\n\n\n\nTEKDPO4K_ConfigureNumAverages\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS TEKDPO4K_ConfigureNumAverages": {
  "prefix": "TEKDPO4K_ConfigureNumAverages",
  "body": [
   "TEKDPO4K_ConfigureNumAverages($$Handle,$$NumAverages);"
  ],
  "description": "\n\n\n\nThis function configures the number of waveforms that the oscilloscope acquires and averages. After the oscilloscope acquires as many waveforms as you specify, it returns to the idle state.\n\n\n\n\n\nThis function only takes affect if the acquisition mode of the scope is set to \"Averaging\".\n\n\n\n\n\nRequirements:\n\n\u00b7 This function requires the TekDPO4K IVI Driver as well as the National Instruments IVI Compliance Package to to be installed before using the instrument driver.\n\n\u00b7 This function requires NI-VISA version 3.5 or higher.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nThe handle of the instrument returned from the initialization function.\n\n\n\n$NumAverages\n\nInteger\n\nThe number of samples to average. This must be a power of 2 value between 2 and 512 (ex. 2,4,8,16...etc)\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\nTEKDPO4K_ConfigureNumAverages($TekScope,256);\n\n\n\n\n\nTEKDPO4K_ConfigureReferenceLevels\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS TEKDPO4K_ConfigureReferenceLevels": {
  "prefix": "TEKDPO4K_ConfigureReferenceLevels",
  "body": [
   "TEKDPO4K_ConfigureReferenceLevels($$Handle,$$LowRefLevel,$$MidRefLevel,$$HighRefLevel);"
  ],
  "description": "\n\n\n\nThis function configures the reference levels for waveform measurements. You must call this function before you call the TEKDPO4K_ReadWaveFormMeasurement function if you want to measure rise time, fall time, width negative, width positive, duty cycle negative, or duty cycle positive parameters.\n\n\n\n\n\nRequirements:\n\n\u00b7 This function requires the TekDPO4K IVI Driver as well as the National Instruments IVI Compliance Package to to be installed before using the instrument driver.\n\n\u00b7 This function requires NI-VISA version 3.5 or higher.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nThe handle of the instrument returned from the initialization function.\n\n\n\n$LowRefLevel\n\nFloat\n\nThe low reference level percentage you want the scope to use for waveform measurements.\n\n\n\n$MidRefLevel\n\nFloat\n\nThe middle reference level percentage you want the scope to use for waveform measurements.\n\n\n\n$HighRefLevel\n\nFloat\n\nThe high reference level percentage you want the scope to use for waveform measurements.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\nTEKDPO4K_ConfigureReferenceLevels($Handle,10,50,75);\n\n\n\n\n\nTEKDPO4K_ConfigureTrigger\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS TEKDPO4K_ConfigureTrigger": {
  "prefix": "TEKDPO4K_ConfigureTrigger",
  "body": [
   "TEKDPO4K_ConfigureTrigger($$Handle,$$TriggerType,$$TriggerHoldoff);"
  ],
  "description": "\n\n\n\nThis function configures the common attributes of the trigger subsystem. These attributes are the trigger type and holdoff.\n\n\n\nWhen you call tkdpo4k_ReadWaveform, tkdpo4k_ReadWaveformMeasurement, tkdpo4k_ReadMinMaxWaveform, or tkdpo4k_InitiateAcquisition, the oscilloscope waits for a trigger. You specify the type of trigger for which the oscilloscope waits with the Trigger Type parameter.\n\n\n\nIf the oscilloscope requires multiple waveform acquisitions to build a complete waveform, it waits for the length of time you specify with the Holdoff parameter to elapse since the previous trigger. The oscilloscope then waits for the next trigger. Once the oscilloscope acquires a complete waveform, it returns to the Idle state.\n\n\n\nNote: After you call this function, you must call the trigger configuration function that corresponds to the Trigger Type you select to completely specify the trigger. For example, if you set the Trigger Type to TKDPO4K_VAL_EDGE_TRIGGER, you use the tkdpo4k_ConfigureEdgeTriggerSource function to completely specify the trigger.\n\n\n\n\n\nRequirements:\n\n\u00b7 This function requires the TekDPO4K IVI Driver as well as the National Instruments IVI Compliance Package to to be installed before using the instrument driver.\n\n\u00b7 This function requires NI-VISA version 3.5 or higher.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nThe handle of the instrument returned from the initialization function.\n\n\n\n$TriggerType\n\nString\n\nThe trigger type to use. Allowable values are:\n\n\u00b7 \"EDGE\"\n\n\u00b7 \"AC_LINE\"\n\n\u00b7 \"TV\"\n\n\u00b7 \"RUNT\"\n\n\u00b7 \"GLITCH\"\n\n\u00b7 \"TRANSITION\"\n\n\u00b7 \"PATTERN\"\n\n\u00b7 \"STATE\"\n\n\u00b7 \"SETHOLD\"\n\n\u00b7 \"CAN\"\n\n\u00b7 \"I2C\"\n\n\u00b7 \"SPI\"\n\n\n\n$TriggerHoldOff\n\nFloat\n\nThe length of time that you want the oscilloscope to wait after it detects a trigger until the oscilloscope enables the trigger subsystem to detect another trigger.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\nTEKDPO4K_ConfigureTrigger($TekScope\",\"EDGE\",0.00001);\n\n\n\n\n\nTEKDPO4K_ConfigureTriggerModifier\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS TEKDPO4K_ConfigureTriggerMode": {
  "prefix": "TEKDPO4K_ConfigureTriggerMode",
  "body": [
   "TEKDPO4K_ConfigureTriggerMode($$Handle,$$TriggerModifier);"
  ],
  "description": "\n\n\n\nThis function configures the oscilloscope trigger modifier. The allowable values are \"NONE\" and \"AUTO\".\n\n\n\n\n\nRequirements:\n\n\u00b7 This function requires the TekDPO4K IVI Driver as well as the National Instruments IVI Compliance Package to to be installed before using the instrument driver.\n\n\u00b7 This function requires NI-VISA version 3.5 or higher.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nThe handle of the instrument returned from the initialization function.\n\n\n\n$TriggerModifier\n\nString\n\nThe trigger modifier to apply to the trigger settings:\n\n\u00b7 \"NONE\" = The Trigger Mode is set to Normal\n\n\u00b7 \"AUTO\" = The Trigger Mode is set to Auto Triggering (continuous acquisition)\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\nTEKDPO4K_ConfigureTriggerModifier($Handle,\u201dNONE\u201d);\n\n\n\n\n\nTEKDPO4K_Init\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS TEKDPO4K_Init": {
  "prefix": "TEKDPO4K_Init",
  "body": [
   "$$Handle=TEKDPO4K_Init($$resourceName,$$resetDevice);"
  ],
  "description": "\n\nThis function opens and optionally resets the instrument for communication.\n\n\n\nNotes:\n\n\u00b7 These functions work with the Tektronix 2k, 3k and 4k series oscilloscopes.\n\n\n\n\n\nRequirements:\n\n\u00b7 This function requires the TekDPO4K IVI Driver as well as the National Instruments IVI Compliance Package to to be installed before using the instrument driver.\n\n\u00b7 This function requires NI-VISA version 3.5 or higher.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$resourceName\n\nString\n\nSpecifies the resource name of the device to initialize.\n\n\n\n$resetDevice\n\nBoolean\n\nSpecify whether you want to reset the device during the initialization procedure.\n\nValid values :\n\nTrue : Reset the device.\n\nFalse : Do not reset the device.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nReturns a session handle that you can use to identify the device in all subsequent function calls.\n\n\n\n\n\nExample:\n\n$Handle = TEKDPO4K_Init(\"GPIB0::0:Instr\",\"TRUE\");\n\n\n\n\n\nTEKDPO4K_ReadDelayMeasurement\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS TEKDPO4K_ReadDelayMeasurement": {
  "prefix": "TEKDPO4K_ReadDelayMeasurement",
  "body": [
   "$$Measurement=TEKDPO4K_ReadDelayMeasurement($$Handle,$$ChannelFrom,$$ChannelTo);"
  ],
  "description": "\n\n\n\nThis function initiates an acquisition on the channels that you enable with the ConfigureChannel function. It then waits for the acquisition to complete, obtains a waveform measurement on the channel you specify, and returns the measurement value. This function returns the measured delay from one channel to another as specified in the function arguments.\n\n\n\nNotes:\n\n\n\n(1) You must configure the appropriate reference levels and trigger level before you call this function.\n\n\n\n\n\nRequirements:\n\n\u00b7 This function requires the TekDPO4K IVI Driver as well as the National Instruments IVI Compliance Package to to be installed before using the instrument driver.\n\n\u00b7 This function requires NI-VISA version 3.5 or higher.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nThe handle of the instrument returned from the initialization function.\n\n\n\n$ChannelFrom\n\nString\n\nThe name of the channel to measure from. Allowable values are:\n\n\u00b7 \"CH1\"\n\n\u00b7 \"CH2\"\n\n\u00b7 \"CH3\" (For 4 Channel Scopes)\n\n\u00b7 \"CH4\" (For 4 Channel Scopes)\n\n\u00b7 \"REF1\" Reference 1\n\n\u00b7 \"REF2\" Reference 2\n\n\u00b7 \"REF3\" Reference 3\n\n\u00b7 \"REF4\" Reference 4\n\n\u00b7 \"MATH\" Math\n\n\n\n$ChannelTo\n\nString\n\nThe name of the channel to measure to. Allowable values are:\n\n\u00b7 \"CH1\"\n\n\u00b7 \"CH2\"\n\n\u00b7 \"CH3\" (For 4 Channel Scopes)\n\n\u00b7 \"CH4\" (For 4 Channel Scopes)\n\n\u00b7 \"REF1\" Reference 1\n\n\u00b7 \"REF2\" Reference 2\n\n\u00b7 \"REF3\" Reference 3\n\n\u00b7 \"REF4\" Reference 4\n\n\u00b7 \"MATH\" Math\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Measurement\n\nFloat\n\nThe requested measurement.\n\n\n\n\n\nExample:\n\n\n\n\n\n$Measurement = TEKDPO4K_ReadDelayMeasurement($Handle,\"CH1\",\"CH2\");\n\n\n\n\n\nTEKDPO4K_ReadPhaseMeasurement\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS TEKDPO4K_ReadPhaseMeasurement": {
  "prefix": "TEKDPO4K_ReadPhaseMeasurement",
  "body": [
   "$$Measurement=TEKDPO4K_ReadPhaseMeasurement($$Handle,$$ChannelFrom,$$ChannelTo);"
  ],
  "description": "\n\n\n\nThis function initiates an acquisition on the channels that you enable with the ConfigureChannel function. It then waits for the acquisition to complete, obtains a waveform measurement on the channel you specify, and returns the measurement value. This function returns the measured phase difference from one channel to another as specified in the function arguments.\n\n\n\nNotes:\n\n\n\n(1) You must configure the appropriate reference levels and trigger level before you call this function.\n\n\n\n\n\nRequirements:\n\n\u00b7 This function requires the TekDPO4K IVI Driver as well as the National Instruments IVI Compliance Package to to be installed before using the instrument driver.\n\n\u00b7 This function requires NI-VISA version 3.5 or higher.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nThe handle of the instrument returned from the initialization function.\n\n\n\n$ChannelFrom\n\nString\n\nThe name of the channel to measure from. Allowable values are:\n\n\u00b7 \"CH1\"\n\n\u00b7 \"CH2\"\n\n\u00b7 \"CH3\" (For 4 Channel Scopes)\n\n\u00b7 \"CH4\" (For 4 Channel Scopes)\n\n\u00b7 \"REF1\" Reference 1\n\n\u00b7 \"REF2\" Reference 2\n\n\u00b7 \"REF3\" Reference 3\n\n\u00b7 \"REF4\" Reference 4\n\n\u00b7 \"MATH\" Math\n\n\n\n$ChannelTo\n\nString\n\nThe name of the channel to measure to. Allowable values are:\n\n\u00b7 \"CH1\"\n\n\u00b7 \"CH2\"\n\n\u00b7 \"CH3\" (For 4 Channel Scopes)\n\n\u00b7 \"CH4\" (For 4 Channel Scopes)\n\n\u00b7 \"REF1\" Reference 1\n\n\u00b7 \"REF2\" Reference 2\n\n\u00b7 \"REF3\" Reference 3\n\n\u00b7 \"REF4\" Reference 4\n\n\u00b7 \"MATH\" Math\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Measurement\n\nFloat\n\nThe requested measurement.\n\n\n\n\n\nExample:\n\n\n\n\n\n$Measurement = TEKDPO4K_ReadPhaseMeasurement($Handle,\"CH1\",\"CH2\");\n\n\n\n\n\nTEKDPO4K_ReadWaveformData\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS TEKDPO4K_ReadWaveformData": {
  "prefix": "TEKDPO4K_ReadWaveformData",
  "body": [
   "($$ActualPoints,$$InitialX,$$XIncrement,$$MeasureArray)=TEKDPO4K_ReadWaveformData($$Handle,$$ChannelName,$$WaveFormSize,$$MaxTimeOut);"
  ],
  "description": "\n\n\n\nThis function initiates an acquisition on the channels that you enable with the ConfigureChannel function. It then waits for the acquisition to complete, and returns the raw waveform data sampled by the scope into a two dimensional array.\n\n\n\n\n\nThe first dimension of the array contains the X (Time) coordinates of the sampled data, whereas the second dimension of the array contains the Y (Voltage) coordinates of the sampled data.\n\n\n\n\n\nIf the number of requested sample points can't be aquired in the time duration specified by the $MaxTimeOut parameter, the function will return a failure.\n\n\n\nNotes:\n\nThe data contained in the returned two dimension array can be accessed and manipulated by using the functions contained the Array function library.\n\n\n\n\n\nSpecial Notes:\n\nThe NI instrument driver that this function uses is not compatible with the Agilent IO Library USB driver due to a bug in the way it handles the NI VISA LOCK STATE... if you are using the Oscilloscope via USB and have the Agilent IO Libraries installed, you'll need to use the TekDPO4K_ReadWaveformDataRaw command to access this functionality.\n\n\n\n\n\nRequirements:\n\n\u00b7 This function requires the TekDPO4K IVI Driver as well as the National Instruments IVI Compliance Package to to be installed before using the instrument driver.\n\n\u00b7 This function requires NI-VISA version 3.5 or higher.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nThe handle of the instrument returned from the initialization function.\n\n\n\n$ChannelName\n\nString\n\nThe name of the channel to configure. Allowable values are:\n\n\u00b7 \"CH1\"\n\n\u00b7 \"CH2\"\n\n\u00b7 \"CH3\" (For 4 Channel Scopes)\n\n\u00b7 \"CH4\" (For 4 Channel Scopes)\n\n\u00b7 \"REF1\" Reference 1\n\n\u00b7 \"REF2\" Reference 2\n\n\u00b7 \"REF3\" Reference 3\n\n\u00b7 \"REF4\" Reference 4\n\n\u00b7 \"MATH\" Math\n\n\n\n$WaveformSize\n\nInteger\n\nThe desired number of points to sample\n\n\n\n$MaxTimeout\n\nInteger\n\nThe timeout in milliseconds to wait for the measurement sample acquisition to complete before failing.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ActualPoints\n\nInteger\n\nThe number of actual points that were sampled during the requested operation.\n\n\n\n$InitialX\n\nFloat\n\nThe initial X starting point for the data contained in the array. (X is time based data)\n\n\n\n$XIncrement\n\nFloat\n\nThe time increment in seconds between each sample of X.\n\n\n\n$MeasureArray\n\nArray\n\nThis variable contains a two-dimension array of Floating point numbers specifying the time and voltage dimensions in seconds, and volts respectively.\n\n\n\n\n\nExample:\n\n\n\n\n\n$Scope = TEKDPO4K_Init(\"USB0::0x0699::0x0401::C020195::INSTR\",\"TRUE\");\n\nTEKDPO4K_AutoSetup($Scope);\n\nSleep(2);\n\n($NumSamples,$InitialX,$XIncrement,$MeasureArray) = TEKDPO4K_ReadWaveformData($Scope,\"CH1\",15000,1000);\n\nUpdateStatus($NumSamples);\n\nUpdateStatus($InitialX);\n\nUpdateStatus($XIncrement);\n\nUpdateStatus($MeasureArray);\n\n\n\n\n\nTEKDPO4K_ReadWaveFormDataRaw\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS TEKDPO4K_ReadWaveformDataRaw": {
  "prefix": "TEKDPO4K_ReadWaveformDataRaw",
  "body": [
   "($$InitialX,$$XIncrement,$$MeasureArray)=TEKDPO4K_ReadWaveformDataRaw($$Handle,$$ChannelName,$$WaveFormSize);"
  ],
  "description": "\n\n\n\nThis function initiates an acquisition on the channels that you enable with the ConfigureChannel function. It then waits for the acquisition to complete, and returns the raw waveform data sampled by the scope into a two dimensional array.\n\n\n\n\n\nThe first dimension of the array contains the X (Time) coordinates of the sampled data, whereas the second dimension of the array contains the Y (Voltage) coordinates of the sampled data.\n\n\n\nNotes:\n\nThe data contained in the returned two dimension array can be accessed and manipulated by using the functions contained the Array function library.\n\n\n\n\n\nSpecial Notes:\n\nThis function is a re-implementation of the TEKDPO4K_ReadWaveformData command. This version of the function uses raw SCPI commands instead of the National Instruments driver provided for this instrument. This function was added due to a compatibility problem with the Agilent IO Library which prevents this function from operating correctly when the Agilent IO library is installed alongside of the NI VISA stack. If the Agilent IO Libraries aren't installed on your tester, you should use the TEKDPO4K_ReadWaveformData instead due to the enhanced error checking provided by the high-level instrument driver.\n\n\n\n\n\nRequirements:\n\n\u00b7 This function requires the TekDPO4K IVI Driver as well as the National Instruments IVI Compliance Package to to be installed before using the instrument driver.\n\n\u00b7 This function requires NI-VISA version 3.5 or higher.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nThe handle of the instrument returned from the initialization function.\n\n\n\n$ChannelName\n\nString\n\nThe name of the channel to configure. Allowable values are:\n\n\u00b7 \"CH1\"\n\n\u00b7 \"CH2\"\n\n\u00b7 \"CH3\" (For 4 Channel Scopes)\n\n\u00b7 \"CH4\" (For 4 Channel Scopes)\n\n\u00b7 \"REF1\" Reference 1\n\n\u00b7 \"REF2\" Reference 2\n\n\u00b7 \"REF3\" Reference 3\n\n\u00b7 \"REF4\" Reference 4\n\n\u00b7 \"MATH\" Math\n\n\n\n$WaveformSize\n\nInteger\n\nThe desired number of points to sample\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InitialX\n\nFloat\n\nThe initial X starting point for the data contained in the array. (X is time based data)\n\n\n\n$XIncrement\n\nFloat\n\nThe time increment in seconds between each sample of X.\n\n\n\n$MeasureArray\n\nArray\n\nThis variable contains a two-dimension array of Floating point numbers specifying the time and voltage dimensions in seconds, and volts respectively.\n\n\n\n\n\nExample:\n\n\n\n\n\n$Scope = TEKDPO4K_Init(\"USB0::0x0699::0x0401::C020195::INSTR\",\"TRUE\");\n\nTEKDPO4K_AutoSetup($Scope);\n\nSleep(2);\n\n($InitialX,$XIncrement,$MeasureArray) = TEKDPO4K_ReadWaveformDataRaw($Scope,\"CH1\",15000);\n\nUpdateStatus($InitialX);\n\nUpdateStatus($XIncrement);\n\nUpdateStatus($MeasureArray);\n\n\n\n\n\nTEKDPO4K_ReadWaveformMeasurement\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS TEKDPO4K_ReadWaveformMeasurement": {
  "prefix": "TEKDPO4K_ReadWaveformMeasurement",
  "body": [
   "$$Measurement=TEKDPO4K_ReadWaveformMeasurement($$Handle,$$ChannelName,$$MeasurementFunction,$$MaximumTimeout);"
  ],
  "description": "\n\n\n\nThis function initiates an acquisition on the channels that you enable with the ConfigureChannel function. It then waits for the acquisition to complete, obtains a waveform measurement on the channel you specify, and returns the measurement value. You specify a particular\n\nmeasurement type, such as rise time, frequency, and voltage peak-to-peak.\n\n\n\nNotes:\n\n\n\n(1) You must configure the appropriate reference levels before you call this function to take a rise time, fall time, width negative, width positive, duty cycle negative, or duty cycle positive measurement.\n\n\n\n\n\nRequirements:\n\n\u00b7 This function requires the TekDPO4K IVI Driver as well as the National Instruments IVI Compliance Package to to be installed before using the instrument driver.\n\n\u00b7 This function requires NI-VISA version 3.5 or higher.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nThe handle of the instrument returned from the initialization function.\n\n\n\n$ChannelName\n\nString\n\nThe name of the channel to configure. Allowable values are:\n\n\u00b7 \"CH1\"\n\n\u00b7 \"CH2\"\n\n\u00b7 \"CH3\" (For 4 Channel Scopes)\n\n\u00b7 \"CH4\" (For 4 Channel Scopes)\n\n\u00b7 \"REF1\" Reference 1\n\n\u00b7 \"REF2\" Reference 2\n\n\u00b7 \"REF3\" Reference 3\n\n\u00b7 \"REF4\" Reference 4\n\n\u00b7 \"MATH\" Math\n\n\n\n$MeasurementFunction\n\nString\n\nThe measurement function to perform:\n\n\u00b7 \"RISETIME\";\n\n\u00b7 \"FALLTIME\"\n\n\u00b7 \"FREQUENCY\"\n\n\u00b7 \"PERIOD\"\n\n\u00b7 \"VOLTAGE_RMS\"\n\n\u00b7 \"VOLTAGE_P2P\"\n\n\u00b7 \"VOLTAGE_MAX\"\n\n\u00b7 \"VOLTAGE_MIN\"\n\n\u00b7 \"VOLTAGE_HIGH\"\n\n\u00b7 \"VOLTAGE_LOW\"\n\n\u00b7 \"VOLTAGE_AVERAGE\"\n\n\u00b7 \"WIDTH_NEGATIVE\"\n\n\u00b7 \"WIDTH_POSITIVE\"\n\n\u00b7 \"DUTYCYCLE_NEGATIVE\"\n\n\u00b7 \"DUTYCYCLE_POSITIVE\"\n\n\u00b7 \"AMPLITUDE\"\n\n\u00b7 \"VOLTAGE_CYCLE_RMS\"\n\n\u00b7 \"VOLTAGE_CYCLE_AVERAGE\"\n\n\u00b7 \"POSITIVE_OVERSHOOT\"\n\n\u00b7 \"NEGATIVE_OVERSHOOT\"\n\n\u00b7 \"TIMING BURST WIDTH\"\n\n\u00b7 \"AREA\"\n\n\u00b7 \"CYCLE_AREA\"\n\n\u00b7 \"CROSS_NEGATIVE\"\n\n\u00b7 \"CROSS_POSITIVE\"\n\n\n\n$MaximumTimeout\n\nInteger\n\nThe timeout in milliseconds to wait for the measurement to complete before failing.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Measurement\n\nFloat\n\nThe requested measurement.\n\n\n\n\n\nExample:\n\n\n\n\n\n$Measurement = TEKDPO4K_ReadWaveFormMeasurement($Handle,\"CH1\",\"FREQUENCY\",1000);\n\n\n\n\n\nTEKDPO4K_SendCommand\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS TEKDPO4K_SendCommand": {
  "prefix": "TEKDPO4K_SendCommand",
  "body": [
   "TEKDPO4K_SendCommand($$Handle,$$Command);"
  ],
  "description": "\n\n\n\nThis function passes a raw SCPI command to to the instrument to control functionality that isn't exposed via the device driver.\n\nNOTE: This function validates that the command was sent and received by the instrument successfully, but it doesn't validate that the command sent was valid, or processed successfully.\n\n\n\n\n\nRequirements:\n\n\u00b7 This function requires the TekDPO4K IVI Driver as well as the National Instruments IVI Compliance Package to to be installed before using the instrument driver.\n\n\u00b7 This function requires NI-VISA version 3.5 or higher.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nThe handle of the instrument returned from the initialization function.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\nTEKDPO4K_SendCommand($Handle,\u201dTRIGGER:A:MODE NORMAL\u201d);\n\n\n\n\n\nTEKDPO4K_SetVerticalScale\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS TEKDPO4K_SetVerticalScale": {
  "prefix": "TEKDPO4K_SetVerticalScale",
  "body": [
   "TEKDPO4K_SetVerticalScale($$Handle,$$ChannelName,$$VerticalScale);"
  ],
  "description": "\n\n\n\nThis function allows configuring the vertical scale of the specified channel to any arbitrary value. The TEKDPO4K_ConfigureChannel function will only set the vertical scale to default increments.\n\n\n\n\n\nRequirements:\n\n\u00b7 This function requires the TekDPO4K IVI Driver as well as the National Instruments IVI Compliance Package to to be installed before using the instrument driver.\n\n\u00b7 This function requires NI-VISA version 3.5 or higher.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nThe handle of the instrument returned from the initialization function.\n\n\n\n$ChannelName\n\nString\n\nThe name of the channel to configure. Allowable values are:\n\n\u00b7 \"CH1\"\n\n\u00b7 \"CH2\"\n\n\u00b7 \"CH3\" (For 4 Channel Scopes)\n\n\u00b7 \"CH4\" (For 4 Channel Scopes)\n\n\n\n$VerticalScale\n\nFloat\n\nThe desired value of the vertical scale for the specified channel (specified in Volts).\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\nTEKDPO4K_SetVerticalScale($Handle,\"CH1\",3);\n\nTEKDPO4K_ConfigureChannel($Handle,\"CH1\",10.0,0,\"GROUND\",1.0,\"TRUE\");\n\n\n\n\n\nTDS2012_Abort\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS TDS2012_Abort": {
  "prefix": "TDS2012_Abort",
  "body": [
   "$$status=TDS2012_Abort($$TDS2012_handle);"
  ],
  "description": "\n\n\n\n\n\nThis function aborts an acquisition and returns the oscilloscope to the Idle state. You initiate an acquisition with the TDS2012_ReadWaveformMeasurement, and TDS2012_InitiateAcquisition functions.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$TDS2012B_handle\n\nObject\n\nHandle created by the TDS2012_Initialize() function used in all subsequent driver calls.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$status\n\nInteger\n\nreturns 0 (zero) if no errors\n\n\n\n\n\nTDS2012_AcquisitionStatus\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS TDS2012_AcquisitionStatus": {
  "prefix": "TDS2012_AcquisitionStatus",
  "body": [
   "($$status,$$acquisitionStatus)=TDS2012_AcquisitionStatus($$TDS2012_handle);"
  ],
  "description": "\n\n\n\n\n\nThis function returns whether an acquisition is in progress, complete, or if the status is unknown.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$TDS2012B_handle\n\nObject\n\nHandle created by the TDS2012_Initialize() function used in all subsequent driver calls.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$status\n\nInteger\n\nreturns 0 (zero) if no errors\n\n\n\n$acquisitionStatus\n\nString\n\nValid values are as follows:\n\n\u201cACQUIRING\u201d - currently acquiring a waveform.\n\n\u201cCOMPLETED\u201d - acquisition is complete.\n\n\u201cUNKNOWN\u201d - cannot determine the status of the acquisition.\n\n\n\n\n\nTDS2012_AutoSetup\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS TDS2012_AutoSetup": {
  "prefix": "TDS2012_AutoSetup",
  "body": [
   "$$status=TDS2012_AutoSetup($$TDS2012B_handle);"
  ],
  "description": "\n\n\n\n\n\nAutomatically configures the instrument.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$TDS2012B_handle\n\nObject\n\nHandle created by the TDS2012_Initialize() function used in all subsequent driver calls.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$status\n\nInteger\n\nreturns 0 (zero) if no errors\n\n\n\n\n\nTDS2012_ChannelDisable\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS TDS2012_ChannelDisable": {
  "prefix": "TDS2012_ChannelDisable",
  "body": [
   "$$status=TDS2012_ChannelDisable($$TDS2012_handle,$$channelName);"
  ],
  "description": "\n\n\n\n\n\nDisables the selected channel.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$TDS2012B_handle\n\nObject\n\nHandle created by the TDS2012_Initialize() function used in all subsequent driver calls.\n\n\n\n$channelName\n\nString\n\nThe channel name you want to disable:\n\n\u00b7 \u201cCH1\u201d \u2013 channel 1\n\n\u00b7 \u201cCH2\u201d \u2013 channel 2\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$status\n\nInteger\n\nreturns 0 (zero) if no errors\n\n\n\n\n\nTDS2012_ChannelEnable\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS TDS2012_ChannelEnable": {
  "prefix": "TDS2012_ChannelEnable",
  "body": [
   "$$status=TDS2012_ChannelEnable($$TDS2012_handle,$$channelName);"
  ],
  "description": "\n\n\n\n\n\nEnables the selected channel.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$TDS2012B_handle\n\nObject\n\nHandle created by the TDS2012_Initialize() function used in all subsequent driver calls.\n\n\n\n$channelName\n\nString\n\nThe channel name you want to enable:\n\n\u00b7 \u201cCH1\u201d \u2013 channel 1\n\n\u00b7 \u201cCH2\u201d \u2013 channel 2\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$status\n\nInteger\n\nreturns 0 (zero) if no errors\n\n\n\n\n\nTDS2012_Close\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS TDS2012_Close": {
  "prefix": "TDS2012_Close",
  "body": [
   "TDS2012_Close($$TDS2012_handle);"
  ],
  "description": "\n\n\n\n\n\nCloses the instrument IO session. After calling TDS2012_Close(), you cannot use the instrument again until you call TDS2012_Initialize().\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$TDS2012B_handle\n\nObject\n\nHandle created by the TDS2012_Initialize() function used in all subsequent driver calls.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n-\n\n-\n\n\n\n\n\nTDS2012_ConfigureAcquisitionType\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS TDS2012_ConfigureAcquisitionType": {
  "prefix": "TDS2012_ConfigureAcquisitionType",
  "body": [
   "$$status=TDS2012_ConfigureAcquisitionType($$TDS2012_handle,$$acquisitionType);"
  ],
  "description": "\n\n\n\n\n\nThis function configures how the oscilloscope acquires data and fills the waveform record.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$TDS2012B_handle\n\nObject\n\nHandle created by the TDS2012_Initialize() function used in all subsequent driver calls.\n\n\n\n$acquisitionType\n\nString\n\n\u00b7 \u201cNORMAL\u201d \u2013 set to normal acquisition mode.\n\n\u00b7 \u201cAVERAGE\u201d - Sets the oscilloscope to the average acquisition mode. The oscilloscope acquires multiple waveforms and calculates an average value for each point in the waveform record. You specify the number of waveforms the oscilloscope acquires with the TDS2012_ConfigureNumAverages().\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$status\n\nInteger\n\nreturns 0 (zero) if no errors\n\n\n\n\n\nTDS2012_ConfigureChannel\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS TDS2012_ConfigureChannel": {
  "prefix": "TDS2012_ConfigureChannel",
  "body": [
   "$$status=TDS2012_ConfigureChannel($$TDS2012_handle,$$channelName,$$verticalRange,$$verticalOffset,$$verticalCoupling,$$probeAttenutation,$$channelEnable);"
  ],
  "description": "\n\n\n\n\n\nThis function configures the common attributes of the oscilloscope's channel subsystem for a particular channel.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$TDS2012B_handle\n\nObject\n\nHandle created by the TDS2012_Initialize() function used in all subsequent driver calls.\n\n\n\n$channelName\n\nString\n\nThe channel name you want to configure:\n\n\u00b7 \u201cCH1\u201d \u2013 channel 1\n\n\u00b7 \u201cCH2\u201d \u2013 channel 2\n\n\n\n$verticalRange\n\nFloat\n\nThe value of the input range the oscilloscope uses for the channel. For example, to acquire a sine wave that spans between -10.0 and 10.0 volts, pass 20.0 as the value of this parameter.\n\n\n\n\n\nUnits: volts\n\nValid Range: The probe attenuation determines the valid range for this parameter.\n\nThe valid range is as follows:\n\n(20e-3 "
 }
,
 "JTS $status\u2013TDS2012_ConfigureNumAverages": {
  "prefix": "$status\u2013TDS2012_ConfigureNumAverages",
  "body": [
   "$$status\u2013TDS2012_ConfigureNumAverages($$TDS2012_handle,$$numAverages);"
  ],
  "description": "\n\n\n\n\n\nThis function configures the number of waveforms that the oscilloscope acquires and averages.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$TDS2012B_handle\n\nObject\n\nHandle created by the TDS2012_Initialize() function used in all subsequent driver calls.\n\n\n\n$numAverages\n\nInteger\n\nThe number of waveforms you want the oscilloscope to acquire and to average. Valid values are: 4, 16, 64, 128.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$status\n\nInteger\n\nreturns 0 (zero) if no errors\n\n\n\n\n\nTDS2012_ConfigureRefLevels\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS TDS2012_ConfigureRefLevels": {
  "prefix": "TDS2012_ConfigureRefLevels",
  "body": [
   "$$status=TDS2012_ConfigureRefLevels($$TDS2012B_handle,$$proximal,$$mesial,$$distal);"
  ],
  "description": "\n\n\n\n\n\nSets the reference levels on the waveform to make the measurements.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$TDS2012B_handle\n\nObject\n\nHandle created by the TDS2012_Initialize() function used in all subsequent driver calls.\n\n\n\n$proximal\n\nInteger\n\nValue normally set to 10 which sets the reference to 10% of the lower endpoint of the waveform.\n\n\n\n$mesial\n\nInteger\n\nValue normally set to 50 which sets the reference to 50% of the midpoint of the waveform.\n\n\n\n$distal\n\nInteger\n\nValue normally set to 90 which set the reference to 90% of the upper endpoint of the waveform.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$status\n\nInteger\n\nreturns 0 (zero) if no errors.\n\n\n\n\n\nTDS2012_FetchWaveformMeasurement\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS TDS2012_FetchWaveformMeasurement": {
  "prefix": "TDS2012_FetchWaveformMeasurement",
  "body": [
   "($$status,$$measurement)=TDS2012_FetchWaveformMeasurement($$TDS2012B_handle,$$channel,$$function);"
  ],
  "description": "\n\n\n\n\n\nReturns the measurement for the selected function.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$TDS2012B_handle\n\nObject\n\nHandle created by the TDS2012_Initialize() function used in all subsequent driver calls.\n\n\n\n$channel\n\nString\n\nSelects the channel\n\n\u00b7 \u201cCH1\u201d = channel 1\n\n\u00b7 \u201cCH2\u201d for channel 2.\n\n\n\n$function\n\nString\n\nVariable to select the measurement function as follows:\n\n\u00b7 \u201cFREQUENCY\u201d: The number of cycles that occur in one second.\n\n\u00b7 \u201cPERIOD\u201d: The time it takes for the first complete signal cycle to occur.\n\n\u00b7 \u201cVRMS\u201d: Obtains the true Root Mean Square voltage for one cycle of a periodic signal.\n\n\u00b7 \u201cVPP\u201d: The absolute difference between the maximum and minimum amplitudes.\n\n\u00b7 \u201cVAVG\u201d: Calculate the Arithmetic mean over the entire waveform.\n\n\u00b7 \u201cRISE_TIME\u201d: The time between 10% and 90% of the first rising edge of the waveform.\n\n\u00b7 \u201cFALL_TIME\u201d: The time between 90% and 10% of the first falling edge of the waveform.\n\n\u00b7 \u201cWIDTH_POS\u201d: The time between the first rising edge and the next falling edge at 50% of the waveform level.\n\n\u00b7 \u201cWIDTH_NEG\u201d: The time between the first falling edge and the next rising edge at 50% of the waveform level.\n\n\u00b7 \u201cVMAX\u201d: The maximum voltage.\n\n\u00b7 \u201cVMIN\u201d: The minimum voltage.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$status\n\nInteger\n\nreturns 0 (zero) if no errors.\n\n\n\n$measurement\n\nFloat\n\nReturns the measured value.\n\n\n\n\n\nTDS2012_Initialize\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS TDS2012_Initialize": {
  "prefix": "TDS2012_Initialize",
  "body": [
   "$$TDS2012B_handle=TDS2012_Initialize($$resourceName,$$IDQuery,$$resetDevice);"
  ],
  "description": "\n\n\n\n\n\nCreates a new IVI instrument driver session. .\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$resourceName\n\nString\n\nOpens a session to the specified device using the interface and address you specify for the Resource Name parameter.\n\n\n\n$IDQuery\n\nBoolean\n\nValid values are \"TRUE\" or \"FALSE\".\n\nIf the ID Query parameter is set to \u201cTRUE\u201d, this function queries the instrument ID and checks that it is valid for this instrument driver.\"FALSE\" does not check.\n\n\n\n$resetDevice\n\nBoolean\n\nValid values are \"TRUE\" or \"FALSE\".\n\nIf the Reset parameter is set to \u201cTRUE\u201d, this function resets the instrument to a known state. \"FALSE\" does not reset the device.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$TDS2012B_handle\n\nObject\n\nReturns a handle that you use to identify the instrument in all subsequent instrument driver function calls.\n\n\n\n\n\nExample:\n\n$TDS2012B_handle = TDS2012_Initialize(\"USB0::1689::871::C051871::0::INSTR\",\"FALSE\",\"TRUE\");\n\n\n\n\n\nTDS2012_InitiateAquisition\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS TDS2012_InitiateAcquisition": {
  "prefix": "TDS2012_InitiateAcquisition",
  "body": [
   "$$status=TDS2012_InitiateAcquisition($$TDS2012_handle);"
  ],
  "description": "\n\n\n\n\n\nThis function initiates a waveform acquisition. After you call this function, the oscilloscope leaves the Idle state and waits for a trigger. The oscilloscope acquires a waveform for each channel you have enabled with the TDS2012_ConfigureChannel().\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$TDS2012B_handle\n\nObject\n\nHandle created by the TDS2012_Initialize() function used in all subsequent driver calls.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$status\n\nInteger\n\nreturns 0 (zero) if no errors.\n\n\n\n\n\nTDS2012_ReadWaveformMeasurement\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS TDS2012_ReadWaveformMeasurement": {
  "prefix": "TDS2012_ReadWaveformMeasurement",
  "body": [
   "($$status,$$measurement)=TDS2012_ReadWaveformMeasurement($$TDS2012B_handle,$$channel,$$function,$$maxTime);"
  ],
  "description": "\n\n\n\n\n\nReturns the measurement for the selected function within an allocated time.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$TDS2012B_handle\n\nObject\n\nHandle created by the TDS2012_Initialize() function used in all subsequent driver calls.\n\n\n\n$channel\n\nString\n\nSelects the channel\n\n\u00b7 \u201cCH1\u201d = channel 1\n\n\u00b7 \u201cCH2\u201d for channel 2.\n\n\n\n$function\n\nString\n\nVariable to select the measurement function as follows:\n\n\u00b7 \u201cFREQUENCY\u201d: The number of cycles that occur in one second.\n\n\u00b7 \u201cPERIOD\u201d: The time it takes for the first complete signal cycle to occur.\n\n\u00b7 \u201cVRMS\u201d: Obtains the true Root Mean Square voltage for one cycle of a periodic signal.\n\n\u00b7 \u201cVPP\u201d: The absolute difference between the maximum and minimum amplitudes.\n\n\u00b7 \u201cVAVG\u201d: Calculate the Arithmetic mean over the entire waveform.\n\n\u00b7 \u201cRISE_TIME\u201d: The time between 10% and 90% of the first rising edge of the waveform.\n\n\u00b7 \u201cFALL_TIME\u201d: The time between 90% and 10% of the first falling edge of the waveform.\n\n\u00b7 \u201cWIDTH_POS\u201d: The time between the first rising edge and the next falling edge at 50% of the waveform level.\n\n\u00b7 \u201cWIDTH_NEG\u201d: The time between the first falling edge and the next rising edge at 50% of the waveform level.\n\n\u00b7 \u201cVMAX\u201d: The maximum voltage.\n\n\u00b7 \u201cVMIN\u201d: The minimum voltage.\n\n\n\n\n\n$maxTime\n\nInteger\n\nThe maximum length of time in which to allow the read waveform measurement operation to complete. Valid range is 0 \u2013 5000 milliseconds. 5000 milliseconds is normal.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$status\n\nInteger\n\nreturns 0 (zero) if no errors.\n\n\n\n$measurement\n\nFloat\n\nReturns the measured value.\n\n\n\n\n\nTDS2012_SendSWTrigger\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS TDS2012_SendSWTrigger": {
  "prefix": "TDS2012_SendSWTrigger",
  "body": [
   "$$status=TDS2012_SendSWTrigger($$TDS2012_handle);"
  ],
  "description": "\n\n\n\n\n\nThis function sends a command to trigger the oscilloscope.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$TDS2012B_handle\n\nObject\n\nHandle created by the TDS2012_Initialize() function used in all subsequent driver calls.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$status\n\nInteger\n\nreturns 0 (zero) if no errors\n\n\n\n\n\nTDS2012_SetBandwidthLimit\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS TDS2012_SetBandwidthLimit": {
  "prefix": "TDS2012_SetBandwidthLimit",
  "body": [
   "$$status=TDS2012_SetBandwidthLimit($$TDS2012_handle,$$channelName,$$bandwidthLimit);"
  ],
  "description": "\n\n\n\n\n\nSets the bandwidth setting of the specified oscilloscope channel.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$TDS2012B_handle\n\nObject\n\nHandle created by the TDS2012_Initialize() function used in all subsequent driver calls.\n\n\n\n$channelName\n\nString\n\nThe channel name you want to configure:\n\n? \u201cCH1\u201d - channel 1\n\n? \u201cCH2\u201d - channel 2\n\n\n\n$bandwidthLimit\n\nBoolean\n\nStatus of the channel's bandwidth setting:\n\ntrue - sets the channel bandwidth to 20 MHz.\n\nfalse - sets the channel bandwidth to the full bandwidth of the\n\noscilloscope (100MHz).\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$status\n\nInteger\n\nreturns 0 (zero) if no errors\n\n\n\n\n\nTDS2012_SetHorzScale\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS TDS2012_SetHorzScale": {
  "prefix": "TDS2012_SetHorzScale",
  "body": [
   "$$status=TDS2012_SetHorzScale($$TDS2012_handle,$$scale);"
  ],
  "description": "\n\n\n\n\n\nSets the horizontal scale in s/div. The value will automatically be coerced to the next highest valid setting.\n\n\n\n\n\nExample:\n\n\n\n\n\n$status = TDS2012_SetHorzScale($TDSHandle, 7E-6);\n\n\n\n\n\nSets the scope to 10\u03bcs per division (next valid setting above 7\u03bcs/div). $status will be 0 on a successful run.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$TDS2012B_handle\n\nObject\n\nHandle created by the TDS2012_Initialize() function used in all subsequent driver calls.\n\n\n\n$scale\n\nFloat\n\nThe horizontal time scale in seconds/division.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$status\n\nInteger\n\nreturns 0 (zero) if no errors\n\n\n\n\n\nTDS2012_SetTriggerLevel\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS TDS2012_SetTriggerLevel": {
  "prefix": "TDS2012_SetTriggerLevel",
  "body": [
   "TDS2012_SetTriggerLevel($$TDS2012B_handle,$$TriggerLevel);"
  ],
  "description": "\n\nSets the trigger voltage level.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$TDS2012B_handle\n\nObject\n\nHandle created by the TDS2012_Initialize() function used in all subsequent driver calls.\n\n\n\n$TriggerLevel\n\nFloat\n\nSpecifies the desired trigger level in volts.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nUsage Example:\n\n\n\n\n\nTDS2012_SetTriggerLevel($Handle,4.25);\n\n\n\n\n\nC152_Close\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS C152_Close": {
  "prefix": "C152_Close",
  "body": [
   "C152_Close();"
  ],
  "description": "\n\nThis function is used to close the C152 card and release its resources, and should be called at the end of the application.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone.\n\n\n\n\n\nExample :\n\nC152_Close();\n\n\n\n\n\nC152_ConfigFromFile\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS C152_ConfigFromFile": {
  "prefix": "C152_ConfigFromFile",
  "body": [
   "C152_ConfigFromFile();"
  ],
  "description": "\n\nThis function is used to load the configuration of the C152 card from a configuration file. Use Adlink's Motion Creator program to test and configure the C152. After saving the configuration, the file will exist in the user's system directory as C152.ini.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone.\n\n\n\n\n\nExample\n\nC152_Initial(0,0);\n\nC152_ConfigFromFile();\n\n\n\n\n\nC152_EmergencyStop\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS C152_EmergencyStop": {
  "prefix": "C152_EmergencyStop",
  "body": [
   "C152_EmergencyStop($$AxisNo);"
  ],
  "description": "\n\nImmediately stop the axis.\n\n\n\n\n\nNOTE:\n\n\u00b7 Stops the controller output to the axis. Motion may continue due to inertia of the motor.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AxisNo\n\nInteger\n\nThe axis to stop motion of.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone.\n\n\n\n\n\nExample\n\nC152_EmergencyStop(0);\n\n\n\n\n\nC152_GetGpioInput\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS C152_GetGpioInput": {
  "prefix": "C152_GetGpioInput",
  "body": [
   "$$digitalStatus=C152_GetGpioInput($$iCardID);"
  ],
  "description": "\n\nThe C152 has 4 digital input channels. This function will get the digital input status.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$iCardID\n\nInteger\n\nCard ID.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$digitalStatus\n\nInteger\n\nThe digital status of the 4 digital input channels.\n\n\n\n\n\nExample\n\n$digitalStatus = C152_GetGpioInput(0);\n\n\n\n\n\nC152_GetPosition\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS C152_GetPosition": {
  "prefix": "C152_GetPosition",
  "body": [
   "$$fPos=C152_GetPosition($$AxisNo);"
  ],
  "description": "\n\nGet the value of the feedback position counter.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AxisNo\n\nInteger\n\nAxis Number.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$fPos\n\nFloat\n\nPosition Counter.\n\n\n\n\n\nExample\n\n$fPos = C152_GetPosition($AxisNo);\n\n\n\n\n\nC152_Initial\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS C152_Initial": {
  "prefix": "C152_Initial",
  "body": [
   "C152_Initial($$iCardID,$$iManualID);"
  ],
  "description": "\n\nThis function is used to initialize a C152 card without assigning the hardware resources. All C152 cards must be initialized by this function before calling other functions in the application. By setting the parameter \u201c iManual_ID\u201d, the user can choose the type of ID that is assigned manually or automatic.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$iCardID\n\nInteger\n\nCard ID.\n\n\n\n$iManualID\n\nInteger\n\nManual ID.\n\n0 = configure card automatically.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone.\n\n\n\n\n\nExample:\n\nC152_Initial(0,0);\n\n\n\n\n\nC152_MotionDone\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS C152_MotionDone": {
  "prefix": "C152_MotionDone",
  "body": [
   "$$motionStatus=C152_MotionDone($$AxisNo);"
  ],
  "description": "\n\nThis function returns the motion status of the specified axis of the C152. The return code is:\n\n0 Normal stopped condition\n\n1 Waiting for DR\n\n2 Waiting for CSTA input\n\n3 Waiting for an internal synchronous signal\n\n4 Waiting for another axis to stop\n\n5 Waiting for a completion of ERC timer\n\n6 Waiting for a completion of direction change timer\n\n7 Correcting backlash\n\n8 Wait PA/PB\n\n9 At FA speed\n\n10 At FL speed\n\n11 Accelerating\n\n12 At FH speed\n\n13 Decelerating\n\n14 Wait INP\n\n15 Others (Controlling Start)\n\n16 SALM\n\n17 SPEL\n\n18 SMEL\n\n19 SEMG\n\n20 SSTP\n\n21 SERC\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AxisNo\n\nInteger\n\nAxis Number.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$motionStatus\n\nInteger\n\nThe motion status of the C152.\n\n\n\n\n\nExample\n\n$motionStatus = C152_MotionDone(0);\n\n\n\n\n\nC152_SetPosition\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS C152_SetPosition": {
  "prefix": "C152_SetPosition",
  "body": [
   "C152_SetPosition($$AxisNo,$$Position);"
  ],
  "description": "\n\nThis function is used to change the feedback position counter to the specified value.\n\n\n\n\n\nNOTE:\n\n\u00b7 The value to be set will be scaled by the move ratio. If the move ratio is 0.5, the set value will be twice the given value.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AxisNo\n\nInteger\n\nAxis Number.\n\n\n\n$Position\n\nFloat\n\nThe number to set the feedback position counter to.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone.\n\n\n\n\n\nExample\n\nC152_SetPosition(0, 2000);\n\n\n\n\n\nC152_SetTrMoveAll\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS C152_SetTrMoveAll": {
  "prefix": "C152_SetTrMoveAll",
  "body": [
   "C152_SetTrMoveAll($$TotalAxes,$$AxisArray,$$DistanceArray,$$StrVelArray,$$MaxVelArray,$$TaccArray,$$TdecArray);"
  ],
  "description": "\n\nSets up a simultaneous, multi-axis operation using trapezoidal profiles. All specified axes will be set to start and stop moving at the same time. The axes to move are specified in $AxisArray and the number of axes to move must be specified in $TotalAxes.\n\n\n\n\n\nNOTE:\n\n\u00b7 $TotalAxes specifies the number of axes to move and the size of each of the arrays in the other parameters must equal $TotalAxes.\n\n\u00b7 This function only sets up the move parameters. The axes do not move until the function C152_StartMoveAll is run.\n\n\u00b7 The function C152_StopMoveAll is used to stop the motion of all the axes.\n\n\u00b7 To move only one axis at a time use C152_StartTrMove or C152_StartSrMove.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$TotalAxes\n\nInteger\n\nThe number of axes to move simultaneously.\n\n\n\n$AxisArray\n\nInteger Array\n\nThe axes to be moved.\n\n\n\n$DistanceArray\n\nFloat Array\n\nThe distance to move each axis.\n\n\n\n$StrVelArray\n\nFloat Array\n\nThe starting velocity for each axis.\n\n\n\n$MaxVelArray\n\nFloat Array\n\nThe constant velocity for each axis.\n\n\n\n$TaccArray\n\nFloat Array\n\nThe acceleration time for each axis.\n\n\n\n$TdecArray\n\nFloat Array\n\nThe deceleration time for each axis.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone.\n\n\n\n\n\nExample\n\n// Set up the Axis array to move axes 0, 2 and 3.\n\n$AxisArray = Array1DCreate(\"INTEGER\", 3);\n\nArray1DSetValue($AxisArray, 0, 0);\n\nArray1DSetValue($AxisArray, 1, 2);\n\nArray1DSetValue($AxisArray, 2, 3);\n\n\n\n\n\n// Set up the distance array.\n\n$DistanceArray = Array1DCreate(\"FLOAT\", 3);\n\nArray1DSetValue($DistanceArray, 0, 2000);\n\nArray1DSetValue($DistanceArray, 1, 500);\n\nArray1DSetValue($DistanceArray, 2, 1200);\n\n\n\n\n\n// Set up the starting velocity array.\n\n$StrVelArray = Array1DCreate(\"FLOAT\", 3);\n\nArray1DSetValue($StrVelArray, 0, 8000);\n\nArray1DSetValue($StrVelArray, 1, 8000);\n\nArray1DSetValue($StrVelArray, 2, 8000);\n\n\n\n\n\n// Set up the maximum (constant) velocity array.\n\n$MaxVelArray = Array1DCreate(\"FLOAT\", 3);\n\nArray1DSetValue($MaxVelArray, 0, 25000);\n\nArray1DSetValue($MaxVelArray, 1, 25000);\n\nArray1DSetValue($MaxVelArray, 2, 25000);\n\n\n\n\n\n// Set up the acceleration array.\n\n$TaccArray = Array1DCreate(\"FLOAT\", 3);\n\nArray1DSetValue($TaccArray, 0, 0.2);\n\nArray1DSetValue($TaccArray, 1, 0.2);\n\nArray1DSetValue($TaccArray, 2, 0.2);\n\n\n\n\n\n// Set up the deceleration array.\n\n$TdecArray = Array1DCreate(\"FLOAT\", 3);\n\nArray1DSetValue($TdecArray, 0, 0.8);\n\nArray1DSetValue($TdecArray, 1, 0.8);\n\nArray1DSetValue($TdecArray, 2, 0.8);\n\n\n\n\n\n// Tell the controller what we want to move.\n\nC152_SetTrMoveAll(3, $AxisArray, $DistanceArray, $StrVelArray, $MaxVelArray, $TaccArray, $TdecArray);\n\n\n\n\n\nC152_StartMoveAll\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS C152_StartMoveAll": {
  "prefix": "C152_StartMoveAll",
  "body": [
   "C152_StartMoveAll($$FirstAxis);"
  ],
  "description": "\n\nStarts a simultaneous multi-axis operation.\n\n\n\n\n\nNOTE:\n\n\u00b7 The multi-axis operation must have already been defined using C152_SetTrMoveAll.\n\n\u00b7 The function C152_StopMoveAll is used to stop the motion of all the axes.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$FirstAxis\n\nInteger\n\nThe first axis in a previously set up multi-axis move.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone.\n\n\n\n\n\nExample\n\nC152_StartMoveAll(0);\n\n\n\n\n\nC152_StartSrMove\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS C152_StartSrMove": {
  "prefix": "C152_StartSrMove",
  "body": [
   "C152_StartSrMove($$AxisNo,$$Dist,$$StrVel,$$MaxVel,$$Tacc,$$Tdec,$$STacc,$$STdec);"
  ],
  "description": "\n\nBegin a relative S-curve profile move. This function causes the axis to accelerate from a starting velocity (StrVel), rotate at constant velocity (MaxVel), and decelerate to stop at the relative distance with an S-curve profile. The acceleration (Tacc) and deceleration (Tdec) time is specified independently.\n\n\n\n\n\nNOTE:\n\n\u00b7 This function does not wait for motion completion, but immediately returns control to the program.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AxisNo\n\nInteger\n\nAxis Number\n\n\n\n$Dist\n\nFloat\n\nDistance of the Move\n\n\n\n$StrVel\n\nFloat\n\nStarting Velocity\n\n\n\n$MaxVel\n\nFloat\n\nConstant Velocity\n\n\n\n$Tacc\n\nFloat\n\nAcceleration time\n\n\n\n$Tdec\n\nFloat\n\nDeceleration time\n\n\n\nSTacc\n\nFloat\n\nS-Curve acceleration time\n\n\n\nSTdec\n\nFloat\n\nS-Curve deceleration time\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone.\n\n\n\n\n\nExample:\n\n// Set Motor from the place 0 to $Position, Start Velocity:8000, Maximum Velocity:25000\n\n// Accel Time:0.2 , Decel Time: 0.8, S-Curve Accel Time: 0.4, S-Curve Decel Time: 0.6\n\nC152_StartSrMove(0, $Postion, 8000, 25000, 0.2, 0.8, 0.4, 0.6);\n\nC152_StopMoveAll(0);\n\n// Wait for motor to come to a stop.\n\nSleepMilliseconds(3000);\n\n\n\n\n\nC152_StartTrMove\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS C152_StartTrMove": {
  "prefix": "C152_StartTrMove",
  "body": [
   "C152_StartTrMove($$AxisNo,$$Dist,$$StrVel,$$MaxVel,$$Tacc,$$Tdec);"
  ],
  "description": "\n\nBegin a relative trapezoidal profile move. This function causes the axis to accelerate from a starting velocity (StrVel), rotate at constant velocity (MaxVel), and decelerate to stop at the relative distance with a trapezoidal profile. The acceleration (Tacc) and deceleration (Tdec) time is specified independently.\n\n\n\n\n\nNOTE:\n\n\u00b7 This function does not wait for motion completion, but immediately returns control to the program.\n\n\u00b7 Velocity parameters are in pulses per second.\n\n\u00b7 Acceleration times are in seconds.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AxisNo\n\nInteger\n\nAxis Number.\n\n\n\n$Dist\n\nFloat\n\nDistance of the Move\n\n\n\n$StrVel\n\nFloat\n\nStarting Velocity in pulses per second\n\n\n\n$MaxVel\n\nFloat\n\nConstant Velocity in pulses per second\n\n\n\n$Tacc\n\nFloat\n\nAcceleration time in seconds\n\n\n\n$Tdec\n\nFloat\n\nDeceleration time in seconds\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone.\n\n\n\n\n\nExample:\n\n//Set Motor from the place 0 to $Position, Start Velocity:8000, Maximum Velocity:25000\n\n// Accel Time:0.2 , Decel Time: 0.8\n\nC152_StartTrMove(0,$Position, 8000, 25000, 0.2, 0.8);\n\nC152_StopMoveAll(0);\n\n// Wait for motor to come to a stop.\n\nSleepMilliseconds(3000);\n\n\n\n\n\nC152_StopMove\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS C152_StopMove": {
  "prefix": "C152_StopMove",
  "body": [
   "C152_StopMove($$AxisNo,$$Tdec);"
  ],
  "description": "\n\nDecelerate the axis to stop.\n\n\n\n\n\nNOTE:\n\n\u00b7 Stops the controller output to the axis. Motion may continue due to inertia of the motor.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AxisNo\n\nInteger\n\nThe axis to stop motion of.\n\n\n\n$Tdec\n\nFloat\n\nThe deceleration time.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone.\n\n\n\n\n\nExample\n\nC152_StopMove(0, 0.8);\n\n\n\n\n\nC152_StopMoveAll\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS C152_StopMoveAll": {
  "prefix": "C152_StopMoveAll",
  "body": [
   "C152_StopMoveAll($$AxisNo);"
  ],
  "description": "\n\nStop the axes.\n\n\n\n\n\nNOTE:\n\n\u00b7 If a simultaneous multi-axis operation was defined using C152_SetTrMoveAll and started using C152_StartMoveAll this function will stop ALL axes from moving starting at $AxisNo.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AxisNo\n\nInteger\n\nThe first axis in a previously set up multi-axis move.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone.\n\n\n\n\n\nExample\n\nC152_StopMoveAll(0);\n\n\n\n\n\nC154_Close\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS C154_Close": {
  "prefix": "C154_Close",
  "body": [
   "C154_Close();"
  ],
  "description": "\n\n\n\n\n\nThis function will close the C-154 card and release its resources. This should be called at the end of the test script.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone.\n\n\n\n\n\nExample:\n\nC154_Close();\n\n\n\n\n\nC154_ConfigFromFile\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS C154_ConfigFromFile": {
  "prefix": "C154_ConfigFromFile",
  "body": [
   "C154_ConfigFromFile();"
  ],
  "description": "\n\n\n\n\n\nThis function will load the MPC-154 configuration from file.\n\n\n\n\n\nNote:\n\n\u00b7 The user should use the Adlink Motion Creator program to configure and test the MPC-154 card.\n\n\u00b7 The Motion Creator program will store the configuration in the system directory as C154.ini.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone.\n\n\n\n\n\nExample:\n\nC154_Initial(0, 0);\n\nC154_ConfigFromFile();\n\n\n\n\n\nC154_EmgStop\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS C154_GetGpioInput": {
  "prefix": "C154_GetGpioInput",
  "body": [
   "$$digitalStatus=C154_GetGpioInput($$iCardID);"
  ],
  "description": "\n\n\n\n\n\nThe MPC-154 card has 4 digital input channels. This function will get the digital input status.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$iCardID\n\nInteger\n\nCard ID.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$digitalStatus\n\nInteger\n\nThe digital status of the 4 digital input channels.\n\n\n\n\n\nExample:\n\n$digitalStatus = C154_GetGpioInput(0);\n\n\n\n\n\nC154_GetIOStatus\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS C154_GetIOStatus": {
  "prefix": "C154_GetIOStatus",
  "body": [
   "$$IOStatus=C154_GetIOStatus($$axisNo);"
  ],
  "description": "\n\nThis function will return the I/O status for the specified axis.\n\n\n\n\n\nNote:\n\nThe I/O status is bit encoded according to the following table:\n\nBit\n\nName\n\nDescription\n\n\n\n0\n\nRDY\n\nRDY pin input\n\n\n\n1\n\nALM\n\nAlarm signal\n\n\n\n2\n\n+EL\n\nPositive Limit Switch\n\n\n\n3\n\n-EL\n\nNegative Limit Switch\n\n\n\n4\n\nORG\n\nOrigin Switch\n\n\n\n5\n\nDIR\n\nDIR output\n\n\n\n6\n\nEMG\n\nEMG status\n\n\n\n7\n\n\n\n\n\n8\n\nERC\n\nERC pin output\n\n\n\n9\n\nEZ\n\nIndex signal\n\n\n\n10\n\nCLR\n\nClear signal\n\n\n\n11\n\n\n\n\n\n12\n\nSD\n\nSlow Down signal input\n\n\n\n13\n\nINP\n\nIn-Position signal input\n\n\n\n14\n\nSVON\n\nServo-ON output status\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$axusNo\n\nInteger\n\nAxis number to return the status of.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$IOStatus\n\nInteger\n\nThe bit encoded status for the axis.\n\n\n\n\n\nExample:\n\n$status = C154_GetIOStatus(0);\n\n// If the return is \"0000000000000100\" the Positive Limit switch is on.\n\n\n\n\n\nC154_GetPosition\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS C154_GetPosition": {
  "prefix": "C154_GetPosition",
  "body": [
   "$$positionCount=C154_GetPosition($$axisNo);"
  ],
  "description": "\n\nThis function will return the value of the feedback position counter for the specified axis.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$axisNo\n\nInteger\n\nThe axis number to return the position counter of.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$positionCount\n\nInteger\n\nThe value of the feedback position counter.\n\n\n\n\n\nExample:\n\n$axisNo = 0;\n\n$positionCount = C154_GetPosition($axisNo);\n\n\n\n\n\nC154_Initial\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS C154_Initial": {
  "prefix": "C154_Initial",
  "body": [
   "C154_Initial($$cardID,$$manualID);"
  ],
  "description": "\n\n\n\n\n\nThis function will initialize a C-154 card without assigning any hardware resources. All C-154 cards must be initialized by this function before using any other functions.\n\n\n\n\n\nNote:\n\n\u00b7 Setting $manulID selects whether the card's ID is assigned manually or automatically.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$cardID\n\nInteger\n\nThe card ID that will be assigned if the selection if for manual ID.\n\n\n\n$manualID\n\nInteger\n\nSpecifies whether the card's ID is assigned automatically or manually.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nReturns the handle to the instrument to use in following instrument control functions.\n\n\n\n\n\nExample:\n\nC154_Initial(0, 0);\n\n\n\n\n\nC154_MotionDone\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS C154_MotionDone": {
  "prefix": "C154_MotionDone",
  "body": [
   "$$motionStatus=C154_MotionDone($$AxisNo);"
  ],
  "description": "\n\nThis function returns the motion status of the specified axis of the MPC-154. The return code is:\n\n0 Normal stopped condition\n\n1 Waiting for DR\n\n2 Waiting for CSTA input\n\n3 Waiting for an internal synchronous signal\n\n4 Waiting for another axis to stop\n\n5 Waiting for a completion of ERC timer\n\n6 Waiting for a completion of direction change timer\n\n7 Correcting backlash\n\n8 Wait PA/PB\n\n9 At FA speed\n\n10 At FL speed\n\n11 Accelerating\n\n12 At FH speed\n\n13 Decelerating\n\n14 Wait INP\n\n15 Others (Controlling Start)\n\n16 SALM\n\n17 SPEL\n\n18 SMEL\n\n19 SEMG\n\n20 SSTP\n\n21 SERC\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AxisNo\n\nInteger\n\nAxis Number.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$motionStatus\n\nInteger\n\nThe motion status of the C152.\n\n\n\n\n\nExample:\n\n$motionStatus = C154_MotionDone(0);\n\n\n\n\n\nC154_SdStop\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS C154_SdStop": {
  "prefix": "C154_SdStop",
  "body": [
   "C154_SdStop($$AxisNo,$$decelTime);"
  ],
  "description": "\n\nThis function will cause the specified axis to decelerate to stop in the specified time.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AxisNo\n\nInteger\n\nAxis Number to stop.\n\n\n\n$decelTime\n\nFloat\n\nThe number of seconds to decelerate from current speed to stop.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone.\n\n\n\n\n\nExample:\n\n$axisNo = 0;\n\n$decelTime = 0.2;\n\nC152_SdStop($axisNo, $decelTime);\n\n\n\n\n\nC154_SetPosition\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS C154_SetPosition": {
  "prefix": "C154_SetPosition",
  "body": [
   "C154_SetPosition($$AxisNo,$$Position);"
  ],
  "description": "\n\nThis function is used to change the feedback position counter to the specified value.\n\n\n\n\n\nNOTE:\n\n\u00b7 The value to be set will be scaled by the move ratio. If the move ratio is 0.5, the set value will be twice the given value.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AxisNo\n\nInteger\n\nAxis Number.\n\n\n\n$Position\n\nFloat\n\nThe number to set the feedback position counter to.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone.\n\n\n\n\n\nExample\n\n$axisNo = 0;\n\n$positionVal = 2000;\n\nC154_SetPosition($axisNo, $positionVal);\n\n\n\n\n\nC154_SetTrMoveAll\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS C154_SetTrMoveAll": {
  "prefix": "C154_SetTrMoveAll",
  "body": [
   "C154_SetTrMoveAll($$TotalAxes,$$AxisArray,$$DistanceArray,$$StrVelArray,$$MaxVelArray,$$TaccArray,$$TdecArray);"
  ],
  "description": "\n\nSets up a simultaneous, multi-axis operation using trapezoidal profiles. All specified axes will be set to start and stop moving at the same time. The axes to move are specified in $AxisArray and the number of axes to move must be specified in $TotalAxes.\n\n\n\n\n\nNOTE:\n\n\u00b7 $TotalAxes specifies the number of axes to move and the size of each of the arrays in the other parameters must equal $TotalAxes.\n\n\u00b7 This function only sets up the move parameters. The axes do not move until the function C154_StartMoveAll is run.\n\n\u00b7 The function C154_StopMoveAll is used to stop the motion of all the axes.\n\n\u00b7 To move only one axis at a time use C154_StartTrMove or C154_StartSrMove.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$TotalAxes\n\nInteger\n\nThe number of axes to move simultaneously.\n\n\n\n$AxisArray\n\nInteger Array\n\nThe axes to be moved.\n\n\n\n$DistanceArray\n\nFloat Array\n\nThe distance to move each axis.\n\n\n\n$StrVelArray\n\nFloat Array\n\nThe starting velocity for each axis.\n\n\n\n$MaxVelArray\n\nFloat Array\n\nThe constant velocity for each axis.\n\n\n\n$TaccArray\n\nFloat Array\n\nThe acceleration time for each axis.\n\n\n\n$TdecArray\n\nFloat Array\n\nThe deceleration time for each axis.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone.\n\n\n\n\n\nExample:\n\n// Set up the Axis array to move axes 0, 2 and 3.\n\n$AxisArray = Array1DCreate(\"INTEGER\", 3);\n\nArray1DSetValue($AxisArray, 0, 0);\n\nArray1DSetValue($AxisArray, 1, 2);\n\nArray1DSetValue($AxisArray, 2, 3);\n\n\n\n\n\n// Set up the distance array.\n\n$DistanceArray = Array1DCreate(\"FLOAT\", 3);\n\nArray1DSetValue($DistanceArray, 0, 2000);\n\nArray1DSetValue($DistanceArray, 1, 500);\n\nArray1DSetValue($DistanceArray, 2, 1200);\n\n\n\n\n\n// Set up the starting velocity array.\n\n$StrVelArray = Array1DCreate(\"FLOAT\", 3);\n\nArray1DSetValue($StrVelArray, 0, 8000);\n\nArray1DSetValue($StrVelArray, 1, 8000);\n\nArray1DSetValue($StrVelArray, 2, 8000);\n\n\n\n\n\n// Set up the maximum (constant) velocity array.\n\n$MaxVelArray = Array1DCreate(\"FLOAT\", 3);\n\nArray1DSetValue($MaxVelArray, 0, 25000);\n\nArray1DSetValue($MaxVelArray, 1, 25000);\n\nArray1DSetValue($MaxVelArray, 2, 25000);\n\n\n\n\n\n// Set up the acceleration array.\n\n$TaccArray = Array1DCreate(\"FLOAT\", 3);\n\nArray1DSetValue($TaccArray, 0, 0.2);\n\nArray1DSetValue($TaccArray, 1, 0.2);\n\nArray1DSetValue($TaccArray, 2, 0.2);\n\n\n\n\n\n// Set up the deceleration array.\n\n$TdecArray = Array1DCreate(\"FLOAT\", 3);\n\nArray1DSetValue($TdecArray, 0, 0.8);\n\nArray1DSetValue($TdecArray, 1, 0.8);\n\nArray1DSetValue($TdecArray, 2, 0.8);\n\n\n\n\n\n// Tell the controller what we want to move.\n\nC154_SetTrMoveAll(3, $AxisArray, $DistanceArray, $StrVelArray, $MaxVelArray, $TaccArray, $TdecArray);\n\n\n\n\n\nC154_StartMoveAll\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS C154_StartMoveAll": {
  "prefix": "C154_StartMoveAll",
  "body": [
   "C154_StartMoveAll($$FirstAxis);"
  ],
  "description": "\n\nStarts a simultaneous multi-axis operation.\n\n\n\n\n\nNOTE:\n\n\u00b7 The multi-axis operation must have already been defined using C154_SetTrMoveAll.\n\n\u00b7 The function C154_StopMoveAll is used to stop the motion of all the axes.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$FirstAxis\n\nInteger\n\nThe first axis in a previously set up multi-axis move.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone.\n\n\n\n\n\nExample:\n\nC154_StartMoveAll(0);\n\n\n\n\n\nC154_StartSrMove\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS C154_StartSrMove": {
  "prefix": "C154_StartSrMove",
  "body": [
   "C154_StartSrMove($$AxisNo,$$Dist,$$StrVel,$$MaxVel,$$Tacc,$$Tdec,$$STacc,$$STdec);"
  ],
  "description": "\n\nBegin a relative S-curve profile move. This function causes the axis to accelerate from a starting velocity (StrVel), rotate at constant velocity (MaxVel), and decelerate to stop at the relative distance with an S-curve profile. The acceleration (Tacc) and deceleration (Tdec) time is specified independently.\n\n\n\n\n\nNOTE:\n\n\u00b7 This function does not wait for motion completion, but immediately returns control to the program.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AxisNo\n\nInteger\n\nAxis Number\n\n\n\n$Dist\n\nFloat\n\nDistance of the Move\n\n\n\n$StrVel\n\nFloat\n\nStarting Velocity\n\n\n\n$MaxVel\n\nFloat\n\nConstant Velocity\n\n\n\n$Tacc\n\nFloat\n\nAcceleration time\n\n\n\n$Tdec\n\nFloat\n\nDeceleration time\n\n\n\nSTacc\n\nFloat\n\nS-Curve acceleration time\n\n\n\nSTdec\n\nFloat\n\nS-Curve deceleration time\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone.\n\n\n\n\n\nExample:\n\n// Set Motor from the place 0 to $Position, Start Velocity:8000, Maximum Velocity:25000\n\n// Accel Time:0.2 , Decel Time: 0.8, S-Curve Accel Time: 0.4, S-Curve Decel Time: 0.6\n\nC154_StartSrMove(0, $Postion, 8000, 25000, 0.2, 0.8, 0.4, 0.6);\n\nC154_StopMoveAll(0);\n\n// Wait for motor to come to a stop.\n\nSleepMilliseconds(3000);\n\n\n\n\n\nC154_StartTrMove\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS C154_StartTrMove": {
  "prefix": "C154_StartTrMove",
  "body": [
   "C154_StartTrMove($$AxisNo,$$Dist,$$StrVel,$$MaxVel,$$Tacc,$$Tdec);"
  ],
  "description": "\n\nBegin a relative trapezoidal profile move. This function causes the axis to accelerate from a starting velocity (StrVel), rotate at constant velocity (MaxVel), and decelerate to stop at the relative distance with a trapezoidal profile. The acceleration (Tacc) and deceleration (Tdec) time is specified independently.\n\n\n\n\n\nNOTE:\n\n\u00b7 This function does not wait for motion completion, but immediately returns control to the program.\n\n\u00b7 Velocity parameters are in pulses per second.\n\n\u00b7 Acceleration times are in seconds.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AxisNo\n\nInteger\n\nAxis Number.\n\n\n\n$Dist\n\nFloat\n\nDistance of the Move\n\n\n\n$StrVel\n\nFloat\n\nStarting Velocity in pulses per second\n\n\n\n$MaxVel\n\nFloat\n\nConstant Velocity in pulses per second\n\n\n\n$Tacc\n\nFloat\n\nAcceleration time in seconds\n\n\n\n$Tdec\n\nFloat\n\nDeceleration time in seconds\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone.\n\n\n\n\n\nExample:\n\n//Set Motor from the place 0 to $Position, Start Velocity:8000, Maximum Velocity:25000\n\n// Accel Time:0.2 , Decel Time: 0.8\n\nC154_StartTrMove(0, $Position, 8000, 25000, 0.2, 0.8);\n\nC154_StopMoveAll(0);\n\n// Wait for motor to come to a stop.\n\nSleepMilliseconds(3000);\n\n\n\n\n\nC154_StartTrMoveXY\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS C154_StartTrMoveXY": {
  "prefix": "C154_StartTrMoveXY",
  "body": [
   "C154_StartTrMoveXY($$cardID,$$DistX,$$DistY,$$strVel,$$maxVel,$$Tacc,$$Tdec);"
  ],
  "description": "\n\nThis function starts a relative 2-axis linear interpolation for X & Y with a trapezoidal profile\n\n\n\n\n\nNOTE:\n\n\u00b7 This function does not wait for motion completion, but immediately returns control to the program.\n\n\u00b7 Velocity parameters are in pulses per second.\n\n\u00b7 Acceleration times are in seconds.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$cardID\n\nInteger\n\nThe ID of the card to perform the move.\n\n\n\n$DistX\n\nFloat\n\nDistance of the Move of axis 0.\n\n\n\n$DistY\n\nFloat\n\nDistance of the Move of axis 1.\n\n\n\n$strVel\n\nFloat\n\nStarting Velocity.\n\n\n\n$maxVel\n\nFloat\n\nConstant velocity.\n\n\n\n$Tacc\n\nFloat\n\nAcceleration time in seconds.\n\n\n\n$Tdec\n\nFloat\n\nDeceleration time in seconds.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone.\n\n\n\n\n\nExample:\n\n//Set Motor from the place 0 to $PositionX, $PositionY, Start Velocity:8000, Maximum Velocity:25000\n\n// Accel Time:0.2 , Decel Time: 0.8\n\nC154_StartTrMove(0, $PositionX, $PositionY, 8000, 25000, 0.2, 0.8);\n\nC154_StopMoveAll(0);\n\n// Wait for motor to come to a stop.\n\nSleepMilliseconds(3000);\n\n\n\n\n\nC154_StopMoveAll\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS C154_StopMoveAll": {
  "prefix": "C154_StopMoveAll",
  "body": [
   "C154_StopMoveAll($$AxisNo);"
  ],
  "description": "\n\nStop movement in all axes, starting with the specified one.\n\n\n\n\n\nNOTE:\n\n\u00b7 If a simultaneous multi-axis operation was started with C154_StartSrMove, C154_StartTrMove or defined using C154_SetTrMoveAll and started using C154_StartMoveAll this function will stop ALL axes from moving starting at $AxisNo.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AxisNo\n\nInteger\n\nThe first axis in a previously set up multi-axis move.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone.\n\n\n\n\n\nExample:\n\nC154_StopMoveAll(0);\n\n\n\n\n\nC154_TestArray\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS C154_TestArray": {
  "prefix": "C154_TestArray",
  "body": [
   "$$Added=C154_TestArray($$axisArray);"
  ],
  "description": "\n\nAdds the elements of the $axisArray.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$axisArray\n\nArray\n\nA one dimensional array of integers.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Added\n\nInteger\n\nThe sum of all of the elements in the array.\n\n\n\n\n\nExample\n\nC154_TestArray($axisArray);\n\n\n\n\n\nEpos_ActivateHomingMode\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Epos_ActivateHomingMode": {
  "prefix": "Epos_ActivateHomingMode",
  "body": [
   "$$ErrorCode=Epos_ActivateHomingMode($$Handle,$$NodeId);"
  ],
  "description": "\n\nThis function activates the homing mode.\n\n\n\n\n\nResult:\n\n$ErrorCode = Epos_ActivateHomingMode($Handle,$NodeId);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nInteger\n\nThe handle of the opened device using the function Epos_OpenDevice\n\n\n\n$NodeId\n\nInteger\n\nNode ID of the addressed device. ID is given from hardware switches or the layer setting services (LSS).\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\nInteger\n\nThe result of the executed function.\n\nWhen 0 is returned, no error is occurred.\n\n\n\n\n\nExample:\n\n$ErrorCode = Epos_ActivateHomingMode($Handle,1);\n\n\n\n\n\nEpos_ActivatePositionMode\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Epos_ActivatePositionMode": {
  "prefix": "Epos_ActivatePositionMode",
  "body": [
   "$$ErrorCode=Epos_ActivatePositionMode($$Handle,$$NodeId);"
  ],
  "description": "\n\nThis function activates the position mode.\n\n\n\n\n\nResult:\n\n$ErrorCode = Epos_ActivatePositionMode($Handle,$NodeId);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nInteger\n\nThe handle of the opened device using the function Epos_OpenDevice\n\n\n\n$NodeId\n\nInteger\n\nNode ID of the addressed device. ID is given from hardware switches or the layer setting services (LSS).\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\nInteger\n\nThe result of the executed function.\n\nWhen 0 is returned, no error is occurred.\n\n\n\n\n\nExample:\n\n$ErrorCode = Epos_ActivatePositionMode($Handle,1);\n\n\n\n\n\nEpos_ClearFault\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Epos_ClearFault": {
  "prefix": "Epos_ClearFault",
  "body": [
   "$$ErrorCode=Epos_ClearFault($$Handle,$$NodeId);"
  ],
  "description": "\n\nThis function changes the device state from fault state to disable state.\n\n\n\n\n\nResult:\n\n$ErrorCode = Epos_ClearFault($Handle,$NodeId);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nInteger\n\nThe handle of the opened device using the function Epos_OpenDevice\n\n\n\n$NodeId\n\nInteger\n\nNode ID of the addressed device. ID is given from hardware switches or the layer setting services (LSS).\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\nInteger\n\nThe result of the executed function.\n\nWhen 0 is returned, no error is occurred.\n\n\n\n\n\nExample:\n\n$ErrorCode = Epos_ClearFault($Handle,1);\n\n\n\n\n\nEpos_CloseDevice\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Epos_CloseDevice": {
  "prefix": "Epos_CloseDevice",
  "body": [
   "$$ErrorCode=Epos_CloseDevice($$Handle);"
  ],
  "description": "\n\nThis function closes the opened port.\n\n\n\n\n\nResult:\n\n$ErrorCode = Epos_CloseDevice($Handle);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nInteger\n\nThe handle of the opened device using the function Epos_OpenDevice\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\nInteger\n\nThe result of the executed function.\n\nWhen 0 is returned, no error is occurred.\n\n\n\n\n\nExample:\n\n$ErrorCode = Epos_CloseDevice($Handle);\n\n\n\n\n\nEpos_DigitalInputConfiguration\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Epos_DigitalInputConfiguration": {
  "prefix": "Epos_DigitalInputConfiguration",
  "body": [
   "$$ErrorCode=Epos_DigitalInputConfiguration($$Handle,$$NodeId,$$DigitalInputNb,$$Configuration,$$Mask,$$Polarity,$$ExecutionMask);"
  ],
  "description": "\n\nThis function sets the parameter for one digital input.\n\n\n\n\n\nResult:\n\n$ErrorCode = Epos_DigitalInputConfiguration($Handle,$NodeId,$DigitalInputNb,$Configuration,$Mask,$Polarity,$ExecutionMask);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nInteger\n\nThe handle of the opened device using the function Epos_OpenDevice\n\n\n\n$NodeId\n\nInteger\n\nNode ID of the addressed device. ID is given from hardware switches or the layer setting services (LSS).\n\n\n\n$DigitalInputNb\n\nInteger\n\nNumber of digital input\n\n\n\n$Configuration\n\nString\n\nConfigures which functionality will be assigned to digital input,\n\nPossible values:\n\n\u00b7 DRIVE ENABLE\n\n\u00b7 GENERAL PURPOSE A\n\n\u00b7 GENERAL PURPOSE B\n\n\u00b7 GENERAL PURPOSE C\n\n\u00b7 GENERAL PURPOSE D\n\n\u00b7 GENERAL PURPOSE E\n\n\u00b7 GENERAL PURPOSE F\n\n\u00b7 GENERAL PURPOSE G\n\n\u00b7 GENERAL PURPOSE H\n\n\u00b7 GENERAL PURPOSE I\n\n\u00b7 GENERAL PURPOSE J\n\n\u00b7 HOME SWITCH\n\n\u00b7 NEGATIVE LIMIT SWITCH\n\n\u00b7 POSITION MARKER\n\n\u00b7 POSITIVE LIMIT SWITCH\n\n\u00b7 QUICK STOP\n\n\n\n$Mask\n\nBool\n\nIf true, functionality state will be displayed. if false, not displayed.\n\n\n\n$Polarity\n\nBool\n\nIf true, low active. If false, high active.\n\n\n\n$ExecutionMask\n\nBool\n\nIf true, set the error routine (only for positive and negative switch).\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\nInteger\n\nThe result of the executed function.\n\nWhen 0 is returned, no error is occurred.\n\n\n\n\n\nExample:\n\n$ErrorCode = Epos_DigitalInputConfiguration($EposHandle,$Node,4,\"HOME SWITCH\",true,true,true);\n\n\n\n\n\nEpos_FindHome\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Epos_FindHome": {
  "prefix": "Epos_FindHome",
  "body": [
   "$$ErrorCode=Epos_FindHome($$Handle,$$NodeId,$$HomingMethod);"
  ],
  "description": "\n\nThis function finds the home of your system.\n\n\n\n\n\nResult:\n\n$ErrorCode = Epos_FindHome($Handle,$NodeId,$HomingMethod);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nInteger\n\nThe handle of the opened device using the function Epos_OpenDevice\n\n\n\n$NodeId\n\nInteger\n\nNode ID of the addressed device. ID is given from hardware switches or the layer setting services (LSS).\n\n\n\n$HomingMethod\n\nString\n\nThe homing method to be used.\n\nPossible values:\n\n\u00b7 ACTUAL POSITION\n\n\u00b7 CURRENT THRESHOLD NEGATIVE SPEED\n\n\u00b7 CURRENT THRESHOLD NEGATIVE SPEED AND INDEX\n\n\u00b7 CURRENT THRESHOLD POSITIVE SPEED\n\n\u00b7 CURRENT THRESHOLD POSITIVE SPEED AND INDEX\n\n\u00b7 HOME SWITCH NEGATIVE SPEED\n\n\u00b7 HOME SWITCH NEGATIVE SPEED AND INDEX\n\n\u00b7 HOME SWITCH POSITIVE SPEED\n\n\u00b7 HOME SWITCH POSITIVE SPEED AND INDEX\n\n\u00b7 INDEX NEGATIVE SPEED\n\n\u00b7 INDEX POSITIVE SPEED\n\n\u00b7 NEGATIVE LIMIT SWITCH\n\n\u00b7 NEGATIVE LIMIT SWITCH AND INDEX\n\n\u00b7 POSITIVE LIMIT SWITCH\n\n\u00b7 POSITIVE LIMIT SWITCH AND INDEX\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\nInteger\n\nThe result of the executed function.\n\nWhen 0 is returned, no error is occurred.\n\n\n\n\n\nExample:\n\n$ErrorCode = Epos_FindHome($EposHandle,$Node,\"HOME SWITCH POSITIVE SPEED\");\n\n\n\n\n\nEpos_GetErrorInfo\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Epos_GetErrorInfo": {
  "prefix": "Epos_GetErrorInfo",
  "body": [
   "($$ErrorCode,$$ErrorString)=Epos_GetErrorInfo($$ErrorCode);"
  ],
  "description": "\n\nThis function returns the error information about the executed function from a received error code.\n\n\n\n\n\nResult:\n\n($ErrorCode,$ErrorString) = Epos_GetErrorInfo($ErrorCode);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\nInteger\n\nThe supplied error code to retrieve the error message.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\nInteger\n\nThe result of the executed function.\n\nWhen 0 is returned, no error is occurred.\n\n\n\n$ErrorString\n\nString\n\nError string\n\n\n\n\n\nExample:\n\n($ErrorCode,$ErrorString) = Epos_GetErrorInfo($ErrorCode);\n\n\n\n\n\nEpos_GetPositionIs\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Epos_GetPositionIs": {
  "prefix": "Epos_GetPositionIs",
  "body": [
   "($$ErrorCode,$$Position)=Epos_GetPositionIs($$Handle,$$NodeId);"
  ],
  "description": "\n\nThis function returns the position actual value.\n\n\n\n\n\nResult:\n\n($ErrorCode,$Position) = Epos_GetPositionIs($Handle,$NodeId);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nInteger\n\nThe handle of the opened device using the function Epos_OpenDevice\n\n\n\n$NodeId\n\nInteger\n\nNode ID of the addressed device. ID is given from hardware switches or the layer setting services (LSS).\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\nInteger\n\nThe result of the executed function.\n\nWhen 0 is returned, no error is occurred.\n\n\n\n$Position\n\nInteger\n\nPosition actual value\n\n\n\n\n\nExample:\n\n($ErrorCode,$Position) = Epos_GetPositionIs($Handle,$NodeId);\n\n\n\n\n\nEpos_GetPositionMust\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Epos_GetPositionMust": {
  "prefix": "Epos_GetPositionMust",
  "body": [
   "($$ErrorCode,$$Position)=Epos_GetPositionMust($$Handle,$$NodeId);"
  ],
  "description": "\n\nThis function returns the position demand value.\n\n\n\n\n\nResult:\n\n($ErrorCode,$Position) = Epos_GetPositionMust($Handle,$NodeId);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nInteger\n\nThe handle of the opened device using the function Epos_OpenDevice\n\n\n\n$NodeId\n\nInteger\n\nNode ID of the addressed device. ID is given from hardware switches or the layer setting services (LSS).\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\nInteger\n\nThe result of the executed function.\n\nWhen 0 is returned, no error is occurred.\n\n\n\n$Position\n\nInteger\n\nPosition demand value\n\n\n\n\n\nExample:\n\n($ErrorCode,$Position) = Epos_GetPositionMust($Handle,$NodeId);\n\n\n\n\n\nEpos_OpenDevice\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Epos_OpenDevice": {
  "prefix": "Epos_OpenDevice",
  "body": [
   "($$ErrorCode,$$Handle)=Epos_OpenDevice($$DeviceName,$$ProtocolStackName,$$InterfaceName,$$PortName);"
  ],
  "description": "\n\nThis function opens the port for sending and receiving commands. This function opens interfaces with the RS232, the USB and with CANopen boards.\n\n\n\n\n\nResult:\n\n($ErrorCode,$Handle) = Epos_OpenDevice($DeviceName,$ProtocolStackName,$InterfaceName,$PortName);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$DeviceName\n\nString\n\nThe name of the connected device.\n\nAllowed values:\n\n\u00b7 EPOS\n\n\u00b7 EPOS2\n\n\n\n$ProtocolStackName\n\nString\n\nThe name of used bus system.\n\nAllowed values:\n\n\u00b7 MAXON_RS232\n\n\u00b7 MAXON SERIAL V2\n\n\u00b7 CANopen\n\n\n\n$InterfaceName\n\nString\n\nThe name of the used interface. I refer to the device documentation for detailed information.\n\n\n\n$PortName\n\nString\n\nThe name of the used port. I refer to the device documentation for detailed information.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\nInteger\n\nThe result of the executed function.\n\nWhen 0 is returned, no error is occurred.\n\n\n\n$Handle\n\nInteger\n\nThe handle to the opened device.\n\n\n\n\n\nExample:\n\n($ErrorCode,$Handle) = Epos_OpenDevice(\"EPOS\",\"MAXON_RS232\",\"RS232\",\"COM1\");\n\n\n\n\n\nEpos_ResetDevice\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Epos_ResetDevice": {
  "prefix": "Epos_ResetDevice",
  "body": [
   "($$ErrorCode,$$Position)=Epos_ResetDevice($$Handle,$$NodeId);"
  ],
  "description": "\n\nThis function is used to send the NMT service \"Reset Node\". It is a command without acknowledge.\n\n\n\n\n\nResult:\n\n($ErrorCode,$Position) = Epos_ResetDevice($Handle,$NodeId);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nInteger\n\nThe handle of the opened device using the function Epos_OpenDevice\n\n\n\n$NodeId\n\nInteger\n\nNode ID of the addressed device. ID is given from hardware switches or the layer setting services (LSS).\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\nInteger\n\nThe result of the executed function.\n\nWhen 0 is returned, no error is occurred.\n\n\n\n$Position\n\nInteger\n\nPosition actual value\n\n\n\n\n\nExample:\n\n($ErrorCode,$Position) = Epos_ResetDevice($Handle,$NodeId);\n\n\n\n\n\nEpos_SetDisableState\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Epos_SetDisableState": {
  "prefix": "Epos_SetDisableState",
  "body": [
   "$$ErrorCode=Epos_SetDisableState($$Handle,$$NodeId);"
  ],
  "description": "\n\nThis function changes the device to disable state.\n\n\n\n\n\nResult:\n\n$ErrorCode = Epos_SetDisableState($Handle,$NodeId);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nInteger\n\nThe handle of the opened device using the function Epos_OpenDevice\n\n\n\n$NodeId\n\nInteger\n\nNode ID of the addressed device. ID is given from hardware switches or the layer setting services (LSS).\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\nInteger\n\nThe result of the executed function.\n\nWhen 0 is returned, no error is occurred.\n\n\n\n\n\nExample:\n\n$ErrorCode = Epos_SetDisableState($Handle,$NodeId);\n\n\n\n\n\nEpos_SetEnableState\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Epos_SetEnableState": {
  "prefix": "Epos_SetEnableState",
  "body": [
   "$$ErrorCode=Epos_SetEnableState($$Handle,$$NodeId);"
  ],
  "description": "\n\nThis function changes the device to enable state.\n\n\n\n\n\nResult:\n\n$ErrorCode = Epos_SetEnableState($Handle,$NodeId);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nInteger\n\nThe handle of the opened device using the function Epos_OpenDevice\n\n\n\n$NodeId\n\nInteger\n\nNode ID of the addressed device. ID is given from hardware switches or the layer setting services (LSS).\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\nInteger\n\nThe result of the executed function.\n\nWhen 0 is returned, no error is occurred.\n\n\n\n\n\nExample:\n\n$ErrorCode = Epos_SetEnableState($Handle,$NodeId);\n\n\n\n\n\nEpos_SetHomingParameter\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Epos_SetHomingParameter": {
  "prefix": "Epos_SetHomingParameter",
  "body": [
   "$$ErrorCode=Epos_SetHomingParameter($$Handle,$$NodeId,$$HomingAcceleration,$$SpeedSwitch,$$SpeedIndex,$$HomeOffset,$$CurrentThreshold,$$HomePosition);"
  ],
  "description": "\n\nThis function writes all homing parameters.\n\n\n\n\n\nResult:\n\n$ErrorCode = Epos_SetHomingParameter($Handle,$NodeId,$HomingAcceleration,$SpeedSwitch,$SpeedIndex,$HomeOffset,$CurrentThreshold,$HomePosition);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nInteger\n\nThe handle of the opened device using the function Epos_OpenDevice\n\n\n\n$NodeId\n\nInteger\n\nNode ID of the addressed device. ID is given from hardware switches or the layer setting services (LSS).\n\n\n\n$HomingAcceleration\n\nInteger\n\nAcceleration for homing profile\n\n\n\n$SpeedSwitch\n\nInteger\n\nSpeed during search for switch\n\n\n\n$SpeedIndex\n\nInteger\n\nSpeed during search for index signal\n\n\n\n$HomeOffset\n\nInteger\n\nHome offset after homing\n\n\n\n$CurrentThreshold\n\nInteger\n\nCurrent threshold for homing method\n\n\n\n$HomePosition\n\nInteger\n\nAssign the current Homing position with this value\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\nInteger\n\nThe result of the executed function.\n\nWhen 0 is returned, no error is occurred.\n\n\n\n\n\nExample:\n\n$ErrorCode = Epos_SetHomingParameter($EposHandle,$Node,100,29,10,0,500,0);\n\n\n\n\n\nEpos_SetMaxAcceleration\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Epos_SetMaxAcceleration": {
  "prefix": "Epos_SetMaxAcceleration",
  "body": [
   "$$ErrorCode=Epos_SetMaxAcceleration($$Handle,$$NodeId,$$MaxAcceleration);"
  ],
  "description": "\n\nThis function writes the maximal allowed acceleration/deceleration.\n\n\n\n\n\nResult:\n\n$ErrorCode = Epos_SetMaxAcceleration($Handle,$NodeId,$MaxAcceleration);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nInteger\n\nThe handle of the opened device using the function Epos_OpenDevice\n\n\n\n$NodeId\n\nInteger\n\nNode ID of the addressed device. ID is given from hardware switches or the layer setting services (LSS).\n\n\n\n$MaxAcceleration\n\nInteger\n\nThis value is the limit of the other acceleration/ deceleration objects.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\nInteger\n\nThe result of the executed function.\n\nWhen 0 is returned, no error is occurred.\n\n\n\n\n\nExample:\n\n($ErrorCode,$Position) = Epos_SetEnableState($Handle,$NodeId);\n\n\n\n\n\nEpos_SetMaxFollowingError\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Epos_SetMaxFollowingError": {
  "prefix": "Epos_SetMaxFollowingError",
  "body": [
   "$$ErrorCode=Epos_SetMaxFollowingError($$Handle,$$NodeId,$$MaxFollowingError);"
  ],
  "description": "\n\nThis function writes the maximal allowed following error parameter.\n\n\n\n\n\nResult:\n\n$ErrorCode = Epos_SetMaxFollowingError($Handle,$NodeId,$MaxFollowingError);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nInteger\n\nThe handle of the opened device using the function Epos_OpenDevice\n\n\n\n$NodeId\n\nInteger\n\nNode ID of the addressed device. ID is given from hardware switches or the layer setting services (LSS).\n\n\n\n$MaxAcceleration\n\nInteger\n\nMaximal allowed difference of position actual value to position demand value.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\nInteger\n\nThe result of the executed function.\n\nWhen 0 is returned, no error is occurred.\n\n\n\n\n\nExample:\n\n$ErrorCode = Epos_SetMaxFollowingError($Handle,$NodeId,$MaxFollowingError);\n\n\n\n\n\nEpos_SetMaxProfileVelocity\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Epos_SetMaxProfileVelocity": {
  "prefix": "Epos_SetMaxProfileVelocity",
  "body": [
   "$$ErrorCode=Epos_SetMaxProfileVelocity($$Handle,$$NodeId,$$MaxProfileVelocity);"
  ],
  "description": "\n\nThis function writes the maximal allowed velocity.\n\n\n\n\n\nResult:\n\n$ErrorCode = Epos_SetMaxProfileVelocity($Handle,$NodeId,$MaxProfileVelocity);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nInteger\n\nThe handle of the opened device using the function Epos_OpenDevice\n\n\n\n$NodeId\n\nInteger\n\nNode ID of the addressed device. ID is given from hardware switches or the layer setting services (LSS).\n\n\n\n$MaxProfileVelocity\n\nInteger\n\nThis value is used as velocity limit in a position (or velocity) move.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\nInteger\n\nThe result of the executed function.\n\nWhen 0 is returned, no error is occurred.\n\n\n\n\n\nExample:\n\n$ErrorCode = Epos_SetMaxProfileVelocity($Handle,$NodeId,$MaxProfileVelocity);\n\n\n\n\n\nEpos_SetOperationMode\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Epos_SetOperationMode": {
  "prefix": "Epos_SetOperationMode",
  "body": [
   "$$ErrorCode=Epos_SetOperationMode($$Handle,$$NodeId,$$OperationMode);"
  ],
  "description": "\n\nThis function sets the operation mode.\n\n\n\n\n\nResult:\n\n$ErrorCode = Epos_SetOperationMode($Handle,$NodeId,$OperationMode);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nInteger\n\nThe handle of the opened device using the function Epos_OpenDevice\n\n\n\n$NodeId\n\nInteger\n\nNode ID of the addressed device. ID is given from hardware switches or the layer setting services (LSS).\n\n\n\n$OperationMode\n\nString\n\nThe operation mode.\n\nAllowed values:\n\n\u00b7 CURRENT MODE\n\n\u00b7 HOMING MODE\n\n\u00b7 INTERPOLATED POSITION MODE\n\n\u00b7 MASTER ENCODER MODE\n\n\u00b7 POSITION MODE\n\n\u00b7 PROFILE POSITION MODE\n\n\u00b7 PROFILE VELOCITY MODE\n\n\u00b7 STEP DIRECTION MODE\n\n\u00b7 VELOCITY MODE\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\nInteger\n\nThe result of the executed function.\n\nWhen 0 is returned, no error is occurred.\n\n\n\n\n\nExample:\n\n$ErrorCode = Epos_SetOperationMode($Handle,1,\"POSITION MODE\");\n\n\n\n\n\nEpos_SetPositionMust\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Epos_SetPositionMust": {
  "prefix": "Epos_SetPositionMust",
  "body": [
   "$$ErrorCode=Epos_SetPositionMust($$Handle,$$NodeId,$$PositionMust);"
  ],
  "description": "\n\nThis function sets the position demand value.\n\n\n\n\n\nResult:\n\n$ErrorCode = Epos_SetPositionMust($Handle,$NodeId,$PositionMust);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nInteger\n\nThe handle of the opened device using the function Epos_OpenDevice\n\n\n\n$NodeId\n\nInteger\n\nNode ID of the addressed device. ID is given from hardware switches or the layer setting services (LSS).\n\n\n\n$PositionMust\n\nInteger\n\nPosition demand value\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\nInteger\n\nThe result of the executed function.\n\nWhen 0 is returned, no error is occurred.\n\n\n\n\n\nExample:\n\n$ErrorCode = Epos_SetPositionMust($EposHandle,$Node,$PositionMust);\n\n\n\n\n\nEpos_StopHoming\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Epos_StopHoming": {
  "prefix": "Epos_StopHoming",
  "body": [
   "$$ErrorCode=Epos_StopHoming($$Handle,$$NodeId);"
  ],
  "description": "\n\nThis function interrupts homing.\n\n\n\n\n\nResult:\n\n$ErrorCode = Epos_StopHoming($Handle,$NodeId);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nInteger\n\nThe handle of the opened device using the function Epos_OpenDevice\n\n\n\n$NodeId\n\nInteger\n\nNode ID of the addressed device. ID is given from hardware switches or the layer setting services (LSS).\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\nInteger\n\nThe result of the executed function.\n\nWhen 0 is returned, no error is occurred.\n\n\n\n\n\nExample:\n\n$ErrorCode = Epos_StopHoming($Handle,$NodeId);\n\n\n\n\n\nIBootControl\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS IBootControl": {
  "prefix": "IBootControl",
  "body": [
   "IBootControl($$IpAddress,$$Command,$$Port);"
  ],
  "description": "\n\nThis function allows for remote control of the iBoot remote power cycle unit created by DataProbe Industries. The iBoot is a low-cost single outlet power-cycle relay with a built in web-server for remote control. In order to use the IBootControl function, the default password of the iBoot unit must be 'PASS'. This is the default shipping password of the iBoot units. Assuming that the command is successfully sent, this function generates a passing result. In the event that the command is not received correctly, a failing result is generated.\n\nExample:\n\nIBootControl(\"192.168.1.254\",\"ON\",80); Function Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$IpAddress\n\nString\n\nThe string in dotted quad notation representing the IP Address of the IBoot unit. For example \"192.168.1.254\"\n\n\n\n$Command\n\nString\n\nThe command to send to the IBoot unit. Valid Commands are:\n\n\u00b7 \"ON\" = Turns on the IBoot Unit.\n\n\u00b7 \"OFF\" = Turns off the IBoot Unit.\n\n\u00b7 \"CYCLE\" = Changes the State of the IBoot Unit.\n\n\n\n$Port\n\nInteger\n\nThe TCP/IP Port on which to send the iBoot commands. By Default, this is port 80.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nIPALControl\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS IPALControl": {
  "prefix": "IPALControl",
  "body": [
   "IPALControl($$IpAddress,$$Password,$$PortNumber$$DesiredState);"
  ],
  "description": "\n\nThis function allows for remote control of the iPAL remote power cycle unit created by DataProbe Industries. The iPAL is an 8 outlet power-cycle relay with a built in web-server for remote control. In order to use the IPALControl function, the unit must be configured with an IP Address Assuming that the command is successfully sent, this function generates a passing result. In the event that the command is not received correctly, a failing result is generated.\n\nExample:\n\nIPALControl(\"192.168.1.100\",\"PASS\",1,\"ON\")\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$IpAddress\n\nString\n\nThe string in dotted quad notation representing the IP Address of the IBoot unit. For example \"192.168.1.254\"\n\n\n\n$Password\n\nString\n\nThe password set on the device\n\n\n\n$PortNumber\n\nInteger\n\nThe Port to turn on or off. Valid values are 1-8.\n\n\n\n$DesiredState\n\nString\n\nThe command to send to the IBoot unit. Valid Commands are:\n\n\u00b7 \"ON\" = Turns on the Port\n\n\u00b7 \"OFF\" = Turns off the Port\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nA661XX_Close\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS A66101A_Close": {
  "prefix": "A66101A_Close",
  "body": [
   "A66101A_Close($$Handle);"
  ],
  "description": "\n\nCloses the I/O session to the instrument. Driver methods and properties that access the instrument are not accessible after Close is called.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nHandle of the instrument.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\nNone\n\nNone\n\n\n\n\n\nA661XXA_ConfigureCurrentLimit\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS A66101A_ConfigureCurrentLimit": {
  "prefix": "A66101A_ConfigureCurrentLimit",
  "body": [
   "A66101A_ConfigureCurrentLimit($$Handle,$$Limit_Enable,$$Limit);"
  ],
  "description": "\n\nSpecifies the output current limit value and enables or disables the overcurrent protection (OCP) function\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nHandle of the instrument\n\n\n\n$Limit_Enable\n\nString\n\nThis enables or disables the power module overcurrent protection (OCP) function. If \"Regulate\", Agilent661xxCurrentLimitRegulate is selected for which the output regulates at the current limit value when the current limit is reached. If \"Trip\", Agilent661xxCurrentLimitTrip is selected for which the output shuts down when the current limit is reached.\n\n\n\n$Limit\n\nDouble\n\nSpecifies the current limit value.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\nNone\n\nNone\n\n\n\n\n\nA661XXA_DisplayProperties\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS A66101A_DisplayProperties": {
  "prefix": "A66101A_DisplayProperties",
  "body": [
   "A66101A_DisplayProperties($$Handle,$$Enable);"
  ],
  "description": "\n\nIf True, the insturment updates the display. If False, the instrument does not update the display.\\\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nHandle of the instrument\n\n\n\n$Enable\n\nBoolean\n\nIf True, the insturment updates the display. If False, the instrument does not update the display.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\nNone\n\nNone\n\n\n\n\n\nA661XXA_Initialize\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS A66XXA_Initialize": {
  "prefix": "A66XXA_Initialize",
  "body": [
   "$$Handle=A66XXA_Initialize($$ResourceName,$$IdQurey,$$Reset,$$OptionalString);"
  ],
  "description": "\n\nOpens the I/O session to the instrument. Driver methods and properties that access the instrument are only accessible after Initialize is called. Initialize optionally performs a Reset and queries the instrument to validate the instrument model.\n\nThis function returns the instrument handle.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ResourceName\n\nString\n\nGPIB address of the instrument\n\n\n\n$IdQuery\n\nBoolean\n\nSpecifies whether to verify the ID of the instrument.\n\n\n\n$Reset\n\nBoolean\n\nSpecifies whether to reset the instrument.\n\n\n\n$OptionalString\n\nString\n\nSpecifies the initial values of certain IVI inherent attributes for the session.The format of an assignment in the OptionString parameter is \"Name=Value\", where Name is one of the option string names in the table below.\n\n\n\n\n\nName\n\nAllowed Values\n\n\n\nRangeCheck\n\ntrue or false\n\n\n\nQuerytInstrStatus\n\ntrue or false\n\n\n\nCache\n\ntrue or false\n\n\n\nSimulate\n\ntrue or false\n\n\n\nRecordCoercions\n\ntrue or false\n\n\n\nInterchangeCheck\n\ntrue or false\n\n\n\nDriverSetup\n\nany string\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nInstrument handle\n\n\n\n\n\nA661XXA_List_Properties\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS A66101A_List_Properties": {
  "prefix": "A66101A_List_Properties",
  "body": [
   "A66101A_List_Properties($$Handle,$$CurrentMode,$$Step,$$VoltageMode);"
  ],
  "description": "\n\nSets up the List Properties of the power supply module.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nHandle of the instrument\n\n\n\n$CurrentMode\n\nString\n\nIf \"Fixed\", Agilent661xxListModeFixed is selected which prevents the output from being controlled by lists. If \"List\", Agilent661xxListModeList is selected which allows the output to be controlled by lists.\n\n\n\n$Step\n\nString\n\nIf \"Auto\", Agilent661xxListStepAuto is selected which causes the list to sequence through all of points in the list in response to a single trigger. If \"Once\", Agilent661xxListStepOnce is selected which causes the list to advance one point per trigger. The list will remain at the point until the next trigger occurs.\n\n\n\n$VoltageMode\n\nString\n\nIf \"Fixed\", Agilent661xxListModeFixed is selected which prevents the output from being controlled by lists.If \"List\", Agilent661xxListModeList is selected which allows the output to be controlled by lists.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\nNone\n\nNone\n\n\n\n\n\nA6611XXA_Measure_Current\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS A66101A_Measure_Current": {
  "prefix": "A66101A_Measure_Current",
  "body": [
   "$$Current=A66101A_Measure_Current($$Handle);"
  ],
  "description": "\n\nMeasures the output current and returns the measured value.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nHandle of the instrument.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Current\n\nDouble\n\nMeasured current value in Amps\n\n\n\n\n\nA6611XXA_Measure_Voltage\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS A66101A_Measure_Voltage": {
  "prefix": "A66101A_Measure_Voltage",
  "body": [
   "$$Voltage=A66101A_Measure_Voltage($$Handle);"
  ],
  "description": "\n\nMeasures the output current and returns the measured value.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nHandle of the instrument.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Voltage\n\nDouble\n\nMeasured voltage value in volts\n\n\n\n\n\nA661X_Output_Properties\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS A66101A_Output_Properties": {
  "prefix": "A66101A_Output_Properties",
  "body": [
   "A66101A_Output_Properties($$Handle,$$Power_Supply_Enable,$$Relay_Enable,$$Relay_Polarity,$$Voltage_Level);"
  ],
  "description": "\n\nSets the output properties.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nHandle of the instrument\n\n\n\n$Power_Supply_Enable\n\nBoolean\n\nSpecifies whether the power module output is enabled or disabled.\n\n\n\n$Relay_Enable\n\nBoolean\n\nSpecifies the current limit value.\n\n\n\n$Relay_Polarity\n\nBoolean\n\nSpecifies the output relay polarity. This command is valid only if the power module is configured for the optional relay connector\n\n\n\n$Voltage_Level\n\nDouble\n\nSpecifies the output voltage level. The units are volts.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\nNone\n\nNone\n\n\n\n\n\nA661XXA_SetupList\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS A66101A_SetupList": {
  "prefix": "A66101A_SetupList",
  "body": [
   "A66101A_SetupList($$Handle,$$WhichList,$$TrigSource,$$ListCount,$$ListPoints,$$DwellPoints,$$ListStep);"
  ],
  "description": "\n\nConfigures the power supply module to execute a list on the next trigger signal. Downloads the dwell, voltage, and current list to the module. The following steps are required to set up a list:\n\nEnable the voltage list function\n\nEnable the current list function\n\nSpecify the number of voltage output levels (points)\n\nSpecify the number of current output levels (points)\n\nSpecify the time duration of each output level (dwell)\n\nSpecify the times the list is repeated (count)\n\nSpecify what will trigger the list (source)\n\nSelect the way the list will response to triggers (step)\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nHandle of the instrument\n\n\n\n$WhichList\n\nString\n\nIf \"Voltage\", Agilent661xxListTypeVoltage is selected which selects the Voltage list. If \"Current\", Agilent661xxListTypeCurrent is selected which selects the current list.\n\n\n\n$TrigSource\n\nString\n\nIf \"Immediate\", Agilent661xxTriggerSourceImmediate is selected which executes an immediate trigger.\n\nIf \"External\", Agilent661xxTriggerSourceExternal is selected which triggers on a mainframe trigger in signal.\n\nIf \"Hold\", Agilent661xxTriggerSourceHold is selected which does not respond to any triggers except Immediate Triggers.\n\nIf \"Link\", Agilent661xxTriggerSourceLink is selected which triggers on internal power module event as specified by Agilent661xxTriggeredLinkEnum.\n\nIf \"TTLT\", Agilent661xxTriggerSourceTTLT is selected which triggers on a Mainframe Trigger Out signal.\n\n\n\n$ListCount\n\nLong Integer\n\nThe number of times the list is executed before it is completed. Values range from 1 through 9.9E37. Any number greater than 65534 causes the list to be executed indefinitely.\n\n\n\n$ListPoints\n\nArray\n\nAn array that specifies the values in a voltage or current list. Up to 20 values can be entered in a list. The array of list points are given as String with each value seperated by a \";\"\n\n\n\n$DwellPoints\n\nArray\n\nAn array that specifies the dwell values in the list. The dwell time is the time interval that the output remains at the programmed voltage or current. Up to 20 dwell values can be entered in a list. The array of dwell points are given as String with each value seperated by a \";\"\n\n\n\n$ListStep\n\nString\n\nIf \"Auto\", Agilent661xxListStepAuto is selected which causes the list to sequence through all of points in the list in response to a single trigger.\n\nIf \"Once\", Agilent661xxListStepOnce is selected which causes the list to advance one point per trigger. The list will remain at the point until the next trigger occurs.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\nNone\n\nNone\n\n\n\n\n\nA661XXA_SetupOutputSequence\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS A66101A_SetupOutputSequence": {
  "prefix": "A66101A_SetupOutputSequence",
  "body": [
   "A66101A_SetupOutputSequence($$Handle,$$Trigger,$$Delay,$$Voltage,$$Current);"
  ],
  "description": "\n\nCreates an output programming sequence for multiple power supply modules. This method must be programmed once for each module to be sequenced. However, only one module must be designated as a Trigger Module. This module will be the one that initiates the output sequencing upon receiving a bus trigger.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nHandle of the instrument\n\n\n\n$Trigger\n\nBoolean\n\nIf set to True, it designates this module as the Trigger module. All other modules in the sequence must be set to False.\n\n\n\n$Delay\n\nDouble\n\nSpecifies the delay time from receipt of a trigger signal to the start of the output Voltage and Current change.\n\n\n\n$Voltage\n\nDouble\n\nThe triggered voltage value.\n\n\n\n$Current\n\nDouble\n\nThe triggered current value.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\nNone\n\nNone\n\n\n\n\n\nA661XXA_Voltage_Protection\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS A661XXA_Voltage_Protection": {
  "prefix": "A661XXA_Voltage_Protection",
  "body": [
   "A661XXA_Voltage_Protection($$Handle);"
  ],
  "description": "\n\nCalibrates the power module overvoltage protection (OVP) circuit. The power module output must be enabled and operating in the constant voltage (CV) mode. Can only be used in calibration mode.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nHandle of the instrument.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\nNone\n\nNone\n\n\n\n\n\nE343XA_CheckCurrentProtection\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS E343XA_CheckCurrentProtection": {
  "prefix": "E343XA_CheckCurrentProtection",
  "body": [
   "($$Current,$$State,$$TripState)=E343XA_CheckCurrentProtection($$Handle);"
  ],
  "description": "\n\nThis function controls the Agilent E343x Series of power supplies. In order to use these function the VXI pnp driver for the instrument must be installed on the system running Jabil Test. The latest version of this driver can be downloaded from Agilent.\n\nThis function checks the status of the current protection settings on the E343XA Power Supply.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nA handle to the E343XA created with the E343XA_Init function.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Current\n\nFloat\n\nThe present current level that is set to trip the over current protection\n\n\n\n$State\n\nBoolean\n\nThe present state of the current protection setting. If current protection is turned on, 'TRUE' is returned. Otherwise 'FALSE' is returned.\n\n\n\n$TripState\n\nBoolean\n\nReturns whether or not the power supply over current protection has been tripped. If the protection is tripped 'TRUE' is returned, otherwise 'FALSE' is returned.\n\n\n\n\n\nE343XA_CheckVoltageProtection\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS E343XA_CheckVoltageProtection": {
  "prefix": "E343XA_CheckVoltageProtection",
  "body": [
   "($$Voltage,$$State,$$TripState)=E343XA_CheckVoltageProtection($$Handle);"
  ],
  "description": "\n\nThis function controls the Agilent E343x Series of power supplies. In order to use these function the VXI pnp driver for the instrument must be installed on the system running Jabil Test. The latest version of this driver can be downloaded from Agilent.\n\nThis function checks the status of the current protection settings on the E343XA Power Supply.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nA handle to the E343XA created with the E343XA_Init function.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Voltage\n\nFloat\n\nThe present voltage level that is set to trip the over voltage protection\n\n\n\n$State\n\nBoolean\n\nThe present state of the voltage protection setting. If voltage protection is turned on, 'TRUE' is returned. Otherwise 'FALSE' is returned.\n\n\n\n$TripState\n\nBoolean\n\nReturns whether or not the power supply over voltage protection has been tripped. If the protection is tripped 'TRUE' is returned, otherwise 'FALSE' is returned.\n\n\n\n\n\nE343XA_Close\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS E343XA_Close": {
  "prefix": "E343XA_Close",
  "body": [
   "E343XA_Close($$Handle);"
  ],
  "description": "\n\nThis function controls the Agilent E343x Series of power supplies. In order to use these function the VXI pnp driver for the instrument must be installed on the system running Jabil Test. The latest version of this driver can be downloaded from Agilent.\n\n\n\nThis function closes the E343XA Power supply, and leaves it in it's current state.\n\nExample:\n\nE343XA_Close($Handle);\n\n\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nA Handle to the E343XA created with the E343XA_Init function.\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nE343XA_Init\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS E343XA_Init": {
  "prefix": "E343XA_Init",
  "body": [
   "$$handle=E343XA_Init($$resourceString,$$reset);"
  ],
  "description": "\n\nThis function initializes the E343XA Power supply, and returns a handle to the instrument. If the $Reset argument is set to TRUE, the instrument is reset to it's default configuration.\n\n\n\n\n\nRemarks:\n\nThis function controls the E343XA series of Power Supplies.\n\nIn order to use these functions the VXI PnP driver for the instrument must be loaded.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$resourceString\n\nString\n\nThe VISA style resource string for the instrument. Example: \"GPIB0::5::INSTR\"\n\n\n\n$reset\n\nBoolean\n\nSpecifies whether or not to reset the instrument upon initialization.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$handle\n\nObject\n\nHandle to the open communications channel that can be used by other functions.\n\n\n\n\n\nExample:\n\n\n\n\n\n// Initialize and reset an instrument on GPIB bus address 5.\n\n$resource = \"GPIB0::5::INSTR\";\n\n$reset = true;\n\n\n\n$handle = E343XA_Init($resource, $reset);\n\n\n\n\n\nE343XA_MeasureCurrent\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS E343XA_MeasureCurrent": {
  "prefix": "E343XA_MeasureCurrent",
  "body": [
   "$$Current=E343XA_MeasureCurrent($$Handle);"
  ],
  "description": "\n\nThis function controls the Agilent E343x Series of power supplies. In order to use these function the VXI pnp driver for the instrument must be installed on the system running Jabil Test. The latest version of this driver can be downloaded from Agilent.\n\nThis function returns the current draw of the E343XA power supply.\n\nExample:\n\nE343XA_MeasureCurrent($Handle);\n\n\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nA handle to the E343XA created with the E343XA_Init function.\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Current\n\nFloat\n\nThe current draw measured in Amps.\n\n\n\n\n\nE343XA_MeasureVoltage\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS E343XA_MeasureVoltage": {
  "prefix": "E343XA_MeasureVoltage",
  "body": [
   "$$Voltage=E343XA_MeasureVoltage($$Handle);"
  ],
  "description": "\n\nThis function controls the Agilent E343x Series of power supplies. In order to use these function the VXI pnp driver for the instrument must be installed on the system running Jabil Test. The latest version of this driver can be downloaded from Agilent.\n\nThis function returns the output voltage of the E343XA power supply.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nA handle to the E343XA created with the E343XA_Init function.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Voltage\n\nFloat\n\nThe output voltage measured in Volts.\n\n\n\n\n\nE343XA_Output\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS E343XA_Output": {
  "prefix": "E343XA_Output",
  "body": [
   "E343XA_Output($$Handle,$$State);"
  ],
  "description": "\n\nThis function controls the Agilent E343x Series of power supplies. In order to use these function the VXI pnp driver for the instrument must be installed on the system running Jabil Test. The latest version of this driver can be downloaded from Agilent.\n\nThis function turns the output of the E343XA Power Supply 'ON' or 'OFF'.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nA handle to the E343XA created with the E343XA_Init function.\n\n\n\n$State\n\nString\n\nSets the output of the power supply to 'ON' or 'OFF'\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nE343XA_SetCurrent\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS E343XA_SetCurrent": {
  "prefix": "E343XA_SetCurrent",
  "body": [
   "E343XA_SetCurrent($$Handle,$$Current);"
  ],
  "description": "\n\nThis function controls the Agilent E343x Series of power supplies. In order to use these function the VXI pnp driver for the instrument must be installed on the system running Jabil Test. The latest version of this driver can be downloaded from Agilent.\n\nThis function sets the output current of the E343XA power supply.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nA handle to the E343XA created with the E343XA_Init function.\n\n\n\n$Current\n\nFloat\n\nThe desired output current in amps.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nE343XA_SetCurrentProtection\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS E343XA_SetCurrentProtection": {
  "prefix": "E343XA_SetCurrentProtection",
  "body": [
   "E343XA_SetCurrentProtection($$Handle,$$Current,$$State);"
  ],
  "description": "\n\nThis function controls the Agilent E343x Series of power supplies. In order to use these function the VXI pnp driver for the instrument must be installed on the system running Jabil Test. The latest version of this driver can be downloaded from Agilent.\n\nThis function sets the output current proection of the E343XA power supply.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nA handle to the E343XA created with the E343XA_Init function.\n\n\n\n$Current\n\nFloat\n\nThe desired output current limit in amps which will cause the over current trip protection.\n\n\n\n$State\n\nString\n\nSets the output current protection to 'ON' or 'OFF'\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nE343XA_SetDisplay\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS E343XA_SetDisplay": {
  "prefix": "E343XA_SetDisplay",
  "body": [
   "E343XA_SetDisplay($$Handle,$$DisplayStatus,$$DisplayMode,$$DisplayString);"
  ],
  "description": "\n\nThis function controls the Agilent E343x Series of power supplies. In order to use these function the VXI pnp driver for the instrument must be installed on the system running Jabil Test. The latest version of this driver can be downloaded from Agilent.\n\nThis function controls the LED read-out on the E343XA power supply.\n\nExamples: E343XA_SetDisplay($Handle,\"ON\",\"NORMAL\",\"\");\n\nE343XA_SetDisplay($Handle,\"ON\",\"TEXT\",\"Hello World\");\n\n\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nA handle to the E343XA created with the E343XA_Init function.\n\n\n\n$DisplayStatus\n\nString\n\nSpecifies whether the E343XA display should be turned \"OFF\" or \"ON\".\n\n\n\n$DisplayMode\n\nString\n\nSpecifies whether the E343XA display is in \"NORMAL\" mode which shows the current status of the instrument, or \"TEXT\" mode which displays the string specified by the $DisplayString argument.\n\n\n\n$DisplayString\n\nString\n\nSpecifies the string to display on the LED readout of the E343XA Power Supply.\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nE343XA_SetVoltage\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS E343XA_SetVoltage": {
  "prefix": "E343XA_SetVoltage",
  "body": [
   "E343XA_SetVoltage($$Handle,$$Voltage);"
  ],
  "description": "\n\nThis function controls the Agilent E343x Series of power supplies. In order to use these function the VXI pnp driver for the instrument must be installed on the system running Jabil Test. The latest version of this driver can be downloaded from Agilent.\n\nThis function sets the output voltage of the E343XA power supply.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nA handle to the E343XA created with the E343XA_Init function.\n\n\n\n$Voltage\n\nFloat\n\nThe desired voltage in volts.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nE343XA_SetVoltageProtection\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS E343XA_SetVoltageProtection": {
  "prefix": "E343XA_SetVoltageProtection",
  "body": [
   "E343XA_SetVoltageProtection($$Handle,$$Voltage,$$State);"
  ],
  "description": "\n\nThis function controls the Agilent E343x Series of power supplies. In order to use these function the VXI pnp driver for the instrument must be installed on the system running Jabil Test. The latest version of this driver can be downloaded from Agilent.\n\nThis function sets the output voltage protection of the E343XA power supply.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nA handle to the E343XA created with the E343XA_Init function.\n\n\n\n$Voltage\n\nFloat\n\nThe desired output voltage limit in amps which will cause the over voltage trip protection.\n\n\n\n$State\n\nString\n\nSets the output voltage protection to 'ON' or 'OFF'\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nE36xx_Close\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS E36XX_Close": {
  "prefix": "E36XX_Close",
  "body": [
   "E36XX_Close($$InstrumentHandle);"
  ],
  "description": "\n\n\n\n\n\nThe close function terminates the software connection to the instrument and de-allocates system resources. It is generally a good programming habit to close the instrument handle when the program is done using the instrument.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThe handle of the instrument returned from the E36XX_Init function\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\nE36XX_Close($InstrumentHandle);\n\n\n\n\n\nSupported Instruments\n\nAgilent E3632A, E3633A, E3634A, E3640A, E3641A, E3642A, E3643A, E3644A, E3631A, E3645A, E3646A, E3647A, E3648A, E3649A\n\n\n\n\n\nE36xx_ConfigureOCP\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS E36XX_ConfigureOCP": {
  "prefix": "E36XX_ConfigureOCP",
  "body": [
   "E36XX_ConfigureOCP($$InstrumentHandle,$$CurrentLimit,$$Enabled,$$OutputChannel);"
  ],
  "description": "\n\n\n\n\n\nThis function configures the over current protection for the specified output.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThe handle of the instrument returned from the E36XX_Init function\n\n\n\n$CurrentLimit\n\nFloat\n\nThe Current limit for the specified output.\n\n\n\n$Enabled\n\nBoolean\n\nEnable the over current protections [TRUE,FALSE]\n\n\n\n$OutputChannel\n\nInteger\n\nThe Output Channel To Be Configured (Allowable values for the output channel are between 1 and 3 depending on the model of power supply).\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\nE36XX_ConfigureOCP($InstrumentHandle,7,TRUE,1);\n\n\n\n\n\nSupported Instruments\n\nAgilent E3632A, E3633A, E3634A, E3640A, E3641A, E3642A, E3643A, E3644A, E3631A, E3645A, E3646A, E3647A, E3648A, E3649A\n\n\n\n\n\nE36XX_ConfigureOVP\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS E36XX_ConfigureOVP": {
  "prefix": "E36XX_ConfigureOVP",
  "body": [
   "E36XX_ConfigureOVP($$InstrumentHandle,$$VoltageLimit,$$Enabled,$$OutputChannel);"
  ],
  "description": "\n\n\n\n\n\nThis function configures the over voltage protection for the specified output.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThe handle of the instrument returned from the E36XX_Init function\n\n\n\n$VoltageLimit\n\nFloat\n\nThe voltage limit for the specified output.\n\n\n\n$Enabled\n\nBoolean\n\nEnable the over current protections [TRUE,FALSE]\n\n\n\n$OutputChannel\n\nInteger\n\nThe Output Channel To Be Configured (Allowable values for the output channel are between 1 and 3 depending on the model of power supply).\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\nE36XX_ConfigureOVP($InstrumentHandle,7,TRUE,1);\n\n\n\n\n\nSupported Instruments\n\nAgilent E3632A, E3633A, E3634A, E3640A, E3641A, E3642A, E3643A, E3644A, E3631A, E3645A, E3646A, E3647A, E3648A, E3649A\n\n\n\n\n\nE36XX_GetNumberOfOutputs\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS E36XX_GetNumberOfOutputs": {
  "prefix": "E36XX_GetNumberOfOutputs",
  "body": [
   "$$Outputs=E36XX_GetNumberOfOutputs($$InstrumentHandle);"
  ],
  "description": "\n\n\n\n\n\nThis function returns the amount of outputs available on the instrument.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThe handle of the instrument returned from the N67XX_Init function\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Outputs\n\nInteger\n\nThe amount of outputs on the device.\n\n\n\n\n\nExamples:\n\n$outputs= E36XX_GetNumberOfOutputs($Handle);\n\n\n\n\n\nSupported Instruments\n\nAgilent E3632A, E3633A, E3634A, E3640A, E3641A, E3642A, E3643A, E3644A, E3631A, E3645A, E3646A, E3647A, E3648A, E3649A\n\n\n\n\n\nE36xx_Init\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS E36XX_Init": {
  "prefix": "E36XX_Init",
  "body": [
   "$$Handle=E36XX_Init($$ResourceString,$$QueryInstrument,$$ResetInstrument);"
  ],
  "description": "\n\n\n\nThe initialize function initializes the software connection to the instrument and optionally verifies that instrument is in the system. In addition, it may perform any necessary actions to place the instrument in its reset state.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ResourceString\n\nString\n\nThe resource string of the instrument, for instance \"GPIB0::5::INSTR\"\n\n\n\n$QueryInstrument\n\nBoolean\n\nSpecifies whether or not to query the instrument on initialization.\n\n\n\n$ResetInstrument\n\nBoolean\n\nSpecifies whether or not to reset the instrument on initialization.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nReturns the handle to the instrument to use in following instrument control functions.\n\n\n\n\n\nExamples:\n\n$Handle = E36XX_Init(\"GPIB0::5::INSTR\",false,true);\n\n\n\n\n\nSupported Instruments\n\nAgilent E3632A, E3633A, E3634A, E3640A, E3641A, E3642A, E3643A, E3644A, E3631A, E3645A, E3646A, E3647A, E3648A, E3649A\n\n\n\n\n\nE36XX_MeasureCurrent\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS E36XX_MeasureCurrent": {
  "prefix": "E36XX_MeasureCurrent",
  "body": [
   "$$Current=E36XX_MeasureCurrent($$InstrumentHandle,$$OutputChannel);"
  ],
  "description": "\n\n\n\n\n\nThis function measures the output current on the specified channel.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThe handle of the instrument returned from the E36XX_Init function\n\n\n\n$OutputChannel\n\nInteger\n\nThe output channel on which to perform the current measurement. (Allowable values for the output channel are between 1 and 3 depending on the model of power supply).\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Current\n\nFloat\n\nThe current from the power supply measured in amperes.\n\n\n\n\n\nExamples:\n\n$Current = E36XX_MeasureCurrent($InstrumentHandle,$OutputChannel);\n\n\n\n\n\nSupported Instruments\n\nAgilent E3632A, E3633A, E3634A, E3640A, E3641A, E3642A, E3643A, E3644A, E3631A, E3645A, E3646A, E3647A, E3648A, E3649A\n\n\n\n\n\nE36XX_MeasureVoltage\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS E36XX_MeasureVoltage": {
  "prefix": "E36XX_MeasureVoltage",
  "body": [
   "$$Voltage=E36XX_MeasureVoltage($$InstrumentHandle,$$OutputChannel);"
  ],
  "description": "\n\n\n\n\n\nThis function measures the output voltage on the specified channel.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThe handle of the instrument returned from the E36XX_Init function\n\n\n\n$OutputChannel\n\nInteger\n\nThe output channel on which to perform the voltage measurement. (Allowable values for the output channel are between 1 and 3 depending on the model of power supply).\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Voltage\n\nFloat\n\nThe voltage from the power supply measured in volts.\n\n\n\n\n\nExamples:\n\n$Voltage = E36XX_MeasureVoltage($InstrumentHandle,$OutputChannel);\n\n\n\n\n\nSupported Instruments\n\nAgilent E3632A, E3633A, E3634A, E3640A, E3641A, E3642A, E3643A, E3644A, E3631A, E3645A, E3646A, E3647A, E3648A, E3649A\n\n\n\n\n\nE36XX_Output\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS E36XX_Output": {
  "prefix": "E36XX_Output",
  "body": [
   "E36XX_Output($$InstrumentHandle,$$Enabled);"
  ],
  "description": "\n\n\n\n\n\nThis function enables or disables the output of the instrument. The state of the disabled output is a condition of zero output voltage and current at the output terminals.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThe handle of the instrument returned from the E36XX_Init function.\n\n\n\n$Enabled\n\nString\n\nEnables the output state of the instrument. Allowable settings are:\n\n\u00b7 \"TRUE\" = Output Enabled\n\n\u00b7 \"FALSE\" = Output Disabled\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\nE36XX_Output($InstrumentHandle,\"TRUE\");\n\n\n\n\n\nSupported Instruments\n\nAgilent E3632A, E3633A, E3634A, E3640A, E3641A, E3642A, E3643A, E3644A, E3631A, E3645A, E3646A, E3647A, E3648A, E3649A\n\n\n\n\n\nE36XX_SetCurrentLimit\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS E36XX_SetCurrentLimit": {
  "prefix": "E36XX_SetCurrentLimit",
  "body": [
   "E36XX_SetCurrentLimit($$InstrumentHandle,$$CurrentLimit,$$Output);"
  ],
  "description": "\n\n\n\n\n\nThis function sets the current limit value for the specified output.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThe handle of the instrument returned from the E36XX_Init function.\n\n\n\n$CurrentLimit\n\nFloat\n\nThe Current limit value in amps\n\n\n\n$Output\n\nInteger\n\nThe output channel to be configured. (Allowable values for the output channel are between 1 and 3 depending on the model of power supply).\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\nE36XX_SetCurrentLimit($InstrumentHandle,7,1);\n\n\n\n\n\nSupported Instruments\n\nAgilent E3632A, E3633A, E3634A, E3640A, E3641A, E3642A, E3643A, E3644A, E3631A, E3645A, E3646A, E3647A, E3648A, E3649A\n\n\n\n\n\nE36XX_SetCurrentLimitBehavior\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS E36XX_SetCurrentLimitBehavior": {
  "prefix": "E36XX_SetCurrentLimitBehavior",
  "body": [
   "E36XX_SetCurrentLimitBehavior($$InstrumentHandle,$$Output,$$CurrentLimitBehavior);"
  ],
  "description": "\n\n\n\n\n\nThis function sets the current limit behavior for the specified output.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThe handle of the instrument returned from the E36XX_Init function.\n\n\n\n$Output\n\nInteger\n\nThe output channel to be configured. (Allowable values for the output channel are between 1 and 3 depending on the model of power supply).\n\n\n\n$Behavior\n\nString\n\nSets the behavior for the power supply when the current limit is reached. Allowable values are:\n\n\u00b7 \"TRIP\"\n\n\u00b7 \"REGULATE\"\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\nE36XX_SetCurrentLimitBehavior($InstrumentHandle,1,\"TRIP\");\n\n\n\n\n\nSupported Instruments\n\nAgilent E3632A, E3633A, E3634A, E3640A, E3641A, E3642A, E3643A, E3644A, E3631A, E3645A, E3646A, E3647A, E3648A, E3649A\n\n\n\n\n\nE36XX_SetVoltage\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS E36XX_SetVoltage": {
  "prefix": "E36XX_SetVoltage",
  "body": [
   "E36XX_SetVoltage($$InstrumentHandle,$$Voltage,$$VoltageRange,$$Output);"
  ],
  "description": "\n\n\n\n\n\nThis function sets the voltage value for the specified output.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThe handle of the instrument returned from the E36XX_Init function.\n\n\n\n$Voltage\n\nFloat\n\nThe Voltage value to be set in volts\n\n\n\n$VoltageRange\n\nString\n\nThe Voltage Range for to be configured [LOW,HIGH]\n\n\n\n$Output\n\nInteger\n\nThe output channel to be configured. (Allowable values for the output channel are between 1 and 3 depending on the model of power supply).\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\nE36XX_SetVoltage($InstrumentHandle,15,LOW,1);\n\n\n\n\n\nSupported Instruments\n\nAgilent E3632A, E3633A, E3634A, E3640A, E3641A, E3642A, E3643A, E3644A, E3631A, E3645A, E3646A, E3647A, E3648A, E3649A\n\n\n\n\n\nE36XX_SetVoltageAndCurrent\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS E36XX_SetVoltageAndCurrent": {
  "prefix": "E36XX_SetVoltageAndCurrent",
  "body": [
   "E36XX_SetVoltageAndCurrent($$InstrumentHandle,$$Voltage,$$Current,$$Output);"
  ],
  "description": "\n\n\n\n\n\nThis function sets the voltage and current limit value for the specified output.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThe handle of the instrument returned from the E36XX_Init function.\n\n\n\n$Voltage\n\nFloat\n\nThe Voltage value to be set in Volts\n\n\n\n$Current\n\nFloat\n\nThe Current Value to be set in Amps\n\n\n\n$Output\n\nInteger\n\nThe output channel to be configured. (Allowable values for the output channel are between 1 and 3 depending on the model of power supply).\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\nE36XX_SetVoltageAndCurrent($InstrumentHandle,15,7,1);\n\n\n\n\n\nSupported Instruments\n\nAgilent E3632A, E3633A, E3634A, E3640A, E3641A, E3642A, E3643A, E3644A, E3631A, E3645A, E3646A, E3647A, E3648A, E3649A\n\n\n\n\n\nHP662X_Close\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS HP662X_Close": {
  "prefix": "HP662X_Close",
  "body": [
   "HP662X_Close($$Handle);"
  ],
  "description": "\n\nThis function controls the Agilent 662x Series of power supplies. In order to use these function the VXI pnp driver for the instrument must be installed on the system running Jabil Test. The latest version of this driver can be downloaded from Agilent. This functions supports the following model power supplies: 6621A, 6622A, 6623A, 6624A, 6625A, 6626A, 6627A, 6628A, 6629A.\n\nThis function closes the power supply, and releases the handle and resources for the instrument.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nA handle to the HP 662X instrument\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nHP662X_Init\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS HP662X_Init": {
  "prefix": "HP662X_Init",
  "body": [
   "$$Handle=HP662X_Init($$ResourceString,$$Reset);"
  ],
  "description": "\n\nThis function controls the Agilent 662x Series of power supplies. In order to use these function the VXI pnp driver for the instrument must be installed on the system running Jabil Test. The latest version of this driver can be downloaded from Agilent. This functions supports the following model power supplies: 6621A, 6622A, 6623A, 6624A, 6625A, 6626A, 6627A, 6628A, 6629A.\n\nThis function initializes the Power supply, and returns a handle to the instrument. If the $Reset argument is set to TRUE, the instrument is reset to it's default configuration.\n\nExample:\n\n$Handle = HP662X_Init(\"GPIB0::5::INSTR\",\"TRUE\");\n\n\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ResourceString\n\nString\n\nThe Resource string of the instrument, for instance \"GPIB0::5::INSTR\"\n\n\n\n$Reset\n\nBoolean\n\nSpecifies whether or not to reset the instrument upon initialization.\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nA handle to the instrument\n\n\n\n\n\nHP662X_MeasureCurrent\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS HP662X_MeasureCurrent": {
  "prefix": "HP662X_MeasureCurrent",
  "body": [
   "$$Current=HP662X_MeasureCurrent($$Handle,$$Channel);"
  ],
  "description": "\n\nThis function controls the Agilent 662x Series of power supplies. In order to use these function the VXI pnp driver for the instrument must be installed on the system running Jabil Test. The latest version of this driver can be downloaded from Agilent. This functions supports the following model power supplies: 6621A, 6622A, 6623A, 6624A, 6625A, 6626A, 6627A, 6628A, 6629A.\n\nThis function measures the current draw on a specified output port.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nA handle to the HP 662X instrument\n\n\n\n$Channel\n\nInteger\n\nThe channel on the power supply to be configured\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Current\n\nFloat\n\nThe current draw on the specified port measured in Amps.\n\n\n\n\n\nHP662X_MeasureVoltage\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS HP662X_MeasureVoltage": {
  "prefix": "HP662X_MeasureVoltage",
  "body": [
   "$$Voltage=HP662X_MeasureVoltage($$Handle,$$Channel);"
  ],
  "description": "\n\nThis function controls the Agilent 662x Series of power supplies. In order to use these function the VXI pnp driver for the instrument must be installed on the system running Jabil Test. The latest version of this driver can be downloaded from Agilent. This functions supports the following model power supplies: 6621A, 6622A, 6623A, 6624A, 6625A, 6626A, 6627A, 6628A, 6629A.\n\nThis function measures the voltage on a specified output port.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nA handle to the HP 662X instrument\n\n\n\n$Channel\n\nInteger\n\nThe channel on the power supply to be configured\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Voltage\n\nFloat\n\nThe voltage measurement on the specified port measured in volts\n\n\n\n\n\nHP662X_Reset\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS HP662X_Reset": {
  "prefix": "HP662X_Reset",
  "body": [
   "HP662X_Reset($$Handle);"
  ],
  "description": "\n\nThis function controls the Agilent 662x Series of power supplies. In order to use these function the VXI pnp driver for the instrument must be installed on the system running Jabil Test. The latest version of this driver can be downloaded from Agilent. This functions supports the following model power supplies: 6621A, 6622A, 6623A, 6624A, 6625A, 6626A, 6627A, 6628A, 6629A.\n\nThis function resets the power supply to it's default configuration.\n\nExample:\n\nHP662X_Reset($Handle);\n\n\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nA Handle to the HP662X instrument.\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nHP662X_SetCurrent\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS HP662X_SetCurrent": {
  "prefix": "HP662X_SetCurrent",
  "body": [
   "HP662X_SetCurrent($$Handle,$$Channel,$$Current);"
  ],
  "description": "\n\nThis function controls the Agilent 662x Series of power supplies. In order to use these function the VXI pnp driver for the instrument must be installed on the system running Jabil Test. The latest version of this driver can be downloaded from Agilent. This functions supports the following model power supplies: 6621A, 6622A, 6623A, 6624A, 6625A, 6626A, 6627A, 6628A, 6629A.\n\nThis function specifies the output current on a given channel for the power supply.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nA handle to the HP 662X instrument\n\n\n\n$Channel\n\nInteger\n\nThe channel on the power supply to be configured\n\n\n\n$Current\n\nFloat\n\nThe desired current for the power supply channel.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nHP662X_SetCurrentProtection\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS HP662X_SetCurrentProtection": {
  "prefix": "HP662X_SetCurrentProtection",
  "body": [
   "HP662X_SetCurrentProtection($$Handle,$$Channel,$$IsEnabled);"
  ],
  "description": "\n\nThis function controls the Agilent 662x Series of power supplies. In order to use these function the VXI pnp driver for the instrument must be installed on the system running Jabil Test. The latest version of this driver can be downloaded from Agilent. This functions supports the following model power supplies: 6621A, 6622A, 6623A, 6624A, 6625A, 6626A, 6627A, 6628A, 6629A.\n\nThis function configures the Current Protection for a given channel on the power supply.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nA handle to the HP 662X instrument\n\n\n\n$Channel\n\nInteger\n\nThe channel on the power supply to be configured\n\n\n\n$IsEnabled\n\nString\n\nThe desired state of the current protection. Valid Values are:\n\n\u00b7 \"ON\"\n\n\u00b7 \"OFF\"\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nHP662X_SetOutput\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS HP662X_SetOutput": {
  "prefix": "HP662X_SetOutput",
  "body": [
   "HP662X_SetOutput($$Handle,$$Channel,$$State);"
  ],
  "description": "\n\nThis function controls the Agilent 662x Series of power supplies. In order to use these function the VXI pnp driver for the instrument must be installed on the system running Jabil Test. The latest version of this driver can be downloaded from Agilent. This functions supports the following model power supplies: 6621A, 6622A, 6623A, 6624A, 6625A, 6626A, 6627A, 6628A, 6629A.\n\nThis function specifies the output status for a given channel on the power supply.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nA handle to the HP 662X instrument\n\n\n\n$Channel\n\nInteger\n\nThe channel on the power supply to be configured\n\n\n\n$State\n\nString\n\nThe desired output status of the channel. Allowable values are:\n\n\u00b7 \"ON\"\n\n\u00b7 \"OFF\"\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nHP662X_SetVoltage\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS HP662X_SetVoltage": {
  "prefix": "HP662X_SetVoltage",
  "body": [
   "HP662X_SetVoltage($$Handle,$$Channel,$$Voltage);"
  ],
  "description": "\n\nThis function controls the Agilent 662x Series of power supplies. In order to use these function the VXI pnp driver for the instrument must be installed on the system running Jabil Test. The latest version of this driver can be downloaded from Agilent. This functions supports the following model power supplies: 6621A, 6622A, 6623A, 6624A, 6625A, 6626A, 6627A, 6628A, 6629A.\n\nThis function specifies the output voltage on a given channel for the power supply.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nA handle to the HP 662X instrument\n\n\n\n$Channel\n\nInteger\n\nThe channel on the power supply to be configured\n\n\n\n$Voltage\n\nFloat\n\nThe desired voltage for the power supply channel.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nHP662X_SetVoltageProtection\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS HP662X_SetVoltageProtection": {
  "prefix": "HP662X_SetVoltageProtection",
  "body": [
   "HP662X_SetVoltageProtection($$Handle,$$Channel,$$VoltageProtection);"
  ],
  "description": "\n\nThis function controls the Agilent 662x Series of power supplies. In order to use these function the VXI pnp driver for the instrument must be installed on the system running Jabil Test. The latest version of this driver can be downloaded from Agilent. This functions supports the following model power supplies: 6621A, 6622A, 6623A, 6624A, 6625A, 6626A, 6627A, 6628A, 6629A.\n\nThis function specifies the output voltage protection on a given channel for the power supply.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nA handle to the HP 662X instrument\n\n\n\n$Channel\n\nInteger\n\nThe channel on the power supply to be configured\n\n\n\n$VoltageProtection\n\nFloat\n\nThe desired voltage protection limit for the power supply channel.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nHP66XX_Close\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS HP66XX_Close": {
  "prefix": "HP66XX_Close",
  "body": [
   "HP66XX_Close($$InstrumentHandle);"
  ],
  "description": "\n\n\n\n\n\nThe close function terminates the software connection to the instrument and de-allocates system resources. It is generally a good programming habit to close the instrument handle when the program is done using the instrument.\n\n\n\n\n\nNote: This driver requires the Agilent 66XX IVI Driver to be installed before using these functions.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThe handle of the instrument returned from the HP66XX_Init function\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\nHP66XX_Close($InstrumentHandle);\n\n\n\n\n\nSupported Instruments\n\n664xA, 665xA, 667xA, 668xA System DC Power Supplies\n\n603xA Autoranging System Dc Power Supplies (SCPI-compatible units only)\n\nE4356A Telecommunications DC Power Supply\n\n\n\n\n\nHP66XX_Init\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS HP66XX_Init": {
  "prefix": "HP66XX_Init",
  "body": [
   "$$Handle=HP66XX_Init($$InstrumentAddress,$$QueryInstrument,$$ResetInstrument);"
  ],
  "description": "\n\n\n\nThe initialize function initializes the software connection to the instrument and optionally verifies that instrument is in the system. In addition, it may perform any necessary actions to place the instrument in its reset state.\n\n\n\n\n\nNote:\n\n\u00b7 This driver requires the Agilent 66XX IVI Driver to be installed before using these functions.\n\n\u00b7 Setting $QueryInstrument to true will check that the instrument specified by the resource string is a supported type of instrument. It will generate an error if it is not a supported instrument and will generate an error is no instrument is connected at that address. Setting $QueryInstrument to false will only generate an error if no instrument (of any type) is connected at the specified address.\n\n\u00b7 This library supports the following models of power supplies:\n\n4356A, 6641A, 6642A, 6643A, 6644A, 6645A, 6651A, 6652A, 6653A, 6654A, 6655A, 6671A, 6672A, 6673A, 6674A, 6675A, 6680A, 6681A, 6682A, 6683A, 6684A, 6690A, 6691A, 6692A\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentAddress\n\nString\n\nThe resource string of the instrument, for instance \"GPIB0::5::INSTR\"\n\n\n\n$QueryInstrument\n\nBoolean\n\nSpecifies whether or not to query the instrument on initialization.\n\n\n\n$ResetInstrument\n\nBoolean\n\nSpecifies whether or not to reset the instrument on initialization.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nReturns the handle to the instrument to use in following instrument control functions.\n\n\n\n\n\nExamples:\n\n$Handle = HP66XX_Init(\"GPIB0::5::INSTR\", false, true);\n\n\n\n\n\nHP66XX_MeasureCurrent\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS HP66XX_MeasureCurrent": {
  "prefix": "HP66XX_MeasureCurrent",
  "body": [
   "$$Current=HP66XX_MeasureCurrent($$InstrumentHandle);"
  ],
  "description": "\n\n\n\n\n\nThis function measures the output current.\n\n\n\n\n\nIf the measurement does not complete within the time allotted with the hp66xx_setMeasTimeout() function, the function returns a HP66xx_INSTR_ERROR_MEAS_TMO error status.\n\n\n\n\n\nNote: This driver requires the Agilent 66XX IVI Driver to be installed before using these functions.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThe handle of the instrument returned from the HP66XX_Init function\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Current\n\nFloat\n\nThe current from the power supply measured in amps.\n\n\n\n\n\nExamples:\n\n$Current = HP66XX_MeasureCurrent($InstrumentHandle);\n\n\n\n\n\nSupported Instruments\n\n664xA, 665xA, 667xA, 668xA System DC Power Supplies\n\n603xA Autoranging System Dc Power Supplies (SCPI-compatible units only)\n\nE4356A Telecommunications DC Power Supply\n\n\n\n\n\nHP66XX_MeasureVoltage\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS HP66XX_MeasureVoltage": {
  "prefix": "HP66XX_MeasureVoltage",
  "body": [
   "$$Voltage=HP66XX_MeasureVoltage($$InstrumentHandle);"
  ],
  "description": "\n\n\n\n\n\nThis function measures the output voltage.\n\n\n\n\n\nIf the measurement does not complete within the time allotted with the hp66xx_setMeasTimeout() function, the function returns a HP66xx_INSTR_ERROR_MEAS_TMO error status.\n\n\n\n\n\nNote: This driver requires the Agilent 66XX IVI Driver to be installed before using these functions.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThe handle of the instrument returned from the HP66XX_Init function\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Voltage\n\nFloat\n\nThe voltage from the power supply measured in volts.\n\n\n\n\n\nExamples:\n\n$Voltage = HP66XX_MeasureVoltage($InstrumentHandle);\n\n\n\n\n\nSupported Instruments\n\n664xA, 665xA, 667xA, 668xA System DC Power Supplies\n\n603xA Autoranging System Dc Power Supplies (SCPI-compatible units only)\n\nE4356A Telecommunications DC Power Supply\n\n\n\n\n\nHP66XX_SetCurrent\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS HP66XX_SetCurrent": {
  "prefix": "HP66XX_SetCurrent",
  "body": [
   "HP66XX_SetCurrent($$InstrumentHandle,$$CurrentMode,$$CurrentLevel);"
  ],
  "description": "\n\n\n\n\n\nThis function directly programs the selected current parameter of the power supply.\n\n\n\nNote: This driver requires the Agilent 66XX IVI Driver to be installed before using these functions.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThe handle of the instrument returned from the HP66XX_Init function\n\n\n\n$CurrentMode\n\nString\n\nThe current mode for the instrument. Allowable settings are:\n\n\u00b7 \"HP66XX_CURR_IMM\" = Immediate Current Level\n\n\u00b7 \"HP66XX_CURR_TRIG\" = Triggered Current Level\n\n\n\n$CurrentLevel\n\nFloat\n\nThe current level to be programmed.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\nHP66XX_SetCurrent($InstrumentHandle, \"HP66XX_CURR_IMM\", 1.2);\n\n\n\n\n\nSupported Instruments\n\n664xA, 665xA, 667xA, 668xA System DC Power Supplies\n\n603xA Autoranging System Dc Power Supplies (SCPI-compatible units only)\n\nE4356A Telecommunications DC Power Supply\n\n\n\n\n\nHP66XX_SetOutput\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS HP66XX_SetOutput": {
  "prefix": "HP66XX_SetOutput",
  "body": [
   "HP66XX_SetOutput($$InstrumentHandle,$$OutputState,$$SwitchRelay);"
  ],
  "description": "\n\n\n\n\n\nThis function enables or disables the output of the instrument. The state of the disabled output is a condition of zero output voltage and current at the output terminals.\n\n\n\n\n\nThis function also controls the output relay for units with the optional relay connector. The switchRelay parameter specifies if the output relay is also changed.\n\n\n\n\n\nNote: This driver requires the Agilent 66XX IVI Driver to be installed before using these functions.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThe handle of the instrument returned from the HP66XX_Init function\n\n\n\n$OutputState\n\nString\n\nSpecifies the output state of the instrument. Allowable settings are:\n\n\u00b7 \"ON\" = Output Enabled\n\n\u00b7 \"OFF\" = Output Disabled\n\n\n\n$SwitchRelay\n\nBoolean\n\nControls the output relay:\n\n\u00b7 \"TRUE\" = the output relay is switched along with the output\n\n\u00b7 \"FALSE\" = the output relay is NOT switched along with the output\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\nHP66XX_SetOutput($InstrumentHandle, \"ON\", false);\n\n\n\n\n\nSupported Instruments\n\n664xA, 665xA, 667xA, 668xA System DC Power Supplies\n\n603xA Autoranging System Dc Power Supplies (SCPI-compatible units only)\n\nE4356A Telecommunications DC Power Supply\n\n\n\n\n\nHP66XX_SetVoltage\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS HP66XX_SetVoltage": {
  "prefix": "HP66XX_SetVoltage",
  "body": [
   "HP66XX_SetVoltage($$InstrumentHandle,$$VoltageMode,$$VoltageLevel);"
  ],
  "description": "\n\n\n\n\n\nThis function directly programs the selected current parameter of the power supply.\n\n\n\n\n\nNote: This driver requires the Agilent 66XX IVI Driver to be installed before using these functions.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThe handle of the instrument returned from the HP66XX_Init function\n\n\n\n$VoltageMode\n\nString\n\nSpecifies the Voltage Mode to be programmed. Allowable settings are:\n\n\n\n\n\n\u00b7 \"HP66XX_VOLT_IMM\" = Immediate Voltage Level\n\n\u00b7 \"HP66XX_VOLT_TRIG\" = Triggered Voltage Level\n\n\u00b7 \"HP66XX_VOLT_OVP\" = OVP Level\n\n\u00b7 \"HP66XX_VOLT_OVP_MAX\" = Maximum OVP\n\n\u00b7 \"HP66XX_VOLT_OVP_MIN\" = Minimum OVP\n\n\n\n$VoltageLevel\n\nFloat\n\nThe voltage level to be programmed.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\nHP66XX_SetVoltage($InstrumentHandle, \"HP66XX_VOLT_IMM\", 5.0);\n\n\n\n\n\nSupported Instruments\n\n664xA, 665xA, 667xA, 668xA System DC Power Supplies\n\n603xA Autoranging System Dc Power Supplies (SCPI-compatible units only)\n\nE4356A Telecommunications DC Power Supply\n\n\n\n\n\nAG66XX_Close\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG66XX_Close": {
  "prefix": "AG66XX_Close",
  "body": [
   "AG66XX_Close($$InstrumentHandle);"
  ],
  "description": "\n\n\n\n\n\nThe close function terminates the software connection to the instrument and de-allocates system resources. It is generally a good programming habit to close the instrument handle when the program is done using the instrument.\n\n\n\n\n\nNote: This function requires the Agilent 66XX IVI-COM Driver to be installed before using this function.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThe handle of the instrument returned from the AG66XX_Initialize function\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\nAG66XX_Close($InstrumentHandle);\n\n\n\n\n\nSupported Instruments\n\n664xA, 665xA, 667xA, 668xA System DC Power Supplies\n\n603xA Autoranging System Dc Power Supplies (SCPI-compatible units only)\n\nE4356A Telecommunications DC Power Supply\n\n\n\n\n\nAG66XX_Initialize\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS HP66XX_Initialize": {
  "prefix": "HP66XX_Initialize",
  "body": [
   "$$Handle=HP66XX_Initialize($$InstrumentAddress,$$QueryInstrument,$$ResetInstrument,$$OptionString);"
  ],
  "description": "\n\n\n\n\n\nThe initialize function initializes the software connection to the instrument and optionally verifies that instrument is in the system. In addition, it may perform any necessary actions to place the instrument in its reset state.\n\n\n\n\n\nThe option string is optional, and can be set to an empty string.\n\n\n\n\n\nNote:\n\n\u00b7 This function requires the Agilent 66XX IVI-COM Driver to be installed before using this function.\n\n\u00b7 Setting $QueryInstrument to true will check that the instrument specified by the resource string is a supported type of instrument. It will generate an error if it is not a supported instrument and will generate an error is no instrument is connected at that address. Setting $QueryInstrument to false will only generate an error if no instrument (of any type) is connected at the specified address.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentAddress\n\nString\n\nThe resource string of the instrument, for instance \"GPIB0::5::INSTR\"\n\n\n\n$QueryInstrument\n\nBoolean\n\nSpecifies whether or not to query the instrument on initialization.\n\n\n\n$ResetInstrument\n\nBoolean\n\nSpecifies whether or not to reset the instrument on initialization.\n\n\n\n$OptionString\n\nString\n\nSpecifies the initial values of certain IVI inherent attributes for the session.\n\nThe format of an assignment in the OptionString parameter is \"Name=Value\",\n\nwhere Name is one of the option string names in the table below.\n\n\u00b7 RangeCheck=(true/false)\n\n\u00b7 QueryInstrStatus=(true/false)\n\n\u00b7 Cache=(true/false)\n\n\u00b7 Simulate=(true/false)\n\n\u00b7 RecordCoercions=(true/false)\n\n\u00b7 InterchangeCheck=(true/false)\n\n\u00b7 DriverSetup=(setup parameters, see driver documentation for additional details)\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nReturns the handle to the instrument to use in following instrument control functions.\n\n\n\n\n\nExamples:\n\n$Handle = AG66XX_Initialize(\"GPIB0::5::INSTR\", false, true, \"\");\n\n\n\n\n\nSupported Instruments\n\n664xA, 665xA, 667xA, 668xA System DC Power Supplies\n\n603xA Autoranging System Dc Power Supplies (SCPI-compatible units only)\n\nE4356A Telecommunications DC Power Supply\n\n\n\n\n\nAG66XX_MeasureCurrent\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG66XX_MeasureCurrent": {
  "prefix": "AG66XX_MeasureCurrent",
  "body": [
   "$$Current=AG66XX_MeasureCurrent($$InstrumentHandle);"
  ],
  "description": "\n\n\n\n\n\nThis function measures the output current.\n\n\n\n\n\nNote: This function requires the Agilent 66XX IVI-COM Driver to be installed before using this function.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThe handle of the instrument returned from the AG66XX_Initialize function\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Current\n\nFloat\n\nThe current from the power supply measured in amps.\n\n\n\n\n\nExamples:\n\n$Current = AG66XX_MeasureCurrent($InstrumentHandle);\n\n\n\n\n\nSupported Instruments\n\n664xA, 665xA, 667xA, 668xA System DC Power Supplies\n\n603xA Autoranging System Dc Power Supplies (SCPI-compatible units only)\n\nE4356A Telecommunications DC Power Supply\n\n\n\n\n\nAG66XX_MeasureVoltage\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG66XX_MeasureVoltage": {
  "prefix": "AG66XX_MeasureVoltage",
  "body": [
   "$$Voltage=AG66XX_MeasureVoltage($$InstrumentHandle);"
  ],
  "description": "\n\n\n\n\n\nThis function measures the output voltage.\n\n\n\n\n\nNote: This function requires the Agilent 66XX IVI-COM Driver to be installed before using this function.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThe handle of the instrument returned from the AG66XX_Initialize function\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Voltage\n\nFloat\n\nThe voltage from the power supply measured in volts.\n\n\n\n\n\nExamples:\n\n$Voltage = AG66XX_MeasureVoltage($InstrumentHandle);\n\n\n\n\n\nSupported Instruments\n\n664xA, 665xA, 667xA, 668xA System DC Power Supplies\n\n603xA Autoranging System Dc Power Supplies (SCPI-compatible units only)\n\nE4356A Telecommunications DC Power Supply\n\n\n\n\n\nAG66XX_SetOutputCurrentLimit\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG66XX_SetOutputCurrentLimit": {
  "prefix": "AG66XX_SetOutputCurrentLimit",
  "body": [
   "AG66XX_SetOutputCurrentLimit($$InstrumentHandle,$$CurrentLimitMode,$$CurrentLimit);"
  ],
  "description": "\n\n\n\n\n\nThis function sets the output current limit and it's tripping behavior.\n\n\n\nNote: This function requires the Agilent 66XX IVI-COM Driver to be installed before using this function.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThe handle of the instrument returned from the AG66XX_Initialize function\n\n\n\n$CurrentLimitBehavior\n\nString\n\nThe current limiting behavior of the instrument. Allowable values are:\n\n\u00b7 \"TRIP\"\n\n\u00b7 \"REGULATE\"\n\n\n\n$CurrentLevel\n\nFloat\n\nThe current limit setting in AMPS.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\nAG66XX_SetOutputCurrentLimit($InstrumentHandle, \"TRIP\", 2.2);\n\n\n\n\n\nSupported Instruments\n\n664xA, 665xA, 667xA, 668xA System DC Power Supplies\n\n603xA Autoranging System Dc Power Supplies (SCPI-compatible units only)\n\nE4356A Telecommunications DC Power Supply\n\n\n\n\n\nAG66XX_SetOutputEnable\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG66XX_SetOutputEnable": {
  "prefix": "AG66XX_SetOutputEnable",
  "body": [
   "AG66XX_SetOutputEnable($$InstrumentHandle,$$OutputState);"
  ],
  "description": "\n\n\n\n\n\nThis function enables or disables the output of the instrument. The state of the disabled output is a condition of zero output voltage and current at the output terminals.\n\n\n\n\n\nNote: This function requires the Agilent 66XX IVI-COM Driver to be installed before using this function.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThe handle of the instrument returned from the AG66XX_Init function\n\n\n\n$OutputState\n\nString\n\nSpecifies the output state of the instrument. Allowable settings are:\n\n\u00b7 \"ON\" = Output Enabled\n\n\u00b7 \"OFF\" = Output Disabled\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\nAG66XX_SetOutputEnable($InstrumentHandle, \"ON\");\n\n\n\n\n\nSupported Instruments\n\n664xA, 665xA, 667xA, 668xA System DC Power Supplies\n\n603xA Autoranging System Dc Power Supplies (SCPI-compatible units only)\n\nE4356A Telecommunications DC Power Supply\n\n\n\n\n\nAG66XX_SetOutputVoltage\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG66XX_SetOutputVoltage": {
  "prefix": "AG66XX_SetOutputVoltage",
  "body": [
   "AG66XX_SetOutputVoltage($$InstrumentHandle,$$Voltage);"
  ],
  "description": "\n\n\n\n\n\nThis function sets the output voltage for the power supply.\n\n\n\n\n\nNote: This function requires the Agilent 66XX IVI-COM Driver to be installed before using this function.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThe handle of the instrument returned from the HP66XX_Init function\n\n\n\n$VoltageLevel\n\nFloat\n\nThe voltage level to be programmed.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\nAG66XX_SetOutputVoltage($InstrumentHandle, 5.0);\n\n\n\n\n\nSupported Instruments\n\n664xA, 665xA, 667xA, 668xA System DC Power Supplies\n\n603xA Autoranging System Dc Power Supplies (SCPI-compatible units only)\n\nE4356A Telecommunications DC Power Supply\n\n\n\n\n\nN57XX_Close\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS N57XX_Close": {
  "prefix": "N57XX_Close",
  "body": [
   "N57XX_Close($$Handle);"
  ],
  "description": "Closes the I/O session to the instrument. Driver methods and properties that access the instrument are not accessible after Close is called.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nHandle of the instrument.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nnone\n\n\n\n\n\nN57XX_Init\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS N57XX_Init": {
  "prefix": "N57XX_Init",
  "body": [
   "$$Handle=N57XX_Init($$ResourceName,$$IdQuery,$$Reset,$$OptionalString);"
  ],
  "description": "\n\nOpens the I/O session to the instrument. Driver methods and properties that access the instrument are only accessible after Initialize is called. Initialize optionally performs a Reset and queries the instrument to validate the instrument model.\n\nThis function returns the instrument handle.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ResourceName\n\nString\n\nGPIB address of the instrument\n\n\n\n$IdQuery\n\nBoolean\n\nSpecifies whether to verify the ID of the instrument. Allowed Values, \"TRUE\" or \"FALSE\"\n\n\n\n$Reset\n\nBoolean\n\nSpecifies whether to reset the instrument. Allowed Values, \"TRUE\" or \"FALSE\"\n\n\n\n$OptionalString\n\nString\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nInstrument handle\n\n\n\n\n\nN57XX_MeasureCurrent\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS N57XX_MeasureCurrent": {
  "prefix": "N57XX_MeasureCurrent",
  "body": [
   "$$Current=N57XX_MeasureCurrent($$Handle);"
  ],
  "description": "\n\nMeasures the output current and returns the measured value.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nHandle of the instrument.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Current\n\nDouble\n\nMeasured current value in Amps\n\n\n\n\n\nN57XX_MeasureVoltage\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS N57XX_MeasureVoltage": {
  "prefix": "N57XX_MeasureVoltage",
  "body": [
   "$$Voltage=N57XX_MeasureVoltage($$Handle);"
  ],
  "description": "\n\nMeasures the output current and returns the measured value.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nHandle of the instrument.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Voltage\n\nDouble\n\nMeasured voltage value in volts\n\n\n\n\n\nN57XX_Output\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS N57XX_Output": {
  "prefix": "N57XX_Output",
  "body": [
   "N57XX_Output($$Handle,$$State);"
  ],
  "description": "\n\nSets the output properties.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nHandle of the instrument\n\n\n\n$State\n\nString\n\nSpecifies whether the power module output is enabled or disabled. Acceptable values are \"ON\" and \"OFF\"\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\nNone\n\nNone\n\n\n\n\n\nN57XX_SetCurrent\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS N57XX_SetCurrent": {
  "prefix": "N57XX_SetCurrent",
  "body": [
   "N57XX_SetCurrent($$Handle,$$CurrentLevel,$$CurrentBehavior);"
  ],
  "description": "\n\n\n\n\n\nThis function sets the current limit and the bevahior on the N57XX power supply. If the behavior is set to 'TRIP' then the output will trip into over current mode and disable the output. If the output is set to regulate, the power supply will attempt to regulate the amount of current flowing at the desired level.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nHandle of the instrument\n\n\n\n$CurrentLevel\n\nDouble\n\nSpecifies the output current level. The units are amps.\n\n\n\n$CurrentLimitBehavior\n\nString\n\nThe current limiting behavior for the specified output. Allowable options are:\n\n\u00b7 \"TRIP\"\n\n\u00b7 \"REGULATE\"\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\nNone\n\nNone\n\n\n\n\n\nN57XX_SetVoltage\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS N57XX_SetVoltage": {
  "prefix": "N57XX_SetVoltage",
  "body": [
   "N57XX_SetVoltage($$Handle,$$Voltage_Level);"
  ],
  "description": "\n\nSets the output properties.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nHandle of the instrument\n\n\n\n$Voltage_Level\n\nDouble\n\nSpecifies the output voltage level. The units are volts.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\nNone\n\nNone\n\n\n\n\n\nN67XX_Close\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS N67XX_Close": {
  "prefix": "N67XX_Close",
  "body": [
   "N67XX_Close($$InstrumentHandle);"
  ],
  "description": "\n\n\n\nThe close function terminates the software connection to the instrument and de-allocates system resources. It is generally a good programming habit to close the instrument handle when the program is done using the instrument.\n\n\n\n\n\nRemarks:\n\n\n\nThis instrument library requires the loading of the IVI-VISA library, the Keysight IO Libraries Suite and the N67xx Power Supply IVI and MatLab drivers.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThe handle of the instrument returned from the N67XX_Init function\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\nN67XX_Close($InstrumentHandle);\n\n\n\n\n\nSupported Instruments\n\nAll Agilent N67xx Power Supply Mainframes\n\n\n\n\n\nN67XX_ConfigureOVP\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS N67XX_ConfigureOVP": {
  "prefix": "N67XX_ConfigureOVP",
  "body": [
   "N67XX_ConfigureOVP($$InstrumentHandle,$$OutputChannel,$$VoltageLimit);"
  ],
  "description": "\n\n\n\nThis function configures the over voltage protection for the specified output.\n\n\n\n\n\nRemarks:\n\n\n\nThis instrument library requires the loading of the IVI-VISA library, the Keysight IO Libraries Suite and the N67xx Power Supply IVI and MatLab drivers.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThe handle of the instrument returned from the N67XX_Init function\n\n\n\n$OutputChannel\n\nInteger\n\nThe output channel to configure\n\n\n\n$VoltageLimit\n\nFloat\n\nThe voltage limit for the specified output.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\nN67XX_ConfigureOVP($InstrumentHandle,1,5.0);\n\n\n\n\n\nSupported Instruments\n\nAll Agilent n67XX series power supply mainframes.\n\n\n\n\n\nN67XX_ConfigureOutput\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS N67XX_ConfigureOutput": {
  "prefix": "N67XX_ConfigureOutput",
  "body": [
   "N67XX_ConfigureOutput($$InstrumentHandle,$$OutputChannel,$$VoltageLevel,$$VoltageRange,$$CurrentLimit,$$CurrentLimitBehavior);"
  ],
  "description": "\n\n\n\nThis function configures the specified output channel on the Agilent N67xx series power supply.\n\n\n\n\n\nRemarks:\n\n\n\nThis instrument library requires the loading of the IVI-VISA library, the Keysight IO Libraries Suite and the N67xx Power Supply IVI and MatLab drivers.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThe handle of the instrument returned from the N67XX_Init function\n\n\n\n$OutputChannel\n\nInteger\n\nThe output channel to configure\n\n\n\n$VoltageLevel\n\nFloat\n\nThe voltage level for the specified output\n\n\n\n$VoltageRange\n\nFloat\n\nThe voltage range for the specified output\n\n\n\n$CurrentLimit\n\nFloat\n\nThe current limit for the specified output\n\n\n\n$CurrentLimitBehavior\n\nString\n\nThe current limiting behavior for the specified output. Allowable options are:\n\n\u00b7 \"TRIP\"\n\n\u00b7 \"REGULATE\"\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Voltage\n\nFloat\n\nThe voltage from the power supply measured in volts.\n\n\n\n\n\nExamples:\n\n$Current = N67XX_ConfigureOutput($InstrumentHandle,1,5.0,5.0,1.0,\"TRIP\");\n\n\n\n\n\nSupported Instruments\n\nAll Agilent n67XX series power supply mainframes.\n\n\n\n\n\nN67XX_Init\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS N67XX_Init": {
  "prefix": "N67XX_Init",
  "body": [
   "$$Handle=N67XX_Init($$InstrumentAddress,$$QueryInstrument,$$ResetInstrument,$$OptionString);"
  ],
  "description": "\n\n\n\nThe initialize function initializes the software connection to the instrument and optionally verifies that instrument is in the system. In addition, it may perform any necessary actions to place the instrument in its reset state.\n\n\n\n\n\nRemarks:\n\n\n\nThis instrument library requires the loading of the IVI-VISA library, the Keysight IO Libraries Suite and the N67xx Power Supply IVI and MatLab drivers.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentAddress\n\nString\n\nThe resource string of the instrument, for instance \"GPIB0::5::INSTR\"\n\n\n\n$QueryInstrument\n\nBoolean\n\nSpecifies whether or not to query the instrument on initialization.\n\n\n\n$ResetInstrument\n\nBoolean\n\nSpecifies whether or not to reset the instrument on initialization.\n\n\n\n$OptionString\n\nString\n\nOption String for extra parameters to be sent to the N67xx during initialization.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nReturns the handle to the instrument to use in following instrument control functions.\n\n\n\n\n\nExamples:\n\n$Handle =N67XX_Init(\"GPIB0::5::INSTR\",\"FALSE\",\"TRUE\",\"\");\n\n\n\n\n\nSupported Instruments\n\nAll Agilent n67XX series power supply mainframes.\n\n\n\n\n\nN67XX_MeasureCurrent\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS N67XX_MeasureCurrent": {
  "prefix": "N67XX_MeasureCurrent",
  "body": [
   "$$Current=N67XX_MeasureCurrent($$InstrumentHandle,$$OutputChannel);"
  ],
  "description": "\n\n\n\nThis function measures the output current on the specified channel.\n\n\n\n\n\nRemarks:\n\n\n\nThis instrument library requires the loading of the IVI-VISA library, the Keysight IO Libraries Suite and the N67xx Power Supply IVI and MatLab drivers.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThe handle of the instrument returned from the N67XX_Init function\n\n\n\n$OutputChannel\n\nInteger\n\nThe output channel on which to perform the voltage measurement.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Voltage\n\nFloat\n\nThe voltage from the power supply measured in volts.\n\n\n\n\n\nExamples:\n\n$Current = N67XX_MeasureCurrent($InstrumentHandle,$OutputChannel);\n\n\n\n\n\nSupported Instruments\n\nAll Agilent n67XX series power supply mainframes.\n\n\n\n\n\nN67XX_MeasureVoltage\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS N67XX_MeasureVoltage": {
  "prefix": "N67XX_MeasureVoltage",
  "body": [
   "$$Voltage=N67XX_MeasureVoltage($$InstrumentHandle,$$OutputChannel);"
  ],
  "description": "\n\n\n\nThis function measures the output voltage on the specified channel.\n\n\n\n\n\nRemarks:\n\n\n\nThis instrument library requires the loading of the IVI-VISA library, the Keysight IO Libraries Suite and the N67xx Power Supply IVI and MatLab drivers.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThe handle of the instrument returned from the N67XX_Init function\n\n\n\n$OutputChannel\n\nInteger\n\nThe output channel on which to perform the voltage measurement.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Voltage\n\nFloat\n\nThe voltage from the power supply measured in volts.\n\n\n\n\n\nExamples:\n\n$Voltage = N67XX_MeasureVoltage($InstrumentHandle,$OutputChannel);\n\n\n\n\n\nSupported Instruments\n\nAll Agilent n67XX series power supply mainframes.\n\n\n\n\n\nN67XX_ResetOutputProtection\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS N67XX_ResetOutputProtection": {
  "prefix": "N67XX_ResetOutputProtection",
  "body": [
   "N67XX_ResetOutputProtection($$InstrumentHandle,$$OutputChannel);"
  ],
  "description": "\n\n\n\nThis function resets the output protection on the supplied power supply output. It will clear over-current or over-voltage protection trips.\n\n\n\n\n\nRemarks:\n\n\n\nThis instrument library requires the loading of the IVI-VISA library, the Keysight IO Libraries Suite and the N67xx Power Supply IVI and MatLab drivers.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThe handle of the instrument returned from the N67XX_Init function\n\n\n\n$OutputChannel\n\nInteger\n\nThe output channel on which to perform the voltage measurement.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\nN67XX_ResetOutputProtection($InstrumentHandle,$OutputChannel);\n\n\n\n\n\nSupported Instruments\n\nAll Agilent n67XX series power supply mainframes.\n\n\n\n\n\nN67XX_SendCommand\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS N67XX_SendCommand": {
  "prefix": "N67XX_SendCommand",
  "body": [
   "N67XX_SendCommand($$Handle,$$Command,$$ClearAndEnd);"
  ],
  "description": "\n\n\n\nThis function passes a raw SCPI command to to the instrument to control functionality that isn't exposed via the device driver.\n\n\n\nRemarks:\n\n\n\nThis instrument library requires the loading of the IVI-VISA library, the Keysight IO Libraries Suite and the N67xx Power Supply IVI and MatLab drivers.\n\nThe $ClearAndEnd boolean parameter instructs the instrument that the command is complete, and that it should clear the receive buffer.\n\nNOTE: This function validates that the command was sent and received by the instrument successfully, but it doesn't validate that the command sent was processed successfully.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nThe handle of the instrument returned from the initialization function.\n\n\n\n$Command\n\nString\n\nThe command to be sent to the instrument.\n\n\n\n$ClearAndEnd\n\nBoolean\n\nSpecifies that the command is completed, and that the instrument should clear the receive buffer.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\nN67XX_SendCommand($Handle,\u201dTRIGGER:A:MODE NORMAL\u201d,true);\n\n\n\n\n\nN67XX_SetOCPDelay\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS N67XX_SetOCPDelay": {
  "prefix": "N67XX_SetOCPDelay",
  "body": [
   "N67XX_SetOCPDelay($$InstrumentHandle,$$Channel,$$DelayTime);"
  ],
  "description": "\n\n\n\nThis function adjusts the Overcurrent Protection Delay for the specified power supply channel. All other settings of the Over Current Protection mode are unaffected. The $DelayTime parameter is specified in seconds.\n\n\n\n\n\nRemarks:\n\n\n\nThis instrument library requires the loading of the IVI-VISA library, the Keysight IO Libraries Suite and the N67xx Power Supply IVI and MatLab drivers.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThe handle of the instrument returned from the N67XX_Init function.\n\n\n\n$Channel\n\nInteger\n\n\u00b7 The output channel to configure\n\n\n\n$DelayTime\n\nFloat\n\nSpecifies the delay time in seconds (i.e. 250 Milliseconds = 0.250)\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\nN67XX_SetOCPDelay($N67XX,1,0.250); // Sets OCP Delay to 250 Milliseconds\n\n\n\n\n\nSupported Instruments\n\nAll Agilent n67XX series power supply mainframes.\n\n\n\n\n\nN67XX_SetOutputState\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS N67XX_SetOutputState": {
  "prefix": "N67XX_SetOutputState",
  "body": [
   "N67XX_SetOutputState($$InstrumentHandle,$$Channel,$$OutputState);"
  ],
  "description": "\n\n\n\nThis function enables or disables the output of the instrument. The state of the disabled output is a condition of zero output voltage and current at the output terminals.\n\n\n\n\n\nRemarks:\n\n\n\nThis instrument library requires the loading of the IVI-VISA library, the Keysight IO Libraries Suite and the N67xx Power Supply IVI and MatLab drivers.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThe handle of the instrument returned from the N67XX_Init function.\n\n\n\n$Channel\n\nInteger\n\n\u00b7 The output channel to configure\n\n\n\n$OutputState\n\nString\n\nSpecifies the output state of the instrument. Allowable settings are:\n\n\u00b7 \"ON\" = Output Enabled\n\n\u00b7 \"OFF\" = Output Disabled\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\nN67XX_SetOutputState($InstrumentHandle,1,\"ON\");\n\n\n\n\n\nSupported Instruments\n\nAll Agilent n67XX series power supply mainframes.\n\n\n\n\n\nKeithley2303_Init\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Keithley2303_Init": {
  "prefix": "Keithley2303_Init",
  "body": [
   "Keithley2303_Init($$InstrumentHandle);"
  ],
  "description": "\n\n\n\n\n\nInitializes the Instrument.\n\nNOTE: Uses the NIVISA drivers.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nHandle of the instrument.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\n$InstrumentHandle = NIVISA_Open(\"GPIB0::16::Instr\");\n\nKeithley2303_Init($InstrumentHandle);\n\n\n\n\n\nKeithley2303_Read\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Keithley2303_Read": {
  "prefix": "Keithley2303_Read",
  "body": [
   "Keithley2303_Read($$InstrumentHandle);"
  ],
  "description": "\n\n\n\n\n\nAsks the instrument for a reading. The returned value is based on the last setting of the unit. (i.e. \"Volt,\" \"Current,\" or \"DVM\").\n\nNOTE: Uses the NIVISA drivers.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThis is the handle to the com port initialized.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nValue\n\nString\n\nThe reading from the Power Supply.\n\n\n\n\n\nExamples:\n\nKeithley2303_Read($InstrumentHandle);\n\n\n\n\n\nKeithley2303_SetCurrLimit\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Keithley2303_SetCurrLimit": {
  "prefix": "Keithley2303_SetCurrLimit",
  "body": [
   "Keithley2303_SetCurrLimit($$InstrumentHandle,$$Limit);"
  ],
  "description": "\n\nSets the Current Limit. (0 - 5) Amps.\n\nNOTE: Uses the NIVISA drivers.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThis is the handle to the com port initialized.\n\n\n\n$Limit\n\nFloat\n\nCurrent Limit setting (0-5) Amps.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nValue\n\nString\n\nThe reading from the Power Supply.\n\n\n\n\n\nExamples:\n\nKeithley2303_SetCurrLimit($Handle,1.2);\n\n\n\n\n\nKeithley2303_SetOutput\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Keithley2303_SetOutput": {
  "prefix": "Keithley2303_SetOutput",
  "body": [
   "Keithley2303_SetOutput($$InstrumentHandle,$$State);"
  ],
  "description": "\n\nSets the output of the supply to ON or OFF.\n\nNOTE: Uses the NIVISA drivers.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThis is the handle to the com port initialized.\n\n\n\n$State\n\nString\n\n\"ON\" - Turns the output on.\n\n\"OFF\" - Turns the output off.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\nKeithley2303_SetOutput($Handle,\"ON\");\n\n\n\n\n\nKeithley2303_SetSensFunc\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Keithley2303_SetSetSensFunc": {
  "prefix": "Keithley2303_SetSetSensFunc",
  "body": [
   "Keithley2303_SetSetSensFunc($$InstrumentHandle,$$Function);"
  ],
  "description": "\n\nSets the sense reading function. The function may be \"VOLT,\" \"CURR,\" or \"DVM.\"\n\nNOTE: Uses the NIVISA drivers.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThis is the handle to the com port initialized.\n\n\n\n$Function\n\nString\n\n\"VOLT\" - Voltage readback mode.\n\n\"CURR\" - Current readback mode.\n\n\"DVM\" - DVM measurements.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\nKeithley2303_SetSensFunc($InstrumentHandle,\"VOLT\");\n\n\n\n\n\nKeithley2303_SetSenseCurrRange\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Keithley2303_SetSetSenseCurrRange": {
  "prefix": "Keithley2303_SetSetSenseCurrRange",
  "body": [
   "Keithley2303_SetSetSenseCurrRange($$InstrumentHandle,$$State);"
  ],
  "description": "\n\nSets the sense reading range. The range may be either MAX (5A range) or MIN (5mA range).\n\nNOTE: Uses the NIVISA drivers.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThis is the handle to the com port initialized.\n\n\n\n$State\n\nString\n\n\"MAX\" - 5A current readback range. \"MIN\" - 5mA current readback range.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\nKeithley2303_SetSenseCurrRange($Handle,\"MAX\");\n\n\n\n\n\nKeithley2303_SetVoltage\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Keithley2303_SetVoltage": {
  "prefix": "Keithley2303_SetVoltage",
  "body": [
   "Keithley2303_SetVoltage($$InstrumentHandle,$$Voltage);"
  ],
  "description": "\n\nSets the Output Voltage. (0 - 15) Volts.\n\nNOTE: Uses the NIVISA drivers.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThis is the handle to the com port initialized.\n\n\n\n$Voltage\n\nFloat\n\nVoltage Setting (0 - 15) Volts.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\nKeithley2303_SetVoltage($InstrumentHandle,5.2);\n\n\n\n\n\nTenmaPS_Close\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS TenmaPS_Close": {
  "prefix": "TenmaPS_Close",
  "body": [
   "TenmaPS_Close($$InstrumentId);"
  ],
  "description": "\n\n\n\n\n\nThis function closes the communication session with the instrument. The current instrument settings are not affected.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentID\n\nInteger\n\nThe instrument identifier returned from the Tenma_PS script function.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\nTenmaPS_Close($InstrumentId);\n\n\n\n\n\nNote: This driver is for a non IVI Compliant Device.\n\n\n\n\n\nSupported Instruments\n\nAll Tenma Power Supplies\n\n\n\n\n\nTenmaPS_Init\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS TenmaPS_Init": {
  "prefix": "TenmaPS_Init",
  "body": [
   "$$InstrumentID=TenmaPS_Init($$GPIBAddress);"
  ],
  "description": "\n\n\n\nThe initialize function connects to the instrument and sets it to a known state.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$GPIBAddress\n\nInteger\n\nThe GPIB Address of the Device.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentID\n\nInteger\n\nReturns an Integer indicating the ID number of the power supply.\n\n\n\n\n\nExamples:\n\n$InstrumentID =TenmaPS_Init(7);\n\n\n\n\n\nNote: This driver is for a non IVI Compliant Device.\n\nSupported Instruments\n\nAll Tenma Power Supplies\n\n\n\n\n\nTenmaPS_MeasureCurrent\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS TenmaPS_MeasureCurrent": {
  "prefix": "TenmaPS_MeasureCurrent",
  "body": [
   "$$Current=TenmaPS_MeasureCurrent($$InstrumentId);"
  ],
  "description": "\n\n\n\n\n\nThis function measures the present current draw on the power supply's output.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentID\n\nInteger\n\nThe instrument identifier returned from the Tenma_PS script function.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Current\n\nFloat\n\nThe instrument's present current draw.\n\n\n\n\n\nExamples:\n\n$Current = TenmaPS_MeasureCurrent($InstrumentId);\n\n\n\n\n\nNote: This driver is for a non IVI Compliant Device.\n\n\n\n\n\nSupported Instruments\n\nAll Tenma Power Supplies\n\n\n\n\n\nTenmaPS_MeasureVoltage\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS TenmaPS_MeasureVoltage": {
  "prefix": "TenmaPS_MeasureVoltage",
  "body": [
   "$$Voltage=TenmaPS_MeasureVoltage($$InstrumentId);"
  ],
  "description": "\n\n\n\n\n\nThis function measures the present voltage potential on the power supply's output.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentID\n\nInteger\n\nThe instrument identifier returned from the Tenma_PS script function.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Voltage\n\nFloat\n\nThe instrument's present voltage potential.\n\n\n\n\n\nExamples:\n\n$Voltage = TenmaPS_MeasureVoltage($InstrumentId);\n\n\n\n\n\nNote: This driver is for a non IVI Compliant Device.\n\n\n\n\n\nSupported Instruments\n\nAll Tenma Power Supplies\n\n\n\n\n\nTenmaPS_SetOutput\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS TenmaPS_SetOutput": {
  "prefix": "TenmaPS_SetOutput",
  "body": [
   "TenmaPS_SetOutput($$InstrumentId,$$Voltage,$$Current);"
  ],
  "description": "\n\n\n\nThis function sets the instrument output to a desired voltage and current. This function does not affect whether the output of the supply is enabled or disabled.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentID\n\nInteger\n\nThe instrument identifier returned from the Tenma_PS script function.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\nTenmaPS_SetOutput($InstrumentId,5.0,1.0);\n\n\n\n\n\nNote: This driver is for a non IVI Compliant Device.\n\n\n\n\n\nSupported Instruments\n\nAll Tenma Power Supplies\n\n\n\n\n\nTenmaPS_SetVoltageProtection\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS TenmaPS_SetVoltageProtection": {
  "prefix": "TenmaPS_SetVoltageProtection",
  "body": [
   "TenmaPS_SetVoltageProtection($$InstrumentId,$$VoltageProtectionLevel);"
  ],
  "description": "\n\n\n\n\n\nThis function sets the voltage protection limit on the instrument.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentID\n\nInteger\n\nThe instrument identifier returned from the Tenma_PS script function.\n\n\n\n$VoltageProtectionLevel\n\nFloat\n\nThe desired voltage protection level for the instrument.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\nTenmaPS_SetVoltageProtection($InstrumentId,6.00);\n\n\n\n\n\nNote: This driver is for a non IVI Compliant Device.\n\n\n\n\n\nSupported Instruments\n\nAll Tenma Power Supplies\n\n\n\n\n\nTenmaPS_SwitchOutput\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS TenmaPS_SwitchOutput": {
  "prefix": "TenmaPS_SwitchOutput",
  "body": [
   "TenmaPS_SwitchOutput($$InstrumentId,$$Enabled);"
  ],
  "description": "\n\n\n\n\n\nThis function enables and disables the output of the power supply.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentID\n\nInteger\n\nThe instrument identifier returned from the Tenma_PS script function.\n\n\n\n$Enabled\n\nBoolean\n\nSets the output state of the power supply:\n\n\u00b7 \"TRUE\" = Output is Enabled\n\n\u00b7 \"FALSE\" = Output is Disabled\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\nTenmaPS_SwitchOutput($InstrumentId,\"TRUE\");\n\n\n\n\n\nNote: This driver is for a non IVI Compliant Device.\n\n\n\n\n\nSupported Instruments\n\nAll Tenma Power Supplies\n\n\n\n\n\nAG60XX_Close\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG60XX_Close": {
  "prefix": "AG60XX_Close",
  "body": [
   "AG60XX_Close($$InstrumentHandle);"
  ],
  "description": "\n\n\n\n\n\nThe close function terminates the software connection to the instrument and de-allocates system resources. It is generally a good programming habit to close the instrument handle when the program is done using the instrument.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThe handle of the instrument returned from the AG60XX_Init function\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\nAG60XX_Close($InstrumentHandle);\n\n\n\n\n\nSupported Instruments\n\n6060B, 6063B, 6050A, 6051A System Electronic Loads and Electronic Load Mainframes\n\n60501B, 60502B, 60503B, 60504B, 60507B Electronic Load Mainframe modules\n\n\n\n\n\nAG60XX_ConfigureContinuousTransient\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG60XX_ConfigureContinuousTransient": {
  "prefix": "AG60XX_ConfigureContinuousTransient",
  "body": [
   "AG60XX_ConfigureContinuousTransient($$InstrumentHandle,$$OperationMode,$$DutyCycle,$$Frequency,$$ImmediateLevel,$$TransientLevel);"
  ],
  "description": "\n\n\n\n\n\nThis function configures the instrument for continuous transient mode operation. Continuous transients are oscillating currents, resistances, or voltages with a programmable frequency and duty cycle. This is a convenience function which allows for configuring all instrument settings in a single function.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThe handle of the instrument returned from the AG60XX_Init function\n\n\n\n$OperationMode\n\nString\n\nSelects the operational mode of the DC Load. Allowable values are:\n\n\u00b7 \"CURRENT\"\n\n\u00b7 \"RESISTANCE\"\n\n\u00b7 \"VOLTAGE\"\n\n\n\n$DutyCycle\n\nFloat\n\nThe percentage of the total cycle for which the output remains at the transient level.\n\n\n\n$Frequency\n\nFloat\n\nThe frequency of the oscillations\n\n\n\n$ImmediateLevel\n\nFloat\n\nThe immediate level for the specified mode.\n\n\n\n$TransientLevel\n\nFloat\n\nThe transient level for the specified mode.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\nAG60XX_ConfigureContinuousTransient($InstrumentHandle,\"VOLTAGE\",50,10,5,2);\n\n\n\n\n\nSupported Instruments\n\n6060B, 6063B, 6050A, 6051A System Electronic Loads and Electronic Load Mainframes\n\n60501B, 60502B, 60503B, 60504B, 60507B Electronic Load Mainframe modules\n\n\n\n\n\nAG60XX_ConfigureInput\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG60XX_ConfigureInput": {
  "prefix": "AG60XX_ConfigureInput",
  "body": [
   "AG60XX_ConfigureInput($$InstrumentHandle,$$OperationMode,$$Level);"
  ],
  "description": "\n\n\n\n\n\nThis function sets the instrument's mode of operation, corresponding input level, and enables the input.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThe handle of the instrument returned from the AG60XX_Init function\n\n\n\n$OperationMode\n\nString\n\nSelects the operational mode of the DC Load. Allowable values are:\n\n\u00b7 \"CURRENT\"\n\n\u00b7 \"RESISTANCE\"\n\n\u00b7 \"VOLTAGE\"\n\n\n\n$Level\n\nFloat\n\nThe instrument's corresponding immediate level for it's specified mode.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\nAG60XX_ConfigureInput($InstrumentHandle,\"VOLTAGE\",10);\n\n\n\n\n\nSupported Instruments\n\n6060B, 6063B, 6050A, 6051A System Electronic Loads and Electronic Load Mainframes\n\n60501B, 60502B, 60503B, 60504B, 60507B Electronic Load Mainframe modules\n\n\n\n\n\nAG60XX_Init\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG60XX_Init": {
  "prefix": "AG60XX_Init",
  "body": [
   "$$InstrumentHandle=AG60XX_Init($$ResourceName,$$Reset);"
  ],
  "description": "\n\n\n\n\n\nThis function initializes a session with the instrument and returns the handle to the test script.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ResourceName\n\nString\n\nThe resource name of the instrument.\n\n\n\n$Reset\n\nBoolean\n\nSpecifies whether or not to reset the instrument on initialization.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThe instrument handle for the instrument.\n\n\n\n\n\nExamples:\n\n$InstrumentHandle = AG60XX_Init(\"GPIB0::5::INSTR\",\"TRUE\");\n\n\n\n\n\nSupported Instruments\n\n6060B, 6063B, 6050A, 6051A System Electronic Loads and Electronic Load Mainframes\n\n60501B, 60502B, 60503B, 60504B, 60507B Electronic Load Mainframe modules\n\n\n\n\n\nAG60XX_MeasureCurrent\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG60XX_MeasureCurrent": {
  "prefix": "AG60XX_MeasureCurrent",
  "body": [
   "$$MeasuredCurrent=AG60XX_MeasureCurrent($$InstrumentHandle);"
  ],
  "description": "\n\n\n\n\n\nThis function returns the current at the input of the electronic load.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThe handle of the instrument returned from the AG60XX_Init function\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$MeasuredCurrent\n\nFloat\n\nThe measured current\n\n\n\n\n\nExamples:\n\n$MeasuredCurrent = AG60XX_MeasureCurrent($InstrumentHandle);\n\n\n\n\n\nSupported Instruments\n\n6060B, 6063B, 6050A, 6051A System Electronic Loads and Electronic Load Mainframes\n\n60501B, 60502B, 60503B, 60504B, 60507B Electronic Load Mainframe modules\n\n\n\n\n\nAG60XX_MeasurePower\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG60XX_MeasurePower": {
  "prefix": "AG60XX_MeasurePower",
  "body": [
   "$$MeasuredPower=AG60XX_MeasurePower($$InstrumentHandle);"
  ],
  "description": "\n\n\n\n\n\nThis function returns the power at the input of the electronic load.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThe handle of the instrument returned from the AG60XX_Init function\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$MeasuredPower\n\nFloat\n\nThe measured power\n\n\n\n\n\nExamples:\n\n$MeasuredPower = AG60XX_MeasurePower($InstrumentHandle);\n\n\n\n\n\nSupported Instruments\n\n6060B, 6063B, 6050A, 6051A System Electronic Loads and Electronic Load Mainframes\n\n60501B, 60502B, 60503B, 60504B, 60507B Electronic Load Mainframe modules\n\n\n\n\n\nAG60XX_MeasureVoltage\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG60XX_MeasureVoltage": {
  "prefix": "AG60XX_MeasureVoltage",
  "body": [
   "$$MeasuredVoltage=AG60XX_MeasureVoltage($$InstrumentHandle);"
  ],
  "description": "\n\n\n\n\n\nThis function returns the voltage at the input of the electronic load.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThe handle of the instrument returned from the AG60XX_Init function\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$MeasuredVoltage\n\nFloat\n\nThe measured voltage\n\n\n\n\n\nExamples:\n\n$MeasuredVoltage = AG60XX_MeasureVoltage($InstrumentHandle);\n\n\n\n\n\nSupported Instruments\n\n6060B, 6063B, 6050A, 6051A System Electronic Loads and Electronic Load Mainframes\n\n60501B, 60502B, 60503B, 60504B, 60507B Electronic Load Mainframe modules\n\n\n\n\n\nAG60XX_SetCurrent\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG60XX_SetCurrentProtection": {
  "prefix": "AG60XX_SetCurrentProtection",
  "body": [
   "AG60XX_SetCurrentProtection($$InstrumentHandle,$$Enabled,$$Delay,$$CurrentLimit);"
  ],
  "description": "\n\n\n\n\n\nThis function sets a limit to the input current that the electronic load will sink. A current limit may be specified for the single electronic load or for a channel of the multiple electronic load. When the input current reaches the current limit for the specified delay period, the input of the electronic load or channel is shut off and draws no current. This, in effect, provides a \"soft circuit breaker\" for the input current. The clear input protection function re--enables the input current. The tr igger--activated current functions automatically keep track of incoming triggers while the input is shut down and will respond to the trigger as soon as the protection fault is cleared.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThe handle of the instrument returned from the AG60XX_Init function\n\n\n\n$Enabled\n\nString\n\nSpecifies if the Current Protection is enabled. Allowable values are:\n\n\u00b7 \"ON\"\n\n\u00b7 \"OFF\"\n\n\n\n$Delay\n\nFloat\n\nThe duration in milliseconds that the current is allowed to equal or exceed the protection limit before the device is disengaged.\n\n\n\n$CurrentLimit\n\nFloat\n\nThe maximum current level that the device can sink without enabling the protection circuit.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\nAG60XX_SetCurrentProtection($Handle,\"ON\",5000,10.00);\n\n\n\n\n\nSupported Instruments\n\n6060B, 6063B, 6050A, 6051A System Electronic Loads and Electronic Load Mainframes\n\n60501B, 60502B, 60503B, 60504B, 60507B Electronic Load Mainframe modules\n\n\n\n\n\nAG60XX_SetInputState\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG60XX_SetInputState": {
  "prefix": "AG60XX_SetInputState",
  "body": [
   "AG60XX_SetInputState($$InstrumentHandle,$$InputState);"
  ],
  "description": "\n\n\n\n\n\nThis function enables and disables the instrument input.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThe handle of the instrument returned from the AG60XX_Init function\n\n\n\n$InputState\n\nString\n\nSelects the input state of the DC Load. Allowable values are:\n\n\u00b7 \"OFF\"\n\n\u00b7 \"ON\"\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\nAG60XX_SetInputState($InstrumentHandle,\"ON\");\n\n\n\n\n\nSupported Instruments\n\n6060B, 6063B, 6050A, 6051A System Electronic Loads and Electronic Load Mainframes\n\n60501B, 60502B, 60503B, 60504B, 60507B Electronic Load Mainframe modules\n\n\n\n\n\nAG60XX_SetVoltage\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG60XX_SetVoltage": {
  "prefix": "AG60XX_SetVoltage",
  "body": [
   "AG60XX_SetVoltage($$InstrumentHandle,$$VoltageParameter,$$Voltage);"
  ],
  "description": "\n\n\n\n\n\nThis function configures the specified voltage instrument parameter.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThe handle of the instrument returned from the AG60XX_Init function\n\n\n\n$VoltageParameter\n\nString\n\nThis parameter selects the voltage setting to configure. Supported values are:\n\n\n\n\n\n\u00b7 \"VOLT\"\n\n\u00b7 \"VOLT_MAX\"\n\n\u00b7 \"VOLT_MIN\"\n\n\u00b7 \"VOLT_SLEW\"\n\n\u00b7 \"VOLT_SLEW_MAX\"\n\n\u00b7 \"VOLT_SLEW_MIN\"\n\n\u00b7 \"VOLT_TLEV\"\n\n\u00b7 \"VOLT_TLEV_MAX\"\n\n\u00b7 \"VOLT_TLEV_MIN\"\n\n\u00b7 \"VOLT_TRIG\"\n\n\u00b7 \"VOLT_TRIG_MAX\"\n\n\u00b7 \"VOLT_TRIG_MIN\"\n\n\n\n\n\n$Voltage\n\nFloat\n\nThe value for the specified instrument parameter.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\nAG60XX_SetVoltage($InstrumentHandle,\"VOLT_MAX\",30);\n\n\n\n\n\nSupported Instruments\n\n6060B, 6063B, 6050A, 6051A System Electronic Loads and Electronic Load Mainframes\n\n60501B, 60502B, 60503B, 60504B, 60507B Electronic Load Mainframe modules\n\n\n\n\n\nAGN330X_Close\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AGN330X_Close": {
  "prefix": "AGN330X_Close",
  "body": [
   "AGN330X_Close($$InstrumentHandle);"
  ],
  "description": "\n\n\n\n\n\nThe close function terminates the software connection to the instrument and de-allocates system resources. It is generally a good programming habit to close the instrument handle when the program is done using the instrument.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThe handle of the instrument returned from the AGN30XX_Init function\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\nAGN330X_Close($InstrumentHandle);\n\n\n\n\n\nSupported Instruments\n\nAgilent N3300A, N3301A,N3302A,N3303A,N3304A,N3305A,N3306A System Electronic Loads and Electronic Load Mainframes\n\n\n\n\n\nAGN330X_ConfigureContinuousTransient\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AGN330X_ConfigureContinuousTransient": {
  "prefix": "AGN330X_ConfigureContinuousTransient",
  "body": [
   "AGN330X_ConfigureContinuousTransient($$InstrumentHandle,$$Channel,$$OperationMode,$$DutyCycle,$$Frequency,$$ImmediateLevel,$$TransientLevel);"
  ],
  "description": "\n\n\n\n\n\nThis function configures the instrument for continuous transient mode operation. Continuous transients are oscillating currents, resistances, or voltages with a programmable frequency and duty cycle. This is a convenience function which allows for configuring all instrument settings in a single function.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThe handle of the instrument returned from the AGN330X_Init function\n\n\n\n$Channel\n\nInteger\n\n\u00b7 The channel of the instrument to configure\n\n\n\n$OperationMode\n\nString\n\nSelects the operational mode of the DC Load. Allowable values are:\n\n\u00b7 \"CURRENT\"\n\n\u00b7 \"RESISTANCE\"\n\n\u00b7 \"VOLTAGE\"\n\n\n\n$DutyCycle\n\nFloat\n\nThe percentage of the total cycle for which the output remains at the transient level.\n\n\n\n$Frequency\n\nFloat\n\nThe frequency of the oscillations\n\n\n\n$ImmediateLevel\n\nFloat\n\nThe immediate level for the specified mode.\n\n\n\n$TransientLevel\n\nFloat\n\nThe transient level for the specified mode.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\nAGN330X_ConfigureContinuousTransient($handle,1,\"RESISTANCE\",\"50\",\"2\",1000,2000);\n\n\n\n\n\nSupported Instruments\n\nAgilent N3300A, N3301A,N3302A,N3303A,N3304A,N3305A,N3306A System Electronic Loads and Electronic Load Mainframes\n\n\n\n\n\nAGN330X_ConfigureInput\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AGN330X_ConfigureInput": {
  "prefix": "AGN330X_ConfigureInput",
  "body": [
   "AGN330X_ConfigureInput($$InstrumentHandle,$$Channel,$$OperationMode,$$Level);"
  ],
  "description": "\n\n\n\n\n\nThis function sets the instrument's mode of operation, corresponding input level, and enables the input.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThe handle of the instrument returned from the AGN330X_Init function\n\n\n\n$Channel\n\nInteger\n\n\u00b7 Channel Number to Configure\n\n\n\n$OperationMode\n\nString\n\nSelects the operational mode of the DC Load. Allowable values are:\n\n\u00b7 \"CURRENT\"\n\n\u00b7 \"RESISTANCE\"\n\n\u00b7 \"VOLTAGE\"\n\n\n\n$Level\n\nFloat\n\nThe instrument's corresponding immediate level for it's specified mode.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\nAGN330X_ConfigureInput($handle,2,\"RESISTANCE\",1000);\n\nAGN330X_ConfigureInput($handle,1,\"CURRENT\",2.0);\n\nAGN330X_ConfigureInput($handle,1,\"VOLTAGE\",25);\n\n\n\n\n\nSupported Instruments\n\nAgilent N3300A, N3301A,N3302A,N3303A,N3304A,N3305A,N3306A System Electronic Loads and Electronic Load Mainframes\n\n\n\n\n\nAGN330X_Init\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AGN330X_Init": {
  "prefix": "AGN330X_Init",
  "body": [
   "$$InstrumentHandle=AGN330X_Init($$ResourceName,$$Reset);"
  ],
  "description": "\n\n\n\n\n\nThis function initializes a session with the instrument and returns the handle to the test script.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ResourceName\n\nString\n\nThe resource name of the instrument.\n\n\n\n$Reset\n\nBoolean\n\nSpecifies whether or not to reset the instrument on initialization.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThe instrument handle for the instrument.\n\n\n\n\n\nExamples:\n\n$handle = AGN330X_Init(\"GPIB0::5::INSTR\",\"TRUE\",\"TRUE\");\n\n\n\n\n\nSupported Instruments\n\nAgilent N3300A, N3301A,N3302A,N3303A,N3304A,N3305A,N3306A System Electronic Loads and Electronic Load Mainframes\n\n\n\n\n\nAGN330X_MeasureCurrent\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AGN330X_MeasureCurrent": {
  "prefix": "AGN330X_MeasureCurrent",
  "body": [
   "$$MeasuredCurrent=AGN330X_MeasureCurrent($$InstrumentHandle,$$Channel,$$MeasurementType);"
  ],
  "description": "\n\n\n\n\n\nThis function returns the current at the input of the electronic load.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThe handle of the instrument returned from the AG60XX_Init function\n\n\n\n$Channel\n\nInteger\n\nThe Channel to be measured\n\n\n\n$MeasurementType\n\nString\n\nThe type of current measurement to perform. Allowable values are:\n\n\u00b7 \"ACDC\"\n\n\u00b7 \"CURRENT\"\n\n\u00b7 \"MAX\"\n\n\u00b7 \"MIN\"\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$MeasuredCurrent\n\nFloat\n\nThe measured current\n\n\n\n\n\nExamples:\n\n$Current = AGN330X_MeasureCurrent($handle,$Channel,\"CURRENT\");\n\n\n\n\n\nSupported Instruments\n\nAgilent N3300A, N3301A,N3302A,N3303A,N3304A,N3305A,N3306A System Electronic Loads and Electronic Load Mainframes\n\n\n\n\n\nAGN330X_MeasurePower\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AGN330X_MeasurePower": {
  "prefix": "AGN330X_MeasurePower",
  "body": [
   "$$MeasuredPower=AGN330X_MeasurePower($$InstrumentHandle,$$Channel,$$MeasurementType);"
  ],
  "description": "\n\n\n\n\n\nThis function returns the power at the input of the electronic load.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThe handle of the instrument returned from the AG60XX_Init function\n\n\n\n$Channel\n\nInteger\n\nThe Channel to be measured\n\n\n\n$MeasurementType\n\nString\n\nThe type of power measurement to perform. Allowable values are:\n\n\u00b7 \"POWER\"\n\n\u00b7 \"MAX\"\n\n\u00b7 \"MIN\"\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$MeasuredPower\n\nFloat\n\nThe measured power\n\n\n\n\n\nExamples:\n\n$Power1 = AGN330X_MeasurePower($handle,$Channel,\"POWER\");\n\n\n\n\n\nSupported Instruments\n\nAgilent N3300A, N3301A,N3302A,N3303A,N3304A,N3305A,N3306A System Electronic Loads and Electronic Load Mainframes\n\n\n\n\n\nAGN330X_MeasureVoltage\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AGN330X_MeasureVoltage": {
  "prefix": "AGN330X_MeasureVoltage",
  "body": [
   "$$MeasuredVoltage=AGN330X_MeasureVoltage($$InstrumentHandle,$$Channel,$$MeasurementType);"
  ],
  "description": "\n\n\n\n\n\nThis function returns the voltage at the input of the electronic load.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThe handle of the instrument returned from the AGN330X_Init function\n\n\n\n$Channel\n\nInteger\n\nThe Channel to be measured\n\n\n\n$MeasurementType\n\nString\n\nThe type of power measurement to perform. Allowable values are:\n\n\u00b7 \"VOLT\"\n\n\u00b7 \"ACDC\"\n\n\u00b7 \"MIN\"\n\n\u00b7 \"MAX\"\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$MeasuredVoltage\n\nFloat\n\nThe measured voltage\n\n\n\n\n\nExamples:\n\n$Voltage = AGN330X_MeasureVoltage($handle,1,\"VOLT\");\n\n\n\n\n\nSupported Instruments\n\nAgilent N3300A, N3301A,N3302A,N3303A,N3304A,N3305A,N3306A System Electronic Loads and Electronic Load Mainframes\n\n\n\n\n\nAGN330X_SetCurrent\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG60XX_SetCurrent": {
  "prefix": "AG60XX_SetCurrent",
  "body": [
   "AG60XX_SetCurrent($$InstrumentHandle,$$Channel,$$CurrentParameter,$$Current);"
  ],
  "description": "\n\n\n\n\n\nThis function configures the specified current instrument parameter.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThe handle of the instrument returned from the AG60XX_Init function\n\n\n\n$Channel\n\nInteger\n\nThe channel to be configured\n\n\n\n$CurrentParameter\n\nString\n\nThis parameter selects the current setting to configure. Supported values are:\n\n\n\n\n\n\u00b7 \"CURR\"\n\n\u00b7 \"CURR_MAX\"\n\n\u00b7 \"CURR_MIN\"\n\n\u00b7 \"CURR_SLEW\"\n\n\u00b7 \"CURR_SLEW_MAX\"\n\n\u00b7 \"CURR_SLEW_MIN\"\n\n\u00b7 \"CURR_SLEW_NEG\"\n\n\u00b7 \"CURR_SLEW_NEG_MAX\"\n\n\u00b7 \"CURR_SLEW_NEG_MIN\"\n\n\u00b7 \"CURR_SLEW_POS\"\n\n\u00b7 \"CURR_SLEW_POS_MAX\"\n\n\u00b7 \"CURR_SLEW_POS_MIN\"\n\n\u00b7 \"CURR_TLEV\"\n\n\u00b7 \"CURR_TLEV_MAX\"\n\n\u00b7 \"CURR_TLEV_MIN\"\n\n\u00b7 \"CURR_TRIG\"\n\n\u00b7 \"CURR_TRIG_MAX\"\n\n\u00b7 \"CURR_TRIG_MIN\"\n\n\n\n\n\n$Current\n\nFloat\n\nThe specified value for the selected current parameter.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\nAGN330X_SetCurrent($handle,$Channel,\"CURR\",1.25);\n\n\n\n\n\nSupported Instruments\n\nAgilent N3300A, N3301A,N3302A,N3303A,N3304A,N3305A,N3306A System Electronic Loads and Electronic Load Mainframes\n\n\n\n\n\nAGN330X_SetCurrentProtection\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AGN330X_SetCurrentProtection": {
  "prefix": "AGN330X_SetCurrentProtection",
  "body": [
   "AGN330X_SetCurrentProtection($$InstrumentHandle,$$Channel,$$Enabled,$$Delay,$$CurrentLimit);"
  ],
  "description": "\n\n\n\n\n\nThis function sets a limit to the input current that the electronic load will sink. A current limit may be specified for the single electronic load or for a channel of the multiple electronic load. When the input current reaches the current limit for the specified delay period, the input of the electronic load or channel is shut off and draws no current. This, in effect, provides a \"soft circuit breaker\" for the input current. The clear input protection function re--enables the input current. The tr igger--activated current functions automatically keep track of incoming triggers while the input is shut down and will respond to the trigger as soon as the protection fault is cleared.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThe handle of the instrument returned from the AGN330X_Init function\n\n\n\n$Channel\n\nInteger\n\n\u00b7 Channel For Current Protection\n\n\n\n$Enabled\n\nString\n\nSpecifies if the Current Protection is enabled. Allowable values are:\n\n\u00b7 \"ON\"\n\n\u00b7 \"OFF\"\n\n\n\n$Delay\n\nFloat\n\nThe duration in milliseconds that the current is allowed to equal or exceed the protection limit before the device is disengaged.\n\n\n\n$CurrentLimit\n\nFloat\n\nThe maximum current level that the device can sink without enabling the protection circuit.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\nAGN330X_SetCurrentProtection($handle,1,\"TRUE\",\"1000\",5);\n\n\n\n\n\nSupported Instruments\n\nAgilent N3300A, N3301A,N3302A,N3303A,N3304A,N3305A,N3306A System Electronic Loads and Electronic Load Mainframes\n\n\n\n\n\nAGN330X_SetCurrentRange\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AGN30XX_SetCurrentRange": {
  "prefix": "AGN30XX_SetCurrentRange",
  "body": [
   "AGN30XX_SetCurrentRange($$InstrumentHandle,$$RangeType,$$RangeValue);"
  ],
  "description": "\n\n\n\n\n\nThis function selects the full--scale current range of the electronic load. Programming any value within the low range automatically selects the low range and programming any value within the high range automatically selects that range.\n\n\n\n\n\nNotes:\n\n\u00b7 Whenever the electronic load changes resistance range, the input momentarily goes into the off state.\n\n\n\n\n\n\u00b7 The simplest way to set the range is to use the 'SPECIFIED' parameter which sets the range based off of the desired value.\n\n\n\n\n\n\u00b7 If the range type and supplied value for the range contradict, no error will be generated, but the modification will not take effect.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThe handle of the instrument returned from the AG60XX_Init function\n\n\n\n$RangeType\n\nString\n\nThe current Range Type. Allowable values are:\n\n\u00b7 \"SPECIFIED\" = Sets the range type based on the value supplied in the $RangeValue parameter.\n\n\u00b7 \"MIN\" = Sets the minimum Range\n\n\u00b7 \"MAX\" = Sets the Maximum Range\n\n\n\n$RangeValue\n\nFloat\n\nThe desired value for the range. If \"MIN\" or \"MAX\" is specified for the function, this value has no effect.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\nAGN330X_SetCurrentRange($AGN330X,\"MAX\",10);\n\nAGN330X_ConfigureInput($AGN330X,1,\"CURRENT\",10);\n\n\n\n\n\nSupported Instruments\n\nAgilent N3300A, N3301A,N3302A,N3303A,N3304A,N3305A,N3306A System Electronic Loads and Electronic Load Mainframes\n\n\n\n\n\nAGN330X_SetInputState\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AGN30XX_SetInputState": {
  "prefix": "AGN30XX_SetInputState",
  "body": [
   "AGN30XX_SetInputState($$InstrumentHandle,$$Channel,$$InputState);"
  ],
  "description": "\n\n\n\n\n\nThis function enables and disables the specified instrument input.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThe handle of the instrument returned from the AG60XX_Init function\n\n\n\n$InputState\n\nBoolean\n\nSelects the input state of the DC Load. Allowable values are:\n\n\u00b7 \"TRUE\" = Input Enabled\n\n\u00b7 \"FALSE\" = Input Disabled\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\nAGN330X_SetInputState($InstrumentHandle,$Channel,\"ON\");\n\n\n\n\n\nSupported Instruments\n\nAgilent N3300A, N3301A,N3302A,N3303A,N3304A,N3305A,N3306A System Electronic Loads and Electronic Load Mainframes\n\n\n\n\n\nAGN330X_SetResistanceRange\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AGN30XX_SetResistanceRange": {
  "prefix": "AGN30XX_SetResistanceRange",
  "body": [
   "AGN30XX_SetResistanceRange($$InstrumentHandle,$$RangeType,$$RangeValue);"
  ],
  "description": "\n\nThe function selects the full--scale resistance range of the electronic load. Programming any value equal to or greater than zero and less than or equal to the maximum value of the lowest range automatically selects that range. Programming any value greater than the minimum range and less than or equal to the maximum value of the middle range automatically selects that range. There is no overlap between the low and middle ranges. Programming a value greater than the maximum value of the middle range automatically selects the highest value.\n\n\n\n\n\nNotes:\n\n\u00b7 Whenever the electronic load changes resistance range, the input momentarily goes into the off state.\n\n\n\n\n\n\u00b7 The simplest way to set the range is to use the 'SPECIFIED' parameter which sets the range based off of the desired value.\n\n\n\n\n\n\u00b7 If the range type and supplied value for the range contradict, no error will be generated, but the modification will not take effect.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThe handle of the instrument returned from the AG60XX_Init function\n\n\n\n$RangeType\n\nString\n\nThe resistance Range Type. Allowable values are:\n\n\u00b7 \"SPECIFIED\" = Sets the range type based on the value supplied in the $RangeValue parameter.\n\n\u00b7 \"MIN\" = Sets the minimum Range\n\n\u00b7 \"MAX\" = Sets the Maximum Range\n\n\n\n$RangeValue\n\nFloat\n\nThe desired value for the range. If \"MIN\" or \"MAX\" is specified for the function, this value has no effect.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\nAGN330X_SetResistanceRange($AGN330X,\"SPECIFIED\",2000);\n\nAGN330X_ConfigureInput($AGN330X,1,\"RESISTANCE\",2000);\n\n\n\n\n\nSupported Instruments\n\nAgilent N3300A, N3301A,N3302A,N3303A,N3304A,N3305A,N3306A System Electronic Loads and Electronic Load Mainframes\n\n\n\n\n\nAGN330X_SetVoltage\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AGN330X_SetVoltage": {
  "prefix": "AGN330X_SetVoltage",
  "body": [
   "AGN330X_SetVoltage($$InstrumentHandle,$$Channel,$$VoltageParameter,$$Voltage);"
  ],
  "description": "\n\n\n\n\n\nThis function configures the specified voltage instrument parameter on the specified channel.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThe handle of the instrument returned from the AG60XX_Init function\n\n\n\n$Channel\n\nInteger\n\nThe channel to be configured.\n\n\n\n$VoltageParameter\n\nString\n\nThis parameter selects the voltage setting to configure. Supported values are:\n\n\n\n\n\n\u00b7 \"VOLT\"\n\n\u00b7 \"VOLT_MAX\"\n\n\u00b7 \"VOLT_MIN\"\n\n\u00b7 \"SLEW\"\n\n\u00b7 \"SLEW_MAX\"\n\n\u00b7 \"SLEW_MIN\"\n\n\u00b7 \"SLEW_NEG\"\n\n\u00b7 \"SLEW_NEG_MAX\"\n\n\u00b7 \"SLEW_NEG_MIN\"\n\n\u00b7 \"SLEW_POS\"\n\n\u00b7 \"SLEW_POS_MAX\"\n\n\u00b7 \"SLEW_POS_MIN\"\n\n\u00b7 \"TLEV\"\n\n\u00b7 \"TLEV_MAX\"\n\n\u00b7 \"TLEV_MIN\"\n\n\u00b7 \"TRIG\"\n\n\u00b7 \"TRIG_MAX\"\n\n\u00b7 \"TRIG_MIN\"\n\n\n\n\n\n$Voltage\n\nFloat\n\nThe value for the specified instrument parameter.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\nAGN330X_SetVoltage($handle,1,\"VOLT\",25);\n\n\n\n\n\nSupported Instruments\n\nAgilent N3300A, N3301A,N3302A,N3303A,N3304A,N3305A,N3306A System Electronic Loads and Electronic Load Mainframes\n\n\n\n\n\nAGN330X_SetVoltageRange\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AGN30XX_SetVoltageRange": {
  "prefix": "AGN30XX_SetVoltageRange",
  "body": [
   "AGN30XX_SetVoltageRange($$InstrumentHandle,$$RangeType,$$RangeValue);"
  ],
  "description": "\n\nThis function sets the voltage range at the electronic load.\n\n\n\n\n\nNotes:\n\n\u00b7 Whenever the electronic load changes resistance range, the input momentarily goes into the off state.\n\n\n\n\n\n\u00b7 The simplest way to set the range is to use the 'SPECIFIED' parameter which sets the range based off of the desired value.\n\n\n\n\n\n\u00b7 If the range type and supplied value for the range contradict, no error will be generated, but the modification will not take effect.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThe handle of the instrument returned from the AG60XX_Init function\n\n\n\n$RangeType\n\nString\n\nThe voltage Range Type. Allowable values are:\n\n\u00b7 \"SPECIFIED\" = Sets the range type based on the value supplied in the $RangeValue parameter.\n\n\u00b7 \"MIN\" = Sets the minimum Range\n\n\u00b7 \"MAX\" = Sets the Maximum Range\n\n\n\n$RangeValue\n\nFloat\n\nThe desired value for the range. If \"MIN\" or \"MAX\" is specified for the function, this value has no effect.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\n\n\n\n\nSupported Instruments\n\nAgilent N3300A, N3301A,N3302A,N3303A,N3304A,N3305A,N3306A System Electronic Loads and Electronic Load Mainframes\n\n\n\n\n\nBK8500_DisableEnableLoadTimer\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS BK8500_DisableEnableLoadTimer": {
  "prefix": "BK8500_DisableEnableLoadTimer",
  "body": [
   "BK8500_DisableEnableLoadTimer($$InstrumentHandle,$$Mode);"
  ],
  "description": "\n\nEnables or Disables the load timer. This timer can be set active when the load is turned on. Valid range for the timer is 1 to 60,000 seconds.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThis is the handle to the com port initialized.\n\n\n\n$Mode\n\nString\n\n\"ENABLE\" - Enables the load timer.\n\n\"DISABLE\" - Disables the load timer.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\nBK8500_DisableEnableLoadTimer($comPort,\"ENABLE\");\n\n\n\n\n\nBK8500_DisableEnableLocalControl\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS BK8500_DisableEnableLocalControl": {
  "prefix": "BK8500_DisableEnableLocalControl",
  "body": [
   "BK8500_DisableEnableLocalControl($$InstrumentHandle,$$Mode);"
  ],
  "description": "\n\nEnables or Disables the LOCAL key on the front panel of the BK8500.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThis is the handle to the com port initialized.\n\n\n\n$Mode\n\nString\n\n\"ENABLE\" - Enables local key control.\n\n\"DISABLE\" - Disables local key control.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\nBK8500_DisableEnableLocalControl($comPort,\"ENABLE\");\n\n\n\n\n\nBK8500_DisableEnableRemoteSensing\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS BK8500_DisableEnableRemoteSensing": {
  "prefix": "BK8500_DisableEnableRemoteSensing",
  "body": [
   "BK8500_DisableEnableRemoteSensing($$InstrumentHandle,$$Mode);"
  ],
  "description": "\n\nEnables or Disables remote sensing. Remote sensing will compensate for the resistance of the lead wires and remove the effect of the voltage drop across them.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThis is the handle to the com port initialized.\n\n\n\n$Mode\n\nString\n\n\"ENABLE\" - Enables remote sensing.\n\n\"DISABLE\" - Disables remote sensing.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\nBK8500_DisableEnableRemoteSensing($comPort,\"ENABLE\");\n\n\n\n\n\nBK8500_GetDCLoadSettings\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS BK8500_GetDCLoadSettings": {
  "prefix": "BK8500_GetDCLoadSettings",
  "body": [
   "BK8500_GetDCLoadSettings($$comPort,$$StorageRegister);"
  ],
  "description": "\n\nRetrieves the saved DC load settings from the specified $StorageRegister location. The $StorageRegister can be any value between 1 and 25 inclusive.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThis is the handle to the com port initialized.\n\n\n\n$StorageRegister\n\nInteger\n\nStorage register number to retrieve settings from.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\nBK8500_GetDCLoadSettings($comPort,3);\n\n\n\n\n\nBK8500_GetFunctionType\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS BK8500_GetFunctionType": {
  "prefix": "BK8500_GetFunctionType",
  "body": [
   "$$FunctionType=BK8500_GetFunctionType($$InstrumentHandle);"
  ],
  "description": "\n\nReturns the mode of operation of the BK8500. These modes are FIXED, SHORT, TRANSIENT, LIST and BATTERY.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThis is the handle to the com port initialized.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$FunctionType\n\nString\n\n\"FIXED\"\n\n\"SHORT\"\n\n\"TRANSIENT\"\n\n\"LIST\"\n\n\"BATTERY\"\n\n\n\n\n\nExamples:\n\n$FunctionType = BK8500_GetFunctionType($comPort);\n\n\n\n\n\nBK8500_ReadCCModeCurrent\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS BK8500_ReadCCModeCurrent": {
  "prefix": "BK8500_ReadCCModeCurrent",
  "body": [
   "$$Current=BK8500_ReadCCModeCurrent($$InstrumentHandle);"
  ],
  "description": "\n\nReturns the actual DC source/sink current of the BK8500 in Amps.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThis is the handle to the com port initialized.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Current\n\nFloat\n\nThe returned DC current in Amps\n\n\n\n\n\nExamples:\n\n$Current = BK8500_ReadCCModeCurrent($comPort);\n\n\n\n\n\nBK8500_ReadCCModeTransCurandTiming\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS BK8500_ReadCCModeTransCurAndTiming": {
  "prefix": "BK8500_ReadCCModeTransCurAndTiming",
  "body": [
   "($$CurrentA,$$TimeA,$$CurrentB,$$TimeB,$$Operation)=BK8500_ReadCCModeTransCurAndTiming($$InstrumentHandle);"
  ],
  "description": "\n\nReturns the stored transient A and B settings of the BK8500 for constant current mode. This returns the A DC current level in Amps, A duration in seconds, B DC current level in Amps and B duration in seconds.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThis is the handle to the com port initialized.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$CurrentA\n\nFloat\n\nDC Level A.\n\n\n\n$TimeA\n\nFloat\n\nDC Level A duration.\n\n\n\n$CurrentB\n\nFloat\n\nDC Level B.\n\n\n\n$TimeB\n\nFloat\n\nDC Level B duration.\n\n\n\n$Operation\n\nString\n\n\"CONTINUOUS\"\n\n\"PULSE\"\n\n\"TOGGLED\"\n\n\n\n\n\nExamples:\n\n($CurrentA,$TimeA,$CurrentB,$TimeB,$Operation) = BK8500_ReadCCModeTransCurAndTiming($comPort);\n\n\n\n\n\nBK8500_ReadCRModeResistance\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS BK8500_ReadCRModeResistance": {
  "prefix": "BK8500_ReadCRModeResistance",
  "body": [
   "$$Resistance=BK8500_ReadCRModeResistance($$InstrumentHandle);"
  ],
  "description": "\n\nReturns the set resistance of the BK8500 in ohms.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThis is the handle to the com port initialized.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Resistance\n\nFloat\n\nThe returned resistance in ohms.\n\n\n\n\n\nExamples:\n\n$Resistance = BK8500_ReadCRModeResistance($comPort);\n\n\n\n\n\nBK8500_ReadCRModeTransResandTiming\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS BK8500_ReadCRModeTransResandTiming": {
  "prefix": "BK8500_ReadCRModeTransResandTiming",
  "body": [
   "($$ResistanceA,$$TimeA,$$ResistanceB,$$TimeB,$$Operation)=BK8500_ReadCRModeTransResandTiming($$InstrumentHandle);"
  ],
  "description": "\n\nReturns the stored transient A and B settings of the BK8500 for constant resistance mode. This returns the A resistance value in ohms, A duration in seconds, B resistance value in ohms and B duration in seconds.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThis is the handle to the com port initialized.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ResistanceA\n\nFloat\n\nResistance Level A.\n\n\n\n$TimeA\n\nFloat\n\nResistance Level A duration.\n\n\n\n$ResistanceB\n\nFloat\n\nResistance Level B.\n\n\n\n$TimeB\n\nFloat\n\nResistance Level B duration.\n\n\n\n$Operation\n\nString\n\n\"CONTINUOUS\"\n\n\"PULSE\"\n\n\"TOGGLED\"\n\n\n\n\n\nExamples:\n\n($ResistanceA,$TimeA,$ResistanceB,$TimeB,$Operation) = BK8500_ReadCRModeTransResandTiming($comPort);\n\n\n\n\n\nBK8500_ReadCVModeVandTransTiming\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS BK8500_ReadCVModeVandTransTiming": {
  "prefix": "BK8500_ReadCVModeVandTransTiming",
  "body": [
   "($$voltageA,$$TimeA,$$voltageB,$$TimeB,$$Operation)=BK8500_ReadCVModeVandTransTiming($$InstrumentHandle);"
  ],
  "description": "\n\nReturns the stored transient A and B settings of the BK8500 for constant voltage mode. This returns the A voltage level in Volts, A duration in seconds, B voltage level in Volts and B duration in seconds.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThis is the handle to the com port initialized.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$VoltageA\n\nFloat\n\nVoltage Level A.\n\n\n\n$TimeA\n\nFloat\n\nVoltage Level A duration.\n\n\n\n$VoltageB\n\nFloat\n\nVoltage Level B.\n\n\n\n$TimeB\n\nFloat\n\nVoltage Level B duration.\n\n\n\n$Operation\n\nString\n\n\"CONTINUOUS\"\n\n\"PULSE\"\n\n\"TOGGLED\"\n\n\n\n\n\nExamples:\n\n($PowerA,$TimeA,$PowerB,$TimeB,$operation) = BK8500_ReadCWModeTransPwrandTiming($comPort);\n\n\n\n\n\nBK8500_ReadCVModeVoltage\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS BK8500_ReadCVModeVoltage": {
  "prefix": "BK8500_ReadCVModeVoltage",
  "body": [
   "$$Voltage=BK8500_ReadCVModeVoltage($$InstrumentHandle);"
  ],
  "description": "\n\nReturns the set voltage of the BK8500 in volts.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThis is the handle to the com port initialized.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Voltage\n\nFloat\n\nThe returned voltage.\n\n\n\n\n\nExamples:\n\n$Voltage = BK8500_ReadCVModeVoltage($comPort);\n\n\n\n\n\nBK8500_ReadCWModePower\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS BK8500_ReadCWModePower": {
  "prefix": "BK8500_ReadCWModePower",
  "body": [
   "$$Power=BK8500_ReadCWModePower($$InstrumentHandle);"
  ],
  "description": "\n\nReturns the set power of the BK8500 in watts.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThis is the handle to the com port initialized.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Power\n\nFloat\n\nThe returned Power in watts.\n\n\n\n\n\nExamples:\n\n$Power = BK8500_ReadCWModePower($comPort);\n\n\n\n\n\nBK8500_ReadCWModeTransPwrandTiming\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS BK8500_ReadCWModeTransPwrandTiming": {
  "prefix": "BK8500_ReadCWModeTransPwrandTiming",
  "body": [
   "($$PowerA,$$TimeA,$$PowerB,$$TimeB,$$Operation)=BK8500_ReadCWModeTransPwrandTiming($$InstrumentHandle);"
  ],
  "description": "\n\nReturns the stored transient A and B settings of the BK8500 for constant power mode. This returns the A power level in watts, A duration in seconds, B power level in watts and B duration in seconds.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThis is the handle to the com port initialized.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$PowerA\n\nFloat\n\nPower Level A.\n\n\n\n$TimeA\n\nFloat\n\nPower Level A duration.\n\n\n\n$PowerB\n\nFloat\n\nPower Level B.\n\n\n\n$TimeB\n\nFloat\n\nPower Level B duration.\n\n\n\n$Operation\n\nString\n\n\"CONTINUOUS\"\n\n\"PULSE\"\n\n\"TOGGLED\"\n\n\n\n\n\nExamples:\n\n($PowerA,$TimeA,$PowerB,$TimeB,$Operation) = BK8500_ReadCWModeTransPwrandTiming($comPort);\n\n\n\n\n\nBK8500_ReadMaxCurrentAllowed\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS BK8500_ReadMaxCurrentAllowed": {
  "prefix": "BK8500_ReadMaxCurrentAllowed",
  "body": [
   "$$Current=BK8500_ReadMaxCurrentAllowed($$InstrumentHandle);"
  ],
  "description": "\n\nReturns the maximum DC current limit set by the user for the BK8500 in Amps.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThis is the handle to the com port initialized.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Current\n\nFloat\n\nThe returned DC current in Amps.\n\n\n\n\n\nExamples:\n\n$Current = BK8500_ReadMaxCurrentAllowed($comPort);\n\n\n\n\n\nBK8500_ReadMaxPowerAllowed\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS BK8500_ReadMaxPowerAllowed": {
  "prefix": "BK8500_ReadMaxPowerAllowed",
  "body": [
   "$$Power=BK8500_ReadMaxPowerAllowed($$InstrumentHandle);"
  ],
  "description": "\n\nReturns the maximum power limit set by the user for the BK8500 in Watts.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThis is the handle to the com port initialized.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Power\n\nFloat\n\nThe returns the max power limit in watts\n\n\n\n\n\nExamples:\n\n$Power = BK8500_ReadMaxPowerAllowed($comPort);\n\n\n\n\n\nBK8500_ReadMaxVoltageAllowed\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS BK8500_ReadMaxVoltageAllowed": {
  "prefix": "BK8500_ReadMaxVoltageAllowed",
  "body": [
   "$$Voltage=BK8500_ReadMaxVoltageAllowed($$InstrumentHandle);"
  ],
  "description": "\n\nReturns the current mode of operation that the BK8500 is operating in, Constant Current(CC), Voltage(CV), Power(CW) or Resistance(CR).\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThis is the handle to the com port initialized.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Voltage\n\nFloat\n\nThe returned Max Voltage Setting in Volts.\n\n\n\n\n\nExamples:\n\n$Voltage = BK8500_ReadMaxVoltageAllowed($comPort);\n\n\n\n\n\nBK8500_ReadMode\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS BK8500_ReadMode": {
  "prefix": "BK8500_ReadMode",
  "body": [
   "$$Mode=BK8500_ReadMode($$InstrumentHandle);"
  ],
  "description": "\n\nReturns the current mode of operation that the BK8500 is operating in, Constant Current(CC), Voltage(CV), Power(CW) or Resistance(CR).\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThis is the handle to the com port initialized.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Mode\n\nString\n\n\"CC\" - Constant Current Mode\n\n\"CV\" - Constant Voltage Mode\n\n\"CW\" - Constant Power Mode\n\n\"CR\" - Constant Resistance Mode\n\n\n\n\n\nExamples:\n\n$Mode = BK8500_ReadMode($comPort);\n\n\n\n\n\nBK8500_ReadModelInfo\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS BK8500_ReadModelInfo": {
  "prefix": "BK8500_ReadModelInfo",
  "body": [
   "($$model,$$serial,$$firmware)=BK8500_ReadModelInfo($$InstrumentHandle);"
  ],
  "description": "\n\nReturns the BK8500 product model, serial and firmware version numbers.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThis is the handle to the com port initialized.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$model\n\nString\n\nReturns the model number of the BK8500.\n\n\n\n\n\n$serial\n\nString\n\nReturns the serial number of the BK8500.\n\n\n\n$firmware\n\nString\n\nReturns the firmware revision number of the BK8500.\n\n\n\n\n\nExamples:\n\n($model,$serial,$firmware) = BK8500_ReadModelInfo($comPort);\n\n\n\n\n\nBK8500_ReadRemoteSensState\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS BK8500_ReadRemoteSensState": {
  "prefix": "BK8500_ReadRemoteSensState",
  "body": [
   "$$State=BK8500_ReadRemoteSensState($$InstrumentHandle);"
  ],
  "description": "\n\nReturns whether Remote Sense is enabled or disabled on the BK8500.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThis is the handle to the com port initialized.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$State\n\nString\n\n\"ENABLE\" - if remote sense is enabled.\n\n\"DISABLE\" - if remote sense is disabled.\n\n\n\n\n\nExamples:\n\n$State = BK8500_ReadRemoteSensState($comPort);\n\n\n\n\n\nBK8500_ReadTimerLoadOn\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS BK8500_ReadTimerLoadOn": {
  "prefix": "BK8500_ReadTimerLoadOn",
  "body": [
   "$$Seconds=BK8500_ReadTimerLoadOn($$InstrumentHandle);"
  ],
  "description": "\n\nReturns the elapsed duration of the timer during LOAD ON state.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThis is the handle to the com port initialized.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Seconds\n\nInteger\n\nReturns the elapsed time of the timer during LOAD ON state in seconds\n\n\n\n\n\nExamples:\n\n$Seconds = BK8500_ReadTimerLoadOn($comPort);\n\n\n\n\n\nBK8500_ReadTimerState\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS BK8500_ReadTimerState": {
  "prefix": "BK8500_ReadTimerState",
  "body": [
   "$$State=BK8500_ReadTimerState($$comPort);"
  ],
  "description": "\n\nReturns whether timer is enabled or disabled on the BK8500..\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThis is the handle to the com port initialized.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$State\n\nString\n\n\"ENABLE\" - if the timer is enabled.\n\n\"DISABLE\" - if the timer is disabled.\n\n\n\n\n\nExamples:\n\n$State = BK8500_ReadTimerState($comPort);\n\n\n\n\n\nBK8500_ReadTriggerSource\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS BK8500_ReadTriggerSource": {
  "prefix": "BK8500_ReadTriggerSource",
  "body": [
   "$$Trigger=BK8500_ReadTriggerSource($$InstrumentHandle);"
  ],
  "description": "\n\nReturns the trigger source the BK8500 during transient and dynamic load conditions.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThis is the handle to the com port initialized.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Trigger\n\nString\n\nReturns the source of the trigger.\n\n\"IMMEDIATE\" - for an immediate trigger initiated by the user through the front panel Shift+Trigger keys, \"EXTERNAL\" - if a TTL high signal is applied on the external trigger input for at least 5ms.\n\n\"SOFTWARE\" - for a software trigger (via the BK8500_Trigger() command)\n\n\n\n\n\nExamples:\n\n$Trigger = BK8500_ReadTriggerSource($comPort);\n\n\n\n\n\nBK8500_Remote\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS BK8500_Remote": {
  "prefix": "BK8500_Remote",
  "body": [
   "BK8500_Remote($$InstrumentHandle);"
  ],
  "description": "\n\nEnables REMOTE mode for the BK8500 and disables the front panel keys.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThis is the handle to the com port initialized.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\n$comPort = SerialOpen(2,9600,8,\"N\",1);\n\nBK8500_Remote($comPort);\n\n\n\n\n\nBK8500_SaveDCLoadSettings\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS BK8500_SaveDCLoadSettings": {
  "prefix": "BK8500_SaveDCLoadSettings",
  "body": [
   "BK8500_SaveDCLoadSettings($$InstrumentHandle,$$Register);"
  ],
  "description": "\n\nSaves the load settings to a storage register.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThis is the handle to the com port initialized.\n\n\n\n$Register\n\nInteger\n\nA register number to save the settings. Must be a number between 1 and 25.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\nBK8500_SaveDCLoadSettings($comPort,3);\n\n\n\n\n\nBK8500_SelectFunction\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS BK8500_SelectFunction": {
  "prefix": "BK8500_SelectFunction",
  "body": [
   "BK8500_SelectFunction($$InstrumentHandle,$$Function);"
  ],
  "description": "\n\nSets the function for the load.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThis is the handle to the com port initialized.\n\n\n\n$Function\n\nString\n\n\"FIXED\"\n\n\"SHORT\"\n\n\"TRANSIENT\"\n\n\"LIST\"\n\n\"BATTERY\"\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\nBK8500_SelectFunction($comPort, \"BATTERY\");\n\n\n\n\n\nBK8500_SetCCModeCurrent\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS BK8500_SetCCModeCurrent": {
  "prefix": "BK8500_SetCCModeCurrent",
  "body": [
   "BK8500_SetCCModeCurrent($$InstrumentHandle,$$Current);"
  ],
  "description": "\n\nThis function specifies the Current (Amps) for CC mode operation.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThis is the handle to the com port initialized.\n\n\n\n$Current\n\nFloat\n\nThe Current specified in Amps.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\nBK8500_SetCVModeVoltage($comPort, 2.12);\n\n\n\n\n\nBK8500_SetCCModeTransCurandTiming\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS BK8500_SetCCModeTransCurandTiming": {
  "prefix": "BK8500_SetCCModeTransCurandTiming",
  "body": [
   "BK8500_SetCCModeTransCurandTiming($$InstrumentHandle,$$CurrentA,$$TimeA,$$CurrentB,$$TimeB,TransitionMode);"
  ],
  "description": "\n\nThis function configures the load for Resistance level A (Ohms) for Time A (seconds) and then transitions to Resistance level B (Ohms) for Time B (seconds) depending on the transition mode.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThis is the handle to the com port initialized.\n\n\n\n$CurrentA\n\nFloat\n\nThe Current level in Amps for A. (Amps)\n\n\n\n$TimeA\n\nFloat\n\nThe time for A. (seconds)\n\n\n\n$CurrentB\n\nFloat\n\nThe Current level in Amps for B. (Amps)\n\n\n\n$TimeB\n\nFloat\n\nThe time for B. (seconds)\n\n\n\n$TransitionMode\n\nString\n\nSets the transition mode from A to B. \"PULSE,\" \"CONTINUOUS,\" or \"TOGGLED.\"\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\nBK8500_SetCCModeTransCurAndTiming($comPort,2.15,0.43,1.21,0.55,\"PULSE\");\n\n\n\n\n\nBK8500_SetCRModeResistance\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS BK8500_SetCRModeResistance": {
  "prefix": "BK8500_SetCRModeResistance",
  "body": [
   "BK8500_SetCRModeResistance($$InstrumentHandle,$$Resistance);"
  ],
  "description": "\n\nThis function specifies the Resistance (Ohms) for CR mode operation.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThis is the handle to the com port initialized.\n\n\n\n$Resistance\n\nFloat\n\nThe Resistance specified in Ohms.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\nBK8500_SetCRModeResistance($comPort,5.34);\n\n\n\n\n\nBK8500_SetCRModeTransResandTiming\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS BK8500_SetCRModeTransResandTiming": {
  "prefix": "BK8500_SetCRModeTransResandTiming",
  "body": [
   "BK8500_SetCRModeTransResandTiming($$InstrumentHandle,$$ResistanceA,$$TimeA,$$ResistanceB,$$TimeB,TransitionMode);"
  ],
  "description": "\n\nThis function configures the load for Resistance level A (Ohms) for Time A (seconds) and then transitions to Resistance level B (Ohms) for Time B (seconds) depending on the transition mode.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThis is the handle to the com port initialized.\n\n\n\n$ResistanceA\n\nFloat\n\nThe Resistance level in Volts for A. (Ohms)\n\n\n\n$TimeA\n\nFloat\n\nThe time for A. (seconds)\n\n\n\n$ResistanceB\n\nFloat\n\nThe Resistance level in Volts for B. (Ohms)\n\n\n\n$TimeB\n\nFloat\n\nThe time for B. (seconds)\n\n\n\n$TransitionMode\n\nString\n\nSets the transition mode from A to B. \"PULSE,\" \"CONTINUOUS,\" or \"TOGGLED.\"\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\nBK8500_SetCRModeTransResandTiming($comPort,5.42,0.851,3.93,0.923,\"CONTINUOUS\");\n\n\n\n\n\nBK8500_SetCVModeTransVandTiming\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS BK8500_SetCVModeTransVandTiming": {
  "prefix": "BK8500_SetCVModeTransVandTiming",
  "body": [
   "BK8500_SetCVModeTransVandTiming($$InstrumentHandle,$$PowerA,$$TimeA,$$PowerB,$$TimeB,TransitionMode);"
  ],
  "description": "\n\nThis function configures the load for Voltage level A (Volts) for Time A (seconds) and then transitions to Voltage level B (Volts) for Time B (seconds) depending on the transition mode.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThis is the handle to the com port initialized.\n\n\n\n$VoltageA\n\nFloat\n\nThe Voltage level in Volts for A. (Volts)\n\n\n\n$TimeA\n\nFloat\n\nThe time for A. (seconds)\n\n\n\n$VoltageB\n\nFloat\n\nThe Voltage level in Volts for B. (Volts)\n\n\n\n$TimeB\n\nFloat\n\nThe time for B. (seconds)\n\n\n\n$TransitionMode\n\nString\n\nSets the transition mode from A to B. \"PULSE,\" \"CONTINUOUS,\" or \"TOGGLED.\"\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\nBK8500_SetCVModeTransVandTiming($comPort,3.12,0.11,1.55,0.33,\"TOGGLED\");\n\n\n\n\n\nBK8500_SetCVModeVoltage\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS BK8500_SetCVModeVoltage": {
  "prefix": "BK8500_SetCVModeVoltage",
  "body": [
   "BK8500_SetCVModeVoltage($$InstrumentHandle,$$Voltage);"
  ],
  "description": "\n\nThis function specifies the Voltage (Volts) for CV mode operation.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThis is the handle to the com port initialized.\n\n\n\n$Voltage\n\nFloat\n\nThe voltage specified in Volts.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\nBK8500_SetCVModeVoltage($comPort, 2.12);\n\n\n\n\n\nBK8500_SetCWModePower\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS BK8500_SetCWModePower": {
  "prefix": "BK8500_SetCWModePower",
  "body": [
   "BK8500_SetCWModePower($$InstrumentHandle,$$Power);"
  ],
  "description": "\n\nThis function specifies the power (Watts) for CW mode operation.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThis is the handle to the com port initialized.\n\n\n\n$Power\n\nFloat\n\nThe power specified in Watts.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\nBK8500_SetCWModePower($comPort, 110.54);\n\n\n\n\n\nBK8500_SetCWModeTransPwrandTiming\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS BK8500_SetCWModeTransPwrandTiming": {
  "prefix": "BK8500_SetCWModeTransPwrandTiming",
  "body": [
   "BK8500_SetCWModeTransPwrandTiming($$InstrumentHandle,$$PowerA,$$TimeA,$$PowerB,$$TimeB,$$TransitionMode);"
  ],
  "description": "\n\nThis function configures the load for Power level A (Watts) for Time A (seconds) and then transitions to Power level B (Watts) for Time B (seconds) depending on the transition mode.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThis is the handle to the com port initialized.\n\n\n\n$PowerA\n\nFloat\n\nThe Power level in Watts for A. (Watts)\n\n\n\n$TimeA\n\nFloat\n\nThe time for A. (seconds)\n\n\n\n$PowerB\n\nFloat\n\nThe Power level in Watts for B. (Watts)\n\n\n\n$TimeB\n\nFloat\n\nThe time for B. (seconds)\n\n\n\n$TransitionMode\n\nString\n\nSets the transition mode from A to B. \"PULSE,\" \"CONTINUOUS,\" or \"TOGGLED.\"\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\nBK8500_SetCWModeTransPwrandTiming($comPort,10.42,0.71,18.93,0.223,\"CONTINUOUS\");\n\n\n\n\n\nBK8500_SetComAddress\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS BK8500_SetComAddress": {
  "prefix": "BK8500_SetComAddress",
  "body": [
   "BK8500_SetComAddress($$InstrumentHandle,$$Address);"
  ],
  "description": "\n\nSets the address of the unit. When using RS232, and for all other commands based on this driver, set the front panel address setting to 0. This command should NOT be used. It is provided as reference for when a USB based driver is deployed.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThis is the handle to the com port initialized.\n\n\n\n$Address\n\nInteger\n\nA value between 0 and 254. It sets the address of the unit.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\nBK8500_SetComAddress($comPort,0);\n\n\n\n\n\nBK8500_SetLoad\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS BK8500_SetLoad": {
  "prefix": "BK8500_SetLoad",
  "body": [
   "BK8500_SetLoad($$InstrumentHandle,$$Mode);"
  ],
  "description": "\n\nSets the mode of operation for the load. (i.e. \"ON\" or \"OFF\")\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThis is the handle to the com port initialized.\n\n\n\n$Mode\n\nString\n\n\"ON\" - Sets the load ON.\n\n\"OFF\" - Sets the load to OFF.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\nBK8500_SetLoad($comPort,\"ON\");\n\n\n\n\n\nBK8500_SetMaxCurrentAllowed\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS BK8500_SetMaxCurrentAllowed": {
  "prefix": "BK8500_SetMaxCurrentAllowed",
  "body": [
   "BK8500_SetMaxCurrentAllowed($$InstrumentHandle,$$MaxCurrent);"
  ],
  "description": "\n\nThis function configures the Max Current value allowed (Amps).\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThis is the handle to the com port initialized.\n\n\n\n$MaxCurrent\n\nFloat\n\nThe max current value in Amps.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\nBK8500_SetMaxCurrentAllowed($comPort,3.12);\n\n\n\n\n\nBK8500_SetMaxPowerAllowed\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS BK8500_SetMaxPowerAllowed": {
  "prefix": "BK8500_SetMaxPowerAllowed",
  "body": [
   "BK8500_SetMaxPowerAllowed($$InstrumentHandle,$$Power);"
  ],
  "description": "\n\nThis function specifies the maximum power (Watts).\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThis is the handle to the com port initialized.\n\n\n\n$Power\n\nFloat\n\nThe maximum power specified in Watts.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\nBK8500_SetMaxPowerAllowed($comPort,213.45);\n\n\n\n\n\nBK8500_SetMaxVoltageAllowed\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS BK8500_SetMaxVoltageAllowed": {
  "prefix": "BK8500_SetMaxVoltageAllowed",
  "body": [
   "BK8500_SetMaxVoltageAllowed($$InstrumentHandle,$$Voltage);"
  ],
  "description": "\n\nThis function specifies the maximum voltage (Volts).\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThis is the handle to the com port initialized.\n\n\n\n$Voltage\n\nFloat\n\nThe maximum voltage specified in Volts.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\nBK8500_SetMaxVoltageAllowed($comPort,25.12);\n\n\n\n\n\nBK8500_SetMinVoltageInBatTst\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS BK8500_SetMinVoltageInBatTst": {
  "prefix": "BK8500_SetMinVoltageInBatTst",
  "body": [
   "BK8500_SetMinVoltageInBatTst($$InstrumentHandle,$$Voltage);"
  ],
  "description": "\n\nThis function specifies the minimum voltage (Volts).\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThis is the handle to the com port initialized.\n\n\n\n$Voltage\n\nFloat\n\nThe minimum voltage specified in Volts.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\nBK8500_SetMaxCurrentAllowed($comPort,3.12);\n\n\n\n\n\nBK8500_SetMode\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS BK8500_SetMode": {
  "prefix": "BK8500_SetMode",
  "body": [
   "BK8500_SetMode($$InstrumentHandle,$$Mode);"
  ],
  "description": "\n\nSets the mode of operation for the load. (i.e. \"CC,\" \"CV,\" \"CW,\" or \"CR\")\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThis is the handle to the com port initialized.\n\n\n\n$Mode\n\nString\n\n\"CC\" - Sets the load to Constant Current mode.\n\n\"CV\" - Sets the load to Constant Voltage mode.\n\n\"CW\" - Sets the load to Constant Power mode.\n\n\"CR\" - Sets the load to Constant Resistance mode.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\nBK8500_SetMode($comPort,\"CR\");\n\n\n\n\n\nBK8500_SetTimerLoadOn\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS BK8500_SetTimerLoadOn": {
  "prefix": "BK8500_SetTimerLoadOn",
  "body": [
   "BK8500_SetTimerLoadOn($$InstrumentHandle,$$Seconds);"
  ],
  "description": "\n\nSets the timer in seconds for the load to be on.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThis is the handle to the com port initialized.\n\n\n\n$Seconds\n\nInteger\n\nSeconds for the load to be on.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\nBK8500_SetTimerLoadOn($comPort,20);\n\n\n\n\n\nBK8500_SetTriggerSource\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS BK8500_SetTriggerSource": {
  "prefix": "BK8500_SetTriggerSource",
  "body": [
   "BK8500_SetTriggerSource($$InstrumentHandle,$$Source);"
  ],
  "description": "\n\nSets the source used to trigger the load.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThis is the handle to the com port initialized.\n\n\n\n$Source\n\nString\n\n\"IMMEDIATE\" - Means Immediate Trigger. (i.e. Triggered from the front panel.) \"External\" - Means Trigger from the rear panel connector.\n\n\"SOFTWARE\" - Means software trigger. (i.e. Use the BK8500_Trigger command.)\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\nBK8500_SetTriggerSource($comPort,\"EXTERNAL\");\n\n\n\n\n\nBK8500_Trigger\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS BK8500_Trigger": {
  "prefix": "BK8500_Trigger",
  "body": [
   "BK8500_Trigger($$InstrumentHandle);"
  ],
  "description": "\n\nTriggers the electronic load.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThis is the handle to the com port initialized.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\nBK8500_Trigger($comPort);\n\n\n\n\n\nCH6310_ActivateAllLoads\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS CH6310_ActivateAllLoads": {
  "prefix": "CH6310_ActivateAllLoads",
  "body": [
   "($$status)=CH6310_ActivateAllLoads($$instrumentHandle,$$loadEnable);"
  ],
  "description": "\n\nSets all electronic loads as active (load on) or non-active (load off).\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$instrumentHandle\n\nString\n\nHandle to the instrument driver session.\n\n\n\n$loadEnable\n\nBoolean\n\ntrue = turn all loads on\n\nfalse = turn all loads off\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$status\n\nInteger\n\nStatus code returned by function call (0 = success).\n\n\n\n\n\nCH6310_ActivateLoad\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS CH6310_ActivateLoad": {
  "prefix": "CH6310_ActivateLoad",
  "body": [
   "($$status)=CH6310_ActivateLoad($$instrumentHandle,$$loadEnable);"
  ],
  "description": "\n\nThis function makes the current channel's electronic load Acitve(On) / Inactive(Off).\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$instrumentHandle\n\nObject\n\nHandle to the instrument driver session.\n\n\n\n$loadEnable\n\nBoolean\n\ntrue = turn load on\n\nfalse = turn load off\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$status\n\nInteger\n\nStatus code returned by function call (0 = success).\n\n\n\n\n\nCH6310_ActivateShort\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS CH6310_ActivateShort": {
  "prefix": "CH6310_ActivateShort",
  "body": [
   "($$status)=CH6310_ActivateShort($$instrumentHandle,$$shortEnable);"
  ],
  "description": "\n\nActivate or inactivate short-circuited simulation.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$instrumentHandle\n\nObject\n\nHandle to the instrument driver session.\n\n\n\n$shortEnable\n\nBoolean\n\ntrue = turn short on\n\nfalse = turn short off\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$status\n\nInteger\n\nStatus code returned by function call (0 = success).\n\n\n\n\n\nCH6310_Close\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS CH6310_Close": {
  "prefix": "CH6310_Close",
  "body": [
   "($$status)=CH6310_Close($$instrumentHandle);"
  ],
  "description": "\n\nCloses the instrument and disposes of handle.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$instrumentHandle\n\nObject\n\nHandle to the instrument driver session.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$status\n\nInteger\n\nStatus code returned by function call (0 = success).\n\n\n\n\n\nCH6310_EnableChannel\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS CH6310_EnableChannel": {
  "prefix": "CH6310_EnableChannel",
  "body": [
   "($$status)=CH6310_EnableChannel($$instrumentHandle,$$active);"
  ],
  "description": "\n\nEnables or disables the current load module.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$instrumentHandle\n\nObject\n\nHandle to the instrument driver session.\n\n\n\n$active\n\nBoolean\n\ntrue \u2013 channel on\n\nfalse \u2013 channel off\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$status\n\nInteger\n\nStatus code returned by function call (0 = success).\n\n\n\n\n\nCH6310_ErrorMessage\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS CH6310_ErrorMessage": {
  "prefix": "CH6310_ErrorMessage",
  "body": [
   "($$status,$$message)=CH6310_ErrorMessage($$instrumentHandle,$$statusCode);"
  ],
  "description": "\n\nThis function takes the Status Code returned by the instrument driver functions, interprets it and returns it as a user readable string.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$instrumentHandle\n\nObject\n\nHandle to the instrument driver session.\n\n\n\n$statusCode\n\nInteger\n\nStatus code to decode.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$status\n\nInteger\n\nStatus code returned by function call (0 = success).\n\n\n\n$message\n\nString\n\nMessage associated with given status code.\n\n\n\n\n\nCH6310_ErrorQuery\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS CH6310_ErrorQuery": {
  "prefix": "CH6310_ErrorQuery",
  "body": [
   "($$status,$$errorCode,$$errorMessage)=CH6310_ErrorQuery($$instrumentHandle);"
  ],
  "description": "\n\nReads an error code from the instrument's error queue.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$instrumentHandle\n\nObject\n\nHandle to the instrument driver session.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$status\n\nInteger\n\nStatus code returned by function call (0 = success).\n\n\n\n$errorCode\n\nInteger\n\nError code in instruments error queue.\n\n\n\n$errorMessage\n\nString\n\nError message from instrument.\n\n\n\n\n\nCH6310_FetchCurrent\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS CH6310_FetchCurrent": {
  "prefix": "CH6310_FetchCurrent",
  "body": [
   "($$status,$$current)=CH6310_FetchCurrent($$instrumentHandle);"
  ],
  "description": "\n\nFetch real time current measured at the input of the load module.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$instrumentHandle\n\nObject\n\nHandle to the instrument driver session.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$status\n\nInteger\n\nStatus code returned by function call (0 = success).\n\n\n\n$current\n\nFloat\n\nReal time current at active channel.\n\n\n\n\n\nCH6310_FetchStatus\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS CH6310_FetchStatus": {
  "prefix": "CH6310_FetchStatus",
  "body": [
   "($$status,$$state)=CH6310_FetchStatus($$instrumentHandle);"
  ],
  "description": "\n\nFetch real time status of the load module.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$instrumentHandle\n\nObject\n\nHandle to the instrument driver session.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$status\n\nInteger\n\nStatus code returned by function call (0 = success).\n\n\n\n$state\n\nInteger\n\nReal time status of instrument:\n\nState Description\n\n0 No error.\n\n1 Over Current Protection.\n\n2 Over Voltage Protection.\n\n4 Over Power Protection.\n\n8 Reserve Voltage.\n\n16 Over Temperature Protection.\n\n-999 Error retrieving status\n\n\n\n\n\nCH6310_FetchVoltage\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS CH6310_FetchVoltage": {
  "prefix": "CH6310_FetchVoltage",
  "body": [
   "($$status,$$voltage)=CH6310_FetchVoltage($$instrumentHandle);"
  ],
  "description": "\n\nFetch real time voltage measured at the input of the load module.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$instrumentHandle\n\nObject\n\nHandle to the instrument driver session.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$status\n\nInteger\n\nStatus code returned by function call (0 = success).\n\n\n\n$voltage\n\nFloat\n\nReal time voltage at active channel.\n\n\n\n\n\nCH6310_GetCurrent\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS CH6310_GetCurrent": {
  "prefix": "CH6310_GetCurrent",
  "body": [
   "($$status,$$current)=CH6310_GetCurrent($$instrumentHandle,$$currentMode,$$loadLevel,$$suffix);"
  ],
  "description": "\n\nGets static or dynamic load current of constant current (CC) mode.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$instrumentHandle\n\nObject\n\nHandle to the instrument driver session.\n\n\n\n$currentMode\n\nString\n\nLoad type:\n\n\"STATIC\"\n\n\"DYNAMIC\"\n\n\n\n$loadLevel\n\nString\n\nTwo load levels per channel can be independently set and switched between:\n\n\"L1\" = 1st load level\n\n\"L2\" = 2nd load level\n\n\n\n$suffix\n\nInteger\n\nCommand suffix:\n\n0 = NONE (value)\n\n-1 = minimum value\n\n-2 = maximum value\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$status\n\nInteger\n\nStatus code returned by function call (0 = success).\n\n\n\n$current\n\nFloat\n\nCurrent setting value.\n\n\n\n\n\nCH6310_GetCurrentChannel\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS CH6310_GetCurrentChannel": {
  "prefix": "CH6310_GetCurrentChannel",
  "body": [
   "($$status,$$channel)=CH6310_GetCurrentChannel($$instrumentHandle);"
  ],
  "description": "\n\nReturns the channel number of the currently active electronic load.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$instrumentHandle\n\nObject\n\nHandle to the instrument driver session.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$status\n\nInteger\n\nStatus code returned by function call (0 = success).\n\n\n\n$channel\n\nInteger\n\nCurrent active channel.\n\n\n\n\n\nCH6310_GetCurrentLimit\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS CH6310_GetCurrentLimit": {
  "prefix": "CH6310_GetCurrentLimit",
  "body": [
   "($$status,$$currentLimit)=CH6310_GetCurrentLimit($$instrumentHandle);"
  ],
  "description": "\n\nGet the current limit of CV mode.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$instrumentHandle\n\nObject\n\nHandle to the instrument driver session.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$status\n\nInteger\n\nStatus code returned by function call (0 = success).\n\n\n\n$currentLimit\n\nFloat\n\nCurent limit of CV mode.\n\n\n\n\n\nCH6310_GetLoadStatus\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS CH6310_GetLoadStatus": {
  "prefix": "CH6310_GetLoadStatus",
  "body": [
   "($$status,$$state)=CH6310_GetLoadStatus($$instrumentHandle);"
  ],
  "description": "\n\nGet status of the currently active load module.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$instrumentHandle\n\nObject\n\nHandle to the instrument driver session.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$status\n\nInteger\n\nStatus code returned by function call (0 = success).\n\n\n\n$state\n\nInteger\n\nReal time status of channel:\n\nState Description\n\n0 No error.\n\n1 Over Current Protection.\n\n2 Over Voltage Protection.\n\n4 Over Power Protection.\n\n8 Reserve Voltage.\n\n16 Over Temperature Protection.\n\n-999 Error retrieving status\n\n\n\n\n\nCH6310_GetMode\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS CH6310_GetMode": {
  "prefix": "CH6310_GetMode",
  "body": [
   "($$status,$$mode)=CH6310_GetMode($$instrumentHandle);"
  ],
  "description": "\n\nReturns the operational mode of the currently active electronic load module.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$instrumentHandle\n\nObject\n\nHandle to the instrument driver session.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$status\n\nInteger\n\nStatus code returned by function call (0 = success).\n\n\n\n$mode\n\nString\n\nOperational mode of active load module (CCL, CCH, CCDL, CCDH, CRL, CRH, CV).\n\n\n\n\n\nCH6310_GetModuleID\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS CH6310_GetModuleID": {
  "prefix": "CH6310_GetModuleID",
  "body": [
   "($$status,$$modelID)=CH6310_GetModuleID($$instrumentHandle,$$channel);"
  ],
  "description": "\n\nGet module ID of the specific channel.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$instrumentHandle\n\nObject\n\nHandle to the instrument driver session.\n\n\n\n$channel\n\nInteger\n\nChannel to select (1 through 8).\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$status\n\nInteger\n\nStatus code returned by function call (0 = success).\n\n\n\n$modelID\n\nString\n\nOperational mode of active load module (CCL, CCH, CCDL, CCDH, CRL, CRH, CV).\n\n\n\n\n\nCH6310_GetResistance\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS CH6310_GetResistance": {
  "prefix": "CH6310_GetResistance",
  "body": [
   "($$status,$$resistance)=CH6310_GetResistance($$instrumentHandle,$$loadLevel,$$suffix);"
  ],
  "description": "\n\nGets static resistance level of CR mode.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$instrumentHandle\n\nObject\n\nHandle to the instrument driver session.\n\n\n\n$loadLevel\n\nString\n\nTwo load levels per channel can be independently set and switched between:\n\n\"L1\" = 1st load level\n\n\"L2\" = 2nd load level\n\n\n\n$suffix\n\nInteger\n\nCommand suffix:\n\n0 = NONE (value)\n\n-1 = minimum value\n\n-2 = maximum value\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$status\n\nInteger\n\nStatus code returned by function call (0 = success).\n\n\n\n$resistance\n\nFloat\n\nResistance level of CR mode in ohms.\n\n\n\n\n\nCH6310_GetSlewRate\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS CH6310_GetSlewRate": {
  "prefix": "CH6310_GetSlewRate",
  "body": [
   "($$status,$$slewRate)=CH6310_GetSlewRate($$instrumentHandle,$$mode,$$function);"
  ],
  "description": "\n\nGet current slew rate at static or dynamic CC mode, or get resistive slew rate at CR mode.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$instrumentHandle\n\nObject\n\nHandle to the instrument driver session.\n\n\n\n$mode\n\nString\n\nOperational mode"
 }
,
 "JTS CH6310_GetVoltage": {
  "prefix": "CH6310_GetVoltage",
  "body": [
   "($$status,$$voltage)=CH6310_GetVoltage($$instrumentHandle,$$loadLevel);"
  ],
  "description": "\n\nGets voltage of static load during CV mode.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$instrumentHandle\n\nObject\n\nHandle to the instrument driver session.\n\n\n\n$loadLevel\n\nString\n\nTwo load levels per channel can be independently set and switched between:\n\n\"L1\" = 1st load level\n\n\"L2\" = 2nd load level\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$status\n\nInteger\n\nStatus code returned by function call (0 = success).\n\n\n\n$voltage\n\nFloat\n\nStatic load voltage of active channel.\n\n\n\n\n\nCH6310_GetVoltageOn\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS CH6310_GetVoltageOn": {
  "prefix": "CH6310_GetVoltageOn",
  "body": [
   "($$status,$$Von)=CH6310_GetVoltageOn($$instrumentHandle);"
  ],
  "description": "\n\nGets voltage of 'sink current on' of current channel.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$instrumentHandle\n\nObject\n\nHandle to the instrument driver session.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$status\n\nInteger\n\nStatus code returned by function call (0 = success).\n\n\n\n$Von\n\nFloat\n\nVoltage of 'sink current on' of active channel.\n\n\n\n\n\nCH6310_GetVoltageRange\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS CH6310_GetVoltageRange": {
  "prefix": "CH6310_GetVoltageRange",
  "body": [
   "($$status,$$voltageRange)=CH6310_GetVoltageRange($$instrumentHandle);"
  ],
  "description": "\n\nQuery voltage measurement range (High or Low) in CC mode.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$instrumentHandle\n\nObject\n\nHandle to the instrument driver session.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$status\n\nInteger\n\nStatus code returned by function call (0 = success).\n\n\n\n$voltageRange\n\nFloat\n\nVoltage range of active channel.\n\n\n\n\n\nCH6310_Init\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS CH6310_Init": {
  "prefix": "CH6310_Init",
  "body": [
   "($$status,$$instrumentHandle)=CH6310_Init($$resourceName,$$IDQuery,$$resetDevice);"
  ],
  "description": "\n\nThis function performs the following initialization actions:\n\n\n\n\n\n- Opens a session to the Default Resource Manager resource and a session to the specified device using the interface and address specified in the Resource_Name control.\n\n- Performs an identification query on the Instrument.\n\n- Resets the instrument to a known state.\n\n- Sends initialization commands to the instrument that set any necessary programmatic variables such as Headers Off, Short Command form, and Data Transfer Binary to the state necessary for the operation of the instrument driver.\n\n- Returns an Instrument Handle which is used to differentiate between different sessions of this instrument driver"
 }
,
 "JTS CH6310_IsAutoLoadOn": {
  "prefix": "CH6310_IsAutoLoadOn",
  "body": [
   "($$status,$$autoLoadOnStatus)=CH6310_IsAutoLoadOn($$instrumentHandle);"
  ],
  "description": "\n\nReturn if ALL the load modules will do \u201cAuto Load On\u201d during power on.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$instrumentHandle\n\nObject\n\nHandle to the instrument driver session.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$status\n\nInteger\n\nStatus code returned by function call (0 = success).\n\n\n\n$autoLoadOnStatus\n\nBoolean\n\nAutoload on true/false.\n\n\n\n\n\nCH6310_IsLoadActive\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS CH6310_IsLoadActive": {
  "prefix": "CH6310_IsLoadActive",
  "body": [
   "($$status,$$loadActive)=CH6310_IsLoadActive($$instrumentHandle);"
  ],
  "description": "\n\nQuery whether the current channel load module is active or off.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$instrumentHandle\n\nObject\n\nHandle to the instrument driver session.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$status\n\nInteger\n\nStatus code returned by function call (0 = success).\n\n\n\n$loadActive\n\nBoolean\n\nCurrent channel load active true/false.\n\n\n\n\n\nCH6310_IsShortActive\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS CH6310_IsShortActive": {
  "prefix": "CH6310_IsShortActive",
  "body": [
   "($$status,$$shortActive)=CH6310_IsShortActive($$instrumentHandle);"
  ],
  "description": "\n\nQuery if current channel if load module is short-circuited or not.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$instrumentHandle\n\nObject\n\nHandle to the instrument driver session.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$status\n\nInteger\n\nStatus code returned by function call (0 = success).\n\n\n\n$shortActive\n\nBoolean\n\nCurrent channel short-circuit simulation active true/false.\n\n\n\n\n\nCH6310_MeasureIV\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS CH6310_MeasureIV": {
  "prefix": "CH6310_MeasureIV",
  "body": [
   "($$status,$$value)=CH6310_MeasureIV($$instrumentHandle,$$function);"
  ],
  "description": "\n\nReturns voltage/current measured at the input of the electronic load.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$instrumentHandle\n\nObject\n\nHandle to the instrument driver session.\n\n\n\n$function\n\nString\n\nSpecifies voltage or current measurement. Valid functions:\n\n\"VOLTAGE\"\n\n\"CURRENT\"\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$status\n\nInteger\n\nStatus code returned by function call (0 = success).\n\n\n\n$value\n\nFloat\n\nVoltage or current at input of current channel.\n\n\n\n\n\nCH6310_QueryRevision\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS CH6310_QueryRevision": {
  "prefix": "CH6310_QueryRevision",
  "body": [
   "($$status,$$instrumentDriverRevision,$$firmwareRevision)=CH6310_QueryRevision($$instrumentHandle);"
  ],
  "description": "\n\nThis function returns the revision numbers of the instrument driver and instrument firmware, and tells the user with which instrument firmware this revision of the driver is compatible.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$instrumentHandle\n\nObject\n\nHandle to the instrument driver session.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$status\n\nInteger\n\nStatus code returned by function call (0 = success).\n\n\n\n$instrumentDriverRevision\n\nString\n\nDriver revision.\n\n\n\n$firmwareRevision\n\nString\n\nFirmware revision.\n\n\n\n\n\nCH6310_QuerySpecification\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS CH6310_QuerySpecification": {
  "prefix": "CH6310_QuerySpecification",
  "body": [
   "($$status,$$GONGResult)=CH6310_QuerySpecification($$instrumentHandle,$$function);"
  ],
  "description": "\n\nRequests GO-NG result reference to voltage/current/all channels specification.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$instrumentHandle\n\nObject\n\nHandle to the instrument driver session.\n\n\n\n$function\n\nString\n\nReturn specification of active channel for following modes:\n\n\"VOLTAGE\" = voltage GO-NG result to CC and CR Mode\n\nCURRENT\" = current GO-NG result to CC Mode\n\n\"ALL\" = all channels GO-NG result\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$status\n\nInteger\n\nStatus code returned by function call (0 = success).\n\n\n\n$GONGResult\n\nInteger\n\n0 = No-Go\n\n1 = Go\n\n\n\n\n\nCH6310_QueryVonLatch\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS CH6310_QueryVonLatch": {
  "prefix": "CH6310_QueryVonLatch",
  "body": [
   "($$status,$$latched)=CH6310_QueryVonLatch($$instrumentHandle);"
  ],
  "description": "\n\nGet the action type of Von.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$instrumentHandle\n\nObject\n\nHandle to the instrument driver session.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$status\n\nInteger\n\nStatus code returned by function call (0 = success).\n\n\n\n$latched\n\nBoolean\n\nStatus of Von latch mode for current channel:\n\ntrue = latched\n\nfalse = non-latched\n\n\n\n\n\nCH6310_ReadInstrumentData\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS CH6310_ReadInstrumentData": {
  "prefix": "CH6310_ReadInstrumentData",
  "body": [
   "($$status,$$readBuffer,$$numBytesRead)=CH6310_ReadInstrumentData($$instrumentHandle,$$numberBytesToRead);"
  ],
  "description": "\n\nReads data from the instrument's output buffer.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$instrumentHandle\n\nObject\n\nHandle to the instrument driver session.\n\n\n\n$numberBytesToRead\n\nInteger\n\n# of bytes to try and read from output buffer of instrument.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$status\n\nInteger\n\nStatus code returned by function call (0 = success).\n\n\n\n$readBuffer\n\nString\n\nAlpha/numeric data that was on instrument's output buffer.\n\n\n\n$numBytesRead\n\nInteger\n\nActual # of byte that were read from the instrument's output buffer.\n\n\n\n\n\nCH6310_Reset\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS CH6310_Reset": {
  "prefix": "CH6310_Reset",
  "body": [
   "($$status)=CH6310_Reset($$instrumentHandle);"
  ],
  "description": "\n\nThis function resets the instrument to a known state and sends initialization commands to the instrument that set any necessary programmatic variables such as Headers Off, Short Command form, and Data Transfer Binary to the state necessary for the operation of the instrument driver.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$instrumentHandle\n\nObject\n\nHandle to the instrument driver session.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$status\n\nInteger\n\nStatus code returned by function call (0 = success).\n\n\n\n\n\nCH6310_ResetLoad\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS CH6310_ResetLoad": {
  "prefix": "CH6310_ResetLoad",
  "body": [
   "($$status)=CH6310_ResetLoad($$instrumentHandle);"
  ],
  "description": "\n\nResets active load module.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$instrumentHandle\n\nObject\n\nHandle to the instrument driver session.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$status\n\nInteger\n\nStatus code returned by function call (0 = success).\n\n\n\n\n\nCH6310_SelectChannel\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS CH6310_SelectChannel": {
  "prefix": "CH6310_SelectChannel",
  "body": [
   "($$status)=CH6310_SelectChannel($$instrumentHandle,$$channel);"
  ],
  "description": "\n\nSelects a specific channel.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$instrumentHandle\n\nObject\n\nHandle to the instrument driver session.\n\n\n\n$channel\n\nInteger\n\nChannel to select (1 through 8).\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$status\n\nInteger\n\nStatus code returned by function call (0 = success).\n\n\n\n\n\nCH6310_SelectInputPort\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS CH6310_SelectInputPort": {
  "prefix": "CH6310_SelectInputPort",
  "body": [
   "($$status)=CH6310_SelectInputPort($$instrumentHandle,$$inputPort);"
  ],
  "description": "\n\nSelects the input port of the load module to measure voltage from.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$instrumentHandle\n\nObject\n\nHandle to the instrument driver session.\n\n\n\n$inputPort\n\nInteger\n\nInput port of load module:\n\n0 (LOAD)\n\n1 (UUT)\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$status\n\nInteger\n\nStatus code returned by function call (0 = success).\n\n\n\n\n\nCH6310_SelfTest\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS CH6310_SelfTest": {
  "prefix": "CH6310_SelfTest",
  "body": [
   "($$status,$$selfTestResult,$$selfTestMessage)=CH6310_SelfTest($$instrumentHandle);"
  ],
  "description": "\n\nThis function runs the instrument's self test routine and returns the test result(s).\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$instrumentHandle\n\nObject\n\nHandle to the instrument driver session.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$status\n\nInteger\n\nStatus code returned by function call (0 = success).\n\n\n\n$selfTestResult\n\nInterger\n\n0 = success\n\nnon-0 = check reference material for error codes\n\n\n\n$selfTestMessage\n\nString\n\nSelf test result message.\n\n\n\n\n\nCH6310_SetAutoLoadOn\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS CH6310_SetAutoLoadOn": {
  "prefix": "CH6310_SetAutoLoadOn",
  "body": [
   "($$status)=CH6310_SetAutoLoadOn($$instrumentHandle,$$autoLoadOn);"
  ],
  "description": "\n\nSets if ALL the load module will do Auto Load On during power on.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$instrumentHandle\n\nObject\n\nHandle to the instrument driver session.\n\n\n\n$autoLoadOn\n\nBoolean\n\nDetermines if all load modules will have AutoLoad on.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$status\n\nInteger\n\nStatus code returned by function call (0 = success).\n\n\n\n\n\nCH6310_SetCurrent\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS CH6310_SetCurrent": {
  "prefix": "CH6310_SetCurrent",
  "body": [
   "($$status)=CH6310_SetCurrent($$instrumentHandle,$$currentMode,$$loadLevel,$$current);"
  ],
  "description": "\n\nSets static or dynamic load Current of constant current mode for active channel.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$instrumentHandle\n\nObject\n\nHandle to the instrument driver session.\n\n\n\n$currentMode\n\nString\n\nLoad type:\n\n\"STATIC\"\n\n\"DYNAMIC\"\n\n\n\n$loadLevel\n\nString\n\nTwo load levels per channel can be independently set and switched between:\n\n\"L1\" = 1st load level\n\n\"L2\" = 2nd load level\n\n\n\n$current\n\nFloat\n\nCurrent setting:\n\n-2 = maximum current\n\n-1 = minimum current\n\npositive values = current in Amps\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$status\n\nInteger\n\nStatus code returned by function call (0 = success).\n\n\n\n\n\nCH6310_SetCurrentLimit\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS CH6310_SetCurrentLimit": {
  "prefix": "CH6310_SetCurrentLimit",
  "body": [
   "($$status)=CH6310_SetCurrentLimit($$instrumentHandle,$$currentLimit);"
  ],
  "description": "\n\nSet the current limit of CV mode for active channel.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$instrumentHandle\n\nObject\n\nHandle to the instrument driver session.\n\n\n\n$currentLimit\n\nFloat\n\nCurrent limit in CV mode.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$status\n\nInteger\n\nStatus code returned by function call (0 = success).\n\n\n\n\n\nCH6310_SetDisplayMode\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS CH6310_SetDisplayMode": {
  "prefix": "CH6310_SetDisplayMode",
  "body": [
   "($$status)=CH6310_SetDisplayMode($$instrumentHandle,$$display);"
  ],
  "description": "\n\nSets the display mode of front panel of the electronic load.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$instrumentHandle\n\nObject\n\nHandle to the instrument driver session.\n\n\n\n$display\n\nString\n\nFront panel display setting:\n\n\"L\" = Displays the voltage and current values of channel L\n\n\"R\" = Displays the voltage and current values of channel R.\n\n\"LRV\" = Displays the voltage value of channel L and R.\n\n\"LRI\" = Displays the current value of channel L and R.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$status\n\nInteger\n\nStatus code returned by function call (0 = success).\n\n\n\n\n\nCH6310_SetMode\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS CH6310_SetMode": {
  "prefix": "CH6310_SetMode",
  "body": [
   "($$status)=CH6310_SetMode($$instrumentHandle,$$mode);"
  ],
  "description": "\n\nSet operational modes of currently active channel.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$instrumentHandle\n\nObject\n\nHandle to the instrument driver session.\n\n\n\n$mode\n\nString\n\nOperational mode of load : CCL, CCH, CCDL, CCDH, CRL, CRH, CV\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$status\n\nInteger\n\nStatus code returned by function call (0 = success).\n\n\n\n\n\nCH6310_SetResistance\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS CH6310_SetResistance": {
  "prefix": "CH6310_SetResistance",
  "body": [
   "($$status)=CH6310_SetResistance($$instrumentHandle,$$loadLevel,$$resistance);"
  ],
  "description": "\n\nSets static resistance level of CR mode.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$instrumentHandle\n\nObject\n\nHandle to the instrument driver session.\n\n\n\n$loadLevel\n\nString\n\nTwo load levels per channel can be independently set and switched between:\n\n\"L1\" = 1st load level\n\n\"L2\" = 2nd load level\n\n\n\n$resistance\n\nFloat\n\nStatic resistance of CR mode.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$status\n\nInteger\n\nStatus code returned by function call (0 = success).\n\n\n\n\n\nCH6310_SetSlewRate\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS CH6310_SetSlewRate": {
  "prefix": "CH6310_SetSlewRate",
  "body": [
   "($$status)=CH6310_SetSlewRate($$instrumentHandle,$$mode,$$function,$$slewRate);"
  ],
  "description": "\n\nSet current slew rate in static or dynamic CC mode, or set resistive slew rate in CR mode\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$instrumentHandle\n\nObject\n\nHandle to the instrument driver session.\n\n\n\n$mode\n\nString\n\nOperational mode"
 }
,
 "JTS CH6310_SetVoltage": {
  "prefix": "CH6310_SetVoltage",
  "body": [
   "($$status)=CH6310_SetVoltage($$instrumentHandle,$$loadLevel,$$voltage);"
  ],
  "description": "\n\nSets voltage of static load during CV mode.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$instrumentHandle\n\nObject\n\nHandle to the instrument driver session.\n\n\n\n$loadLevel\n\nString\n\nTwo load levels per channel can be independently set and switched between:\n\n\"L1\" = 1st load level\n\n\"L2\" = 2nd load level\n\n\n\n$voltage\n\nFloat\n\nVoltage of static load in CV mode.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$status\n\nInteger\n\nStatus code returned by function call (0 = success).\n\n\n\n\n\nCH6310_SetVoltageRange\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS CH6310_SetVoltageRange": {
  "prefix": "CH6310_SetVoltageRange",
  "body": [
   "($$status)=CH6310_SetVoltageRange($$instrumentHandle,$$voltageRange);"
  ],
  "description": "\n\nSets voltage measurement range to High or Low in CC mode.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$instrumentHandle\n\nObject\n\nHandle to the instrument driver session.\n\n\n\n$voltageRange\n\nFloat\n\nVoltage measurement range (0 to 80V).\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$status\n\nInteger\n\nStatus code returned by function call (0 = success).\n\n\n\n\n\nCH6310_SetVon\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS CH6310_SetVon": {
  "prefix": "CH6310_SetVon",
  "body": [
   "($$status)=CH6310_SetVon($$instrumentHandle,$$Von);"
  ],
  "description": "\n\nSets voltage of sink current on of current channel.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$instrumentHandle\n\nObject\n\nHandle to the instrument driver session.\n\n\n\n$Von\n\nFloat\n\nVoltage of sink current on.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$status\n\nInteger\n\nStatus code returned by function call (0 = success).\n\n\n\n\n\nCH6310_SetVonLatch\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS CH6310_SetVonLatch": {
  "prefix": "CH6310_SetVonLatch",
  "body": [
   "($$status)=CH6310_SetVonLatch($$instrumentHandle,$$latch);"
  ],
  "description": "\n\nSet the action type of Von.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$instrumentHandle\n\nObject\n\nHandle to the instrument driver session.\n\n\n\n$latch\n\nBoolean\n\nVon latch mode for current channel:\n\ntrue = latched\n\nfalse = non-latched\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$status\n\nInteger\n\nStatus code returned by function call (0 = success).\n\n\n\n\n\nCH6310_WriteInstrumentData\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS CH6310_WriteInstrumentData": {
  "prefix": "CH6310_WriteInstrumentData",
  "body": [
   "($$status)=CH6310_WriteInstrumentData($$instrumentHandle,$$command);"
  ],
  "description": "\n\nSends commands/queries to the instrument.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$instrumentHandle\n\nObject\n\nHandle to the instrument driver session.\n\n\n\n$command\n\nString\n\nSCPI command to write to instrument.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$status\n\nInteger\n\nStatus code returned by function call (0 = success).\n\n\n\n\n\nLadyBug_GetAddress_Idx\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS LadyBug_GetAddress_Idx": {
  "prefix": "LadyBug_GetAddress_Idx",
  "body": [
   "$$ErrorCode=LadyBug_GetAddress_Idx($$Index);"
  ],
  "description": "\n\nThis function requires the installation of the LadyBug sensor driver on the system.\n\nThis function returns the address given the index. Index is assigned by the operating system when the unit is plugged in.\n\n\n\nResult:\n\n$ErrorCode = LadyBug_GetAddress_Idx($Index);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Index\n\ninteger\n\nIndex which will normally be between 1 and 16.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\ninteger\n\nThe address between 1 and 255. If $ErrorCode < 0, there is a failure.\n\n\n\n\n\nExample:\n\n$ErrorCode = LadyBug_GetAddress_Idx(1);\n\n\n\n\n\nLadyBug_GetAddress_SN\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS LadyBug_GetAddress_SN": {
  "prefix": "LadyBug_GetAddress_SN",
  "body": [
   "$$ErrorCode=LadyBug_GetAddress_SN($$SerialNumber);"
  ],
  "description": "\n\nThis function requires the installation of the LadyBug sensor driver on the system.\n\nThis function returns the address given the serial number.\n\n\n\nResult:\n\n$ErrorCode = LadyBug_GetAddress_SN($SerialNumber);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$SerialNumber\n\nstring\n\nSerial number.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\ninteger\n\nThe address between 1 and 255. If $ErrorCode < 0, there is a failure.\n\n\n\n\n\nExample:\n\n$ErrorCode = LadyBug_GetAddress_SN(\"123456\");\n\n\n\n\n\nLadyBug_GetFrequency\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS LadyBug_GetFrequency": {
  "prefix": "LadyBug_GetFrequency",
  "body": [
   "($$ErrorCode,$$Frequency)=LadyBug_GetFrequency($$Address);"
  ],
  "description": "\n\nThis function requires the installation of the LadyBug sensor driver on the system.\n\nThis function gets the frequency of the addressed device.\n\n\n\nResult:\n\n($ErrorCode,$Frequency) = LadyBug_GetFrequency($Address);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Address\n\ninteger\n\nThe address of the instrument.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\ninteger\n\nSuccess if $ErrorCode > 0. If $ErrorCode <= 0, there is a failure.\n\n\n\n$Frequency\n\nfloat\n\nThe frequency in Hz.\n\n\n\n\n\nExample:\n\n($ErrorCode,$Frequency) = LadyBug_GetFrequency(1);\n\n\n\n\n\nLadyBug_InitializeSensor_Addr\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS LadyBug_InitializeSensor_Addr": {
  "prefix": "LadyBug_InitializeSensor_Addr",
  "body": [
   "$$ErrorCode=LadyBug_InitializeSensor_Addr($$Address);"
  ],
  "description": "\n\nThis function requires the installation of the LadyBug sensor driver on the system.\n\nThis function cause the sensor to be initialized. This includes downloading the calibration factors and other data required to operate the sensor. Initialization normally takes about five seconds.\n\n\n\nResult:\n\n$ErrorCode = LadyBug_InitializeSensor_Addr($Address);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Address\n\ninteger\n\nThe address of the instrument.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\ninteger\n\nSuccess if $ErrorCode > 0. If $ErrorCode <= 0, there is a failure.\n\n\n\n\n\nExample:\n\n$ErrorCode = LadyBug_InitializeSensor_Addr(1);\n\n\n\n\n\nLadyBug_InitializeSensor_Idx\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS LadyBug_InitializeSensor_Idx": {
  "prefix": "LadyBug_InitializeSensor_Idx",
  "body": [
   "$$ErrorCode=LadyBug_InitializeSensor_Idx($$Index);"
  ],
  "description": "\n\nThis function requires the installation of the LadyBug sensor driver on the system.\n\nThis function cause the sensor to be initialized. This includes downloading the calibration factors and other data required to operate the sensor. Initialization normally takes about five seconds.\n\n\n\nResult:\n\n$ErrorCode = LadyBug_InitializeSensor_Idx($Index);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Index\n\ninteger\n\nThe index of the instrument.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\ninteger\n\nSuccess if $ErrorCode > 0. If $ErrorCode <= 0, there is a failure.\n\n\n\n\n\nExample:\n\n$ErrorCode = LadyBug_InitializeSensor_Idx(1);\n\n\n\n\n\nLadyBug_InitializeSensor_SN\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS LadyBug_InitializeSensor_SN": {
  "prefix": "LadyBug_InitializeSensor_SN",
  "body": [
   "$$ErrorCode=LadyBug_InitializeSensor_SN($$SerialNumber);"
  ],
  "description": "\n\nThis function requires the installation of the LadyBug sensor driver on the system.\n\nThis function cause the sensor to be initialized. This includes downloading the calibration factors and other data required to operate the sensor. Initialization normally takes about five seconds.\n\n\n\nResult:\n\n$ErrorCode = LadyBug_InitializeSensor_SN($SerialNumber);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$SerialNumber\n\nstring\n\nThe serial number.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\ninteger\n\nSuccess if $ErrorCode > 0. If $ErrorCode <= 0, there is a failure.\n\n\n\n\n\nExample:\n\n$ErrorCode = LadyBug_InitializeSensor_SN(\"123456\");\n\n\n\n\n\nLadyBug_IsSensorConnected_Addr\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS LadyBug_IsSensorConnected_Addr": {
  "prefix": "LadyBug_IsSensorConnected_Addr",
  "body": [
   "$$ErrorCode=LadyBug_IsSensorConnected_Addr($$Address);"
  ],
  "description": "\n\nThis function requires the installation of the LadyBug sensor driver on the system.\n\nThis function determines if the specified sensor is connected. The query is based on the address.\n\n\n\nResult:\n\n$ErrorCode = LadyBug_IsSensorConnected_Addr($Address);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Address\n\ninteger\n\nThe address of the instrument.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\ninteger\n\n$ErrorCode = 1: serial number is connected.\n\n$ErrorCode = 0: serial number is not connected.\n\nIf $ErrorCode < 0, there is a failure.\n\n\n\n\n\nExample:\n\n$ErrorCode = LadyBug_IsSensorConnected_Addr(1);\n\n\n\n\n\nLadyBug_IsSensorConnected_SN\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS LadyBug_IsSensorConnected_SN": {
  "prefix": "LadyBug_IsSensorConnected_SN",
  "body": [
   "$$ErrorCode=LadyBug_IsSensorConnected_SN($$SerialNumber);"
  ],
  "description": "\n\nThis function requires the installation of the LadyBug sensor driver on the system.\n\nThis function determines if the specified sensor is connected. The query is based on the serial number.\n\n\n\nResult:\n\n$ErrorCode = LadyBug_IsSensorConnected_SN($SerialNumber);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$SerialNumber\n\nstring\n\nSerial number.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\ninteger\n\n$ErrorCode = 1: serial number is connected.\n\n$ErrorCode = 0: serial number is not connected.\n\nIf $ErrorCode < 0, there is a failure.\n\n\n\n\n\nExample:\n\n$ErrorCode = LadyBug_IsSensorConnected_SN(\"123456\");\n\n\n\n\n\nLadyBug_MeasureCW\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS LadyBug_MeasureCW": {
  "prefix": "LadyBug_MeasureCW",
  "body": [
   "($$ErrorCode,$$CW)=LadyBug_MeasureCW($$Address);"
  ],
  "description": "\n\nThis function requires the installation of the LadyBug sensor driver on the system.\n\nThis function makes CW measurements. The value returned is in the units currently selected. The time to make this measurement can vary widely. Measurement time in particular depends on the setting of averaging. Typical measurement times are about 0.3 to 1.0 msec per buffer. Each buffer contains about 120 averages so that a measurement for 100 buffers (averaging set to 100) would take 30 to 100 msec. Another setting that affects the measurement time is anti-aliasing. The measurement time is about 40% greater with anti-aliasing on than with anti-aliasing off. Anti-aliasing is generally required if the baseband content (or demodulated signal) has a frequency above 200 kHz. Finally, getting an accurate measurement requires that the frequency be set.\n\n\n\n\n\nResult:\n\n($ErrorCode,$CW) = LadyBug_MeasureCW($Address);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Address\n\ninteger\n\nThe address of the instrument.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\ninteger\n\nSuccess if $ErrorCode > 0. If $ErrorCode <= 0, there is a failure.\n\n\n\n$CW\n\ndouble\n\nResult of CW measurement.\n\n\n\n\n\nExample:\n\n($ErrorCode,$CW) = LadyBug_MeasureCW(1);\n\n\n\n\n\nLadyBug_MeasureCW_PF\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS LadyBug_MeasureCW_PF": {
  "prefix": "LadyBug_MeasureCW_PF",
  "body": [
   "($$ErrorCode,$$CW,$$Result)=LadyBug_MeasureCW_PF($$Address);"
  ],
  "description": "\n\nThis function requires the installation of the LadyBug sensor driver on the system.\n\nThis routine makes CW measurements and evaluates that measurement relative to the current limit. The value returned is in the units currently selected.\n\n\n\n\n\nResult:\n\n($ErrorCode,$CW,$Result) = LadyBug_MeasureCW_PF($Address);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Address\n\ninteger\n\nThe address of the instrument.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\ninteger\n\nSuccess if $ErrorCode > 0. If $ErrorCode <= 0, there is a failure.\n\n\n\n$CW\n\ndouble\n\nResult of CW measurement.\n\n\n\n$Result\n\nstring\n\nThe limit test result. Returned values:\n\n\u00b7 PASS\n\n\u00b7 FAIL_LOW\n\n\u00b7 FAIL_HIGH\n\n\u00b7 FAIL_BETWEEN_LIMIT_EXC\n\n\u00b7 FAIL_BETWEEN_LIMIT_INC\n\n\u00b7 NO_DETERMINATION\n\n\n\n\n\nExample:\n\n($ErrorCode,$CW,$Result) = LadyBug_MeasureCW_PF(1);\n\n\n\n\n\nLadyBug_MeasurePulse\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS LadyBug_MeasurePulse": {
  "prefix": "LadyBug_MeasurePulse",
  "body": [
   "($$ErrorCode,$$Pulse,$$Peak,$$Aveage,$$DutyCycle)=LadyBug_MeasurePulse($$Address);"
  ],
  "description": "\n\nThis function requires the installation of the LadyBug sensor driver on the system.\n\nThis function makes pulse measurements. The measurement returns pulse power (average power in the pulse); peak power (highest sample measured); averge power; and duty cycle. These are direct measurements. The measurements are made using the number of buffers (averages) and the units specified earlier.\n\n\n\n\n\nResult:\n\n($ErrorCode,$Pulse,$Peak,$Aveage,$DutyCycle) = LadyBug_MeasurePulse($Address);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Address\n\ninteger\n\nThe address of the instrument.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\ninteger\n\nSuccess if $ErrorCode > 0. If $ErrorCode <= 0, there is a failure.\n\n\n\n$Pulse\n\nfloat\n\nPulse power\n\n\n\n$Peak\n\nfloat\n\nPeak power.\n\n\n\n$Average\n\nfloat\n\nAverage power.\n\n\n\n$DutyCycle\n\nfloat\n\nDuty cycle.\n\n\n\n\n\nExample:\n\n($ErrorCode,$Pulse,$Peak,$Average,$DutyCycle) = LadyBug_MeasurePulse(1);\n\n\n\n\n\nLadyBug_MeasurePulse_PF\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS LadyBug_MeasurePulse_PF": {
  "prefix": "LadyBug_MeasurePulse_PF",
  "body": [
   "($$ErrorCode,$$Pulse,$$Peak,$$Aveage,$$DutyCycle,$$Result)=LadyBug_MeasurePulse_PF($$Address);"
  ],
  "description": "\n\nThis function requires the installation of the LadyBug sensor driver on the system.\n\nThis function makes pulse measurements. The measurement returns pulse power (average power in the pulse); peak power (highest sample measured); average power; and duty cycle. These are direct measurements. The measurements are made using the number of buffers (averages) and the units specified earlier.\n\n\n\n\n\nResult:\n\n($ErrorCode,$Pulse,$Peak,$Aveage,$DutyCycle,$Result) = LadyBug_MeasurePulse_PF($Address);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Address\n\ninteger\n\nThe address of the instrument.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\ninteger\n\nSuccess if $ErrorCode > 0. If $ErrorCode <= 0, there is a failure.\n\n\n\n$Pulse\n\nfloat\n\nPulse power\n\n\n\n$Peak\n\nfloat\n\nPeak power.\n\n\n\n$Average\n\nfloat\n\nAverage power.\n\n\n\n$DutyCycle\n\nfloat\n\nDuty cycle.\n\n\n\n$Result\n\nstring\n\nThe limit test result. Returned values:\n\n\u00b7 PASS\n\n\u00b7 FAIL_LOW\n\n\u00b7 FAIL_HIGH\n\n\u00b7 FAIL_BETWEEN_LIMIT_EXC\n\n\u00b7 FAIL_BETWEEN_LIMIT_INC\n\n\u00b7 NO_DETERMINATION\n\n\n\n\n\nExample:\n\n($ErrorCode,$Pulse,$Peak,$Aveage,$DutyCycle,$Result) = LadyBug_MeasurePulse_PF(1);\n\n\n\n\n\nLadyBug_SensorCount\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS LadyBug_SensorCount": {
  "prefix": "LadyBug_SensorCount",
  "body": [
   "$$Count=LadyBug_SensorCount();"
  ],
  "description": "\n\nThis function requires the installation of the LadyBug sensor driver on the system.\n\nThis function returns the number of sensors currently connected to the computer.\n\nResult:\n\n$Count = LadyBug_SensorCount();\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Count\n\ninteger\n\nIf $ErrorCode < 0, there is a failure.\n\nSuccess: The number of sensors connected to the PC. The number will be between 0 and 16.\n\n\n\n\n\nExample:\n\n$Count = LadyBug_SensorCount();\n\n\n\n\n\nFULL Lady Bug RF Power Sensor Extended Example:\n\n//"
 }
,
 "JTS LadyBug_SetAntiAliasingEnabled": {
  "prefix": "LadyBug_SetAntiAliasingEnabled",
  "body": [
   "$$ErrorCode=LadyBug_SetAntiAliasingEnabled($$Address,$$OnOff);"
  ],
  "description": "\n\nThis function requires the installation of the LadyBug sensor driver on the system.\n\nThis function enable or disable this feature.\n\nNormally, the sampling rate is 500 kHz. As the baseband signals approach the Nyquist criteria (realistically about 200 kHz in this case) problems arise. There are several approaches that can be used to resolve this problem. We use an anti-aliasing capability that really amounts to randomizing the samples. This randomization does have some affect on the rapidity of acquiring the data.\n\nAs a result, the anti-aliasing algorithm is normally turned off. However, if you are measuring signals that have baseband content greater than about 200 kHz we recommend turning on the anti-aliasing feature.\n\n\n\n\n\nResult:\n\n$ErrorCode = LadyBug_SetAntiAliasingEnabled($Address,$OnOff);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Address\n\ninteger\n\nThe address of the instrument.\n\n\n\n$OnOff\n\nboolean\n\nIf $OnOff is true, it's enabled. If $OnOff is false, it's not enabled.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\ninteger\n\nSuccess if $ErrorCode > 0. If $ErrorCode <= 0, there is a failure.\n\n\n\n\n\nExample:\n\n$ErrorCode = LadyBug_SetAntiAliasingEnabled(1,false);\n\n\n\n\n\nLadyBug_SetAutoPulseEnabled\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS LadyBug_SetAutoPulseEnabled": {
  "prefix": "LadyBug_SetAutoPulseEnabled",
  "body": [
   "$$ErrorCode=LadyBug_SetAutoPulseEnabled($$Address,$$OnOff);"
  ],
  "description": "\n\nThis function requires the installation of the LadyBug sensor driver on the system.\n\nThis function enable or disable the default or automatic pulse measurement criteria. The default value is 3 dB below the measured peak value. This means that when this feature is enabled, the pulse power will be the average of all power greater than 3 dB below peak.\n\nFor example, if the peak was measured to be -30 dBm and this feature was enabled, all samples greater than -33dBm would be included as pulse power.\n\n\n\n\n\nResult:\n\n$ErrorCode = LadyBug_SetAutoPulseEnabled($Address,$OnOff);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Address\n\ninteger\n\nThe address of the instrument.\n\n\n\n$OnOff\n\nboolean\n\nIf $OnOff is true, it's enabled. If $OnOff is false, it's not enabled.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\ninteger\n\nSuccess if $ErrorCode > 0. If $ErrorCode <= 0, there is a failure.\n\n\n\n\n\nExample:\n\n$ErrorCode = LadyBug_SetAutoPulseEnabled(1,false);\n\n\n\n\n\nLadyBug_SetCWReference\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS LadyBug_SetCWReference": {
  "prefix": "LadyBug_SetCWReference",
  "body": [
   "$$ErrorCode=LadyBug_SetCWReference($$Address,$$ReferenceLevel,$$Unit);"
  ],
  "description": "\n\nThis function requires the installation of the LadyBug sensor driver on the system.\n\nThis function setups the sensor for relative measurements during CW measurements. To make relative measurements you must set the units of measure to \u201cdB Relative\u201d.\n\n\n\n\n\nResult:\n\n$ErrorCode = LadyBug_SetCWReference($Address,$ReferenceLevel,$Unit);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Address\n\ninteger\n\nThe address of the instrument.\n\n\n\n$ReferenceLevel\n\nfloat\n\nThe reference level.\n\n\n\n$Unit\n\nstring\n\nThe measurement power unit. Valid values:\n\n\u00b7 W\n\n\u00b7 V\n\n\u00b7 DBW\n\n\u00b7 DBUV\n\n\u00b7 DBREL\n\n\u00b7 DBM\n\n\u00b7 DBKW\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\ninteger\n\nSuccess if $ErrorCode > 0. If $ErrorCode <= 0, there is a failure.\n\n\n\n\n\nExample:\n\n$ErrorCode = LadyBug_SetCWReference($Address,1.0,\"DBM\");\n\n\n\n\n\nLadyBug_SetDutyCycleEnabled\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS LadyBug_SetDutyCycleEnabled": {
  "prefix": "LadyBug_SetDutyCycleEnabled",
  "body": [
   "$$ErrorCode=LadyBug_SetDutyCycleEnabled($$Address,$$OnOff);"
  ],
  "description": "\n\nThis function requires the installation of the LadyBug sensor driver on the system.\n\nCW power sensors have traditionally \u201cadjusted\u201d their power reading based on a known duty cycle provided by the user. Since the Ladybug sensors can measure pulse power and duty cycle directly this is generally viewed as an obsolete technique. However, this feature has been included in deference to this tradition and for comparative reasons.\n\nThe calculation to adjust for duty cycle is:\n\n10Log10(Duty Cycle)\n\nSo if your duty cycle was assumed to be 10%, the calculation for equivalent average power would be:\n\n10Log10( 0.1) = -10 dB\n\nThis means the average power of a signal with a 10% duty cycle will be 10 dB below the peak value. For meters measuring average power the power reading is simply adjusted by 10 dB. This adjustment yields the peak power but it also assumes that the duty cycle is correct.\n\nThis function enables or disables the duty cycle adjustment.\n\n\n\n\n\nResult:\n\n$ErrorCode = LadyBug_SetDutyCycleEnabled($Address,$OnOff);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Address\n\ninteger\n\nThe address of the instrument.\n\n\n\n$OnOff\n\nboolean\n\nIf $OnOff is true, it's enabled. If $OnOff is false, it's not enabled.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\ninteger\n\nSuccess if $ErrorCode > 0. If $ErrorCode <= 0, there is a failure.\n\n\n\n\n\nExample:\n\n$ErrorCode = LadyBug_SetDutyCycleEnabled(1,false);\n\n\n\n\n\nLadyBug_SetDutyCyclePerCent\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS LadyBug_SetDutyCyclePerCent": {
  "prefix": "LadyBug_SetDutyCyclePerCent",
  "body": [
   "$$ErrorCode=LadyBug_SetDutyCyclePerCent($$Address,$$DutyCycle);"
  ],
  "description": "\n\nThis function requires the installation of the LadyBug sensor driver on the system.\n\nCW power sensors have traditionally \u201cadjusted\u201d their power reading based on a known duty cycle provided by the user. Since the Ladybug sensors can measure pulse power and duty cycle directly this is generally viewed as an obsolete technique. However, this feature has been included in deference to this tradition and for comparative reasons.\n\nThe calculation to adjust for duty cycle is:\n\n10Log10(Duty Cycle)\n\nSo if your duty cycle was assumed to be 10%, the calculation for equivalent average power would be:\n\n10Log10( 0.1) = -10 dB\n\nThis means the average power of a signal with a 10% duty cycle will be 10 dB below the peak value. For meters measuring average power the power reading is simply adjusted by 10 dB. This adjustment yields the peak power but it also assumes that the duty cycle is correct.\n\n\n\n\n\nResult:\n\n$ErrorCode = LadyBug_SetDutyCyclePerCent($Address,$DutyCycle);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Address\n\ninteger\n\nThe address of the instrument.\n\n\n\n$DutyCycle\n\nfloat\n\nDuty cycle per cent value.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\ninteger\n\nSuccess if $ErrorCode > 0. If $ErrorCode <= 0, there is a failure.\n\n\n\n\n\nExample:\n\n$ErrorCode = LadyBug_SetDutyCyclePerCent(1,10);\n\n\n\n\n\nLadyBug_SetFrequency\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS LadyBug_SetFrequency": {
  "prefix": "LadyBug_SetFrequency",
  "body": [
   "$$ErrorCode=LadyBug_SetFrequency($$Address,$$Frequency);"
  ],
  "description": "\n\nThis function requires the installation of the LadyBug sensor driver on the system.\n\nThis function sets the frequency of the addressed device.\n\n\n\nResult:\n\n$ErrorCode = LadyBug_SetFrequency($Address,$Frequency);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Address\n\ninteger\n\nThe address of the instrument.\n\n\n\n$Frequency\n\nfloat\n\nThe frequency in Hz.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\ninteger\n\nSuccess if $ErrorCode > 0. If $ErrorCode <= 0, there is a failure.\n\n\n\n\n\nExample:\n\n$ErrorCode = LadyBug_SetFrequency(1,1000.0);\n\n\n\n\n\nLadyBug_SetLimitEnabled\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS LadyBug_SetLimitEnabled": {
  "prefix": "LadyBug_SetLimitEnabled",
  "body": [
   "$$ErrorCode=LadyBug_SetLimitEnabled($$Address,$$LimitStyle);"
  ],
  "description": "\n\nThis function requires the installation of the LadyBug sensor driver on the system.\n\nLimits are fixed values against which a measured value is compared. Then an evaluation is expressed as pass or fail (normally). This evaluation is done during a measurement. Specifically, the evaluation is made and returned during either LadyBug_MeasureCW_PF or LadyBug_MeasurePulse_PF.\n\n\n\n\n\nResult:\n\n$ErrorCode = LadyBug_SetLimitEnabled($Address,$LimitStyle);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Address\n\ninteger\n\nThe address of the instrument.\n\n\n\n$LimitStyle\n\nstring\n\nThe limit style to apply. Valid values:\n\n\u00b7 DOUBLE_SIDED\n\n\u00b7 SINGLE_SIDED\n\n\u00b7 OFF\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\ninteger\n\nSuccess if $ErrorCode > 0. If $ErrorCode <= 0, there is a failure.\n\n\n\n\n\nExample:\n\n$ErrorCode = LadyBug_SetLimitEnabled(1,\"DOUBLE_SIDED\");\n\n\n\n\n\nLadyBug_SetMeasurementPowerUnits\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS LadyBug_SetMeasurementPowerUnits": {
  "prefix": "LadyBug_SetMeasurementPowerUnits",
  "body": [
   "$$ErrorCode=LadyBug_SetMeasurementPowerUnits($$Address,$$Unit);"
  ],
  "description": "\n\nThis function requires the installation of the LadyBug sensor driver on the system.\n\nThis function set the measurement power units.\n\nResult:\n\n$ErrorCode = LadyBug_SetMeasurementPowerUnits($Address,$Unit);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Address\n\ninteger\n\nThe address of the instrument.\n\n\n\n$Unit\n\nstring\n\nThe measurement power unit. Valid values:\n\n\u00b7 W\n\n\u00b7 V\n\n\u00b7 DBW\n\n\u00b7 DBUV\n\n\u00b7 DBREL\n\n\u00b7 DBM\n\n\u00b7 DBKW\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\ninteger\n\nSuccess if $ErrorCode > 0. If $ErrorCode <= 0, there is a failure.\n\n\n\n\n\nExample:\n\n$ErrorCode = LadyBug_SetMeasurementPowerUnits(1,\"W\");\n\n\n\n\n\nLadyBug_SetOffset\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS LadyBug_SetOffset": {
  "prefix": "LadyBug_SetOffset",
  "body": [
   "$$ErrorCode=LadyBug_SetOffset($$Address,$$Offset);"
  ],
  "description": "\n\nThis function requires the installation of the LadyBug sensor driver on the system.\n\nThis function causes a fixed offset to be added to the reading. The offset is typically used to compensate for losses or gains in the measurement path. This offset is fixed and is not a function of frequency. If you need an offset that is a function of frequency use the response function calls.\n\n\n\n\n\nResult:\n\n$ErrorCode = LadyBug_SetOffset($Address,$Offset);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Address\n\ninteger\n\nThe address of the instrument.\n\n\n\n$Offset\n\nfloat\n\nThe offset.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\ninteger\n\nSuccess if $ErrorCode > 0. If $ErrorCode <= 0, there is a failure.\n\n\n\n\n\nExample:\n\n$ErrorCode = LadyBug_SetOffset(1,2.0);\n\n\n\n\n\nLadyBug_SetOffsetEnabled\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS LadyBug_SetOffsetEnabled": {
  "prefix": "LadyBug_SetOffsetEnabled",
  "body": [
   "$$ErrorCode=LadyBug_SetOffsetEnabled($$Address,$$OnOff);"
  ],
  "description": "\n\nThis function requires the installation of the LadyBug sensor driver on the system.\n\nThis function cause a fixed offset to be added to the reading, or enable/disable the feature. The offset is typically used to compensate for losses or gains in the measurement path. This offset is fixed and is not a function of frequency.\n\n\n\n\n\nResult:\n\n$ErrorCode = LadyBug_SetOffsetEnabled($Address,$OnOff);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Address\n\ninteger\n\nThe address of the instrument.\n\n\n\n$OnOff\n\nboolean\n\nIf $OnOff is true, it's enabled. If $OnOff is false, it's not enabled.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\ninteger\n\nSuccess if $ErrorCode > 0. If $ErrorCode <= 0, there is a failure.\n\n\n\n\n\nExample:\n\n$ErrorCode = LadyBug_SetOffsetEnabled(1,false);\n\n\n\n\n\nLadyBug_SetPulseReference\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS LadyBug_SetPulseReference": {
  "prefix": "LadyBug_SetPulseReference",
  "body": [
   "$$ErrorCode=LadyBug_SetPulseReference($$Address,$$PulseRef,$$PeakRef,$$AvgRef,$$DutyRef,$$Unit);"
  ],
  "description": "\n\nThis function requires the installation of the LadyBug sensor driver on the system.\n\nThis function setups the sensor for relative measurements during CW measurements. To make relative measurements you must set the units of measure to \u201cdB Relative\u201d.\n\n\n\n\n\nResult:\n\n$ErrorCode = LadyBug_SetPulseReference($Address,$PulseRef,$PeakRef,$AvgRef,$DutyRef,$Unit);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Address\n\ninteger\n\nThe address of the instrument.\n\n\n\n$PulseRef\n\nfloat\n\nThe pulse reference level.\n\n\n\n$PeakRef\n\nfloat\n\nThe peak reference level.\n\n\n\n$AvgRef\n\nfloat\n\nThe average reference level.\n\n\n\n$DutyRef\n\nfloat\n\nThe duty cycle reference level.\n\n\n\n$Unit\n\nstring\n\nThe measurement power unit. Valid values:\n\n\u00b7 W\n\n\u00b7 V\n\n\u00b7 DBW\n\n\u00b7 DBUV\n\n\u00b7 DBREL\n\n\u00b7 DBM\n\n\u00b7 DBKW\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\ninteger\n\nSuccess if $ErrorCode > 0. If $ErrorCode <= 0, there is a failure.\n\n\n\n\n\nExample:\n\n$ErrorCode = LadyBug_SetPulseReference(1,1.0,1.0,1.0,10.0,\"W\");\n\n\n\n\n\nLadyBug_SetResponseEnabled\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS LadyBug_SetResponseEnabled": {
  "prefix": "LadyBug_SetResponseEnabled",
  "body": [
   "$$ErrorCode=LadyBug_SetResponseEnabled($$Address,$$OnOff);"
  ],
  "description": "\n\nThis function requires the installation of the LadyBug sensor driver on the system.\n\nResponse is a frequency sensitive offset, so as you change the measurement frequency the response changes accordingly. Response amplitude is always expressed in dB and the frequency is expressed in Hz. The interpolation is linear with respect to frequency and dB.\n\nThe response allows up to 201 points to be entered. The response points are frequency and amplitude pairs. Each set of function calls below are accompanied by the definition of the points. When the points are passed you must also specify the number of points.\n\nThis function enables/disables the response feature.\n\n\n\n\n\nResult:\n\n$ErrorCode = LadyBug_SetResponseEnabled($Address,$OnOff);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Address\n\ninteger\n\nThe address of the instrument.\n\n\n\n$OnOff\n\nboolean\n\nIf $OnOff is true, it's enabled. If $OnOff is false, it's not enabled.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\ninteger\n\nSuccess if $ErrorCode > 0. If $ErrorCode <= 0, there is a failure.\n\n\n\n\n\nExample:\n\n$ErrorCode = LadyBug_SetResponseEnabled(1,false);\n\n\n\n\n\nNI445X_Init\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI445X_Init": {
  "prefix": "NI445X_Init",
  "body": [
   "NI445X_Init($$deviceNumber);"
  ],
  "description": "\n\nThis is a direct mapping of the NIDAQ functions , therefore it requires NIDAQ by National Instruments to be installed.\n\nThis function opens and configures a dynamic signal analyzer.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$deviceNumber\n\nInteger\n\nThe number assigned to your device in the Measurement and Automation explorer utility by National Instruments.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nAeroFlexSigGen_AttenuatorHold\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AeroFlexSigGen_AttenuatorHold": {
  "prefix": "AeroFlexSigGen_AttenuatorHold",
  "body": [
   "AeroFlexSigGen_AttenuatorHold($$handle,$$hold);"
  ],
  "description": "\n\n\n\n\n\nThis function sets the Attenuator Hold Setting.\n\nNote: If the attenuator hold is enabled, the bulk attenuators will be held in their current state. The range of RF output level available will then be restricted. This property can only be set if the LO external trigger mode is set to \"NONE\".\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$handle\n\nObject\n\nThe handle of the instrument returned from the AeroFlexSigGen_Open function\n\n\n\n$hold\n\nBoolean\n\nSets the attenuator hold setting.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nnone\n\n\n\n\n\nExample:\n\n\n\n\n\nAeroFlexSigGen_AttenuatorHold($handle, false);\n\n\n\n\n\nAeroFlexSigGen_Close\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AeroFlexSigGen_Close": {
  "prefix": "AeroFlexSigGen_Close",
  "body": [
   "AeroFlexSigGen_Close($$handle);"
  ],
  "description": "\n\n\n\n\n\nThis method closes and frees up all resources used by the signal generator.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$handle\n\nObject\n\nThe handle of the instrument returned from the AeroFlexSigGen_Open function\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nnone\n\n\n\n\n\nExample:\n\n\n\n\n\nAeroFlexSigGen_Close($handle);\n\n\n\n\n\nAeroFlexSigGen_EnableOutput\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AeroFlexSigGen_EnableOutput": {
  "prefix": "AeroFlexSigGen_EnableOutput",
  "body": [
   "AeroFlexSigGen_EnableOutput($$handle,$$enable);"
  ],
  "description": "\n\n\n\n\n\nThis property sets the RF output enable of the active channel being used by the signal generator when in manual (i.e. non-hopping) mode.\n\nNote: Default is false\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$handle\n\nObject\n\nThe handle of the instrument returned from the AeroFlexSigGen_Open function\n\n\n\n$enable\n\nBoolean\n\nEnable or Disable the output for the signal generator.\n\n[TRUE or FALSE]\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nnone\n\n\n\n\n\nExample:\n\n\n\n\n\nAeroFlexSigGen_EnableOuput($handle, TRUE);\n\n\n\n\n\nAeroFlexSigGen_GetCurrentlyPlayingARBFile\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AeroFlexSigGen_GetCurrentlyPlayingARBFile": {
  "prefix": "AeroFlexSigGen_GetCurrentlyPlayingARBFile",
  "body": [
   "AeroFlexSigGen_GetCurrentlyPlayingARBFile($$handle);"
  ],
  "description": "\n\n\n\n\n\nThis function returns true or false depending on whether or not the signal generator is currently playing back an arbitrary wave form file created in MATLAB or the IQ Creator software package. If an ARB file is currently being played back on the Signal Generator, the name of the file is also returned.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$handle\n\nObject\n\nThe handle of the instrument returned from the AeroFlexSigGen_Open function\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$IsFilePlaying\n\nBoolean\n\nTrue/False value indicating whether or not an arbitrary waveform file is currently being played back on the system.\n\n\n\n$FileName\n\nString\n\nThe name of the file being played back on the system, the file name is an empty string if no file is currently being played back.\n\n\n\n\n\nExample:\n\n\n\n\n\n($IsFilePlaying,$FileName) = AeroFlexSigGen_GetCurrentlyPlayingARBFile($handle);\n\nUpdateStatus($IsFileIsPlaying);\n\nUpdateStatus($FileName);\n\n\n\n\n\nAeroFlexSigGen_Open\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AeroFlexSigGen_Open": {
  "prefix": "AeroFlexSigGen_Open",
  "body": [
   "$$handle=AeroFlexSigGen_Open($$sigGenResource,$$oscResource,$$oscIsPlugin);"
  ],
  "description": "\n\nThis method attempts to boot the signal generator using the parameters provided.\n\n$sigGenResource and $oscResource must be valid Visa resource strings.\n\n$oscIsPlugin must be set to true if an AF3010 is not being used for the LO, in which case the $oscResource must have been preset to a valid plugin. Note that using a plugin to drive the local oscillator will reduce the overall functionality of the signal generator.\n\nThis function initializes a session with the instrument and returns the handle to the test script.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$sigGenResource\n\nString\n\nThe resource name of the signal generator.\n\n\n\n$oscResource\n\nString\n\nThe resource name of the oscillator.\n\n\n\n$oscIsPlugin\n\nBoolean\n\nLocal Oscillator input to the signal generator is plugin [TRUE or FALSE]\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$handle\n\nObject\n\nThe handle to the instrument session.\n\n\n\n\n\nExample:\n\n\n\n\n\n$handle = AeroFlexSigGen_Open(\"PXI2::15::INSTR\", \"PXI2::14::INSTR\", FALSE);\n\n\n\n\n\nAeroFlexSigGen_PlayARBFile\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AeroFlexSigGen_PlayARBFile": {
  "prefix": "AeroFlexSigGen_PlayARBFile",
  "body": [
   "AeroFlexSigGen_PlayARBFile($$handle,$$filename);"
  ],
  "description": "\n\n\n\n\n\nThis method plays an ARB file from the instrument's catalog. If the file isn't already present in the catalog, this function adds it automatically.\n\nThis function also automatically sets the IQ source to ARB, and the VCO frequency as appropriate for the file being played.\n\nNote: The file is identified in the catalog by the name given here. If the name is specified differently it will be loaded again. It may be necessary to have one or more options enabled on the module to be able to load certain ARB files.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$handle\n\nObject\n\nThe handle of the instrument returned from the AeroFlexSigGen_Open function\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n\n\n\n\nAeroFlex_PlayARBFile($Handle,\"c:\\\\arbfiles\\\\myfile.aiq\");\n\n\n\n\n\nAeroFlexSigGen_SetChannel\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AeroFlexSigGen_SetChannel": {
  "prefix": "AeroFlexSigGen_SetChannel",
  "body": [
   "AeroFlexSigGen_SetChannel($$handle,$$ChannelNumber);"
  ],
  "description": "\n\n\n\n\n\nThis function sets the active channel being used by the signal generator when in manual (i.e. non-hopping) mode.\n\nNote: This property can only be set if the LO external trigger mode is set to \"NONE\"\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$handle\n\nObject\n\nThe handle of the instrument returned from the AeroFlexSigGen_Open function\n\n\n\n$ChannelNumber\n\nInteger\n\nSets the desired channel for the signal generator\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nnone\n\n\n\n\n\nExample:\n\n\n\n\n\nAeroFlexSigGen_SetChannel($handle, 2);\n\n\n\n\n\nAeroFlexSigGen_SetFrequency\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AeroFlexSigGen_SetFrequency": {
  "prefix": "AeroFlexSigGen_SetFrequency",
  "body": [
   "AeroFlexSigGen_SetFrequency($$handle,$$frequency);"
  ],
  "description": "\n\n\n\n\n\nThis method sets the frequency (in Hz) of the active channel being used by the signal generator when in manual mode.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$handle\n\nObject\n\nThe handle of the instrument returned from the AeroFlexSigGen_Open function\n\n\n\n$frquency\n\nFloat\n\nThe frequency value to set the signal generator to.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nnone\n\n\n\n\n\nExample:\n\n\n\n\n\nAeroFlexSigGen_SetFrequency($handle, 250.06);\n\n\n\n\n\nAeroFlexSigGen_SetLORef\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AeroFlexSigGen_SetLORef": {
  "prefix": "AeroFlexSigGen_SetLORef",
  "body": [
   "AeroFlexSigGen_SetLORef($$handle,$$LOReferenceMode);"
  ],
  "description": "\n\nThis function sets the LO external reference mode.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$handle\n\nObject\n\nThe handle of the instrument returned from the AeroFlexSigGen_Open function\n\n\n\n$LOReferenceMode\n\nString\n\nSets the desired LO reference mode:\n\n\u00b7 \"OCXO\" = Internal\n\n\u00b7 \"INTERNAL\" = Internal\n\n\u00b7 \"EXTERNALDAISY\" = External\n\n\u00b7 \"EXTERNALTERMINATED\" = External\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nnone\n\n\n\n\n\nExample:\n\n\n\n\n\nAeroFlexSigGen_SetLOReference($handle,\"INTERNAL\");\n\n\n\n\n\nAeroFlexSigGen_SetLOTriggerSource\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AeroFlexSigGen_SetLOTriggerSource": {
  "prefix": "AeroFlexSigGen_SetLOTriggerSource",
  "body": [
   "AeroFlexSigGen_SetLOTriggerSource($$handle,$$TriggerSource);"
  ],
  "description": "\n\n\n\n\n\nThis property sets the LO external trigger mode. If a plugin is being used to drive the LO, it should be noted that this setting has no effect.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$handle\n\nObject\n\nThe handle of the instrument returned from the AeroFlexSigGen_Open function\n\n\n\n$TriggerSource\n\nString\n\nAllowable values for the LO trigger source include:\n\n\u00b7 ADVANCE\n\n\u00b7 TOGGLE\n\n\u00b7 HOP\n\n\u00b7 NONE\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nnone\n\n\n\n\n\nExample:\n\n\n\n\n\nAeroFlexSigGen_SetLOTriggerSource($handle,\"NONE\");\n\n\n\n\n\nAeroFlexSigGen_SetLevel\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AeroFlexSigGen_SetLevel": {
  "prefix": "AeroFlexSigGen_SetLevel",
  "body": [
   "AeroFlexSigGen_SetLevel($$handle,$$level);"
  ],
  "description": "\n\n\n\n\n\nThis property sets the desired RF output level (in dBm) of the active channel being used by the signal generator when in manual (i.e. non-hopping) mode.\n\nNote: level range -136.0 to +5.0\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$handle\n\nObject\n\nThe handle of the instrument returned from the AeroFlexSigGen_Open function\n\n\n\n$level\n\nFloat\n\nThe level value to set the signal generator to. Range is -136.0 to + 5.0\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nnone\n\n\n\n\n\nExample:\n\n\n\n\n\nAeroFlexSigGen_SetLevel($handle, -10);\n\n\n\n\n\nAeroFlexSigGen_SetMode\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AeroFlexSigGen_SetMode": {
  "prefix": "AeroFlexSigGen_SetMode",
  "body": [
   "AeroFlexSigGen_SetMode($$handle,$$mode);"
  ],
  "description": "\n\n\n\n\n\nThis property sets the RF output levelling mode of the active channel being used by the signal generator when in manual (i.e. non-hopping) mode.\n\nFour modes are accepted:\n\nManual: A simplified interface for the control of the Signal Generator. This mode provides a limited number of functions and properties, providing all the basic Signal Generator functionality.\n\nArbSeq: A form of List Mode: The purpose of this mode is to allow the definition of a sequence of ARB files. The emphasis of this mode is placed on ARB files and the sequence in which they are played.\n\nHopping: A form of List Mode: The emphasis of this mode is the control of a frequency and or level hop/sweep and as such provides the ability to define the dwell duration for each list point independently of each other. It does not provide channelised ARB file selection or control.\n\nFull: This is the default and is provided for legacy support. It provides full access to all channelised and List Mode controls. This mode requires comprehensive knowledge and understanding of the Signal Generator to achieve the functionality provided by any of the other modes of operation.\n\nEach of Manual, ArbSeq and Hopping modes are independent of each other. Setting parameters or properties in any of these modes has no effect on any of the others. They do however impact the settings of Full mode.\n\nEqually, setting parameters in Full mode has no effect on any of the other three modes.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$handle\n\nObject\n\nThe handle of the instrument returned from the AeroFlexSigGen_Open function\n\n\n\n$mode\n\nString\n\nThe RF output leveling mode for the signal generator.\n\n[MANUAL,ARBSEQ,HOPPING,FULL]\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nnone\n\n\n\n\n\nExample:\n\n\n\n\n\nAeroFlexSigGen_SetMode($handle, \"MANUAL\");\n\n\n\n\n\nAeroFlexSigGen_SetModulationSource\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AeroFlexSigGen_SetModulationSource": {
  "prefix": "AeroFlexSigGen_SetModulationSource",
  "body": [
   "AeroFlexSigGen_SetModulationSource($$handle,$$ModulationSource);"
  ],
  "description": "\n\n\n\n\n\nThis function sets the IQ modulation source.\n\n\n\n\n\nNote: This property can only be set if the LO external trigger mode is set to \"NONE\"\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$handle\n\nObject\n\nThe handle of the instrument returned from the AeroFlexSigGen_Open function\n\n\n\n$modulationSource\n\nString\n\nThe desired modulation source:\n\n\u00b7 \"CW\" = Continuous Waveform (basically a tone)\n\n\u00b7 \"LVDS\" = Front Panel LVDS input\n\n\u00b7 \"ARB\" = An Arbitrary Sequence File\n\n\u00b7 \"AM\" = Amplitude Modulation\n\n\u00b7 \"FM\" = Frequency Modulation\n\n\u00b7 \"EXTAnalog\" = External Analog Modulation Input\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nnone\n\n\n\n\n\nExample:\n\n\n\n\n\nAeroFlexSigGen_SetModulationSource($handle, \"CW\");\n\n\n\n\n\nAeroFlexSigGen_SetVCOExternalReference\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AeroFlexSigGen_SetVCOExternalReference": {
  "prefix": "AeroFlexSigGen_SetVCOExternalReference",
  "body": [
   "AeroFlexSigGen_SetVCOExternalReference($$handle,$$ExternalReference);"
  ],
  "description": "\n\nThis function sets whether an external 10 MHZ Reference is being used for the VCO for the signal generator.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$handle\n\nObject\n\nThe handle of the instrument returned from the AeroFlexSigGen_Open function\n\n\n\n$ExternalReference\n\nBoolean\n\nSets whether or not an external 10 Mhz reference is in use:\n\n\u00b7 \"TRUE\" = External Reference\n\n\u00b7 \"FALSE\" = Internal Reference\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nnone\n\n\n\n\n\nExample:\n\n\n\n\n\nAeroFlexSigGen_SetVCOExternalReference($handle,true);\n\n\n\n\n\nAeroFlexSigGen_StopARBFile\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AeroFlexSigGen_StopARBFile": {
  "prefix": "AeroFlexSigGen_StopARBFile",
  "body": [
   "AeroFlexSigGen_StopARBFile($$handle);"
  ],
  "description": "\n\n\n\n\n\nThis function will cease playback of the currently playing ARB file. If no file is currently playing, the function will simply return without an error.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$handle\n\nObject\n\nThe handle of the instrument returned from the AeroFlexSigGen_Open function\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nnone\n\n\n\n\n\nExample:\n\n\n\n\n\nAeroFlexSigGen_StopARBFile($handle);\n\n\n\n\n\nAG33220A_Abort\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG33220A_Abort": {
  "prefix": "AG33220A_Abort",
  "body": [
   "AG33220A_Abort($$Handle);"
  ],
  "description": "\n\n\n\n\n\nThis function immediately stops all signal generation without disconnecting the output relay of the signal generator.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nThe instrument handle\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\nAG33220A_Abort($Handle);\n\n\n\n\n\nSupported Instruments\n\nAgilent AG33220A Signal Generator\n\n\n\n\n\nAG33220A_Close\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG33220A_Close": {
  "prefix": "AG33220A_Close",
  "body": [
   "AG33220A_Close($$AgInstance);"
  ],
  "description": "\n\nThis function uses the Agilent 33220 IVI in order to use the functions in JabilTest.\n\nThis function closes the Agilent 33220A and frees the resources consumed by the instrument.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AgInstance\n\nObject\n\nThe object representing the handle to the instrument.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nAG33220A_Configure\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG33220A_Configure": {
  "prefix": "AG33220A_Configure",
  "body": [
   "AG33220A_Configure($$AgInstance,$$WaveForm,$$Voltage,$$DCOffset,$$Frequency,$$Startphase);"
  ],
  "description": "\n\nThis function uses the Agilent 33220 IVI in order to use the functions in JabilTest..\n\nThis function configure the output waveform of the Agilent 33220A.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AgInstance\n\nObject\n\nThe object representing the handle to the instrument.\n\n\n\n$WaveForm\n\nString\n\nThe waveform shape to be generated by the instrument. Allowable values are:\n\n\u00b7 \"SINE\" or \"SINUSOIDAL\"\n\n\u00b7 \"SQUARE\"\n\n\u00b7 \"PULSE\"\n\n\u00b7 \"NOISE\"\n\n\u00b7 \"RAMP\"\n\n\u00b7 \"DC\"\n\n\u00b7 \"USER\"\n\n\n\n$Voltage\n\nFloat\n\nThe Amplitude of the output voltage.\n\n\n\n$DCOffset\n\nFloat\n\nThe DC offset voltage.\n\n\n\n$Frequency\n\nFloat\n\nThe output frequency.\n\n\n\n$Startphase\n\nFloat\n\nSee operations manual for details\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nAG33220A_Init\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG33220A_Init": {
  "prefix": "AG33220A_Init",
  "body": [
   "$$AgInstance=AG33220A_Init($$ResourceString,$$Reset);"
  ],
  "description": "\n\nThis function uses the Agilent 33220 IVI in order to use the functions in JabilTest.\n\nThis function initializes the Agilent 33220A for operation. This function returns a passing result if the instrument can be initialized successfully, otherwise a failure is generated by the script function.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ResourceString\n\nString\n\nThe resource string identifying the instrument. For example, \"GPIB0::9::Instr\".\n\n\n\n$Reset\n\nBoolean\n\nSpecifies whether or not to reset the instrument upon initialization.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AgInstance\n\nObject\n\nThe object representing the instance of the Agilent 33120A.\n\n\n\n\n\nAG33220A_Reset\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG33220A_Reset": {
  "prefix": "AG33220A_Reset",
  "body": [
   "AG33220A_Reset($$AgInstance);"
  ],
  "description": "\n\nThis function uses the Agilent 33220 IVI in order to use the functions in JabilTest..\n\nThis function resets the Agilent 33220A back to default settings.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AgInstance\n\nObject\n\nThe object representing the handle to the instrument.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nAG33220A_SelfTest\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG33220A_SelfTest": {
  "prefix": "AG33220A_SelfTest",
  "body": [
   "AG33220A_SelfTest($$Handle);"
  ],
  "description": "\n\n\n\n\n\nThis function prompts the instrument to run an internal self test. If the self test is successful, the function passes, otherwise the function fails returning a description of the detected hardware fault.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nThe instrument handle\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\nAG33220A_SelfTest($Handle);\n\n\n\n\n\nSupported Instruments\n\nAgilent AG33220A Signal Generator\n\n\n\n\n\nAG33220A_SetDisplayText\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG33220A_SetDisplayText": {
  "prefix": "AG33220A_SetDisplayText",
  "body": [
   "AG33220A_SetDisplayText($$Handle,$$Message);"
  ],
  "description": "\n\n\n\n\n\nThis function sets the display text on the instrument to the value set by the user.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nThe instrument handle\n\n\n\n$Message\n\nString\n\nThe message you want to display on the front panel\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\nAG33220A_SetDisplayText($Handle,\"JABIL RULES!\");\n\n\n\n\n\nSupported Instruments\n\nAgilent AG33220A Signal Generator\n\n\n\n\n\nAG33220A_SetDutyCycle\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG33220A_SetDutyCycle": {
  "prefix": "AG33220A_SetDutyCycle",
  "body": [
   "AG33220A_SetDutyCycle($$agHandle,$$dutyCycle);"
  ],
  "description": "\n\nThis function sets the duty cycle of the output waveform on the signal generator.\n\n\n\n\n\nRemarks:\n\n\u00b7 This function uses the Agilent 33220 IVI in order to use the functions in JabilTest.\n\n\u00b7 Setting the duty cycle is only valid for square wave and pulse outputs. Any other output type will generate an error.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$agHandle\n\nObject\n\nThe handle of the instrument returned from the AG33220A_Init function.\n\n\n\n$dutyCycle\n\nFloat\n\nThe duty cycle in percent (%).\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n// Set duty cycle to 35%.\n\n$dutyCycle = 35;\n\nAG33220A_SetDutyCycle($agHandle, $dutyCycle);\n\n\n\n\n\nAG33220A_SetOperationMode\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG33220A_SetOperationMode": {
  "prefix": "AG33220A_SetOperationMode",
  "body": [
   "AG33220A_SetOperationMode($$AgInstance,$$OperationMode);"
  ],
  "description": "\n\nThis function uses the Agilent 33220 IVI in order to use the functions in JabilTest..\n\nThis function configures the operation mode of the Agilent 33220A.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AgInstance\n\nObject\n\nThe object representing the handle to the instrument.\n\n\n\n$OperationMode\n\nString\n\nThe operating of the instrument. Allowable values are:\n\n\"BURST\"\n\n\"CONTINUOUS\"\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nAG33220A_SetOutputLoad\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG33220A_SetOutputLoad": {
  "prefix": "AG33220A_SetOutputLoad",
  "body": [
   "AG33220A_SetOutputLoad($$Handle,$$Impedance);"
  ],
  "description": "\n\n\n\n\n\nThis function sets the output impedance of the signal generator to the value specified by the $Impendance argument. The impedance is specified in Ohms. This function actually sets function generator to drive a load of the expected impedance specified by the $Impedance argument.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nThe instrument handle\n\n\n\n$Impedance\n\nFloat\n\nThe desired output impedance of the instrument specified in ohms.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\n$InstrumentHandle = AG33220A_SetOutputLoad($Handle,50);\n\n\n\n\n\nSupported Instruments\n\nAgilent AG33220A Signal Generator\n\n\n\n\n\nAG33220A_SetOutputLoadHighImpedance\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG33220A_SetOutputLoadHighImpedance": {
  "prefix": "AG33220A_SetOutputLoadHighImpedance",
  "body": [
   "AG33220A_SetOutputLoadHighImpedance($$Handle);"
  ],
  "description": "\n\n\n\n\n\nThis function sets the output impedance of the signal generator to a high-impedance state. This effectively sets the instrument to expect to drive a load with an infinite impedance.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nThe instrument handle\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\n$InstrumentHandle = AG33220A_SetOutputLoadHighImpedance($Handle);\n\n\n\n\n\nSupported Instruments\n\nAgilent AG33220A Signal Generator\n\n\n\n\n\nAG33220A_SetOutputState\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG33220A_SetOutputState": {
  "prefix": "AG33220A_SetOutputState",
  "body": [
   "AG33220A_SetOutputState($$AgInstance,$$State);"
  ],
  "description": "\n\nThis function uses the Agilent 33220 IVI in order to use the functions in JabilTest..\n\nThis function sets the state of the Agilent 33220A output.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AgInstance\n\nObject\n\nThe object representing the handle to the instrument.\n\n\n\n$State\n\nBoolean\n\nThe state to set the output to.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nAG33220A_SetPulse\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG33220A_SetPulse": {
  "prefix": "AG33220A_SetPulse",
  "body": [
   "AG33220A_SetPulse($$HpInstance,$$Frequency,$$Voltage,$$DCOffset,$$PulseWidth);"
  ],
  "description": "\n\nThis function uses the Agilent 33220 IVI in order to use the functions in JabilTest..\n\nThis function sets the parameters for pulse generation and enables the output.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AgInstance\n\nObject\n\nThe object representing the handle to the instrument.\n\n\n\n$Frequency\n\nFloat\n\nThe frequency at witch the pulse will be generated.\n\n\n\n$Voltage\n\nFloat\n\nThe Peak to Peak output voltage\n\n\n\n$DCOffset\n\nFloat\n\nThe DC offset voltage.\n\n\n\n$PulseWidth\n\nFloat\n\nThe pulse width of the output in seconds\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nHP33120A_Close\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS HP33120A_Close": {
  "prefix": "HP33120A_Close",
  "body": [
   "HP33120A_Close($$HpInstance);"
  ],
  "description": "\n\nThis function uses the Agilent VXI PNP 33120A driver in order to use the functions in JabilTest.\n\nThis function closes the HP33120A and frees the resources consumed by the instrument.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$HpInstance\n\nObject\n\nThe object representing the handle to the instrument.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nHP33120A_Init\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS HP33120A_Init": {
  "prefix": "HP33120A_Init",
  "body": [
   "$$HpInstance=HP33120A_Init($$ResourceString);"
  ],
  "description": "\n\nThis function uses the Agilent VXI PNP 33120A driver in order to use the functions in JabilTest.\n\nThis function initializes the HP33120A for operation. This function returns a passing result if the instrument can be initialized successfully, otherwise a failure is generated by the script function.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ResourceString\n\nString\n\nThe resource string identifying the instrument. For example, \"GPIB0::9::Instr\".\n\n\n\n$Reset\n\nBoolean\n\nSpecifies whether or not to reset the instrument upon initialization.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AgInstance\n\nObject\n\nThe object representing the instance of the HP33120A.\n\n\n\n\n\nHP33120A_SetFrequency\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS HP33120A_SetFrequency": {
  "prefix": "HP33120A_SetFrequency",
  "body": [
   "HP33120A_SetFrequency($$HpInstance,$$Frequency);"
  ],
  "description": "\n\nThis function uses the Agilent VXI PNP 33120A driver in order to use the functions in JabilTest.\n\nThis function configures the frequency of the generated output waveform. The frequency is specified in Hertz.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$HpInstance\n\nObject\n\nThe object representing the handle to the instrument.\n\n\n\n$Frequency\n\nFloat\n\nSpecifies the frequency of the generated waveform function in hertz.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nHP33120A_SetFunctionShape\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS HP33120A_SetFunctionShape": {
  "prefix": "HP33120A_SetFunctionShape",
  "body": [
   "HP33120A_SetFunctionShape($$HpInstance,$$WaveFormShape);"
  ],
  "description": "\n\nThis function uses the Agilent VXI PNP 33120A driver in order to use the functions in JabilTest.\n\nThis function specifies the waveform shape to be generated by the waveform generator.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$HpInstance\n\nObject\n\nThe object representing the handle to the instrument.\n\n\n\n$WaveFormShape\n\nString\n\nThe waveform shape to be generated by the instrument. Allowable values are:\n\n\"SINUSOIDAL\"\n\n\"SQUARE\"\n\n\"TRIANGLE\"\n\n\"RAMP\"\n\n\"NOISE\"\n\n\"DC\"\n\n\"USER\"\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nHP33120A_SetOffset\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS HP33120A_SetOffset": {
  "prefix": "HP33120A_SetOffset",
  "body": [
   "HP33120A_SetOffset($$HpInstance,$$OffsetVoltage);"
  ],
  "description": "\n\nThis function uses the Agilent VXI PNP 33120A driver in order to use the functions in JabilTest.\n\nThis function specifies the voltage offset generated by the waveform generator. The voltage unit is configured by the HP33120A_SetVoltUnit function which should be used before calling the HP33120A_SetVolt function.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$HpInstance\n\nObject\n\nThe object representing the handle to the instrument.\n\n\n\n$OffsetVoltage\n\nFloat\n\nThe scalar value representing the output offset voltage. The unit corresponding to this number is set by using the HP33120A_SetVoltUnit function which should be called prior to using the HP33120A_SetVolt function. The allowable limits are +-2.50 Volts.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nHP33120A_SetVolt\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS HP33120A_SetVolt": {
  "prefix": "HP33120A_SetVolt",
  "body": [
   "HP33120A_SetVolt($$HpInstance,$$Voltage);"
  ],
  "description": "\n\nThis function uses the Agilent VXI PNP 33120A driver in order to use the functions in JabilTest.\n\nThis function specifies the voltage output generated by the waveform generator. The voltage unit is configured by the HP33120A_SetVoltUnit function which should be used before calling the HP33120A_SetVolt function.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$HpInstance\n\nObject\n\nThe object representing the handle to the instrument.\n\n\n\n$Voltage\n\nFloat\n\nThe scalar value representing the output amplitude. The unit corresponding to this number is set by using the HP33120A_SetVoltUnit function which should be called prior to using the HP33120A_SetVolt function.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nHP33120A_SetVoltUnit\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS HP33120A_SetVoltUnit": {
  "prefix": "HP33120A_SetVoltUnit",
  "body": [
   "HP33120A_SetVoltUnit($$HpInstance,$$VoltageUnit);"
  ],
  "description": "\n\nThis function uses the Agilent VXI PNP 33120A driver in order to use the functions in JabilTest.\n\nThis function specifies the voltage unit used by the waveform generator. The actual amplitude is configured using the HP33120A_SetVoltage function.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$HpInstance\n\nObject\n\nThe object representing the handle to the instrument.\n\n\n\n$VoltageUnit\n\nString\n\nSpecifies the voltage unit to be used by the instrument to configure the output amplitude. Allowable values are:\n\n\"VPP\"\n\n\"VRMS\"\n\n\"DBM\"\n\n\"Default\"\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nHP8648X_Close\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS HP8648X_Close": {
  "prefix": "HP8648X_Close",
  "body": [
   "HP8648X_Close($$handle);"
  ],
  "description": "\n\nThis function ends communications with the signal generator.\n\n\n\n\n\nNotes:\n\n\u00b7 The Agilent IO Libraries Suite must be loaded to communicate with this instrument.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$handle\n\nObject\n\nThe session handle that was returned by the HP8648X_Init function.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n// Connect to an instrument on GPIB bus at address 7.\n\n\n\n\n\n$resource = \"GPIB0::7::INSTR\";\n\n$handle = HP8648X_Init($resource, false);\n\n\n\n\n\n//Close communication with the instrument.\n\nHP8648X_Close($handle);\n\n\n\n\n\nHP8648X_Init\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS HP8648X_Init": {
  "prefix": "HP8648X_Init",
  "body": [
   "$$handle=HP8648X_Init($$resource,$$reset);"
  ],
  "description": "\n\nThis function initiates communications with the signal generator and optionally, performs a reset of the instrument.\n\n\n\n\n\nNotes:\n\n\u00b7 The Agilent IO Libraries Suite must be loaded to communicate with this instrument.\n\n\u00b7 Resetting the instrument will clear all settings.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$resource\n\nString\n\nThe resource descriptor for communication with the instrument. In VISA format.\n\n\n\n$reset\n\nBoolean\n\nWhether to reset the instrument when connecting to it.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$handle\n\nObject\n\nA session handle that is used to identify the device in all subsequent function calls.\n\n\n\n\n\nExample:\n\n// Connect to an instrument on GPIB bus at address 7.\n\n\n\n\n\n$resource = \"GPIB0::7::INSTR\";\n\n$handle = HP8648X_Init($resource, false);\n\n\n\n\n\nHP8648X_OutputSignal\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS HP8648X_OutputSignal": {
  "prefix": "HP8648X_OutputSignal",
  "body": [
   "HP8648X_OutputSignal($$handle,$$frequency,$$amplitude,$$modulation,$$modLevel,$$modSignal,$$internalFreq,$$coupling);"
  ],
  "description": "\n\nThis function generates a signal with the supplied characteristics.\n\n\n\n\n\nNotes:\n\n\u00b7 The Agilent IO Libraries Suite must be loaded to communicate with this instrument.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$handle\n\nObject\n\nThe session handle that was returned by the HP8648X_Init function.\n\n\n\n$frequency\n\nFloat\n\nThe frequency of the generated signal in MHz.\n\n\n\n$amplitude\n\nFloat\n\nThe amplitude of the generated signal in dBm.\n\n\n\n$modulation\n\nString\n\nThe modulation type of the generated signal.\n\nValues:\n\n\u00b7 AM\n\n\u00b7 FM\n\n\u00b7 PM.\n\n\n\n$modLevel\n\nFloat\n\nThe modulation level of the generated signal.\n\n\n\n$modSignal\n\nString\n\nThe source of the modulating signal.\n\nValues:\n\n\u00b7 INTERNAL\n\n\u00b7 EXTERNAL\n\n\u00b7 INTERNALEXTERNAL\n\n\n\n$internalFreq\n\nBoolean\n\nWhether to turn on the internal frequency generator.\n\n\n\n$coupling\n\nBoolean\n\nWhether to turn on external coupling of the signal.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n// Connect to an instrument on GPIB bus at address 7.\n\n\n\n\n\n$resource = \"GPIB0::7::INSTR\";\n\n$handle = HP8648X_Init($resource, false);\n\n\n\n\n\n//Generate a signal.\n\n$freq = 23;\n\n$amp = 12;\n\n$mod = \"AM\";\n\n$modLev = 2;\n\n$modSignal = \"INTERNAL\";\n\n$intern = true;\n\n$couple = false;\n\nHP8648X_OutputSignal($handle, $freq, $amp, $mod, $modLev, $modSig, $intern, $couple);\n\n\n\n\n\nHP8648X_SelfTest\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS HP8648X_SelfTest": {
  "prefix": "HP8648X_SelfTest",
  "body": [
   "HP8648X_SelfTest($$handle);"
  ],
  "description": "\n\nThis function tells the instrument to do a self-test.\n\n\n\n\n\nNotes:\n\n\u00b7 The Agilent IO Libraries Suite must be loaded to communicate with this instrument.\n\n\u00b7 If the instrument fails the self-test, this function will fail the test.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$handle\n\nObject\n\nThe session handle that was returned by the HP8648X_Init function.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n// Connect to an instrument on GPIB bus at address 7.\n\n\n\n\n\n$resource = \"GPIB0::7::INSTR\";\n\n$handle = HP8648X_Init($resource, false);\n\n\n\n\n\n//Perform the Self Test.\n\nHP8648X_SelfTest($handle);\n\n\n\n\n\nHPESG_Close\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS HPESG_Close": {
  "prefix": "HPESG_Close",
  "body": [
   "HPESG_Close($$Handle);"
  ],
  "description": "\n\nThis function controls the Agilent ESG Series of Signal Generators. In order to use these function the VXI pnp driver for the instrument must be installed on the system running Jabil Test. The latest version of this driver can be downloaded from Agilent. This function supports the following instruments: ESG-1000B, ESG-2000B, ESG-3000B, ESG-4000B, ESG-D1000B, ESG-D2000B, ESG-D3000B, ESG-D4000B, ESG-1000A, ESG-2000A, ESG-3000A, ESG-4000A, ESG-D1000A, ESG-D2000A, ESG-D3000A, ESG-D4000A, E4423B, E4424B, E4425B, E4426B, E4434B, E4435B, E4436B, and E4437B.\n\nThis function closes the instrument, and releases the instrument handle from memory.\n\nExample:\n\nHPESG_Close($Handle);\n\n\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nThe resource handle of the Spectrum Analyzer\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nHPESG_ConfigAmplitude\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS HPESG.ConfigAmplitude": {
  "prefix": "HPESG.ConfigAmplitude",
  "body": [
   "HPESG.ConfigAmplitude($$Handle,$$AmplitudeOffset,$$AttenuatorHoldMode,$$ALCState,$$ALCBandwidthMode);"
  ],
  "description": "\n\nThis function controls the Agilent ESG Series of Signal Generators. In order to use these function the VXI pnp driver for the instrument must be installed on the system running Jabil Test. The latest version of this driver can be downloaded from Agilent. This function supports the following instruments: ESG-1000B, ESG-2000B, ESG-3000B, ESG-4000B, ESG-D1000B, ESG-D2000B, ESG-D3000B, ESG-D4000B, ESG-1000A, ESG-2000A, ESG-3000A, ESG-4000A, ESG-D1000A, ESG-D2000A, ESG-D3000A, ESG-D4000A, E4423B, E4424B, E4425B, E4426B, E4434B, E4435B, E4436B, and E4437B.\n\nThis function sets up some of the instrument's amplitude parameters.\n\nExample:\n\nHPESG_ConfigAmplitude($Handle,0.00,\"ON\",\"OFF\",\"NARROW\");\n\n\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nThe resource handle of the Spectrum Analyzer\n\n\n\n$AmplitudeOffset\n\nFloat\n\nSets the amplitude offset for the RF output power level in dB. The offset changes the value shown in the amplitude area of the display but does not affect the absolute output power. Default is 0.00dB.\n\n\n\n$AttenuatorHoldMode\n\nString\n\nSets the signal generator to attenuator--hold mode where the power drop--outs do not occur for the power adjustments. Allowable Values are:\n\n\"ON\"\n\n\"OFF\"\n\n\n\n$ALCState\n\nString\n\nSets the state of the signal generator's RF output automatic leveling circuitry (ALC). Allowable Values are:\n\n\"ON\"\n\n\"OFF\"\n\n\n\n$ALCBandwidthMode\n\nString\n\nSelects the bandwidth of the ALC loop. Defaults are Normal if I/Q modulation is off, Narrow if External I/Q modulation is on. Allowable values are:\n\n\"NORMAL\"\n\n\"NARROW\"\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nHPESG_ConfigBERTData\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS HPESG_ConfigBERTData": {
  "prefix": "HPESG_ConfigBERTData",
  "body": [
   "HPESG_ConfigBERTData($$Handle,$$BERTData,$$MaxDataRate,$$TotalBits,$$SpecialPatternIgnore,$$SpecialPattern,$$ResyncOn,$$ResyncLimits);"
  ],
  "description": "\n\nThis function controls the Agilent ESG Series of Signal Generators. In order to use these function the VXI pnp driver for the instrument must be installed on the system running Jabil Test. The latest version of this driver can be downloaded from Agilent. This function supports the following instruments: ESG-1000B, ESG-2000B, ESG-3000B, ESG-4000B, ESG-D1000B, ESG-D2000B, ESG-D3000B, ESG-D4000B, ESG-1000A, ESG-2000A, ESG-3000A, ESG-4000A, ESG-D1000A, ESG-D2000A, ESG-D3000A, ESG-D4000A, E4423B, E4424B, E4425B, E4426B, E4434B, E4435B, E4436B, and E4437B.\n\nThis method is used to set the controls and parameters (BER Data Pattern, Maximum Data Rate, Total Bits, Special Pattern Ignore State, Special Pattern Ignore Data, Resynchronization State, and Resync Limits) for bit error rate test (BERT) measurements.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nThe resource handle of the Spectrum Analyzer\n\n\n\n$BERTData\n\nString\n\nSelect the data pattern for the incoming data bit stream to make BER measurements. The choices are \"PN9\" and \"PN15\". The instrument preset value is PN9.\n\n\n\n$MaxDataRate\n\nString\n\nSelects the maximum data rate mode. The choices are 2 Mbps and 10 Mbps. When 2 Mbps is selected, all BERT functions are available for configuration. When 10 Mbps is selected, the pass/fail judgement and special pattern ignore functions are unavailable. The instrument preset value is 2 Mbps. Valid Choices are:\n\n\"PN9\"\n\n\"PN15\"\n\n\n\n$BERTTotalBits\n\nString\n\nSets the total bit count to be measured. The range is from 100 to 4,294,967,295. The instrument preset value is 10,000.This parameter has to be a string type. Care must be given to make sure that the ASCII characters used are valid decimal numerics.\n\n\n\n$BERTSpecialPatternIgnore\n\nString\n\nSelects the operating state of the special pattern ignore operation. The choices are \"ON\" or \"OFF\". The special pattern ignore operation detects more than 80 bits of 0's or 1's in the incoming bit stream and ignores these bits when making BER measurements. This selection is available only when the maximum data rate (BERTMaxDataRate) is set to 2 Mbps. The instrument preset value is off.\n\n\n\n$BERTSpecialPattern\n\nInteger\n\nSelects the bit parameter of the special pattern ignore function. The choices are all 0's or all 1's. The special pattern ignore operation detects more than 80 bits of 0's or 1's in the incoming bit stream and ignores these bits when making BER measurements. This selection is available only when the maximum data rate (BERTMaxDataRate) is set to 2 Mbps, and the special pattern ignore mode is set on (BERTSpecialPatternIgnoreOn is true). The instrument preset value is all 0's. Valid Choices are:\n\n1 = \"All 1's Pattern\"\n\n0 = \"All 0's Pattern\"\n\n\n\n$BERTResyncOn\n\nString\n\nSelect the operating state for the resynchronization operation. The choices are \"ON\" or \"OFF\". This selection is available only when the maximum data rate (BERTMaxDataRate) is set to 2 Mbps. The instrument preset value is on.\n\n\n\n$BERTResyncLimits\n\nFloat\n\nSets the threshold level for the resynchronizing operation. The range of the value is from 0.05 to 0.40. This selection is available only when the maximum data rate (BERTMaxDataRate) is set to 2 Mbps and the resynchronization operation is enabled (BERTResyncOn is true). The instrument preset value is on 0.4000.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nHPESG_ConfigBERTInput\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS HPESG.ConfigBERTInput": {
  "prefix": "HPESG.ConfigBERTInput",
  "body": [
   "HPESG.ConfigBERTInput($$Handle,$$ClockParity,$$DataPolarity,$$ClockGateOn,$$ClockGatePolarity,$$InputImpedance);"
  ],
  "description": "\n\nThis function controls the Agilent ESG Series of Signal Generators. In order to use these function the VXI pnp driver for the instrument must be installed on the system running Jabil Test. The latest version of this driver can be downloaded from Agilent. This function supports the following instruments: ESG-1000B, ESG-2000B, ESG-3000B, ESG-4000B, ESG-D1000B, ESG-D2000B, ESG-D3000B, ESG-D4000B, ESG-1000A, ESG-2000A, ESG-3000A, ESG-4000A, ESG-D1000A, ESG-D2000A, ESG-D3000A, ESG-D4000A, E4423B, E4424B, E4425B, E4426B, E4434B, E4435B, E4436B, and E4437B.\n\nThis method is used to set the controls and parameters for the input connectors used in the bit error rate tests (the rear panel BER DATA IN, BER CLK IN, and BER GATE IN ports).\n\nThese controls can be found under the Mode, BERT, Configure BERT softkeys.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nThe resource handle of the Spectrum Analyzer\n\n\n\n$ClockParity\n\nString\n\nSelects the polarity of the clock signal at the rear panel BER CLK IN port. The choices are positive and negative. The instrument preset value is positive.\n\n\"POSITIVE\"\n\n\"NEGATIVE\"\n\n\n\n$DataPolarity\n\nString\n\nSelects the polarity of the data signal at the rear panel BER DATA IN port. The choices are positive and negative. The instrument preset value is positive.\n\n\"POSITIVE\"\n\n\"NEGATIVE\n\n\n\n$ClockGateOn\n\nString\n\nSelect the operating state of the clock gate operation. Valid Choices are:\n\n\"ON\"\n\n\"OFF\n\n\n\n$ClockGatePolarity\n\nString\n\nSelects the polarity of the clock gate signal at the rear panel BER GATE IN port. This selection is available only when the BER clock gate is on (BERTClockGateOn is true). The choices are positive and negative. The instrument preset value is positive.\n\n\"POSITIVE\"\n\n\"NEGATIVE\n\n\n\n$InputImpedance\n\nString\n\nSelects the input impedance for the rear panel BER DATA IN, BER CLK IN, and BER GATE IN ports. The choices are 75 ohms and TTL. The instrument preset value is TTL. Valid Choices are:\n\n\"75OHM\"\n\n\"TTL\"\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nHPESG_ConfigBERTTrigger\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS HPESG_ConfigBERTInput": {
  "prefix": "HPESG_ConfigBERTInput",
  "body": [
   "HPESG_ConfigBERTInput($$Handle,$$TriggerSource,$$TriggerCycleCount,$$TriggerDelayOn,$$TriggerDelayBits);"
  ],
  "description": "\n\nThis function controls the Agilent ESG Series of Signal Generators. In order to use these function the VXI pnp driver for the instrument must be installed on the system running Jabil Test. The latest version of this driver can be downloaded from Agilent. This function supports the following instruments: ESG-1000B, ESG-2000B, ESG-3000B, ESG-4000B, ESG-D1000B, ESG-D2000B, ESG-D3000B, ESG-D4000B, ESG-1000A, ESG-2000A, ESG-3000A, ESG-4000A, ESG-D1000A, ESG-D2000A, ESG-D3000A, ESG-D4000A, E4423B, E4424B, E4425B, E4426B, E4434B, E4435B, E4436B, and E4437B.\n\nThis method is used to configure the BERT triggering controls and parameters (BERT Trigger, Cycle Count, Bit Delay, and Delayed Bits).\n\nThese controls can be found under the Mode, BERT, Configure Trigger softkeys.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nThe resource handle of the Spectrum Analyzer\n\n\n\n$TriggerSource\n\nString\n\nConfigures the source of triggering. Valid Values are:\n\n\"IMMEDIATE\" = Auto re--trigger a BER measurement after completion of the last BER measurement.\n\n\"KEY\" = start measurement when the user presses the Trigger hardkey\n\n\"BUS\" = Trigger a BER measurement via GPIB\n\n\"EXTERNAL\" = Trigger a BER measurement on the positive or negative edge of a signal applied to the TRIGGER IN connector.\n\n\n\n$TriggerCycleCount\n\nInteger\n\nSet the number of times that the BER measurement repeats (cycles). The range of values is from 0 to 65,535. With 0 set, the BER measurements are repeated till you set BERT mode off. The instrument preset value is 1.\n\n\n\n$TriggerDelayOn\n\nString\n\nSelect the operating state of the trigger delay. Valid Choices are:\n\n\"ON\"\n\n\"OFF\n\n\n\n$TriggerDelayBits\n\nInteger\n\nSets the number of delay bits for the BER trigger delay. The range of values is from 0 to 65,535. This selection is available only when the BER bit trigger delay is enabled. The instrument preset value is 0.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nHPESG.ConfigCustomModulation\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS HPESG_ConfigCustomModulation": {
  "prefix": "HPESG_ConfigCustomModulation",
  "body": [
   "HPESG_ConfigCustomModulation($$Handle,$$CustomModulationType,$$CustomPhaseMSK,$$CustomFreqDevFSK,$$CustomUserFile);"
  ],
  "description": "\n\nThis function controls the Agilent ESG Series of Signal Generators. In order to use these function the VXI pnp driver for the instrument must be installed on the system running Jabil Test. The latest version of this driver can be downloaded from Agilent. This function supports the following instruments: ESG-1000B, ESG-2000B, ESG-3000B, ESG-4000B, ESG-D1000B, ESG-D2000B, ESG-D3000B, ESG-D4000B, ESG-1000A, ESG-2000A, ESG-3000A, ESG-4000A, ESG-D1000A, ESG-D2000A, ESG-D3000A, ESG-D4000A, E4423B, E4424B, E4425B, E4426B, E4434B, E4435B, E4436B, and E4437B.\n\nThis function customizes the Custom Digital Modulation Formation current modulation type. See the HP-ESG programming manual for full details of each parameter, and it's function.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nThe resource handle of the Spectrum Analyzer\n\n\n\n$CustomModulationType\n\nString\n\nSets the modulation Type, allowable values are:\n\n\"QPSK\"\n\n\"IS95QPSK\"\n\n\"GRAYQPSK\"\n\n\"QPSK\"\n\n\"IS95OQPSK\"\n\n\"BPSK\"\n\n\"P4DQPSK\"\n\n\"PSK8\"\n\n\"D8PSK\"\n\n\"MSK\"\n\n\"FSK2\"\n\n\"FSK4\"\n\n\"FSK8\"\n\n\"FSK16\"\n\n\"C4FM\"\n\n\"QAM4\"\n\n\"QAM16\"\n\n\"QAM32\"\n\n\"QAM64\"\n\n\"QAM256\"\n\n\"UIQ\"\n\n\"UFSK\"\n\n\n\n$CustomPhaseMSK\n\nFloat\n\nSets the MSK phase deviation. The instrument preset is 90 degrees. The range of values is 0.0 to 100.0 degrees. This instrument parameter is only set when a MSK modulation type is selected.\n\n\n\n$CustomFreqDevFSK\n\nFloat\n\nSets the FSK phase deviation. The instrument preset is 400.0 Hz. The range of values is 0.0 to a maximum that is dependent on the symbol rate. This instrument paraeter is only set when a FSK modulation type is selected.\n\n\n\n$CustomUserFile\n\nString\n\nSelects the name of the user I/Q or FSK pre-stored configuration file for the modulation type selected.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nHPESG_ConfigCustomPattern\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS HPESG.ConfigCustomPattern": {
  "prefix": "HPESG.ConfigCustomPattern",
  "body": [
   "HPESG.ConfigCustomPattern($$Handle,$$CustomPatternRepeat,$$CustomPatternData,$$CustomFIX4Data,$$CustomPatternUserFile,$$CustomPatternTrigger,$$CustomPatternExtDelayOn,$$CustomPatternExtDelayBits);"
  ],
  "description": "\n\nThis function controls the Agilent ESG Series of Signal Generators. In order to use these function the VXI pnp driver for the instrument must be installed on the system running Jabil Test. The latest version of this driver can be downloaded from Agilent. This function supports the following instruments: ESG-1000B, ESG-2000B, ESG-3000B, ESG-4000B, ESG-D1000B, ESG-D2000B, ESG-D3000B, ESG-D4000B, ESG-1000A, ESG-2000A, ESG-3000A, ESG-4000A, ESG-D1000A, ESG-D2000A, ESG-D3000A, ESG-D4000A, E4423B, E4424B, E4425B, E4426B, E4434B, E4435B, E4436B, and E4437B.\n\nThis function is used to configure the custom digital modulation format pattern data settings. See the HP-ESG programming manual for full details about each function setting.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nThe resource handle of the Spectrum Analyzer\n\n\n\n$CustomPatternRepeat\n\nString\n\nSet to \"Single\" to output on occurence of the modulated data pattern. Set to \"CONT\" to output a continuous stream of the modulation data pattern selected.\n\n\n\n$CustomPatternData\n\nString\n\nSelect the modulation data source, either internal data generation, custom data, or external data input (I/Q data inputs). Settings are:\n\n\"PN9\" = PN9 pseudo-random bit pattern\n\n\"PN11\" = PN11 pseudo-random bit pattern\n\n\"PN15\" = PN15 pseudo-random bit pattern\n\n\"PN20\" = PN20 pseudo-random bit pattern\n\n\"PN23\" = PN23 pseudo-random bit pattern\n\n\"FIX4\" = 4-bit repeating sequence data pattern\n\n\"USERFILE\" = external data input data pattern\n\n\"EXT\" = external data input pattern\n\n\"P4\" = 4 1's & 4 0's binary data string\n\n\"P8\" = 8 1's & 8 0's binary data pattern\n\n\"P16\" = 16 1's & 16 0's binary data pattern\n\n\"P32\" = 32 1's & 32 0's binary data pattern\n\n\"P64\" = 64 1's & 64 0's binary data pattern\n\n\n\n$CustomPatternFIX4Data\n\nString\n\nSets the 4-bit repeating data pattern if \"FIX4\" is selected for the pattern data source. Valid values are hexidecimal strings from '0' to 'F'.\n\n\n\n$CustomPatternUserFile\n\nString\n\nSelects user file name to load from the instrument memory if \"USERFILE\" is selected for the pattern data source.\n\n\n\n$CustomPatternTrigger\n\nString\n\nSelects the trigger source for triggering the modulated data pattern. Allowable values are:\n\n\"KEY\" = Trigger an armed sweep when the user presses the Trigger hardkey.\n\n\"BUS\" = Trigger an armed sweep via GPIB\n\n\"EXT\" = Trigger an armed sweep on the positive or negative edge of a signal applied tot he TRIGGER IN connector.\n\n\n\n$customPatternExtDelayOn\n\nString\n\nSets the external trigger delay on or off. When external delay is turned on, the transmission of the triggered data will be delayed after the external trigger event by the number of specified by the customPatternExtDelayBits parameter in this function.\n\n\n\n$customPatternExtDelayBits\n\nInteger\n\nSets the number of bits for the external trigger delay, when the customPatternExtDelayOn parameter in this function is set to TRUE.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nHPESG_ConfigFrequency\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS HPESG_ConfigFrequency": {
  "prefix": "HPESG_ConfigFrequency",
  "body": [
   "HPESG_ConfigFrequency($$Handle,$$FrequencyMultiplier,$$FrequencyOffset,$$PhaseAdjustment,$$PhaseNoseMode);"
  ],
  "description": "\n\nThis function controls the Agilent ESG Series of Signal Generators. In order to use these function the VXI pnp driver for the instrument must be installed on the system running Jabil Test. The latest version of this driver can be downloaded from Agilent. This function supports the following instruments: ESG-1000B, ESG-2000B, ESG-3000B, ESG-4000B, ESG-D1000B, ESG-D2000B, ESG-D3000B, ESG-D4000B, ESG-1000A, ESG-2000A, ESG-3000A, ESG-4000A, ESG-D1000A, ESG-D2000A, ESG-D3000A, ESG-D4000A, E4423B, E4424B, E4425B, E4426B, E4434B, E4435B, E4436B, and E4437B.\n\nThis function sets up some the instrument's frequency parameters.\n\nExample:\n\nHPESG_ConfigFrequency($Handle,1,0,0,\"MODE1\");\n\n\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nThe resource handle of the Spectrum Analyzer\n\n\n\n$FrequencyMultiplier\n\nInteger\n\nSet the multiplier for the signal generator's carrier frequency. Multiplies the frequency shown on the display without changing the frequency output at the RF OUTPUT. The range is 1 to 50. Default is 1.\n\n\n\n$FrequencyOffset\n\nFloat\n\nSet the frequency offset. The offset changes the value shown in the in the frequency area of the display without changing the frequency output at the RF OUPUT. Default is 0 Hz.\n\n\n\n$PhaseAdjustment\n\nFloat\n\nAdjust the phase of the modulating signal in radians. The range for phase adjustments is plus or minus 3.141 radians. Default is 0.000.\n\n\n\n$PhaseNoiseMode\n\nString\n\nSelect the phase lock loop (PLL) bandwidth for optimizing phase Allowable values are:\n\n\"MODE1\" = Optimize for < 10kHz offset\n\n\"MODE2\" = Optimize for > 10kHz offset\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nHPESG_ConfigGSMFrame\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS HPESG.ConfigGSMFrame": {
  "prefix": "HPESG.ConfigGSMFrame",
  "body": [
   "HPESG.ConfigGSMFrame($$Handle,$$FrameRepeat,$$FrameTrigger,$$FrameExtDelayOn,$$FrameExtDelayBits,$$SecondaryFrameOn,$$SecondaryFrameTrigger);"
  ],
  "description": "\n\nThis function controls the Agilent ESG Series of Signal Generators. In order to use these function the VXI pnp driver for the instrument must be installed on the system running Jabil Test. The latest version of this driver can be downloaded from Agilent. This function supports the following instruments: ESG-1000B, ESG-2000B, ESG-3000B, ESG-4000B, ESG-D1000B, ESG-D2000B, ESG-D3000B, ESG-D4000B, ESG-1000A, ESG-2000A, ESG-3000A, ESG-4000A, ESG-D1000A, ESG-D2000A, ESG-D3000A, ESG-D4000A, E4423B, E4424B, E4425B, E4426B, E4434B, E4435B, E4436B, and E4437B.\n\nThis method is used to configure GSM Digital Modulation Format framed data format.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nThe resource handle of the Spectrum Analyzer\n\n\n\n$FrameRepeat\n\nString\n\nSet to \"Single\" to output on occurence of the modulated data pattern. Set to \"CONT\" to output a continuous stream of the modulation data pattern selected.\n\n\n\n$FrameTrigger\n\nString\n\nSelect the trigger source for triggering the primary frame data pattern. This instrument parameter is only set when the Frame Repeat mode is Single.\n\nValid Choices are:\n\n\"KEY\"\n\n\"EXTERNAL\"\n\n\"BUS\"\n\n\n\n$FrameExtDelayOn\n\nString\n\nSets the external trigger delay on or off. When external delay is turned on, the transmission of the triggered data will be delayed after the external trigger event by the number of bits specified by the GSMFrameExtDelayBits parameter in this function. This instrument parameter is only set when the Frame Trigger mode is External. Valid Choices are:\n\n\"ON\"\n\n\"OFF\"\n\n\n\n$FrameExtDelayBits\n\nInteger\n\nSets the number of bits for the external trigger delay, when the $FrameExtDelayOn parameter in this function is set to \"ON\".\n\n\n\n$SecondaryFrameOn\n\nString\n\nSets the secondary frame operating state (On or Off). The secondary frame is a data pattern that coexists with the primary. The secondary frame is a copy of the selected primary pattern. It cannot be modified; it can only be turned on or off. This file is named using the format (GSM) as the prefix and SECONDARY_STATE as the suffix. When the secondary frame is activated, the secondary pattern is generated from the specification saved in the instrument state file and moved to the end of the data generator memory. For more information, refer to the instrument's user manual for this format (GSM).\n\n\n\n$SecondaryFrameTrigger\n\nString\n\nSelect the trigger source for triggering the secondary frame data pattern. This instrument parameter is only set when the Frame Repeat mode is Single.\n\nValid Choices are:\n\n\"KEY\"\n\n\"EXTERNAL\"\n\n\"BUS\"\n\n.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nHPESG_ConfigGSMFreqChannel\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS TRUE)orbytheinstrumentfrontpanelFrequencyhardkey(GSMFreqChannelOn=FALSE)andhpESG_SetFrequencyCWfunction.AllowedValues:\"ON\"\"OFF\"$GSMChannelIntegerSelectthefrequencychannelbasedonthefrequencychannelsdefinedintheGSMstandardfortheselectedband.Theinstrumentwillthrowanerrorifthechannelnumberisincompatiblewiththeselectedband.$GSMChannelBandStringSelectthefrequencybandbasedontheGSMstandard,andwhetherthechannelselectedisthebasestationormobilestationchannel.Selectionsare:\"BPGSM\"=P--GSM900Base;channels1--124\"MPGSM\"=P--GSM900Mobile;channels1--124\"BEGSM\"=E--GSM900Base;channels0--124,975--1023\"MEGSM\"=E--GSM900Mobile;channels0--124,975--1023\"BRGSM\"=R--GSM900Base;channels0--124,955--1023\"MRGSM\"=R--GSM900Mobile;channels0--124,955--1023\"BDCS\"=DCS1800Base;channels512--885\"MDCS\"=DCS1800Mobile;channels512--885\"BPCS\"=PCS1900Base;channels512--810\"MPCS\"=PCS1900Mobile;channels512--810ReturnParametersParameterVariableTypeDescriptionNoneHPESG_ConfigGSMModulationPreviousTopNext***HPESG_ConfigGSMModulationUsage:HPESG_ConfigGSMModulation": {
  "prefix": "TRUE)orbytheinstrumentfrontpanelFrequencyhardkey(GSMFreqChannelOn=FALSE)andhpESG_SetFrequencyCWfunction.AllowedValues:\"ON\"\"OFF\"$GSMChannelIntegerSelectthefrequencychannelbasedonthefrequencychannelsdefinedintheGSMstandardfortheselectedband.Theinstrumentwillthrowanerrorifthechannelnumberisincompatiblewiththeselectedband.$GSMChannelBandStringSelectthefrequencybandbasedontheGSMstandard,andwhetherthechannelselectedisthebasestationormobilestationchannel.Selectionsare:\"BPGSM\"=P--GSM900Base;channels1--124\"MPGSM\"=P--GSM900Mobile;channels1--124\"BEGSM\"=E--GSM900Base;channels0--124,975--1023\"MEGSM\"=E--GSM900Mobile;channels0--124,975--1023\"BRGSM\"=R--GSM900Base;channels0--124,955--1023\"MRGSM\"=R--GSM900Mobile;channels0--124,955--1023\"BDCS\"=DCS1800Base;channels512--885\"MDCS\"=DCS1800Mobile;channels512--885\"BPCS\"=PCS1900Base;channels512--810\"MPCS\"=PCS1900Mobile;channels512--810ReturnParametersParameterVariableTypeDescriptionNoneHPESG_ConfigGSMModulationPreviousTopNext***HPESG_ConfigGSMModulationUsage:HPESG_ConfigGSMModulation",
  "body": [
   "HPESG_ConfigGSMFreqChannel($$Handle,$$GSMChannelOn,$$GSMChannel,$$GSMChannelBand);ThisfunctioncontrolstheAgilentESGSeriesofSignalGenerators.InordertousethesefunctiontheVXIpnpdriverfortheinstrumentmustbeinstalledonthesystemrunningJabilTest.ThelatestversionofthisdrivercanbedownloadedfromAgilent.Thisfunctionsupportsthefollowinginstruments:ESG-1000B,ESG-2000B,ESG-3000B,ESG-4000B,ESG-D1000B,ESG-D2000B,ESG-D3000B,ESG-D4000B,ESG-1000A,ESG-2000A,ESG-3000A,ESG-4000A,ESG-D1000A,ESG-D2000A,ESG-D3000A,ESG-D4000A,E4423B,E4424B,E4425B,E4426B,E4434B,E4435B,E4436B,andE4437B.ThismethodisusedtoconfigureGSMDigitalModulationFormatfrequencychannelsparameters.Thisfunctionmaycausetheinstrumenttothrowanerror(--222,\"Dataoutofrange;valueclippedtolowerlimit.\")whenchangingbandsduetoatemporarystatewherethecurrentchannelisincompatiblewiththenewbandselected.FunctionArgumentsParameterVariableTypeDescription$$HandleObjectTheresourcehandleoftheSpectrumAnalyzer$$GSMChannelOnStringSelectswhethertheinstrument'sRFoutputwillbedeterminedbythefrequencychannelandfrequencybandparametersselectedbythisfunction(GSMFreqChannelOn=TRUE)orbytheinstrumentfrontpanelFrequencyhardkey(GSMFreqChannelOn=FALSE)andhpESG_SetFrequencyCWfunction.AllowedValues:\"ON\"\"OFF\"$$GSMChannelIntegerSelectthefrequencychannelbasedonthefrequencychannelsdefinedintheGSMstandardfortheselectedband.Theinstrumentwillthrowanerrorifthechannelnumberisincompatiblewiththeselectedband.$$GSMChannelBandStringSelectthefrequencybandbasedontheGSMstandard,andwhetherthechannelselectedisthebasestationormobilestationchannel.Selectionsare:\"BPGSM\"=P--GSM900Base;channels1--124\"MPGSM\"=P--GSM900Mobile;channels1--124\"BEGSM\"=E--GSM900Base;channels0--124,975--1023\"MEGSM\"=E--GSM900Mobile;channels0--124,975--1023\"BRGSM\"=R--GSM900Base;channels0--124,955--1023\"MRGSM\"=R--GSM900Mobile;channels0--124,955--1023\"BDCS\"=DCS1800Base;channels512--885\"MDCS\"=DCS1800Mobile;channels512--885\"BPCS\"=PCS1900Base;channels512--810\"MPCS\"=PCS1900Mobile;channels512--810ReturnParametersParameterVariableTypeDescriptionNoneHPESG_ConfigGSMModulationPreviousTopNext***HPESG_ConfigGSMModulationUsage:HPESG_ConfigGSMModulation($$Handle,$$GSMModulationType,$$GSMPhaseMSK,$$GSMFreqDevFSK,$$GSMUserFile)"
  ],
  "description": "\n\nThis function controls the Agilent ESG Series of Signal Generators. In order to use these function the VXI pnp driver for the instrument must be installed on the system running Jabil Test. The latest version of this driver can be downloaded from Agilent. This function supports the following instruments: ESG-1000B, ESG-2000B, ESG-3000B, ESG-4000B, ESG-D1000B, ESG-D2000B, ESG-D3000B, ESG-D4000B, ESG-1000A, ESG-2000A, ESG-3000A, ESG-4000A, ESG-D1000A, ESG-D2000A, ESG-D3000A, ESG-D4000A, E4423B, E4424B, E4425B, E4426B, E4434B, E4435B, E4436B, and E4437B.\n\nThis function customizes the GSM Digital Modulation Formation current modulation type. See the HP-ESG programming manual for full details of each parameter, and it's function.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nThe resource handle of the Spectrum Analyzer\n\n\n\n$GSMModulationType\n\nString\n\nSets the modulation Type, allowable values are:\n\n\"QPSK\"\n\n\"IS95QPSK\"\n\n\"GRAYQPSK\"\n\n\"QPSK\"\n\n\"IS95OQPSK\"\n\n\"BPSK\"\n\n\"P4DQPSK\"\n\n\"PSK8\"\n\n\"D8PSK\"\n\n\"MSK\"\n\n\"FSK2\"\n\n\"FSK4\"\n\n\"FSK8\"\n\n\"FSK16\"\n\n\"C4FM\"\n\n\"QAM4\"\n\n\"QAM16\"\n\n\"QAM32\"\n\n\"QAM64\"\n\n\"QAM256\"\n\n\"UIQ\"\n\n\"UFSK\"\n\n\n\n$GSMPhaseMSK\n\nFloat\n\nSets the MSK phase deviation. The instrument preset is 90 degrees. The range of values is 0.0 to 100.0 degrees. This instrument parameter is only set when a MSK modulation type is selected.\n\n\n\n$GSMFreqDevFSK\n\nFloat\n\nSets the FSK phase deviation. The instrument preset is 400.0 Hz. The range of values is 0.0 to a maximum that is dependent on the symbol rate. This instrument paraeter is only set when a FSK modulation type is selected.\n\n\n\n$GSMUserFile\n\nString\n\nSelects the name of the user I/Q or FSK pre-stored configuration file for the modulation type selected.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nHPESG_ConfigGSMNormalTimeslot\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS HPESG_ConfigGSMNormalTimeslot": {
  "prefix": "HPESG_ConfigGSMNormalTimeslot",
  "body": [
   "HPESG_ConfigGSMNormalTimeslot($$Handle,$$TimeslotNormalNumber,$$GSMTimeslotNormalOn,$$GSMTimeslotNormalType,$$GSMTimeslotNormalData,$$GSMTSNormalFIX4Data,$$GSMTimeslotNormalUserFile,$$GSMTimeslotNormalS,$$GSMTimeslotNormalTS);"
  ],
  "description": "\n\nThis function controls the Agilent ESG Series of Signal Generators. In order to use these function the VXI pnp driver for the instrument must be installed on the system running Jabil Test. The latest version of this driver can be downloaded from Agilent. This function supports the following instruments: ESG-1000B, ESG-2000B, ESG-3000B, ESG-4000B, ESG-D1000B, ESG-D2000B, ESG-D3000B, ESG-D4000B, ESG-1000A, ESG-2000A, ESG-3000A, ESG-4000A, ESG-D1000A, ESG-D2000A, ESG-D3000A, ESG-D4000A, E4423B, E4424B, E4425B, E4426B, E4434B, E4435B, E4436B, and E4437B.\n\nThis method configures a normal timeslot type for the specified timeslot when the GSM Digital Modulation Format is set to Framed.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nThe resource handle of the Spectrum Analyzer\n\n\n\n$GSMTimeslotNormalNumber\n\nInteger\n\nSelects the timeslot to configure (0-7)\n\n\n\n$GSMTimeslotNormalOn\n\nString\n\nSets the operating state of the specified timeslot. Valid choices are:\n\n\"ON\"\n\n\"OFF\"\n\n\n\n$GSMTimeslotNormalType\n\nString\n\nSets the timeslot type for the specified timeslot. Valid choices are:\n\n\"NORMAL\"\n\n\"NORMAL_ALL\"\n\n\n\n$GSMTimeslotNormalData\n\nString\n\nSelects the data pattern for the specified timeslot for ramed data transmissions. Choices are:\n\n\"PN9\"\n\n\"PN15\"\n\n\"FIX4\"\n\n\"USERFILE\"\n\n\"EXT\"\n\n\"P4\"\n\n\"P8\"\n\n\"P16\"\n\n\"P32\"\n\n\"P64\"\n\n\n\n$GSMTSNormalFIX4Data\n\nString\n\nSets the 4-bit repeating data pattern if FIX4 is slected for the pattern data source. Valid choices are '0'-'F'.\n\n\n\n$GSMTimeslotNormalUserFile\n\nString\n\nSelects the user file name to load from the instrument memory if User File is selected for the pattern data source.\n\n\n\n$GSMTimeslotNormalS\n\nInteger\n\nSets the 1-bit binary stealing (S) flag for both the stealing flag fields in the normal burst timeslot. The instrument preset value is \"0\" for normal timeslot types.\n\n\n\n$GSMTimeslotNormalTS\n\nString\n\nSets the 26-bit training sequence. The instrument preset value represents the GSM standard and is \"0970897\" for normal timeslot types. The parameter has to be a string type, therefore care must be given to make sure that the ASCII characters used are valid hexadecimal alphanumerics. A \"#H\" must precede the alphanumeric number.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nHPESG_ConfigGSMPattern\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS HPESG_ConfigGSMPattern": {
  "prefix": "HPESG_ConfigGSMPattern",
  "body": [
   "HPESG_ConfigGSMPattern($$Handle,$$GSMPatternRepeat,$$GSMPatternData,$$GSMFIX4Data,$$GSMPatternUserFile,$$GSMPatternTrigger,$$GSMPatternExtDelayOn,$$GSMPatternExtDelayBits);"
  ],
  "description": "\n\nThis function controls the Agilent ESG Series of Signal Generators. In order to use these function the VXI pnp driver for the instrument must be installed on the system running Jabil Test. The latest version of this driver can be downloaded from Agilent. This function supports the following instruments: ESG-1000B, ESG-2000B, ESG-3000B, ESG-4000B, ESG-D1000B, ESG-D2000B, ESG-D3000B, ESG-D4000B, ESG-1000A, ESG-2000A, ESG-3000A, ESG-4000A, ESG-D1000A, ESG-D2000A, ESG-D3000A, ESG-D4000A, E4423B, E4424B, E4425B, E4426B, E4434B, E4435B, E4436B, and E4437B.\n\nThis function is used to configure the GSM digital modulation format pattern data settings. See the HP-ESG programming manual for full details about each function setting.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nThe resource handle of the Spectrum Analyzer\n\n\n\n$GSMPatternRepeat\n\nString\n\nSet to \"Single\" to output on occurence of the modulated data pattern. Set to \"CONT\" to output a continuous stream of the modulation data pattern selected.\n\n\n\n$GSMPatternData\n\nString\n\nSelect the modulation data source, either internal data generation, GSM data, or external data input (I/Q data inputs). Settings are:\n\n\"PN9\" = PN9 pseudo-random bit pattern\n\n\"PN11\" = PN11 pseudo-random bit pattern\n\n\"PN15\" = PN15 pseudo-random bit pattern\n\n\"PN20\" = PN20 pseudo-random bit pattern\n\n\"PN23\" = PN23 pseudo-random bit pattern\n\n\"FIX4\" = 4-bit repeating sequence data pattern\n\n\"USERFILE\" = external data input data pattern\n\n\"EXT\" = external data input pattern\n\n\"P4\" = 4 1's & 4 0's binary data string\n\n\"P8\" = 8 1's & 8 0's binary data pattern\n\n\"P16\" = 16 1's & 16 0's binary data pattern\n\n\"P32\" = 32 1's & 32 0's binary data pattern\n\n\"P64\" = 64 1's & 64 0's binary data pattern\n\n\n\n$GSMPatternFIX4Data\n\nString\n\nSets the 4-bit repeating data pattern if \"FIX4\" is selected for the pattern data source. Valid values are hexidecimal strings from '0' to 'F'.\n\n\n\n$GSMPatternUserFile\n\nString\n\nSelects user file name to load from the instrument memory if \"USERFILE\" is selected for the pattern data source.\n\n\n\n$GSMPatternTrigger\n\nString\n\nSelects the trigger source for triggering the modulated data pattern. Allowable values are:\n\n\"KEY\" = Trigger an armed sweep when the user presses the Trigger hardkey.\n\n\"BUS\" = Trigger an armed sweep via GPIB\n\n\"EXT\" = Trigger an armed sweep on the positive or negative edge of a signal applied tot he TRIGGER IN connector.\n\n\n\n$GSMPatternExtDelayOn\n\nString\n\nSets the external trigger delay on or off. When external delay is turned on, the transmission of the triggered data will be delayed after the external trigger event by the number of specified by the GSMPatternExtDelayBits parameter in this function.\n\n\n\n$GSMPatternExtDelayBits\n\nInteger\n\nSets the number of bits for the external trigger delay, when the GSMPatternExtDelayOn parameter in this function is set to TRUE.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nHPESG_ConfigModulationIQ\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS InternalModulationSource.RequiresOptionUN3orUN4\"EXTERNAL\"=ExternalI/QmodulationSource$BurstEnvelopeModeOnStringSetstheBurstEnvelopeModeto\"ON\"or\"OFF\"$BurstEnvelopeSourceStringSetstheBurstEnvelopeSourceto:\"INTERNAL\"=internally-generatedburstsource\"EXTERNAL\"=externally-generatedburstsource$IQHighCrestModeOnStringSelectforoperatingconditionstoaccomodateI/Qinputswithhighcrestfactor.Whenselectedthemaximumoutputlevelisreducedandthepowerlevelaccuracyisdegraded.I/Qdrivelevelsshouldbereduced,dBperdB,forcrestfactorscreatedthan4dB.\"ON\"enablesI/Qhighcrestfactoroperation,and\"OFF\"disablesI/Qhighcrestfactoroperation.Allowablevaluesare:\"ON\"\"OFF\"$IQAdjustmentsOnStringEnablesI/Qadjustments(I/Qgain,Ioffset,Qoffset,I/Qskey).Allowablevaluesare:\"ON\"\"OFF\"$IQPhasePolarityStringSetsthepolarityoftheI/Qmodulationsignal.Thechoicesarenormalorinverted.IntheinvertedmodetheinputappliedtotheIinputconnecotrisphysicallyroutedtotheQinputportoftheI/Qmodulator.Inaddition,theinputappliedtotheQINPUTconnectorisphysicallyroutedtotheIinputportoftheI/Qmodulator.Iftheuserhasenabledadigitalmodulationmode(instrumentoptionUN3orUN4only),I/Qphasepolaritywillbeautomaticallysettonormal.Itisover-writtenwiththisfunction.Allowablevalues:\"NORMAL\"\"INVERTED\"ReturnParametersParameterVariableTypeDescriptionNoneHPESG_CustomModifyStandardPreviousTopNext***HPESG_CustomModifyStandardUsage:HPESG_CustomModifyStandard($Handle,$CustomPhasePolarity,$CustomDiffDataEncodeOn,$customSymbolRate,$customBurstRiseTime,$customBurstFallTime,$customBurstFallDelay);ThisfunctioncontrolstheAgilentESGSeriesofSignalGenerators.InordertousethesefunctiontheVXIpnpdriverfortheinstrumentmustbeinstalledonthesystemrunningJabilTest.ThelatestversionofthisdrivercanbedownloadedfromAgilent.Thisfunctionsupportsthefollowinginstruments:ESG-1000B,ESG-2000B,ESG-3000B,ESG-4000B,ESG-D1000B,ESG-D2000B,ESG-D3000B,ESG-D4000B,ESG-1000A,ESG-2000A,ESG-3000A,ESG-4000A,ESG-D1000A,ESG-D2000A,ESG-D3000A,ESG-D4000A,E4423B,E4424B,E4425B,E4426B,E4434B,E4435B,E4436B,andE4437B.ThismethodisusedtoconfigureCustomDigitalModulationFormatstandardparameters,modifyingthefollowingaspectsofthestandardtransmission:phasepolarity,user--definedDifferentialEncoderstate,symbolrate,andburstedRFsignalshape.FunctionArgumentsParameterVariableTypeDescription$HandleObjectTheresourcehandleoftheSpectrumAnalyzer$CustomPhasePolarityStringSetthedirectionofrotationofthephasemodulationvector.SelectNormalandthein--phasecomponentwillleadthequadrature--phasecomponentby90degreesintheresultingmodulation.SelectInvertandthein--phasecomponentwilllagthequadrature--phasecomponentby90degreesintheresultingmodulation.TheselectionalsoappliestotheIOUTandQOUTsignals.AllowedValues:\"NORMAL\"\"INVERTED\"$CustomDiffDataEncodeOnStringSetstheoperatingstateoftheuser-definedDifferentialEncoding.AllowedValuesare:\"ON\"\"OFF\"$CustomSymbolRateFloatSetthetransmissionsymbolrate.Theinstrumentpresetvalueis24.300ksps.Thevaluesrangefrom47.684spsthrough12.500000000Mspsbutwillvarydependingonthemodulationtype.$CustomBurstRiseTimeFloatSettheburstedRFsignalrisingedgetime.Theinstrumentpresetvalueis5.860bits.Theminimumandmaximumrangeofvaluesalloweddependsuponthemodulationtypeandthesymbolrate.$CustomBurstRiseDelayFloatSettheburstedRFsignalrisingedgedelay.Theinstrumentpresetvalueis0.000bits.Theminimumandmaximumrangeofvaluesalloweddependsuponthemodulationtypeandthesymbolrate.$CustomBurstFallTimeFloatSettheburstedRFsignalfallingedgetime.Theinstrumentpresetvalueis5.470bits.Theminimumandmaximumrangeofvaluesalloweddependsuponthemodulationtypeandthesymbolrate.$CustomBurstFallDelayFloatSettheburstedRFsignalfallingedgedelay.Theinstrumentpresetvalueis0.000bits.Theminimumandmaximumrangeofvaluesalloweddependsuponthemodulationtypeandthesymbolrate.ReturnParametersParameterVariableTypeDescriptionNoneHPESG_GSMModifyStandardPreviousTopNext***HPESG_GSMModifyStandardUsage:HPESG_GSMModifyStandard($Handle,$GSMPhasePolarity,$GSMDiffDataEncodeOn,$GSMSymbolRate,$GSMBurstRiseTime,$GSMBurstFallTime,$GSMBurstFallDelay);ThisfunctioncontrolstheAgilentESGSeriesofSignalGenerators.InordertousethesefunctiontheVXIpnpdriverfortheinstrumentmustbeinstalledonthesystemrunningJabilTest.ThelatestversionofthisdrivercanbedownloadedfromAgilent.Thisfunctionsupportsthefollowinginstruments:ESG-1000B,ESG-2000B,ESG-3000B,ESG-4000B,ESG-D1000B,ESG-D2000B,ESG-D3000B,ESG-D4000B,ESG-1000A,ESG-2000A,ESG-3000A,ESG-4000A,ESG-D1000A,ESG-D2000A,ESG-D3000A,ESG-D4000A,E4423B,E4424B,E4425B,E4426B,E4434B,E4435B,E4436B,andE4437B.ThismethodisusedtoconfigureGSMDigitalModulationFormatstandardparameters,modifyingthefollowingaspectsofthestandardtransmission:phasepolarity,user--definedDifferentialEncoderstate,symbolrate,andburstedRFsignalshape.FunctionArgumentsParameterVariableTypeDescription$HandleObjectTheresourcehandleoftheSpectrumAnalyzer$GSMPhasePolarityStringSetthedirectionofrotationofthephasemodulationvector.SelectNormalandthein--phasecomponentwillleadthequadrature--phasecomponentby90degreesintheresultingmodulation.SelectInvertandthein--phasecomponentwilllagthequadrature--phasecomponentby90degreesintheresultingmodulation.TheselectionalsoappliestotheIOUTandQOUTsignals.AllowedValues:\"NORMAL\"\"INVERTED\"$GSMDiffDataEncodeOnStringSetstheoperatingstateoftheuser-definedDifferentialEncoding.AllowedValuesare:\"ON\"\"OFF\"$GSMSymbolRateFloatSetthetransmissionsymbolrate.Theinstrumentpresetvalueis270.833333ksps.Thevaluesrangefrom47.684spsthrough12.500000000Mspsbutwillvarydependingonthemodulationtype.$GSMBurstRiseTimeFloatSettheburstedRFsignalrisingedgetime.Theinstrumentpresetvalueis4.224bits.Theminimumandmaximumrangeofvaluesalloweddependsuponthemodulationtypeandthesymbolrate.$GSMBurstRiseDelayFloatSettheburstedRFsignalrisingedgedelay.Theinstrumentpresetvalueis0.000bits.Theminimumandmaximumrangeofvaluesalloweddependsuponthemodulationtypeandthesymbolrate.$GSMBurstFallTimeFloatSettheburstedRFsignalfallingedgetime.Theinstrumentpresetvalueis3.440bits.Theminimumandmaximumrangeofvaluesalloweddependsuponthemodulationtypeandthesymbolrate.$GSMBurstFallDelayFloatSettheburstedRFsignalfallingedgedelay.Theinstrumentpresetvalueis0.125bits.Theminimumandmaximumrangeofvaluesalloweddependsuponthemodulationtypeandthesymbolrate.ReturnParametersParameterVariableTypeDescriptionNoneHPESA_GetBERTMeasurementsPreviousTopNext***HPESG_GetBERTMeasurementsUsage:($ErrorCount,$BitCount,$BitErrorRate,$PassFail)=HPESG_GetBERTMeasurements": {
  "prefix": "InternalModulationSource.RequiresOptionUN3orUN4\"EXTERNAL\"=ExternalI/QmodulationSource$BurstEnvelopeModeOnStringSetstheBurstEnvelopeModeto\"ON\"or\"OFF\"$BurstEnvelopeSourceStringSetstheBurstEnvelopeSourceto:\"INTERNAL\"=internally-generatedburstsource\"EXTERNAL\"=externally-generatedburstsource$IQHighCrestModeOnStringSelectforoperatingconditionstoaccomodateI/Qinputswithhighcrestfactor.Whenselectedthemaximumoutputlevelisreducedandthepowerlevelaccuracyisdegraded.I/Qdrivelevelsshouldbereduced,dBperdB,forcrestfactorscreatedthan4dB.\"ON\"enablesI/Qhighcrestfactoroperation,and\"OFF\"disablesI/Qhighcrestfactoroperation.Allowablevaluesare:\"ON\"\"OFF\"$IQAdjustmentsOnStringEnablesI/Qadjustments(I/Qgain,Ioffset,Qoffset,I/Qskey).Allowablevaluesare:\"ON\"\"OFF\"$IQPhasePolarityStringSetsthepolarityoftheI/Qmodulationsignal.Thechoicesarenormalorinverted.IntheinvertedmodetheinputappliedtotheIinputconnecotrisphysicallyroutedtotheQinputportoftheI/Qmodulator.Inaddition,theinputappliedtotheQINPUTconnectorisphysicallyroutedtotheIinputportoftheI/Qmodulator.Iftheuserhasenabledadigitalmodulationmode(instrumentoptionUN3orUN4only),I/Qphasepolaritywillbeautomaticallysettonormal.Itisover-writtenwiththisfunction.Allowablevalues:\"NORMAL\"\"INVERTED\"ReturnParametersParameterVariableTypeDescriptionNoneHPESG_CustomModifyStandardPreviousTopNext***HPESG_CustomModifyStandardUsage:HPESG_CustomModifyStandard($Handle,$CustomPhasePolarity,$CustomDiffDataEncodeOn,$customSymbolRate,$customBurstRiseTime,$customBurstFallTime,$customBurstFallDelay);ThisfunctioncontrolstheAgilentESGSeriesofSignalGenerators.InordertousethesefunctiontheVXIpnpdriverfortheinstrumentmustbeinstalledonthesystemrunningJabilTest.ThelatestversionofthisdrivercanbedownloadedfromAgilent.Thisfunctionsupportsthefollowinginstruments:ESG-1000B,ESG-2000B,ESG-3000B,ESG-4000B,ESG-D1000B,ESG-D2000B,ESG-D3000B,ESG-D4000B,ESG-1000A,ESG-2000A,ESG-3000A,ESG-4000A,ESG-D1000A,ESG-D2000A,ESG-D3000A,ESG-D4000A,E4423B,E4424B,E4425B,E4426B,E4434B,E4435B,E4436B,andE4437B.ThismethodisusedtoconfigureCustomDigitalModulationFormatstandardparameters,modifyingthefollowingaspectsofthestandardtransmission:phasepolarity,user--definedDifferentialEncoderstate,symbolrate,andburstedRFsignalshape.FunctionArgumentsParameterVariableTypeDescription$HandleObjectTheresourcehandleoftheSpectrumAnalyzer$CustomPhasePolarityStringSetthedirectionofrotationofthephasemodulationvector.SelectNormalandthein--phasecomponentwillleadthequadrature--phasecomponentby90degreesintheresultingmodulation.SelectInvertandthein--phasecomponentwilllagthequadrature--phasecomponentby90degreesintheresultingmodulation.TheselectionalsoappliestotheIOUTandQOUTsignals.AllowedValues:\"NORMAL\"\"INVERTED\"$CustomDiffDataEncodeOnStringSetstheoperatingstateoftheuser-definedDifferentialEncoding.AllowedValuesare:\"ON\"\"OFF\"$CustomSymbolRateFloatSetthetransmissionsymbolrate.Theinstrumentpresetvalueis24.300ksps.Thevaluesrangefrom47.684spsthrough12.500000000Mspsbutwillvarydependingonthemodulationtype.$CustomBurstRiseTimeFloatSettheburstedRFsignalrisingedgetime.Theinstrumentpresetvalueis5.860bits.Theminimumandmaximumrangeofvaluesalloweddependsuponthemodulationtypeandthesymbolrate.$CustomBurstRiseDelayFloatSettheburstedRFsignalrisingedgedelay.Theinstrumentpresetvalueis0.000bits.Theminimumandmaximumrangeofvaluesalloweddependsuponthemodulationtypeandthesymbolrate.$CustomBurstFallTimeFloatSettheburstedRFsignalfallingedgetime.Theinstrumentpresetvalueis5.470bits.Theminimumandmaximumrangeofvaluesalloweddependsuponthemodulationtypeandthesymbolrate.$CustomBurstFallDelayFloatSettheburstedRFsignalfallingedgedelay.Theinstrumentpresetvalueis0.000bits.Theminimumandmaximumrangeofvaluesalloweddependsuponthemodulationtypeandthesymbolrate.ReturnParametersParameterVariableTypeDescriptionNoneHPESG_GSMModifyStandardPreviousTopNext***HPESG_GSMModifyStandardUsage:HPESG_GSMModifyStandard($Handle,$GSMPhasePolarity,$GSMDiffDataEncodeOn,$GSMSymbolRate,$GSMBurstRiseTime,$GSMBurstFallTime,$GSMBurstFallDelay);ThisfunctioncontrolstheAgilentESGSeriesofSignalGenerators.InordertousethesefunctiontheVXIpnpdriverfortheinstrumentmustbeinstalledonthesystemrunningJabilTest.ThelatestversionofthisdrivercanbedownloadedfromAgilent.Thisfunctionsupportsthefollowinginstruments:ESG-1000B,ESG-2000B,ESG-3000B,ESG-4000B,ESG-D1000B,ESG-D2000B,ESG-D3000B,ESG-D4000B,ESG-1000A,ESG-2000A,ESG-3000A,ESG-4000A,ESG-D1000A,ESG-D2000A,ESG-D3000A,ESG-D4000A,E4423B,E4424B,E4425B,E4426B,E4434B,E4435B,E4436B,andE4437B.ThismethodisusedtoconfigureGSMDigitalModulationFormatstandardparameters,modifyingthefollowingaspectsofthestandardtransmission:phasepolarity,user--definedDifferentialEncoderstate,symbolrate,andburstedRFsignalshape.FunctionArgumentsParameterVariableTypeDescription$HandleObjectTheresourcehandleoftheSpectrumAnalyzer$GSMPhasePolarityStringSetthedirectionofrotationofthephasemodulationvector.SelectNormalandthein--phasecomponentwillleadthequadrature--phasecomponentby90degreesintheresultingmodulation.SelectInvertandthein--phasecomponentwilllagthequadrature--phasecomponentby90degreesintheresultingmodulation.TheselectionalsoappliestotheIOUTandQOUTsignals.AllowedValues:\"NORMAL\"\"INVERTED\"$GSMDiffDataEncodeOnStringSetstheoperatingstateoftheuser-definedDifferentialEncoding.AllowedValuesare:\"ON\"\"OFF\"$GSMSymbolRateFloatSetthetransmissionsymbolrate.Theinstrumentpresetvalueis270.833333ksps.Thevaluesrangefrom47.684spsthrough12.500000000Mspsbutwillvarydependingonthemodulationtype.$GSMBurstRiseTimeFloatSettheburstedRFsignalrisingedgetime.Theinstrumentpresetvalueis4.224bits.Theminimumandmaximumrangeofvaluesalloweddependsuponthemodulationtypeandthesymbolrate.$GSMBurstRiseDelayFloatSettheburstedRFsignalrisingedgedelay.Theinstrumentpresetvalueis0.000bits.Theminimumandmaximumrangeofvaluesalloweddependsuponthemodulationtypeandthesymbolrate.$GSMBurstFallTimeFloatSettheburstedRFsignalfallingedgetime.Theinstrumentpresetvalueis3.440bits.Theminimumandmaximumrangeofvaluesalloweddependsuponthemodulationtypeandthesymbolrate.$GSMBurstFallDelayFloatSettheburstedRFsignalfallingedgedelay.Theinstrumentpresetvalueis0.125bits.Theminimumandmaximumrangeofvaluesalloweddependsuponthemodulationtypeandthesymbolrate.ReturnParametersParameterVariableTypeDescriptionNoneHPESA_GetBERTMeasurementsPreviousTopNext***HPESG_GetBERTMeasurementsUsage:($ErrorCount,$BitCount,$BitErrorRate,$PassFail)=HPESG_GetBERTMeasurements",
  "body": [
   "HPESG_ConfigModulationIQ($$Handle,$$IQModeOn,$$IQSource,$$BurstEnvelopeModeOn,$$BurstEnvelopeSource,$$IQHighCrestModeOn,$$IQAdjustrmentsOn,$$IQPhasePolarity);ThisfunctioncontrolstheAgilentESGSeriesofSignalGenerators.InordertousethesefunctiontheVXIpnpdriverfortheinstrumentmustbeinstalledonthesystemrunningJabilTest.ThelatestversionofthisdrivercanbedownloadedfromAgilent.Thisfunctionsupportsthefollowinginstruments:ESG-1000B,ESG-2000B,ESG-3000B,ESG-4000B,ESG-D1000B,ESG-D2000B,ESG-D3000B,ESG-D4000B,ESG-1000A,ESG-2000A,ESG-3000A,ESG-4000A,ESG-D1000A,ESG-D2000A,ESG-D3000A,ESG-D4000A,E4423B,E4424B,E4425B,E4426B,E4434B,E4435B,E4436B,andE4437B.ThisfunctionsetsuptheI/Q(digital)modulationparameters.FunctionArgumentsParameterVariableTypeDescription$$HandleObjectTheresourcehandleoftheSpectrumAnalyzer$$IQModeOnStringSetstheI/QModulationModeto\"ON\"or\"OFF\"$$IQSourceStringSelecttheI/QSourceto:\"INTERNAL\"=InternalModulationSource.RequiresOptionUN3orUN4\"EXTERNAL\"=ExternalI/QmodulationSource$$BurstEnvelopeModeOnStringSetstheBurstEnvelopeModeto\"ON\"or\"OFF\"$$BurstEnvelopeSourceStringSetstheBurstEnvelopeSourceto:\"INTERNAL\"=internally-generatedburstsource\"EXTERNAL\"=externally-generatedburstsource$$IQHighCrestModeOnStringSelectforoperatingconditionstoaccomodateI/Qinputswithhighcrestfactor.Whenselectedthemaximumoutputlevelisreducedandthepowerlevelaccuracyisdegraded.I/Qdrivelevelsshouldbereduced,dBperdB,forcrestfactorscreatedthan4dB.\"ON\"enablesI/Qhighcrestfactoroperation,and\"OFF\"disablesI/Qhighcrestfactoroperation.Allowablevaluesare:\"ON\"\"OFF\"$$IQAdjustmentsOnStringEnablesI/Qadjustments(I/Qgain,Ioffset,Qoffset,I/Qskey).Allowablevaluesare:\"ON\"\"OFF\"$$IQPhasePolarityStringSetsthepolarityoftheI/Qmodulationsignal.Thechoicesarenormalorinverted.IntheinvertedmodetheinputappliedtotheIinputconnecotrisphysicallyroutedtotheQinputportoftheI/Qmodulator.Inaddition,theinputappliedtotheQINPUTconnectorisphysicallyroutedtotheIinputportoftheI/Qmodulator.Iftheuserhasenabledadigitalmodulationmode(instrumentoptionUN3orUN4only),I/Qphasepolaritywillbeautomaticallysettonormal.Itisover-writtenwiththisfunction.Allowablevalues:\"NORMAL\"\"INVERTED\"ReturnParametersParameterVariableTypeDescriptionNoneHPESG_CustomModifyStandardPreviousTopNext***HPESG_CustomModifyStandardUsage:HPESG_CustomModifyStandard($$Handle,$$CustomPhasePolarity,$$CustomDiffDataEncodeOn,$$customSymbolRate,$$customBurstRiseTime,$$customBurstFallTime,$$customBurstFallDelay);ThisfunctioncontrolstheAgilentESGSeriesofSignalGenerators.InordertousethesefunctiontheVXIpnpdriverfortheinstrumentmustbeinstalledonthesystemrunningJabilTest.ThelatestversionofthisdrivercanbedownloadedfromAgilent.Thisfunctionsupportsthefollowinginstruments:ESG-1000B,ESG-2000B,ESG-3000B,ESG-4000B,ESG-D1000B,ESG-D2000B,ESG-D3000B,ESG-D4000B,ESG-1000A,ESG-2000A,ESG-3000A,ESG-4000A,ESG-D1000A,ESG-D2000A,ESG-D3000A,ESG-D4000A,E4423B,E4424B,E4425B,E4426B,E4434B,E4435B,E4436B,andE4437B.ThismethodisusedtoconfigureCustomDigitalModulationFormatstandardparameters,modifyingthefollowingaspectsofthestandardtransmission:phasepolarity,user--definedDifferentialEncoderstate,symbolrate,andburstedRFsignalshape.FunctionArgumentsParameterVariableTypeDescription$$HandleObjectTheresourcehandleoftheSpectrumAnalyzer$$CustomPhasePolarityStringSetthedirectionofrotationofthephasemodulationvector.SelectNormalandthein--phasecomponentwillleadthequadrature--phasecomponentby90degreesintheresultingmodulation.SelectInvertandthein--phasecomponentwilllagthequadrature--phasecomponentby90degreesintheresultingmodulation.TheselectionalsoappliestotheIOUTandQOUTsignals.AllowedValues:\"NORMAL\"\"INVERTED\"$$CustomDiffDataEncodeOnStringSetstheoperatingstateoftheuser-definedDifferentialEncoding.AllowedValuesare:\"ON\"\"OFF\"$$CustomSymbolRateFloatSetthetransmissionsymbolrate.Theinstrumentpresetvalueis24.300ksps.Thevaluesrangefrom47.684spsthrough12.500000000Mspsbutwillvarydependingonthemodulationtype.$$CustomBurstRiseTimeFloatSettheburstedRFsignalrisingedgetime.Theinstrumentpresetvalueis5.860bits.Theminimumandmaximumrangeofvaluesalloweddependsuponthemodulationtypeandthesymbolrate.$$CustomBurstRiseDelayFloatSettheburstedRFsignalrisingedgedelay.Theinstrumentpresetvalueis0.000bits.Theminimumandmaximumrangeofvaluesalloweddependsuponthemodulationtypeandthesymbolrate.$$CustomBurstFallTimeFloatSettheburstedRFsignalfallingedgetime.Theinstrumentpresetvalueis5.470bits.Theminimumandmaximumrangeofvaluesalloweddependsuponthemodulationtypeandthesymbolrate.$$CustomBurstFallDelayFloatSettheburstedRFsignalfallingedgedelay.Theinstrumentpresetvalueis0.000bits.Theminimumandmaximumrangeofvaluesalloweddependsuponthemodulationtypeandthesymbolrate.ReturnParametersParameterVariableTypeDescriptionNoneHPESG_GSMModifyStandardPreviousTopNext***HPESG_GSMModifyStandardUsage:HPESG_GSMModifyStandard($$Handle,$$GSMPhasePolarity,$$GSMDiffDataEncodeOn,$$GSMSymbolRate,$$GSMBurstRiseTime,$$GSMBurstFallTime,$$GSMBurstFallDelay);ThisfunctioncontrolstheAgilentESGSeriesofSignalGenerators.InordertousethesefunctiontheVXIpnpdriverfortheinstrumentmustbeinstalledonthesystemrunningJabilTest.ThelatestversionofthisdrivercanbedownloadedfromAgilent.Thisfunctionsupportsthefollowinginstruments:ESG-1000B,ESG-2000B,ESG-3000B,ESG-4000B,ESG-D1000B,ESG-D2000B,ESG-D3000B,ESG-D4000B,ESG-1000A,ESG-2000A,ESG-3000A,ESG-4000A,ESG-D1000A,ESG-D2000A,ESG-D3000A,ESG-D4000A,E4423B,E4424B,E4425B,E4426B,E4434B,E4435B,E4436B,andE4437B.ThismethodisusedtoconfigureGSMDigitalModulationFormatstandardparameters,modifyingthefollowingaspectsofthestandardtransmission:phasepolarity,user--definedDifferentialEncoderstate,symbolrate,andburstedRFsignalshape.FunctionArgumentsParameterVariableTypeDescription$$HandleObjectTheresourcehandleoftheSpectrumAnalyzer$$GSMPhasePolarityStringSetthedirectionofrotationofthephasemodulationvector.SelectNormalandthein--phasecomponentwillleadthequadrature--phasecomponentby90degreesintheresultingmodulation.SelectInvertandthein--phasecomponentwilllagthequadrature--phasecomponentby90degreesintheresultingmodulation.TheselectionalsoappliestotheIOUTandQOUTsignals.AllowedValues:\"NORMAL\"\"INVERTED\"$$GSMDiffDataEncodeOnStringSetstheoperatingstateoftheuser-definedDifferentialEncoding.AllowedValuesare:\"ON\"\"OFF\"$$GSMSymbolRateFloatSetthetransmissionsymbolrate.Theinstrumentpresetvalueis270.833333ksps.Thevaluesrangefrom47.684spsthrough12.500000000Mspsbutwillvarydependingonthemodulationtype.$$GSMBurstRiseTimeFloatSettheburstedRFsignalrisingedgetime.Theinstrumentpresetvalueis4.224bits.Theminimumandmaximumrangeofvaluesalloweddependsuponthemodulationtypeandthesymbolrate.$$GSMBurstRiseDelayFloatSettheburstedRFsignalrisingedgedelay.Theinstrumentpresetvalueis0.000bits.Theminimumandmaximumrangeofvaluesalloweddependsuponthemodulationtypeandthesymbolrate.$$GSMBurstFallTimeFloatSettheburstedRFsignalfallingedgetime.Theinstrumentpresetvalueis3.440bits.Theminimumandmaximumrangeofvaluesalloweddependsuponthemodulationtypeandthesymbolrate.$$GSMBurstFallDelayFloatSettheburstedRFsignalfallingedgedelay.Theinstrumentpresetvalueis0.125bits.Theminimumandmaximumrangeofvaluesalloweddependsuponthemodulationtypeandthesymbolrate.ReturnParametersParameterVariableTypeDescriptionNoneHPESA_GetBERTMeasurementsPreviousTopNext***HPESG_GetBERTMeasurementsUsage:($$ErrorCount,$$BitCount,$$BitErrorRate,$$PassFail)=HPESG_GetBERTMeasurements($$Handle,$$MeasureMode);"
  ],
  "description": "\n\nThis function controls the Agilent ESG Series of Signal Generators. In order to use these function the VXI pnp driver for the instrument must be installed on the system running Jabil Test. The latest version of this driver can be downloaded from Agilent. This function supports the following instruments: ESG-1000B, ESG-2000B, ESG-3000B, ESG-4000B, ESG-D1000B, ESG-D2000B, ESG-D3000B, ESG-D4000B, ESG-1000A, ESG-2000A, ESG-3000A, ESG-4000A, ESG-D1000A, ESG-D2000A, ESG-D3000A, ESG-D4000A, E4423B, E4424B, E4425B, E4426B, E4434B, E4435B, E4436B, and E4437B.\n\nThis method returns the BERT measurement results. The user can select whether to return the intermediate values for the measurements or the total values from one measurement cycle.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nA reference handle to the HPESG\n\n\n\n$MeasureMode\n\nString\n\nSelect the measurement results type to return. Valid Choices are:\n\n\"INTERMEDIATE\" = return immediate values of Bit Error Rate Test\n\n\"TOTAL\" = return total values of Bit Error Rate Test\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCount\n\nInteger\n\nThe Error Count\n\n\n\n$BitCount\n\nInteger\n\nThe Bit Count\n\n\n\n$BitErrorRate\n\nDouble\n\nThe Bit Error Rate\n\n\n\n$PassFail\n\nInteger\n\nReturns Pass/Fail Status\n\n0 = FAIL\n\n1 = PASS\n\n\n\n\n\nHPESG_Init\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS HPESG.Init": {
  "prefix": "HPESG.Init",
  "body": [
   "$$Handle=HPESG.Init($$ResourceString,$$Reset);"
  ],
  "description": "\n\nThis function controls the Agilent ESG Series of Signal Generators. In order to use these function the VXI pnp driver for the instrument must be installed on the system running Jabil Test. The latest version of this driver can be downloaded from Agilent. This function supports the following instruments: ESG-1000B, ESG-2000B, ESG-3000B, ESG-4000B, ESG-D1000B, ESG-D2000B, ESG-D3000B, ESG-D4000B, ESG-1000A, ESG-2000A, ESG-3000A, ESG-4000A, ESG-D1000A, ESG-D2000A, ESG-D3000A, ESG-D4000A, E4423B, E4424B, E4425B, E4426B, E4434B, E4435B, E4436B, and E4437B.\n\nThis function initializes the ESG Signal Generator, and returns a handle to the instrument. If the $Reset argument is set to TRUE, the instrument is reset to it's default configuration.\n\nExample:\n\n$Handle = HPESG_Init(\"GPIB0::5::INSTR\",\"TRUE\");\n\n\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ResourceString\n\nString\n\nThe Resource string of the instrument, for instance \"GPIB0::18::INSTR\"\n\n\n\n$Reset\n\nBoolean\n\nSpecifies whether or not to reset the instrument upon initialization.\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nA reference handle to the HP-ESG Signal Generator\n\n\n\n\n\nHPESG_ModeSetIQBaseband\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS HPESG_QueryBERTMeasurementDone": {
  "prefix": "HPESG_QueryBERTMeasurementDone",
  "body": [
   "HPESG_ModeSetIQBaseband($$Handle,$$IQBaseBandType,IQBaseBandTypeOn);ThisfunctioncontrolstheAgilentESGSeriesofSignalGenerators.InordertousethesefunctiontheVXIpnpdriverfortheinstrumentmustbeinstalledonthesystemrunningJabilTest.ThelatestversionofthisdrivercanbedownloadedfromAgilent.Thisfunctionsupportsthefollowinginstruments:ESG-1000B,ESG-2000B,ESG-3000B,ESG-4000B,ESG-D1000B,ESG-D2000B,ESG-D3000B,ESG-D4000B,ESG-1000A,ESG-2000A,ESG-3000A,ESG-4000A,ESG-D1000A,ESG-D2000A,ESG-D3000A,ESG-D4000A,E4423B,E4424B,E4425B,E4426B,E4434B,E4435B,E4436B,andE4437B.Thisfunctionturnstheselecteddigitalmodulationformatonandoff(NADC,GSM,PDC,PHS,DECT,TETRA,Custom,orEDGE)FunctionArgumentsParameterVariableTypeDescription$$HandleObjectTheresourcehandleoftheSpectrumAnalyzer$$IQBaseBandTypeStringSetstheI/QBasebandModulationType.Allowablevaluesare:\"NADC\"\"GSM\"\"PDC\"\"PHS\"\"DECT\"\"TETRA\"\"Custom\"\"EDGE\"$$IQBaseBandOnStringTurnsthebasebandMode\"ON\"or\"OFF\".ReturnParametersParameterVariableTypeDescriptionNoneHPESG_QueryBERTMeasurementDonePreviousTopNext***HPESG_QueryBERTMeasurementDoneUsage:$$Done=HPESG_QueryBERTMeasurementDone($$Handle);"
  ],
  "description": "\n\nThis function controls the Agilent ESG Series of Signal Generators. In order to use these function the VXI pnp driver for the instrument must be installed on the system running Jabil Test. The latest version of this driver can be downloaded from Agilent. This function supports the following instruments: ESG-1000B, ESG-2000B, ESG-3000B, ESG-4000B, ESG-D1000B, ESG-D2000B, ESG-D3000B, ESG-D4000B, ESG-1000A, ESG-2000A, ESG-3000A, ESG-4000A, ESG-D1000A, ESG-D2000A, ESG-D3000A, ESG-D4000A, E4423B, E4424B, E4425B, E4426B, E4434B, E4435B, E4436B, and E4437B.\n\nThis function returns the BERT measurement completion status. It queries the instrument Standard Operation Condition Register and tests the status of bit 4. When bit 4 equals 1, then a BERT measurement is in progress, and the BERTMeasurementDone_Q parameter will return VI_FALSE. If bit 4 equals 0, then the measurement has completed, and the BERTMeasurementDone_Q will return VI_TRUE.\n\nThis function will wait 1 millisecond before checking the instrument status to allow for the BERT measurement status to change to a 1 after the instrument may have received a bus trigger command. This is to insure the BERTMeasurementDone_Q parameter doesn't return VI_TRUE before the status register has a chance to change.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nA reference to the HP-ESA handle\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Done\n\nBoolean\n\nReturns 'TRUE' if the test is complete, otherwise returns 'FALSE'\n\n\n\n\n\nHPESG_SendCommand\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS HPESG_SendCommand": {
  "prefix": "HPESG_SendCommand",
  "body": [
   "HPESG_SendCommand($$HPESG,$$Command);"
  ],
  "description": "\n\nThis function controls the Agilent ESG Series of Signal Generators. In order to use these function the VXI pnp driver for the instrument must be installed on the system running Jabil Test. The latest version of this driver can be downloaded from Agilent. This function supports the following instruments: ESG-1000B, ESG-2000B, ESG-3000B, ESG-4000B, ESG-D1000B, ESG-D2000B, ESG-D3000B, ESG-D4000B, ESG-1000A, ESG-2000A, ESG-3000A, ESG-4000A, ESG-D1000A, ESG-D2000A, ESG-D3000A, ESG-D4000A, E4423B, E4424B, E4425B, E4426B, E4434B, E4435B, E4436B, and E4437B.\n\nThis function passes the supplied SCPI GPIB command to the instrument. This is useful for passing commands to the instrument that aren't supported by the driver.\n\nExample\n\nHPESG_SendCommand($HPESG,\"SENSE:MODE:BERT ON\");\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nThe resource handle of the Spectrum Analyzer\n\n\n\n$Command\n\nString\n\nThe SCPI command to send to the instrument.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nHPESG_SetFrequencyCW\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS HPESG_SetFrequencyCW": {
  "prefix": "HPESG_SetFrequencyCW",
  "body": [
   "HPESG_SetFrequencyCW($$Handle,$$Frequency);"
  ],
  "description": "\n\nThis function controls the Agilent ESG Series of Signal Generators. In order to use these function the VXI pnp driver for the instrument must be installed on the system running Jabil Test. The latest version of this driver can be downloaded from Agilent. This function supports the following instruments: ESG-1000B, ESG-2000B, ESG-3000B, ESG-4000B, ESG-D1000B, ESG-D2000B, ESG-D3000B, ESG-D4000B, ESG-1000A, ESG-2000A, ESG-3000A, ESG-4000A, ESG-D1000A, ESG-D2000A, ESG-D3000A, ESG-D4000A, E4423B, E4424B, E4425B, E4426B, E4434B, E4435B, E4436B, and E4437B.\n\nThis function sets the signal generator's CW (Continuous Wave) output frequency. By executing this function the frequency becomes the active function and the current value is also shown in the active entry area of the display.\n\nExample:\n\nHPESG_SetFrequencyCW($Handle,10000000);\n\n\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nThe resource handle of the Spectrum Analyzer\n\n\n\n$Frequency\n\nFloat\n\nThis is the value of the frequency to be set in Hz.\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nHPESG.SetModulationOn\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS HPESG_SetModulationOn": {
  "prefix": "HPESG_SetModulationOn",
  "body": [
   "HPESG_SetModulationOn($$Handle,$$OutputState);"
  ],
  "description": "\n\nThis function controls the Agilent ESG Series of Signal Generators. In order to use these function the VXI pnp driver for the instrument must be installed on the system running Jabil Test. The latest version of this driver can be downloaded from Agilent. This function supports the following instruments: ESG-1000B, ESG-2000B, ESG-3000B, ESG-4000B, ESG-D1000B, ESG-D2000B, ESG-D3000B, ESG-D4000B, ESG-1000A, ESG-2000A, ESG-3000A, ESG-4000A, ESG-D1000A, ESG-D2000A, ESG-D3000A, ESG-D4000A, E4423B, E4424B, E4425B, E4426B, E4434B, E4435B, E4436B, and E4437B.\n\nThis function sets the signal generator modulation output state to either \"ON\" or \"OFF\".\n\nExample:\n\nHPESG_SetModulationOn($Handle,-72);\n\n\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nThe resource handle of the Spectrum Analyzer\n\n\n\n$OutputState\n\nString\n\nSets the Modulation Output state. Allowable values are:\n\n\"ON\"\n\n\"OFF\"\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nHPESG_SetPower\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS HPESG_SetPower": {
  "prefix": "HPESG_SetPower",
  "body": [
   "HPESG_SetPower($$Handle,$$OutputPower);"
  ],
  "description": "\n\nThis function controls the Agilent ESG Series of Signal Generators. In order to use these function the VXI pnp driver for the instrument must be installed on the system running Jabil Test. The latest version of this driver can be downloaded from Agilent. This function supports the following instruments: ESG-1000B, ESG-2000B, ESG-3000B, ESG-4000B, ESG-D1000B, ESG-D2000B, ESG-D3000B, ESG-D4000B, ESG-1000A, ESG-2000A, ESG-3000A, ESG-4000A, ESG-D1000A, ESG-D2000A, ESG-D3000A, ESG-D4000A, E4423B, E4424B, E4425B, E4426B, E4434B, E4435B, E4436B, and E4437B.\n\nThis function sets the signal generator output power in dBm. This function does not automatically turn on the RF output.\n\nExample:\n\nHPESG_SetPower($Handle,-72);\n\n\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nThe resource handle of the Spectrum Analyzer\n\n\n\n$OutputPower\n\nFloat\n\nSpecifies the output power in dBm.\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nHPESG.SetPowerOn\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS HPESG_SetPowerOn": {
  "prefix": "HPESG_SetPowerOn",
  "body": [
   "HPESG_SetPowerOn($$Handle,$$OutputState);"
  ],
  "description": "\n\nThis function controls the Agilent ESG Series of Signal Generators. In order to use these function the VXI pnp driver for the instrument must be installed on the system running Jabil Test. The latest version of this driver can be downloaded from Agilent. This function supports the following instruments: ESG-1000B, ESG-2000B, ESG-3000B, ESG-4000B, ESG-D1000B, ESG-D2000B, ESG-D3000B, ESG-D4000B, ESG-1000A, ESG-2000A, ESG-3000A, ESG-4000A, ESG-D1000A, ESG-D2000A, ESG-D3000A, ESG-D4000A, E4423B, E4424B, E4425B, E4426B, E4434B, E4435B, E4436B, and E4437B.\n\nThis function sets the signal generator output state to either \"ON\" or \"OFF\".\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nThe resource handle of the Spectrum Analyzer\n\n\n\n$OutputState\n\nString\n\nSets the RF Output state. Allowable values are:\n\n\"ON\"\n\n\"OFF\"\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nARFSG_Amod_AM_Config\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ARFSG_AMod_AM_Config": {
  "prefix": "ARFSG_AMod_AM_Config",
  "body": [
   "ARFSG_AMod_AM_Config($$ARFSG_handle,$$path,$$source,$$depth);"
  ],
  "description": "\n\nThis function configures the attributes that control the signal generator's amplitude modulation.\n\nEquivalent instrument command: [:SOURce]:AM[1]|2:SOURce INT|EXT1|EXT2;\n\n[:SOURce]:AM[1]|2[:DEPTh][:LINear] <val><unit>|UP|DOWN\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ARFSG_handle\n\nObject\n\nHandle created by the ARFSG_Init() function.\n\n\n\n$path\n\nInteger\n\nThe AM path to configure (1 or 2).\n\n\n\n$source\n\nString\n\nSpecifies the source of the signal that is used as the modulating signal:\n\n\u00b7 \u201cINT1\u201d\n\n\u00b7 \u201cEXT1\u201d\n\n\u00b7 \u201cEXT2\u201d\n\n\n\n$depth\n\nFloat\n\nSpecifies the extent of modulation the signal generator applies to the RF-signal (in percent).\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n-\n\n-\n\n\n\n\n\nARFSG_Amod_AM_Enable\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ARFSG_AMod_AM_Enable": {
  "prefix": "ARFSG_AMod_AM_Enable",
  "body": [
   "ARFSG_AMod_AM_Enable($$ARFSG_handle,$$path,$$enableAM);"
  ],
  "description": "\n\nSpecifies whether the signal generator applies amplitude modulation to the RF output signal.\n\nEquivalent instrument command: [:SOURce]:AM[1]|2:STATe ON|OFF|1|0\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ARFSG_handle\n\nObject\n\nHandle created by the ARFSG_Init() function.\n\n\n\n$path\n\nInteger\n\nThe AM path to configure (1 or 2).\n\n\n\n$enableAM\n\nBoolean\n\nAM enable state.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n-\n\n-\n\n\n\n\n\nARFSG_Amod_AM_ExtCoupling\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ARFSG_AMod_AM_ExtCoupling": {
  "prefix": "ARFSG_AMod_AM_ExtCoupling",
  "body": [
   "ARFSG_AMod_AM_ExtCoupling($$ARFSG_handle,$$path,$$extCoupling);"
  ],
  "description": "\n\nSpecifies the coupling of the external source of the modulating signal. The command does not change the currently active source or switch the current modulation on or off.\n\nEquivalent instrument command: [:SOURce]:AM[1]|2:EXTernal[1]|2:COUPling AC|DC\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ARFSG_handle\n\nObject\n\nHandle created by the ARFSG_Init() function.\n\n\n\n$path\n\nInteger\n\nThe AM path to configure (1 or 2).\n\n\n\n$extCoupling\n\nString\n\nSelects coupling type. Valid values:\n\n\u00b7 \"AC\"\n\n\u00b7 \"DC\"\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n-\n\n-\n\n\n\n\n\nARFSG_Amod_Enable\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ARFSG_AMod_Enable": {
  "prefix": "ARFSG_AMod_Enable",
  "body": [
   "ARFSG_AMod_Enable($$ARFSG_handle,$$enablePULM);"
  ],
  "description": "\n\nTurns modulation to the RF output (AM, FM, PM, Pulse) signal on and off.\n\nEquivalent instrument command: :OUTPut:MODulation[:STATe] ON|OFF|1|0\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ARFSG_handle\n\nObject\n\nHandle created by the ARFSG_Init() function.\n\n\n\n$enableMod\n\nBoolean\n\nModulation enable state.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n-\n\n-\n\n\n\n\n\nARFSG_Amod_FM_Config\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ARFSG_AMod_FM_Config": {
  "prefix": "ARFSG_AMod_FM_Config",
  "body": [
   "ARFSG_AMod_FM_Config($$ARFSG_handle,$$path,$$source,$$deviation);"
  ],
  "description": "\n\nThis function configures the attributes that control the signal generator's frequency modulation.\n\nEquivalent instrument command: [:SOURce]:FM[1]|2:SOURce INT|EXT1|EXT2;\n\n[:SOURce]:FM[1]|2:DEV:TRACK ON;\n\n[:SOURce]:FM[1]|2[:DEViation] <val><unit>\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ARFSG_handle\n\nObject\n\nHandle created by the ARFSG_Init() function.\n\n\n\n$path\n\nInteger\n\nThe FM path to configure (1 or 2).\n\n\n\n$source\n\nString\n\nSpecifies the source of the signal that is used as the modulating signal:\n\n\u00b7 \u201cINT1\u201d\n\n\u00b7 \u201cEXT1\u201d\n\n\u00b7 \u201cEXT2\u201d\n\n\n\n$deviation\n\nFloat\n\nSpecifies the extent of modulation (peak frequency deviation) the signal generator applies to the RF-signal in HZ.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n-\n\n-\n\n\n\n\n\nARFSG_Amod_FM_Enable\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ARFSG_AMod_FM_Enable": {
  "prefix": "ARFSG_AMod_FM_Enable",
  "body": [
   "ARFSG_AMod_FM_Enable($$ARFSG_handle,$$path,$$enableFM);"
  ],
  "description": "\n\nSpecifies whether the signal generator applies frequency modulation to the RF output signal.\n\nEquivalent instrument command: [:SOURce]:FM[1]|2:STATe ON|OFF|1|0\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ARFSG_handle\n\nObject\n\nHandle created by the ARFSG_Init() function.\n\n\n\n$path\n\nInteger\n\nThe FM path to configure (1 or 2).\n\n\n\n$enableFM\n\nBoolean\n\nFM enable state.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n-\n\n-\n\n\n\n\n\nARFSG_Amod_FM_ExtCoupling\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ARFSG_AMod_FM_ExtCoupling": {
  "prefix": "ARFSG_AMod_FM_ExtCoupling",
  "body": [
   "ARFSG_AMod_FM_ExtCoupling($$ARFSG_handle,$$path,$$extCoupling);"
  ],
  "description": "\n\nSpecifies the coupling of the external source of the modulating signal. The command does not change the currently active source or switch the current modulation on or off.\n\nEquivalent instrument command: [:SOURce]:FM[1]|2:EXTernal[1]|2:COUPling AC|DC\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ARFSG_handle\n\nObject\n\nHandle created by the ARFSG_Init() function.\n\n\n\n$path\n\nInteger\n\nThe FM path to configure (1 or 2).\n\n\n\n$extCoupling\n\nString\n\nSelects coupling type. Valid values:\n\n\u00b7 \"AC\"\n\n\u00b7 \"DC\"\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n-\n\n-\n\n\n\n\n\nARFSG_Amod_PM_Config\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ARFSG_AMod_PM_Config": {
  "prefix": "ARFSG_AMod_PM_Config",
  "body": [
   "ARFSG_AMod_PM_Config($$ARFSG_handle,$$path,$$source,$$deviation);"
  ],
  "description": "\n\nThis function configures the attributes that control the signal generator's phase modulation.\n\nEquivalent instrument command: [:SOURce]:PM[1]|2:SOURce INT|EXT1|EXT2;\n\n[:SOURce]:PM[1]|2:DEV:TRACK ON;\n\n[:SOURce]:PM[1]|2[:DEViation] <val><unit>\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ARFSG_handle\n\nObject\n\nHandle created by the ARFSG_Init() function.\n\n\n\n$path\n\nInteger\n\nThe PM path to configure (1 or 2).\n\n\n\n$source\n\nString\n\nSpecifies the source of the signal that is used as the modulating signal:\n\n\u00b7 \u201cINT1\u201d\n\n\u00b7 \u201cEXT1\u201d\n\n\u00b7 \u201cEXT2\u201d\n\n\n\n$deviation\n\nFloat\n\nSpecifies the extent of modulation (peak frequency deviation) the signal generator applies to the RF-signal in rads.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n-\n\n-\n\n\n\n\n\nARFSG_Amod_PM_Enable\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ARFSG_AMod_PM_Enable": {
  "prefix": "ARFSG_AMod_PM_Enable",
  "body": [
   "ARFSG_AMod_PM_Enable($$ARFSG_handle,$$path,$$enablePM);"
  ],
  "description": "\n\nSpecifies whether the signal generator applies phase modulation to the RF output signal.\n\nEquivalent instrument command: [:SOURce]:PM[1]|2:STATe ON|OFF|1|0\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ARFSG_handle\n\nObject\n\nHandle created by the ARFSG_Init() function.\n\n\n\n$path\n\nInteger\n\nThe PM path to configure (1 or 2).\n\n\n\n$enablePM\n\nBoolean\n\nPM enable state.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n-\n\n-\n\n\n\n\n\nARFSG_Amod_PM_ExtCoupling\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ARFSG_AMod_PM_ExtCoupling": {
  "prefix": "ARFSG_AMod_PM_ExtCoupling",
  "body": [
   "ARFSG_AMod_PM_ExtCoupling($$ARFSG_handle,$$path,$$extCoupling);"
  ],
  "description": "\n\nSpecifies the coupling of the external source of the modulating signal. The command does not change the currently active source or switch the current modulation on or off.\n\nEquivalent instrument command: [:SOURce]:PM[1]|2:EXTernal[1]|2:COUPling AC|DC\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ARFSG_handle\n\nObject\n\nHandle created by the ARFSG_Init() function.\n\n\n\n$path\n\nInteger\n\nThe PM path to configure (1 or 2).\n\n\n\n$extCoupling\n\nString\n\nSelects coupling type. Valid values:\n\n\u00b7 \"AC\"\n\n\u00b7 \"DC\"\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n-\n\n-\n\n\n\n\n\nARFSG_Amod_PULM_Config\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ARFSG_AMod_PULM_Config": {
  "prefix": "ARFSG_AMod_PULM_Config",
  "body": [
   "ARFSG_AMod_PULM_Config($$ARFSG_handle,$$source,$$shape,$$freq,$$period,$$width);"
  ],
  "description": "\n\nThis function configures the attributes that control the signal generator's pulse modulation.\n\nEquivalent instrument command: [:SOURce]:PULM:SOURce INT|EXT[1]|EXT2;\n\n[:SOURce]:PULM:INTernal[1]:FUNCtion:SHAPe PULSe|SQUare;\n\n[:SOURce]:PULM:INTernal[1]:FREQuency <val><unit>|UP|DOWN;\n\n[:SOURce]:PULM:INTernal[1]:PERiod <val><unit>|UP|DOWN;\n\n[:SOURce]:PULM:INTernal[1]:PWIDth <val><unit> |UP|DOWN\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ARFSG_handle\n\nObject\n\nHandle created by the ARFSG_Init() function.\n\n\n\n$source\n\nString\n\nSpecifies the source of the signal that is used as the modulating signal:\n\n\u00b7 \u201cINT1\u201d\n\n\u00b7 \u201cEXT1\u201d\n\n\u00b7 \u201cEXT2\u201d\n\n\n\n$shape\n\nString\n\nInternal pulse modulation waveform type. Only used when $source parameter is set to \u201cINT1\u201d. Valid values:\n\n\u00b7 \u201cSQUARE\u201d \u2013 need to specify rate with $freq parameter\n\n\u00b7 \u201cPULSE\u201d \u2013 need to specify period and pulse width with $period and $width parameters\n\n\n\n$freq\n\nFloat\n\nRate of the internal square wave pulse modulation source. Only used when $shape parameter is set to \u201cSQUARE\u201d\n\n\n\n$period\n\nFloat\n\nPeriod for the internally generated pulse modulation source. Only used when $shape parameter is set to \"PULSE\u201d.\n\n\n\n$width\n\nFloat\n\nPulse width for the internally generated pulse modulation source. Only used when $shape parameter is set to \"PULSE\u201d.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n-\n\n-\n\n\n\n\n\nARFSG_Amod_PULM_Enable\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ARFSG_AMod_PULM_Enable": {
  "prefix": "ARFSG_AMod_PULM_Enable",
  "body": [
   "ARFSG_AMod_PULM_Enable($$ARFSG_handle,$$enablePULM);"
  ],
  "description": "\n\nSpecifies whether the signal generator applies pulse modulation to the RF output signal.\n\nEquivalent instrument command: [:SOURce]:PULM:STATe ON|OFF|1|0\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ARFSG_handle\n\nObject\n\nHandle created by the ARFSG_Init() function.\n\n\n\n$enablePULM\n\nBoolean\n\nPulse Modulation enable state.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n-\n\n-\n\n\n\n\n\nARFSG_Amod_PULM_ExtPolarity\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ARFSG_AMod_PULM_ExtPolarity": {
  "prefix": "ARFSG_AMod_PULM_ExtPolarity",
  "body": [
   "ARFSG_AMod_PULM_ExtPolarity($$ARFSG_handle,$$extPolarity);"
  ],
  "description": "\n\nSpecifies the polarity of the external source signal.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ARFSG_handle\n\nObject\n\nHandle created by the ARFSG_Init() function.\n\n\n\n$extPolarity\n\nString\n\nSelects polarity type. Valid values:\n\n\u00b7 \"NORMAL\"\n\n\u00b7 \"INVERSE\"\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n-\n\n-\n\n\n\n\n\nARFSG_ALC_Config\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ARFSG_ALC_Config": {
  "prefix": "ARFSG_ALC_Config",
  "body": [
   "ARFSG_ALC_Config($$ARFSG_handle,$$source,$$bandwidth);"
  ],
  "description": "\n\nThis function configures the ALC (Automatic Level Control) of the signal generator's RF output.\n\nEquivalent instrument command: [:SOURce]:POWer:ALC:BANDwidth|BWIDth 100HZ|1KHZ|10KHZ\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ARFSG_handle\n\nObject\n\nHandle created by the ARFSG_Init() function.\n\n\n\n$source\n\nString\n\nSource for ALC. Valid strings are:\n\n\"INTERNAL\" - The generated signal itself is used.\n\n\"EXTERNAL\" - The signal on the the front panel ALC INPUT connector is used. 1\n\n\"MODULE\" - The signal on the rear panel SOURCE MODULE interface connector is used. 1\n\n\n\n\n\n1Not supported by E4428C\n\n\n\n$bandwidth\n\nFloat\n\nThe bandwidth of the automatic leveling control (ALC) loop in hertz. Valid values:\n\n100 - This bandwidth has the longest settling time, but the least signal degradation and lowest error vector magnitude for digital signals. This is the auto selection for digital modulation.\n\n1000 - This bandwidth is the auto selection for pulse modulation and AM modulation to a carrier frequency of 500 kHz.\n\n10000 - This bandwidth has the fastest settling time, but the most signal degradation and highest error vector magnitude for digital signals. This is the auto selection for AM modulation above a 500 kHz carrier frequency and with FM/\u03a6M modulation.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n-\n\n-\n\n\n\n\n\nARFSG_ALC_Enable\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ARFSG_ALC_Enable": {
  "prefix": "ARFSG_ALC_Enable",
  "body": [
   "ARFSG_ALC_Enable($$ARFSG_handle,$$enableALC);"
  ],
  "description": "\n\nTurns the ALC (Automatic Level Control) On/Off. The purpose of the ALC circuit is to hold output power at a desired level by adjusting the signal generator\u2019s power circuits to compensate for power drift. Power drift occurs over time and changes in temperature.\n\nEquivalent instrument command: [:SOURce]:POWer:ALC[:STATe] ON|OFF|1|0\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ARFSG_handle\n\nObject\n\nHandle created by the ARFSG_Init() function.\n\n\n\n$enableALC\n\nBoolean\n\nALC enable state.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n-\n\n-\n\n\n\n\n\nARFSG_Close\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ARFSG_Close": {
  "prefix": "ARFSG_Close",
  "body": [
   "ARFSG_Close($$ARFSG_handle);"
  ],
  "description": "\n\nCloses the I/O session to the instrument. Driver methods and properties that access the instrument are not accessible after Close is called.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ARFSG_handle\n\nObject\n\nHandle created by the ARFSG_Init() function.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n-\n\n-\n\n\n\n\n\nARFSG_Init\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ARFSG_Init": {
  "prefix": "ARFSG_Init",
  "body": [
   "$$ARFSG_handle=ARFSG_Init($$resourceName,$$IDQuery,$$resetDevice,$$optionString);"
  ],
  "description": "\n\nCreates a new IVI instrument driver session.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$resourceName\n\nString\n\nOpens a session to the specified device using the interface and address you specify for the resourceName parameter.\n\n\n\n$IDQuery\n\nBoolean\n\nValid values are True or False.\n\nSpecifies whether to verify the ID of the instrument.\n\n\n\n$resetDevice\n\nBoolean\n\nValid values are True or False.\n\nSpecifies whether to reset the instrument.\n\n\n\n$optionString\n\nString\n\nThe user can use the $optionString parameter to specify the initial values of certain IVI inherent attributes for the session. The format of an assignment in the $optionString parameter is 'Name=Value', where Name is one of:\n\n\n\n\n\n\u00b7 RangeCheck\n\n\u00b7 QuerytInstrStatus\n\n\u00b7 Cache\n\n\u00b7 Simulate\n\n\u00b7 RecordCoercions\n\n\u00b7 InterchangeCheck\n\n\u00b7 DriverSetup\n\n\n\n\n\nValue is either true or false except for DriverSetup. If the Options String parameter contains an assignment for the Driver Setup attribute, the Initialize function assumes that everything following 'DriverSetup=' is part of the assignment.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ARFSG_handle\n\nObject\n\nReturns a handle that you use to identify the instrument in all subsequent instrument driver function calls.\n\n\n\n\n\nExample:\n\n$E4428C_handle = ARFSG_Init(\"ASRL1::INSTR\", False, True, \"RangeCheck=true,QueryInstrStatus=true\");\n\n\n\n\n\nARFSG_LFGen_Config\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ARFSG_LFGen_Config": {
  "prefix": "ARFSG_LFGen_Config",
  "body": [
   "ARFSG_LFGen_Config($$ARFSG_handle,$$frequency,$$waveform);"
  ],
  "description": "\n\nConfigures the LF generator output frequency and waveform.\n\nEquivalent instrument command: [:SOURce]:LFOutput:FUNCtion[1]:FREQuency <val><unit>\n\n[:SOURce]:LFOutput:FUNCtion[1]:SHAPe SINE|DUALsine|SWEPtsine|TRIangle|SQUare|RAMP|PULSe|NOISe|DC\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ARFSG_handle\n\nObject\n\nHandle created by the ARFSG_Init() function.\n\n\n\n$frequency\n\nFloat\n\nFrequency of the active LF generator.\n\n\n\n$waveform\n\nString\n\nWaveform shape of the active LF generator. Valid values:\n\n\u00b7 \u201cSINE\u201d\n\n\u00b7 \u201cRECTANGLE\u201d\n\n\u00b7 \u201cTRIANGLE\u201d\n\n\u00b7 \u201cRAMPUP\u201d\n\n\u00b7 \u201cRAMPDOWN\u201d\n\n\u00b7 \u201cNOISE\u201d\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n-\n\n-\n\n\n\n\n\nARFSG_LFGen_Enable\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ARFSG_LFGen_Enable": {
  "prefix": "ARFSG_LFGen_Enable",
  "body": [
   "ARFSG_LFGen_Enable($$ARFSG_handle,$$enableLF);"
  ],
  "description": "\n\nTurns the LF generator output On/Off.\n\nEquivalent instrument command: [:SOURce]:LFOutput:STATe ON|OFF|1|0\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ARFSG_handle\n\nObject\n\nHandle created by the ARFSG_Init() function.\n\n\n\n$enableLF\n\nBoolean\n\nLF generator enable state.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n-\n\n-\n\n\n\n\n\nARFSG_LFGen_OutputVolt\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ARFSG_LFGen_OutputVolt": {
  "prefix": "ARFSG_LFGen_OutputVolt",
  "body": [
   "ARFSG_LFGen_OutputVolt($$ARFSG_handle,$$voltage);"
  ],
  "description": "\n\nSpecifies the output voltage of the LF generator.\n\nEquivalent instrument command: [:SOURce]:LFOutput:AMPLitude <val><unit>\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ARFSG_handle\n\nObject\n\nHandle created by the ARFSG_Init() function.\n\n\n\n$voltage\n\nFloat\n\nLF output voltage.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n-\n\n-\n\n\n\n\n\nARFSG_LFGen_Source\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ARFSG_LFGen_Source": {
  "prefix": "ARFSG_LFGen_Source",
  "body": [
   "ARFSG_LFGen_Source($$ARFSG_handle,$$source);"
  ],
  "description": "\n\nSets the low frequency source for the LF output.\n\nEquivalent instrument command: [:SOURce]:LFOutput:SOURce INT[1]|FUNCtion\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ARFSG_handle\n\nObject\n\nHandle created by the ARFSG_Init() function.\n\n\n\n$source\n\nString\n\nLF generator source. Valid values:\n\n\u00b7 \u201cINT1\u201d \u2013 This choice enables you to output a signal where the frequency and shape of the signal is set by the internal source as it is being used by a modulation. For example, if the internal source is currently assigned to an AM path configuration and AM is turned on, the signal output at the LF OUTPUT connector will have the frequency and shape of the amplitude modulating signal.\n\n\u00b7 \u201cFUNCTION\u201d - This choice enables the selection of an internal function generator.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n-\n\n-\n\n\n\n\n\nARFSG_PGen_Config\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ARFSG_PGen_Config": {
  "prefix": "ARFSG_PGen_Config",
  "body": [
   "ARFSG_PGen_Config($$ARFSG_handle,$$trigSource,$$pulseWidth,$$enableGating);"
  ],
  "description": "\n\nConfigures the pulse generator within the RF signal generator.\n\nEquivalent instrument command: [:SOURce]:PULM:SOURce INT|EXT[1]|EXT2;\n\n[:SOURce]:PULM:INTernal[1]:PWIDth <val><unit> |UP|DOWN;\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ARFSG_handle\n\nObject\n\nHandle created by the ARFSG_Init() function.\n\n\n\n$trigSource\n\nString\n\nSpecifies the source of the signal the pulse generator uses to generate one pulse.\n\n\n\n$pulseWidth\n\nFloat\n\nSpecifies the width of the output pulse. Valid range is 4uS \u2013 30S.\n\n\n\n$enableGating\n\nBoolean\n\nTurns pulse gating on/off.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n-\n\n-\n\n\n\n\n\nARFSG_PGen_ConfigExtTrig\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ARFSG_PGen_ConfigExtTrig": {
  "prefix": "ARFSG_PGen_ConfigExtTrig",
  "body": [
   "ARFSG_PGen_ConfigExtTrig($$ARFSG_handle,$$extTrigSlope,$$delay);"
  ],
  "description": "\n\nConfigures the external trigger for the pulse generator.\n\nEquivalent instrument command: :PULM:INT1:DEL\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ARFSG_handle\n\nObject\n\nHandle created by the ARFSG_Init() function.\n\n\n\n$extTrigSlope\n\nString\n\nSpecifies whether the trigger event occurs on the rising or falling edge of the input signal.\n\n\n\n$delay\n\nFloat\n\nSpecifies the delay from trigger input to start of the output pulse.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n-\n\n-\n\n\n\n\n\nARFSG_PGen_DoubleDelay\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ARFSG_PGen_DoubleDelay": {
  "prefix": "ARFSG_PGen_DoubleDelay",
  "body": [
   "ARFSG_PGen_DoubleDelay($$ARFSG_handle,$$delay);"
  ],
  "description": "\n\nSpecifies the delay of the second pulse.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ARFSG_handle\n\nObject\n\nHandle created by the ARFSG_Init() function.\n\n\n\n$delay\n\nFloat\n\nDelay in seconds.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n-\n\n-\n\n\n\n\n\nARFSG_PGen_DoubleEnable\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ARFSG_PGen_DoubleEnable": {
  "prefix": "ARFSG_PGen_DoubleEnable",
  "body": [
   "ARFSG_PGen_DoubleEnable($$ARFSG_handle,$$enableDouble);"
  ],
  "description": "\n\nTurns double pulse mode On/Off.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ARFSG_handle\n\nObject\n\nHandle created by the ARFSG_Init() function.\n\n\n\n$enableDouble\n\nBoolean\n\nDouble pulse enable state.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n-\n\n-\n\n\n\n\n\nARFSG_PGen_IntTrigPer\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ARFSG_PGen_IntTrigPer": {
  "prefix": "ARFSG_PGen_IntTrigPer",
  "body": [
   "ARFSG_PGen_IntTrigPer($$ARFSG_handle,$$trigPer);"
  ],
  "description": "\n\nSpecifies the period of the pulse generator's output signal.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ARFSG_handle\n\nObject\n\nHandle created by the ARFSG_Init() function.\n\n\n\n$trigPer\n\nFloat\n\nPulse period. Valid range 8uS \u2013 30S\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n-\n\n-\n\n\n\n\n\nARFSG_PGen_OutputEnable\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ARFSG_PGen_OutputEnable": {
  "prefix": "ARFSG_PGen_OutputEnable",
  "body": [
   "ARFSG_PGen_OutputEnable($$ARFSG_handle,$$enablePGen);"
  ],
  "description": "\n\nTurns the pulse generator on/off.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ARFSG_handle\n\nObject\n\nHandle created by the ARFSG_Init() function.\n\n\n\n$enablePGen\n\nBoolean\n\nPulse generator enable status.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n-\n\n-\n\n\n\n\n\nARFSG_PGen_OutputPolarity\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ARFSG_PGen_OutputPolarity": {
  "prefix": "ARFSG_PGen_OutputPolarity",
  "body": [
   "ARFSG_PGen_OutputPolarity($$ARFSG_handle,$$PGenPolarity);"
  ],
  "description": "\n\nSpecifies the polarity of the pulse generator output signal.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ARFSG_handle\n\nObject\n\nHandle created by the ARFSG_Init() function.\n\n\n\n$PGenPolarity\n\nString\n\nOutput polarity. Valid strings:\n\n\u00b7 \"NORMAL\"\n\n\u00b7 \"INVERTED\"\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n-\n\n-\n\n\n\n\n\nARFSG_RF_Config\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ARFSG_RF_Config": {
  "prefix": "ARFSG_RF_Config",
  "body": [
   "ARFSG_RF_Config($$ARFSG_handle,$$freq,$$power);"
  ],
  "description": "\n\nSpecifies the frequency and amplitude (power/level) of the RF output signal.\n\nEquivalent instrument command: [:POW:LEV:IMM:AMPL <level>; FREQ:CW <freq>\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ARFSG_handle\n\nObject\n\nHandle created by the ARFSG_Init() function.\n\n\n\n$freq\n\nFloat\n\nRF frequency.\n\n\n\n$power\n\nFloat\n\nRF power.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n-\n\n-\n\n\n\n\n\nARFSG_RF_Enable\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ARFSG_RF_Enable": {
  "prefix": "ARFSG_RF_Enable",
  "body": [
   "ARFSG_RF_Enable($$ARFSG_handle,$$enableRF);"
  ],
  "description": "\n\nTurns the RF output signal On/Off.\n\nEquivalent instrument command: :OUTPut[:STATe] ON|OFF|1|0\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ARFSG_handle\n\nObject\n\nHandle created by the ARFSG_Init() function.\n\n\n\n$enableRF\n\nBoolean\n\nRF enabled state.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n-\n\n-\n\n\n\n\n\nARFSG_RF_Settle\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ARFSG_RF_Settle": {
  "prefix": "ARFSG_RF_Settle",
  "body": [
   "ARFSG_RF_Settle($$ARFSG_handle,$$timeout);"
  ],
  "description": "\n\nReturns if the state of the RF output signal has settled. Use after changing output state, before trying to make any measurements.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ARFSG_handle\n\nObject\n\nHandle created by the ARFSG_Init() function.\n\n\n\n$timeout\n\nInteger\n\nMaximum time in milliseconds to wait for function to return.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n-\n\n-\n\n\n\n\n\nSupported Instruments\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ARFSG_Sweep_FreqStep_Config": {
  "prefix": "ARFSG_Sweep_FreqStep_Config",
  "body": [
   "ARFSG_Sweep_FreqStep_Config($$ARFSG_handle,$$start,$$stop,$$points);"
  ],
  "description": "\n\nConfigures frequency step sweep settings.\n\nEquivalent instrument command: [:SOURce]:LIST:TYPE LIST|STEP;\n\n[:SOURce]:FREQuency:STARt <val><unit>;\n\n[:SOURce]:FREQuency:STOP <val><unit>;\n\n[:SOURce]:SWEep:POINts <val>\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ARFSG_handle\n\nObject\n\nHandle created by the ARFSG_Init() function.\n\n\n\n$start\n\nFloat\n\nStarting frequency of sweep.\n\n\n\n$stop\n\nFloat\n\nStopping frequency of sweep.\n\n\n\n$points\n\nInteger\n\nNumber of points in sweep.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n-\n\n-\n\n\n\n\n\nARFSG_Sweep_FreqStep_Start\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ARFSG_Sweep_FreqStep_Start": {
  "prefix": "ARFSG_Sweep_FreqStep_Start",
  "body": [
   "ARFSG_Sweep_FreqStep_Start($$ARFSG_handle);"
  ],
  "description": "\n\nStarts currently enabled sweep. Follow with the OPC command to ensure sweep finishes before program continues.\n\nEquivalent instrument command: :FREQuency:MODE LIST; :INITiate:IMMediate:ALL\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ARFSG_handle\n\nObject\n\nHandle created by the ARFSG_Init() function.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n-\n\n-\n\n\n\n\n\nARFSG_OPC\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ARFSG_OPC": {
  "prefix": "ARFSG_OPC",
  "body": [
   "ARFSG_OPC($$ARFSG_handle,$$timeout);"
  ],
  "description": "\n\nDoes not return until previously started operations complete or $timeout milliseconds of time have expired. Use after an operation that takes a variable amount of time instead of a Sleep() function.\n\nEquivalent instrument command: "
 }
,
 "JTS ARFSG_PrintErrors": {
  "prefix": "ARFSG_PrintErrors",
  "body": [
   "ARFSG_PrintErrors($$ARFSG_handle);"
  ],
  "description": "\n\nPrints out all errors and clears the queue.\n\nEquivalent instrument command: :SYSTem:ERRor[:NEXT]?\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ARFSG_handle\n\nObject\n\nHandle created by the ARFSG_Init() function.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n-\n\n-\n\n\n\n\n\nARFSG_SCPI_Read\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ARFSG_SCPI_Read": {
  "prefix": "ARFSG_SCPI_Read",
  "body": [
   "$$message=ARFSG_SCPI_Read($$ARFSG_handle);"
  ],
  "description": "\n\nRetrieves string from instrument. Used to get the response from a SCPI query sent with the ARFSG_SCPI_Write function.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ARFSG_handle\n\nObject\n\nHandle created by the ARFSG_Init() function.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$message\n\nString\n\nReturn string from instrument.\n\n\n\n\n\nARFSG_SCPI_Write\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ARFSG_SCPI_Write": {
  "prefix": "ARFSG_SCPI_Write",
  "body": [
   "ARFSG_SCPI_Write($$ARFSG_handle,$$command);"
  ],
  "description": "\n\nSends a string directly to instrument. Used to communicate with and control instrument using SCPI commands.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ARFSG_handle\n\nObject\n\nHandle created by the ARFSG_Init() function.\n\n\n\n$command\n\nString\n\nSCPI command to send to instrument. See \"SCPI Command Reference\" from Agilent for a list of valid commands.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n-\n\n-\n\n\n\n\n\nExample:\n\n\n\n\n\nARFSG_SCPI_Write($InstrHandle, \""
 }
,
 "JTS ARFSG_SendSWTrig": {
  "prefix": "ARFSG_SendSWTrig",
  "body": [
   "ARFSG_SendSWTrig($$ARFSG_handle);"
  ],
  "description": "\n\nSends a software trigger, which causes the signal generator to start signal generation (in BUS mode).\n\nEquivalent instrument command: "
 }
,
 "JTS ARFSG_Clear": {
  "prefix": "ARFSG_Clear",
  "body": [
   "ARFSG_Clear($$ARFSG_handle);"
  ],
  "description": "\n\nClears all event registers and error queue. The enable registers are unaffected.\n\nEquivalent instrument command: "
 }
,
 "JTS ARFSG_DisplayEnable": {
  "prefix": "ARFSG_DisplayEnable",
  "body": [
   "ARFSG_DisplayEnable($$ARFSG_handle,$$enableDisp);"
  ],
  "description": "\n\nSpecififes whether the display is on or off.\n\nEquivalent instrument command: DISPlay[:WINDow][:STATe] ON|OFF|1|0\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ARFSG_handle\n\nObject\n\nHandle created by the ARFSG_Init() function.\n\n\n\n$enableDisp\n\nBoolean\n\nValid values are True and False.\n\nTurns instrument display On/Off.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n-\n\n-\n\n\n\n\n\nARFSG_Reset\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ARFSG_Reset": {
  "prefix": "ARFSG_Reset",
  "body": [
   "ARFSG_Reset($$ARFSG_handle);"
  ],
  "description": "\n\nPlaces the instrument in a known state and configures instrument options on which the IVI specific driver depends (for example, enabling/disabling headers). For an IEEE 488.2 instrument, Reset sends the command string "
 }
,
 "JTS BK4084_Close": {
  "prefix": "BK4084_Close",
  "body": [
   "BK4084_Close($$comPort);"
  ],
  "description": "\n\nIssues the close command to reset the BK precision 4084 to its default state. If the unit returns a successful response, a PASS result is generated, otherwise a FAIL result is returned from this function.\n\n\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$comPort\n\nObject\n\nAn instance of the SerialPort object to be used for communicating with the BK Precision 4084AWG\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nBK4084_CountClr\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS BK4084_CountClr": {
  "prefix": "BK4084_CountClr",
  "body": [
   "BK4084_CountClr($$comPort);"
  ],
  "description": "\n\nIssues the command to clear the counted values the counter. If the unit returns a successful response, a PASS result is generated, otherwise a FAIL result is returned from this function.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$comPort\n\nObject\n\nAn instance of the SerialPort object to be used for communicating with the BK Precision 4084AWG\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nBK4084_CountInit\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS BK4084_CountInit": {
  "prefix": "BK4084_CountInit",
  "body": [
   "BK4084_CountInit($$comPort);"
  ],
  "description": "\n\nIssues the command to initialize the counter and have it start counting. If the unit returns a successful response, a PASS result is generated, otherwise a FAIL result is returned from this function.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$comPort\n\nObject\n\nAn instance of the SerialPort object to be used for communicating with the BK Precision 4084AWG\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nBK4084_CountRead\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS BK4084_CountRead": {
  "prefix": "BK4084_CountRead",
  "body": [
   "$$Count_Value=BK4084_CountRead($$comPort);"
  ],
  "description": "\n\nIssues the command to stop the counter and read the current value of the counter. If the unit returns a successful response, a PASS result is generated, otherwise a FAIL result is returned from this function.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$comPort\n\nObject\n\nAn instance of the SerialPort object to be used for communicating with the BK Precision 4084AWG\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Count_Value\n\nFloat\n\nThe current value of the counter\n\n\n\n\n\nBK4084_DC\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS BK4084_DC": {
  "prefix": "BK4084_DC",
  "body": [
   "BK4084_DC($$comPort,$$Frequency,$$Vpp,$$DC_offset);"
  ],
  "description": "\n\nIssues the command to create a positive DC Waveform this would directly set the output of the function generator including its frequency, amplitude and offset.\n\nIf the unit returns a successful response, a PASS result is generated, otherwise a FAIL result is returned from this function.\n\n"
 }
,
 "JTS BK4084_Dwnramp": {
  "prefix": "BK4084_Dwnramp",
  "body": [
   "BK4084_Dwnramp($$comPort,$$Frequency,$$Vpp,$$DC_offset);"
  ],
  "description": "\n\nIssues the command to create a falling ramp Waveform this would directly set the output of the function generator including its frequency, amplitude and offset.\n\nIf the unit returns a successful response, a PASS result is generated, otherwise a FAIL result is returned from this function.\n\n\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Comport\n\nObject\n\nAn instance of the SerialPort object to be used for communicating with the BK Precision 4084AWG.\n\n\n\n$Frequency\n\nFloat\n\nThis is the frequency value of the waveform.\n\n\n\n$Vpp\n\nFloat\n\nThis is the peak to peak voltage of the waveform.\n\n\n\n$DC_Offset\n\nFloat\n\nThis is the DC Offset value of the waveform.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\nNone\n\nNone\n\n\n\n\n\nExamples:\n\nTo output a falling ramp waveform of 5kHz,3Vp-p with \u20132.5V DC offset:\n\nBK4084_Dwnramp($comport,5.0E+3,3,-2.5);\n\n\n\n\n\nBK4084_FreqMeas\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS BK4084_FreqMeas": {
  "prefix": "BK4084_FreqMeas",
  "body": [
   "$$Frequency_Measured=BK4084_FreqMeas($$comport);"
  ],
  "description": "\n\nIssues the command to enable the instrument to start a new frequency measurement and output the frequency value after frequency is measured.\n\nIf the unit returns a successful response, a PASS result is generated, otherwise a FAIL result is returned from this function.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Comport\n\nObject\n\nAn instance of the SerialPort object to be used for communicating with the BK Precision 4084AWG.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Frequency_Measured\n\nFloat\n\nThis is the frequency measured in HZ\n\n\n\n\n\nBK4084_Init\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS BK4084_Init": {
  "prefix": "BK4084_Init",
  "body": [
   "BK4084_Init($$comPort);"
  ],
  "description": "\n\nIssues the initialize command to verify that com port can communicate with signal generator. The first parameter to this function is a SerialPort object which first must be created by using the SerialOpen function. The SerialOpen function should be passed the parameters (9600,8,\"N\",1) for communication with the BK Precision 4084AWG function Generator. If the unit returns a successful response, a PASS result is generated, otherwise a FAIL result is returned from this function.\n\n\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$comPort\n\nObject\n\nAn instance of the SerialPort object to be used for communicating with the BK Precision 4084AWG\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nBK4084_Noise\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS BK4084_Noise": {
  "prefix": "BK4084_Noise",
  "body": [
   "BK4084_Noise($$comPort,$$Frequency,$$Vpp,$$DC_offset);"
  ],
  "description": "\n\nIssues the command to create a Noise Waveform this would directly set the output of the function generator including its frequency, amplitude and offset.\n\nIf the unit returns a successful response, a PASS result is generated, otherwise a FAIL result is returned from this function.\n\n"
 }
,
 "JTS BK4084_Sin": {
  "prefix": "BK4084_Sin",
  "body": [
   "BK4084_Sin($$comPort,$$Frequency,$$Vpp,$$DC_offset);"
  ],
  "description": "\n\nIssues the command to create a sine Waveform this would directly set the output of the function generator including its frequency, amplitude and offset.\n\nIf the unit returns a successful response, a PASS result is generated, otherwise a FAIL result is returned from this function.\n\n\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Comport\n\nObject\n\nAn instance of the SerialPort object to be used for communicating with the BK Precision 4084AWG.\n\n\n\n$Frequency\n\nFloat\n\nThis is the frequency value of the waveform.\n\n\n\n$Vpp\n\nFloat\n\nThis is the peak to peak voltage of the waveform.\n\n\n\n$DC_Offset\n\nFloat\n\nThis is the DC Offset value of the waveform.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\nNone\n\nNone\n\n\n\n\n\nExamples:\n\nTo output a sine waveform of 5kHz,3Vp-p with \u20132.5V DC offset:\n\nBK4084_Sin($comport,5.0E+3,3,-2.5);\n\n\n\n\n\nBK4084_Squ\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS BK4084_Squ": {
  "prefix": "BK4084_Squ",
  "body": [
   "BK4084_Squ($$comPort,$$Frequency,$$Vpp,$$DC_offset);"
  ],
  "description": "\n\nIssues the command to create a square Waveform this would directly set the output of the function generator including its frequency, amplitude and offset.\n\nIf the unit returns a successful response, a PASS result is generated, otherwise a FAIL result is returned from this function.\n\n\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Comport\n\nObject\n\nAn instance of the SerialPort object to be used for communicating with the BK Precision 4084AWG.\n\n\n\n$Frequency\n\nFloat\n\nThis is the frequency value of the waveform.\n\n\n\n$Vpp\n\nFloat\n\nThis is the peak to peak voltage of the waveform.\n\n\n\n$DC_Offset\n\nFloat\n\nThis is the DC Offset value of the waveform.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\nNone\n\nNone\n\n\n\n\n\nExamples:\n\nTo output a square waveform of 5kHz,3Vp-p with \u20132.5V DC offset:\n\nBK4084_Squ($comport,5.0E+3,3,-2.5);\n\n\n\n\n\nBK4084_Tri\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS BK4084_Tri": {
  "prefix": "BK4084_Tri",
  "body": [
   "BK4084_Tri($$comPort,$$Frequency,$$Vpp,$$DC_offset);"
  ],
  "description": "\n\nIssues the command to create a triangle Waveform this would directly set the output of the function generator including its frequency, amplitude and offset.\n\nIf the unit returns a successful response, a PASS result is generated, otherwise a FAIL result is returned from this function.\n\n\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Comport\n\nObject\n\nAn instance of the SerialPort object to be used for communicating with the BK Precision 4084AWG.\n\n\n\n$Frequency\n\nFloat\n\nThis is the frequency value of the waveform.\n\n\n\n$Vpp\n\nFloat\n\nThis is the peak to peak voltage of the waveform.\n\n\n\n$DC_Offset\n\nFloat\n\nThis is the DC Offset value of the waveform.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\nNone\n\nNone\n\n\n\n\n\nExamples:\n\nTo output a triangle waveform of 5kHz,3Vp-p with \u20132.5V DC offset:\n\nBK4084_Tri($comport,5.0E+3,3,-2.5);\n\n\n\n\n\nBK4084_Upramp\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS BK4084_Upramp": {
  "prefix": "BK4084_Upramp",
  "body": [
   "BK4084_Upramp($$comPort,$$Frequency,$$Vpp,$$DC_offset);"
  ],
  "description": "\n\nIssues the command to create a Ramp Waveform this would directly set the output of the function generator including its frequency, amplitude and offset.\n\nIf the unit returns a successful response, a PASS result is generated, otherwise a FAIL result is returned from this function.\n\n\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Comport\n\nObject\n\nAn instance of the SerialPort object to be used for communicating with the BK Precision 4084AWG.\n\n\n\n$Frequency\n\nFloat\n\nThis is the frequency value of the waveform.\n\n\n\n$Vpp\n\nFloat\n\nThis is the peak to peak voltage of the waveform.\n\n\n\n$DC_Offset\n\nFloat\n\nThis is the DC Offset value of the waveform.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\nNone\n\nNone\n\n\n\n\n\nExamples:\n\nTo output a ramp waveform of 5kHz,3Vp-p with \u20132.5V DC offset:\n\nBK4084_Upramp($comport,5.0E+3,3,-2.5);\n\n\n\n\n\nNI_Fgen_AdjustSampleClockRelativeDelay\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_Fgen_AdjustSampleClockRelativeDelay": {
  "prefix": "NI_Fgen_AdjustSampleClockRelativeDelay",
  "body": [
   "NI_Fgen_AdjustSampleClockRelativeDelay($$NI_FgenHandle,$$adjustmentTime);"
  ],
  "description": "\n\nThis function requires NI FGEN drivers to be installed on the system.\n\nThis function delays (or phase shifts) the sample clock, which delays the output of the module. Delaying the sample clock can be useful when lining up the output of multiple modules or when intentionally phase shifting the output relative to a fixed reference such as the PLL reference clock.\n\nAdjustment time can be positive or negative, but it must be less than or equal to the sample clock period. The delay takes effect immediately after this function is called.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PXI-5412 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Fgen functions, Jabil Test will fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\nNI_Fgen_AdjustSampleClockRelativeDelay($NI_FgenHandle, $adjustmentTime);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_FgenHandle\n\nObject\n\nThe instrument handle you obtain from NI_Fgen_Initialize that identifies a particular instrument's session.\n\n\n\n$adjustmentTime\n\nFloat\n\nThe amount of time to adjust the sample clock delay in seconds.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n\n\nExample:\n\n$adjustmentTime = New(\"Float\", 0.0);\n\nNI_Fgen_AdjustSampleClockRelativeDelay($NI_FgenHandle, $adjustmentTime);\n\n\n\n\n\nNI_Fgen_ClearArbMemory\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_Fgen_ClearArbMemory": {
  "prefix": "NI_Fgen_ClearArbMemory",
  "body": [
   "NI_Fgen_ClearArbMemory($$NI_FgenHandle);"
  ],
  "description": "\n\nThis function requires NI FGEN drivers to be installed on the system.\n\nThis function removes all previously created arbitrary waveforms and sequences from the signal generator memory, and invalidates all waveform and sequence handles.\n\nRemarks:\n\n\u00b7 This function is tested with a NI PXI-5412 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Fgen functions, Jabil Test will fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\u00b7 The signal generator must not be in the generating state when you call this function.\n\n\n\nResult:\n\nNI_Fgen_ClearArbMemory($NI_FgenHandle);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_FgenHandle\n\nObject\n\nThe instrument handle you obtain from NI_Fgen_Initialize that identifies a particular instrument's session.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n\n\nExample:\n\nNI_Fgen_ClearArbMemory($NI_FgenHandle);\n\n\n\n\n\nNI_Fgen_ClearUserStandardWaveform\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_Fgen_ClearUserStandardWaveform": {
  "prefix": "NI_Fgen_ClearUserStandardWaveform",
  "body": [
   "NI_Fgen_ClearUserStandardWaveform($$NI_FgenHandle,$$ChannelName);"
  ],
  "description": "\n\nThis function requires NI FGEN drivers to be installed on the system.\n\nThis function clears the user-defined waveform created by NI_Fgen_DefineUserStandardWaveform.\n\nRemarks:\n\n\u00b7 This function is tested with a NI PXI-5412 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Fgen functions, Jabil Test will fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\nNI_Fgen_ClearUserStandardWaveform($NI_FgenHandle, $ChannelName);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_FgenHandle\n\nObject\n\nThe instrument handle you obtain from NI_Fgen_Initialize that identifies a particular instrument's session.\n\n\n\n$ChannelName\n\nString\n\nPass the channel name for which you want to configure a standard waveform.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n\n\nExample:\n\nNI_Fgen_ClearUserStandardWaveform($NI_FgenHandle, \"0\");\n\n\n\n\n\nNI_Fgen_Close\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_Fgen_Close": {
  "prefix": "NI_Fgen_Close",
  "body": [
   "NI_Fgen_Close($$NI_FgenHandle);"
  ],
  "description": "\n\nThis function requires NI FGEN drivers to be installed on the system.\n\nThis function closes the instrument I/O session created with NI_Fgen_Initialize. It deallocates any memory resources NI-FGEN uses.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PXI-5412 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Fgen functions, Jabil Test will fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\nNI_Fgen_Close($NI_FgenHandle);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_FgenHandle\n\nObject\n\nThe instrument handle you obtain from NI_Fgen_Initialize that identifies a particular instrument's session.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n\n\nExample:\n\nNI_Fgen_Close($NI_FgenHandle);\n\n\n\n\n\nNI_Fgen_ConfigureAmplitude\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_Fgen_ConfigureAmplitude": {
  "prefix": "NI_Fgen_ConfigureAmplitude",
  "body": [
   "NI_Fgen_ConfigureAmplitude($$NI_FgenHandle,$$ChannelName,$$Amplitude);"
  ],
  "description": "\n\nThis function requires NI FGEN drivers to be installed on the system.\n\nThis function configures the amplitude of the standard waveform that you want the signal generator to produce.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PXI-5412 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Fgen functions, Jabil Test will fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\nNI_Fgen_ConfigureAmplitude($NI_FgenHandle, $ChannelName, $Amplitude);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_FgenHandle\n\nObject\n\nThe instrument handle you obtain from NI_Fgen_Initialize that identifies a particular instrument's session.\n\n\n\n$ChannelName\n\nString\n\nPass the channel name for which you want to configure a standard waveform.\n\n\n\n$Amplitude\n\nFloat\n\nThe peak-to-peak amplitude of the generated waveform in volts.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n\n\nExample:\n\nNI_Fgen_ConfigureAmplitude($NI_FgenHandle, \"0\", 2.0);\n\n\n\n\n\nNI_Fgen_ConfigureArbWaveform\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_Fgen_ConfigureArbWaveform": {
  "prefix": "NI_Fgen_ConfigureArbWaveform",
  "body": [
   "NI_Fgen_ConfigureArbWaveform($$NI_FgenHandle,$$ChannelName,$$WaveformHandle,$$Gain,$$Offset);"
  ],
  "description": "\n\nThis function requires NI FGEN drivers to be installed on the system.\n\nThis function configures the attributes of the signal generator that affect arbitrary waveform generation. These attributes are the arbitrary waveform handle, gain, and offset.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PXI-5412 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Fgen functions, Jabil Test will fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\u00b7 The signal generator must not be in the generating state when you call this function.\n\n\u00b7 You must set the output mode to \"ARB\" before calling this function.\n\n\n\nResult:\n\nNI_Fgen_ConfigureArbWaveform($NI_FgenHandle, $ChannelName, $WaveformHandle, $Gain, $Offset);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_FgenHandle\n\nObject\n\nThe instrument handle you obtain from NI_Fgen_Initialize that identifies a particular instrument's session.\n\n\n\n$ChannelName\n\nString\n\nPass the channel name for which you want to configure a standard waveform.\n\n\n\n$WaveformHandle\n\nInteger\n\nPass the handle of the arbitrary waveform that you want the signal generator to remove. You can create multiple arbitrary waveforms using one of the following niFgen Create Waveform functions:\n\n\u00b7 NI_Fgen_CreateWaveformF64\n\n\u00b7 NI_Fgen_CreateWaveformI16\n\n\u00b7 NI_Fgen_CreateWaveformFromFileI16\n\n\u00b7 NI_Fgen_CreateWaveformFromFileF64\n\nNI_Fgen_CreateWaveformFromFileHWS\n\n\n\n$Gain\n\nFloat\n\nSpecifies the factor by which the signal generator scales the arbitrary waveform data. When you create arbitrary waveforms, you must first normalize the data points to a range of \u20131.00 V to +1.00 V. For example, to configure the output signal to range from \u20132.00 V to +2.00 V, set the gain to 2.00.\n\nUnit : V\n\n\n\n$Offset\n\nFloat\n\nSpecifies the value the signal generator adds to the arbitrary waveform data. When you create arbitrary waveforms, you must first normalize the data points to a range of \u20131.00 V to +1.00 V. You can use this parameter to shift the range of the arbitrary waveform. NI-FGEN sets NIFGEN_ATTR_ARB_OFFSET to this value.\n\nFor example, to configure the output signal to range from 0.00 V to 2.00 V instead of \u20131.00 V to 1.00 V, set the offset to 1.00.\n\nUnit : V\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n\n\nExample:\n\nNI_Fgen_ConfigureArbWaveform($NI_FgenHandle, \"0\", $WaveformHandle, 1.0, 1.0);\n\n\n\n\n\nNI_Fgen_ConfigureClockMode\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_Fgen_ConfigureClockMode": {
  "prefix": "NI_Fgen_ConfigureClockMode",
  "body": [
   "NI_Fgen_ConfigureClockMode($$NI_FgenHandle,$$ClockMode);"
  ],
  "description": "\n\nThis function requires NI FGEN drivers to be installed on the system.\n\nThis function selects the clock mode for the signal generator. For signal generators that support it, this function allows you to switch the sample clock to High-Resolution Sampling mode. When in Divide-Down Sampling mode, you can only set the sample rate to certain frequencies, based on dividing down the update clock. However, in High-Resolution Sampling mode, you can set the sample rate to any value. You must set the output mode to arbitrary waveform output or arbitrary sequence output before calling this function.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PXI-5412 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Fgen functions, Jabil Test will fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\nNI_Fgen_ConfigureClockMode($NI_FgenHandle, $ClockMode);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_FgenHandle\n\nObject\n\nThe instrument handle you obtain from NI_Fgen_Initialize that identifies a particular instrument's session.\n\n\n\n$ClockMode\n\nString\n\nSets the clock mode of the signal generator.\n\nValid value(s) :\n\n\u00b7 \"DIVIDE DOWN\"\n\n\u00b7 \"HIGH RESOLUTION\"\n\n\u00b7 \"AUTOMATIC\"\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n\n\nExample:\n\nNI_Fgen_ConfigureClockMode($NI_FgenHandle, \"AUTOMATIC\");\n\n\n\n\n\nNI_Fgen_ConfigureFrequency\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_Fgen_ConfigureFrequency": {
  "prefix": "NI_Fgen_ConfigureFrequency",
  "body": [
   "NI_Fgen_ConfigureFrequency($$NI_FgenHandle,$$ChannelName,$$Frequency);"
  ],
  "description": "\n\nThis function requires NI FGEN drivers to be installed on the system.\n\nThis function configures the frequency of the standard waveform that you want the signal generator to produce.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PXI-5412 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Fgen functions, Jabil Test will fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\nNI_Fgen_ConfigureFrequency($NI_FgenHandle, $ChannelName, $Frequency);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_FgenHandle\n\nObject\n\nThe instrument handle you obtain from NI_Fgen_Initialize that identifies a particular instrument's session.\n\n\n\n$ChannelName\n\nString\n\nPass the channel name for which you want to configure a standard waveform.\n\n\n\n$Frequency\n\nFloat\n\nPass the frequency of the standard waveform that you want the signal generator to produce. This parameter does not affect signal generator behavior when you set the waveform parameter to DC voltage.\n\nUnit : Hz\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n\n\nExample:\n\nNI_Fgen_ConfigureFrequency($NI_FgenHandle, \"0\", 1000.0);\n\n\n\n\n\nNI_Fgen_ConfigureGain\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_Fgen_ConfigureGain": {
  "prefix": "NI_Fgen_ConfigureGain",
  "body": [
   "NI_Fgen_ConfigureGain($$NI_FgenHandle,$$ChannelName,$$Gain);"
  ],
  "description": "\n\nThis function requires NI FGEN drivers to be installed on the system.\n\nThis function configures the amount of gain to apply to the waveform.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PXI-5412 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Fgen functions, Jabil Test will fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\nNI_Fgen_ConfigureGain($NI_FgenHandle, $ChannelName, $Gain);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_FgenHandle\n\nObject\n\nThe instrument handle you obtain from NI_Fgen_Initialize that identifies a particular instrument's session.\n\n\n\n$ChannelName\n\nString\n\nPass the channel name for which you want to configure a standard waveform.\n\n\n\n$Gain\n\nFloat\n\nSpecifies the factor by which the signal generator scales the arbitrary waveform data. When you create arbitrary waveforms, you must first normalize the data points to a range of \u20131.00 V to +1.00 V. For example, to configure the output signal to range from \u20132.00 V to +2.00 V, set the gain to 2.00.\n\nUnit : V\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n\n\nExample:\n\nNI_Fgen_ConfigureGain($NI_FgenHandle, \"0\", 2.0);\n\n\n\n\n\nNI_Fgen_ConfigureOperationMode\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_Fgen_ConfigureOperationMode": {
  "prefix": "NI_Fgen_ConfigureOperationMode",
  "body": [
   "NI_Fgen_ConfigureOperationMode($$NI_FgenHandle,$$ChannelName,$$OperationMode);"
  ],
  "description": "\n\nThis function requires NI FGEN drivers to be installed on the system.\n\nThis function determines how the signal generator produces waveforms. NI signal generators currently support only one value.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PXI-5412 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Fgen functions, Jabil Test will fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\nNI_Fgen_ConfigureOperationMode($NI_FgenHandle, $ChannelName, $OperationMode);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_FgenHandle\n\nObject\n\nThe instrument handle you obtain from NI_Fgen_Initialize that identifies a particular instrument's session.\n\n\n\n$ChannelName\n\nString\n\nPass the channel name for which you want to configure a standard waveform.\n\n\n\n$OperationMode\n\nString\n\nPass the operation mode you want the signal generator to use.\n\nValid value(s):\n\n\u00b7 \"CONTINUOUS\"\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n\n\nExample:\n\nNI_Fgen_ConfigureOperationMode($NI_FgenHandle, \"0\", \"CONTINUOUS\");\n\n\n\n\n\nNI_Fgen_ConfigureOutputEnabled\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_Fgen_ConfigureOutputEnabled": {
  "prefix": "NI_Fgen_ConfigureOutputEnabled",
  "body": [
   "NI_Fgen_ConfigureOutputEnabled($$NI_FgenHandle,$$ChannelName,$$Enabled);"
  ],
  "description": "\n\nThis function requires NI FGEN drivers to be installed on the system.\n\nThis function enables or disables the signal generator output.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PXI-5412 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Fgen functions, Jabil Test will fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\nNI_Fgen_ConfigureOutputEnabled($NI_FgenHandle, $ChannelName, $Enabled);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_FgenHandle\n\nObject\n\nThe instrument handle you obtain from NI_Fgen_Initialize that identifies a particular instrument's session.\n\n\n\n$ChannelName\n\nString\n\nPass the channel name for which you want to enable or disable the output.\n\n\n\n$Enabled\n\nBoolean\n\nPass whether you want to enable or disable the output.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n\n\nExample:\n\nNI_Fgen_ConfigureOutputEnabled($NI_FgenHandle, \"0\", \"true\");\n\n\n\n\n\nNI_Fgen_ConfigureOutputImpedance\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_Fgen_ConfigureOutputImpedance": {
  "prefix": "NI_Fgen_ConfigureOutputImpedance",
  "body": [
   "NI_Fgen_ConfigureOutputImpedance($$NI_FgenHandle,$$ChannelName,$$Impedance);"
  ],
  "description": "\n\nThis function requires NI FGEN drivers to be installed on the system.\n\nThis function configures the output impedance for the channel you specify.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PXI-5412 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Fgen functions, Jabil Test will fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\nNI_Fgen_ConfigureOutputImpedance($NI_FgenHandle, $ChannelName, $Impedance);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_FgenHandle\n\nObject\n\nThe instrument handle you obtain from NI_Fgen_Initialize that identifies a particular instrument's session.\n\n\n\n$ChannelName\n\nString\n\nPass the channel name for which you want to configure a standard waveform.\n\n\n\n$Impedance\n\nFloat\n\nPass the impedance value that you want the signal generator to use.\n\nUnit : ohm\n\nValid value(s) :\n\n\u00b7 50 OHMS\n\n\u00b7 75 OHMS\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n\n\nExample:\n\nNI_Fgen_ConfigureOutputImpedance($NI_FgenHandle, \"0\", \"75 OHMS\");\n\n\n\n\n\nNI_Fgen_ConfigureOutputMode\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_Fgen_ConfigureOutputMode": {
  "prefix": "NI_Fgen_ConfigureOutputMode",
  "body": [
   "NI_Fgen_ConfigureOutputMode($$NI_FgenHandle,$$OutputMode);"
  ],
  "description": "\n\nThis function requires NI FGEN drivers to be installed on the system.\n\nThis function configures the output mode of the signal generator. The output mode determines how the signal generator produces waveforms.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PXI-5412 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Fgen functions, Jabil Test will fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\nNI_Fgen_ConfigureOutputMode($NI_FgenHandle, $OutputMode);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_FgenHandle\n\nObject\n\nThe instrument handle you obtain from NI_Fgen_Initialize that identifies a particular instrument's session.\n\n\n\n$OutputMode\n\nString\n\nSpecifies the output mode that you want the signal generator to use. The value you specify determines which functions and attributes you can use to configure the waveform the signal generator produces.\n\nValid values:\n\n\u00b7 \"FUNC\" (standard function output)\n\n\u00b7 \"ARB\" (arbitrary waveform output)\n\n\u00b7 \"FREQ LIST\" (frequency list output)\n\n\u00b7 \"SCRIPT\" (script output)\n\n\u00b7 \"SEQ\" (arbitrary sequence output)\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n\n\nExample:\n\nNI_Fgen_ConfigureOutputMode($NI_FgenHandle, \"FUNC\");\n\n\n\n\n\nNI_Fgen_ConfigureRefClockFrequency\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_Fgen_ConfigureRefClockFrequency": {
  "prefix": "NI_Fgen_ConfigureRefClockFrequency",
  "body": [
   "NI_Fgen_ConfigureRefClockFrequency($$NI_FgenHandle,$$RefClockFrequency);"
  ],
  "description": "\n\nThis function requires NI FGEN drivers to be installed on the system.\n\nThis function configures the signal generator reference clock frequency. The signal generator uses the reference clock to derive frequencies and sample rates when generating waveforms.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PXI-5412 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Fgen functions, Jabil Test will fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\u00b7 The signal generator must not be in the generating state when you call this function.\n\n\n\nResult:\n\nNI_Fgen_ConfigureRefClockFrequency($NI_FgenHandle, $RefClockFrequency);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_FgenHandle\n\nObject\n\nThe instrument handle you obtain from NI_Fgen_Initialize that identifies a particular instrument's session.\n\n\n\n$RefClockFrequency\n\nFloat\n\nPass the reference clock frequency .\n\nUnit : Hz\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n\n\nExample:\n\nNI_Fgen_ConfigureRefClockFrequency($NI_FgenHandle, 1000000.0);\n\n\n\n\n\nNI_Fgen_ConfigureRefClockSource\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_Fgen_ConfigureRefClockSource": {
  "prefix": "NI_Fgen_ConfigureRefClockSource",
  "body": [
   "NI_Fgen_ConfigureRefClockSource($$NI_FgenHandle,$$RefClockSource);"
  ],
  "description": "\n\nThis function requires NI FGEN drivers to be installed on the system.\n\nThis function configures the signal generator reference clock source. The signal generator uses the reference clock to derive frequencies and sample rates when generating waveforms.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PXI-5412 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Fgen functions, Jabil Test will fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\nNI_Fgen_ConfigureRefClockSource($NI_FgenHandle, $RefClockSource);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_FgenHandle\n\nObject\n\nThe instrument handle you obtain from NI_Fgen_Initialize that identifies a particular instrument's session.\n\n\n\n$RefClockSource\n\nString\n\nPass the reference clock source that you want the signal generator to use.\n\nValid value(s) :\n\n\u00b7 \"INTERNAL CLOCK\" (Internal clock source)\n\n\u00b7 \"EXTERNAL CLOCK\" (External clock source)\n\n\u00b7 \"RTSI CLOCK\" (RTSI clock)\n\n\u00b7 \"TTL7 LINE\"\n\n\u00b7 \"PXI 10MHZ CLOCK\"\n\n\u00b7 \"REF IN\" (External clock source)\n\n\u00b7 \"RTSI0\"\n\n\u00b7 \"RTSI1\"\n\n\u00b7 \"RTSI2\"\n\n\u00b7 \"RTSI3\"\n\n\u00b7 \"RTSI4\"\n\n\u00b7 \"RTSI5\"\n\n\u00b7 \"RTSI6\"\n\n\u00b7 \"RTSI7\"\n\n\u00b7 \"CLK IN\" (CLK IN front panel connector)\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n\n\nExample:\n\nNI_Fgen_ConfigureRefClockSource($NI_FgenHandle, \"INTERNAL CLOCK\");\n\n\n\n\n\nNI_Fgen_ConfigureSampleRate\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_Fgen_ConfigureSampleRate": {
  "prefix": "NI_Fgen_ConfigureSampleRate",
  "body": [
   "NI_Fgen_ConfigureSampleRate($$NI_FgenHandle,$$SampleRate);"
  ],
  "description": "\n\nThis function requires NI FGEN drivers to be installed on the system.\n\nThis function configures the sample rate attribute, which determines the rate at which the signal generator produces arbitrary waveforms. When you configure the signal generator to produce an arbitrary sequence, this is the sample rate for all arbitrary waveforms in the sequence. You must set the output mode to arbitrary waveform output or arbitrary sequence output before calling this function.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PXI-5412 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Fgen functions, Jabil Test will fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\u00b7 The signal generator must not be in the generating state when you call this function.\n\n\u00b7 You must set the output mode to \"ARB\" or \"SEQ\" before calling this function.\n\n\n\nResult:\n\nNI_Fgen_ConfigureSampleRate($NI_FgenHandle, $SampleRate);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_FgenHandle\n\nObject\n\nThe instrument handle you obtain from NI_Fgen_Initialize that identifies a particular instrument's session.\n\n\n\n$SampleRate\n\nFloat\n\nPass the sample rate at which you want the signal generator to generate arbitrary waveforms.\n\nUnit : S/s\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n\n\nExample:\n\nNI_Fgen_ConfigureSampleRate($NI_FgenHandle, 40000000.0);\n\n\n\n\n\nNI_Fgen_ConfigureStandardWaveform\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_Fgen_ConfigureStandardWaveform": {
  "prefix": "NI_Fgen_ConfigureStandardWaveform",
  "body": [
   "NI_Fgen_ConfigureStandardWaveform($$NI_FgenHandle,$$ChannelName,$$WaveForm,$$Amplitude,$$DC_Offset,$$Frequency,$$StartPhase);"
  ],
  "description": "\n\nThis function requires NI FGEN drivers to be installed on the system.\n\nThis function configures the attributes of the signal generator that affect standard waveform generation. These attributes are the waveform, amplitude, DC offset, frequency and start phase. The output mode must be set to standard function output with the function NI_Fgen_ConfigureOutputMode.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PXI-5412 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Fgen functions, Jabil Test will fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\u00b7 The signal generator must not be in the generating state when you call this function.\n\n\u00b7 You must set the output mode to standard function output before calling this function with the function NI_Fgen_ConfigureOutputMode.\n\n\n\nResult:\n\nNI_Fgen_ConfigureStandardWaveform($NI_FgenHandle, $ChannelName, $WaveForm, $Amplitude, $DC_Offset, $Frequency, $StartPhase);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_FgenHandle\n\nObject\n\nThe instrument handle you obtain from NI_Fgen_Initialize that identifies a particular instrument's session.\n\n\n\n$ChannelName\n\nString\n\nPass the channel name for which you want to configure a standard waveform.\n\n\n\n$WaveForm\n\nString\n\nPass the standard waveform that you want the signal generator to produce.\n\nValid values:\n\n\u00b7 \"SINE\" (Sinusoid waveform)\n\n\u00b7 \"SQUARE\" (Square waveform)\n\n\u00b7 \"TRIANGLE\" (Triangle waveform)\n\n\u00b7 \"RAMP UP\" (Positive ramp waveform)\n\n\u00b7 \"RAMP DOWN\" (Negative ramp waveform)\n\n\u00b7 \"DC\" (Constant voltage)\n\n\u00b7 \"NOISE\" (White noise)\n\n\u00b7 \"USER\" (User-defined waveform as defined with NI_Fgen_DefineUserStandardWaveform)\n\n\n\n$Amplitude\n\nFloat\n\nPass the amplitude of the standard waveform that you want the signal generator to produce. This value is the amplitude at the output terminal. For example, to produce a waveform ranging from \u20135.00 V to +5.00 V, set the amplitude to 10.00 V.\n\nUnit : Vpk-pk\n\n\n\n$DC_Offset\n\nFloat\n\nPass the DC offset of the standard waveform that you want the signal generator to produce. This value is the offset at the output terminal. The value is the offset from ground to the center of the waveform you specify with the waveform parameter.\n\nUnit : V\n\n\n\n$Frequency\n\nFloat\n\nPass the frequency of the standard waveform that you want the signal generator to produce.\n\nUnit : Hz\n\n\n\n$StartPhase\n\nFloat\n\nPass the horizontal offset of the standard waveform you want the signal generator to produce. Specify this attribute in degrees of one waveform cycle. A start phase of 180 degrees means output generation begins halfway through the waveform. A start phase of 360 degrees offsets the output by an entire waveform cycle, which is identical to a start phase of 0 degrees.\n\nUnit : degrees of one cycle\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n\n\nExample:\n\nNI_Fgen_ConfigureStandardWaveform($NI_FgenHandle, \"0\", \"sine\", 1.0, 0.0, 1000.0, 0.0);\n\n\n\n\n\nNI_Fgen_ConfigureTriggerMode\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_Fgen_ConfigureTriggerMode": {
  "prefix": "NI_Fgen_ConfigureTriggerMode",
  "body": [
   "NI_Fgen_ConfigureTriggerMode($$NI_FgenHandle,$$ChannelName,$$TriggerMode);"
  ],
  "description": "\n\nThis function requires NI FGEN drivers to be installed on the system.\n\nThis function sets the trigger mode.\n\nSupported trigger modes are:\n\n\u00b7 Single Trigger mode : The waveform that you describe in the sequence list generates only once by going through the entire staging list. Only one trigger is required to start the waveform generation. You can use single trigger mode with the output mode in any mode. After a trigger is received, the waveform generation starts from the first stage and continues through to the last stage.\n\n\u00b7 Continuous Trigger mode : The waveform that you describe in the staging list generates infinitely by repeatedly cycling through the staging list. After a trigger is received, the waveform generation starts from the first stage and continues through to the last stage. After the last stage is completed, the waveform generation loops back to the start of the first stage and continues until it is stopped. Only one trigger is required to start the waveform generation.\n\n\u00b7 Stepped Trigger mode : After a start trigger is received, the waveform described by the first stage generates. Then, the device waits for the next trigger signal. On the next trigger, the waveform described by the second stage generates, and so on. Once the staging list is exhausted, the waveform generation returns to the first stage and continues to repeat the cycle.\n\n\u00b7 Burst Trigger mode : After a start trigger is received, the waveform described by the first stage generates until another trigger is received. At the next trigger, the buffer of the previous stage completes, and then the waveform described by the second stage generates. Once the staging list is exhausted, the waveform generation returns to the first stage and continues to repeat the cycle. In Frequency List mode, the duration instruction is ignored, and the trigger switches the frequency to the next frequency in the list.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PXI-5412 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Fgen functions, Jabil Test will fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\nNI_Fgen_ConfigureTriggerMode($NI_FgenHandle, $ChannelName, $TriggerMode);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_FgenHandle\n\nObject\n\nThe instrument handle you obtain from NI_Fgen_Initialize that identifies a particular instrument's session.\n\n\n\n$ChannelName\n\nString\n\nPass the channel name for which you want to configure a standard waveform.\n\n\n\n$TriggerMode\n\nString\n\nPass the trigger mode.\n\nValid value(s) :\n\n\u00b7 \"SINGLE\"\n\n\u00b7 \"CONTINUOUS\"\n\n\u00b7 \"STEPPED\"\n\n\u00b7 \"BURST\"\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n\n\nExample:\n\nNI_Fgen_ConfigureTriggerMode($NI_FgenHandle, \"0\", \"CONTINUOUS\");\n\n\n\n\n\nNI_Fgen_ConfigureTriggerSource\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_Fgen_ConfigureTriggerSource": {
  "prefix": "NI_Fgen_ConfigureTriggerSource",
  "body": [
   "NI_Fgen_ConfigureTriggerSource($$NI_FgenHandle,$$ChannelName,$$TriggerSource);"
  ],
  "description": "\n\nThis function requires NI FGEN drivers to be installed on the system.\n\nThis function configures the trigger source. The signal generator responds to a trigger depending on the operation mode in which the signal generator is operating.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PXI-5412 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Fgen functions, Jabil Test will fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\u00b7 The signal generator must not be in the generating state when you call this function.\n\n\n\nResult:\n\nNI_Fgen_ConfigureTriggerSource($NI_FgenHandle, $ChannelName, $TriggerSource);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_FgenHandle\n\nObject\n\nThe instrument handle you obtain from NI_Fgen_Initialize that identifies a particular instrument's session.\n\n\n\n$ChannelName\n\nString\n\nPass the channel name for which you want to configure a standard waveform.\n\n\n\n$TriggerSource\n\nString\n\nControls which trigger source the signal generator uses.\n\nValid value(s) :\n\n\u00b7 \"IMMEDIATE\"\n\n\u00b7 \"EXTERNAL\"\n\n\u00b7 \"SOFTWARE TRIG\"\n\n\u00b7 \"PXI STAR\"\n\n\u00b7 \"RTSI 0\"\n\n\u00b7 \"RTSI 1\"\n\n\u00b7 \"RTSI 2\"\n\n\u00b7 \"RTSI 3\"\n\n\u00b7 \"RTSI 4\"\n\n\u00b7 \"RTSI 5\"\n\n\u00b7 \"RTSI 6\"\n\n\u00b7 \"RTSI 7\"\n\n\u00b7 \"TTL0\"\n\n\u00b7 \"TTL1\"\n\n\u00b7 \"TTL2\"\n\n\u00b7 \"TTL3\"\n\n\u00b7 \"TTL4\"\n\n\u00b7 \"TTL5\"\n\n\u00b7 \"TTL6\"\n\n\u00b7 \"PFI 0\"\n\n\u00b7 \"PFI 1\"\n\n\u00b7 \"PFI 2\"\n\n\u00b7 \"PFI 3\"\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n\n\nExample:\n\nNI_Fgen_ConfigureTriggerSource($NI_FgenHandle, \"0\", \"IMMEDIATE\");\n\n\n\n\n\nNI_Fgen_ConfigureUpdateClockSource\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_Fgen_ConfigureUpdateClockSource": {
  "prefix": "NI_Fgen_ConfigureUpdateClockSource",
  "body": [
   "NI_Fgen_ConfigureUpdateClockSource($$NI_FgenHandle,$$UpdateClockSource);"
  ],
  "description": "\n\nThis function requires NI FGEN drivers to be installed on the system.\n\nThis function sets the source of the update clock of the signal generator. The source can be internal or external.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PXI-5412 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Fgen functions, Jabil Test will fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\nNI_Fgen_ConfigureUpdateClockSource($NI_FgenHandle, $UpdateClockSource);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_FgenHandle\n\nObject\n\nThe instrument handle you obtain from NI_Fgen_Initialize that identifies a particular instrument's session.\n\n\n\n$UpdateClockSource\n\nString\n\nSpecifies the update clock source. Possible values:\n\n\u00b7 \"EXTERNAL CLOCK\"\n\n\u00b7 \"INTERNAL CLOCK\"\n\n\u00b7 \"PXI STAR\"\n\n\u00b7 \"RTSI0\"\n\n\u00b7 \"RTSI1\"\n\n\u00b7 \"RTSI2\"\n\n\u00b7 \"RTSI3\"\n\n\u00b7 \"RTSI4\"\n\n\u00b7 \"RTSI5\"\n\n\u00b7 \"RTSI6\"\n\n\u00b7 \"RTSI7\"\n\n\u00b7 \"CLK IN\"\n\n\u00b7 \"DDC CLOCK IN\"\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n\n\nExample:\n\n$UpdateClockSource = New(\"String\", \"INTERNAL CLOCK\");\n\nNI_Fgen_ConfigureUpdateClockSource($NI_FgenHandle, $UpdateClockSource);\n\n\n\n\n\nNI_Fgen_CreateWaveformFromFileF64\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_Fgen_CreateWaveformFromFileF64": {
  "prefix": "NI_Fgen_CreateWaveformFromFileF64",
  "body": [
   "$$WaveformHandle=NI_Fgen_CreateWaveformFromFileF64($$NI_FgenHandle,$$ChannelName,$$WfmFile,$$ByteOrder);"
  ],
  "description": "\n\nThis function requires NI FGEN drivers to be installed on the system.\n\nThis function takes the F64 (floating point double) data from the specified file and creates an onboard waveform for use in Arbitrary Waveform mode or Arbitrary Sequence mode. The waveform handle returned can be used later for setting the active waveform, changing the data in the waveform, building sequences of waveforms or even deleting the waveform when it is no longer needed.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PXI-5412 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Fgen functions, Jabil Test will fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\n$WaveformHandle = NI_Fgen_CreateWaveformFromFileF64($NI_FgenHandle, $ChannelName, $WfmFile, $ByteOrder);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_FgenHandle\n\nObject\n\nThe instrument handle you obtain from NI_Fgen_Initialize that identifies a particular instrument's session.\n\n\n\n$ChannelName\n\nString\n\nPass the channel name for which you want to create a waveform.\n\n\n\n$WfmFile\n\nString\n\nThe full path and name of the file where the waveform data resides.\n\n\n\n$ByteOrder\n\nString\n\nSpecifies the byte order of the data in the file. Big Endian and Little Endian refer to the way data is stored in memory, which can differ on different processors.\n\nValid value(s) :\n\n\u00b7 \"BIG ENDIAN\"\n\n\u00b7 \"LITTLE ENDIAN\"\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$WaveformHandle\n\nInteger\n\nThe handle that identifies the new waveform. This handle is used later when referring to this waveform.\n\n\n\n\n\nExample:\n\n$WaveformHandle = NI_Fgen_CreateWaveformFromFileF64($NI_FgenHandle, \"0\", \"C:\\\\work\\\\NI Signal Generator Functions\\\\sine.bin\", \"BIG ENDIAN\");\n\n\n\n\n\nNI_Fgen_CreateWaveformFromFileHWS\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_Fgen_CreateWaveformFromFileHWS": {
  "prefix": "NI_Fgen_CreateWaveformFromFileHWS",
  "body": [
   "$$WaveformHandle=NI_Fgen_CreateWaveformFromFileHWS($$NI_FgenHandle,$$ChannelName,$$HwsFile,$$UseRateFromWaveform,$$UseGainOffsetFromWaveform);"
  ],
  "description": "\n\nThis function requires NI FGEN drivers to be installed on the system.\n\nThis function takes the waveform data from the specified HWS (Hierarchical Waveform Storage) file and creates an onboard waveform for use in Arbitrary Waveform mode or Arbitrary Sequence mode. The waveform handle returned by the function can be used later for setting the active waveform, changing the data in the waveform, building sequences of waveforms or even deleting the waveform when it is no longer needed. When the Analog Waveform Editor saves data in an HWS file, it also stores the rate, gain and offset with the data. If the Use Rate from Waveform and Use Gain and Offset from Waveform inputs are set to True, this function will also set those properties on NI-FGEN.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PXI-5412 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Fgen functions, Jabil Test will fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\u00b7 If you choose to have this function set the gain and offset properties for you, you should NOT use the niFgen Configure Arbitrary Waveform or niFgen Configure Arbitrary Sequence functions, as they also set the gain and offset, thereby overriding the values set by this function. Instead, use the Arbitrary Waveform Handle or Arbitrary Sequence Handle attributes in the niFgen property node.\n\n\u00b7 If you set the Use Rate from Waveform input to True and if Onboard Signal Processing (OSP) is enabled, the 'rate' from the waveform is interpreted as the data rate, and FGEN sets the data rate attribute for you. In all other cases, it is interpreted as the sample rate, and FGEN sets the sample rate attribute for you.\n\n\u00b7 HWS files may contain I16 or DBL data (depending on how it was saved). This function will automatically adapt to either data type. If the file contains DBL data, it must be between -1.0 and +1.0. Check the \"Scale Data to +/- 1V\" option in the Analog Waveform Editor to ensure your data is between -1.0 and +1.0.\n\n\n\nResult:\n\n$WaveformHandle = NI_Fgen_CreateWaveformFromFileHWS($NI_FgenHandle, $ChannelName, $HwsFile, $UseRateFromWaveform, $UseGainOffsetFromWaveform);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_FgenHandle\n\nObject\n\nThe instrument handle you obtain from NI_Fgen_Initialize that identifies a particular instrument's session.\n\n\n\n$ChannelName\n\nString\n\nPass the channel name for which you want to create a waveform.\n\n\n\n$WfmFile\n\nString\n\nThe full path and name of the file where the waveform data resides.\n\n\n\n$UseRateFromWaveform\n\nBoolean\n\nIf you set the Use Rate from Waveform input to True and if Onboard Signal Processing (OSP) is enabled, the 'rate' from the waveform is interpreted as the data rate, and FGEN sets the data rate attribute for you. In all other cases, it is interpreted as the sample rate, and FGEN sets the sample rate attribute for you.\n\nValid value(s) :\n\n\u00b7 \"TRUE\"\n\n\u00b7 \"FALSE\"\n\n\n\n$UseGainOffsetFromWaveform\n\nBoolean\n\nIf this input is set to true, NI-FGEN retrieves the gain and offset values from the specified HWS file and applies them to the NI-FGEN driver.\n\nValid value(s) :\n\n\u00b7 \"TRUE\"\n\n\u00b7 \"FALSE\"\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$WaveformHandle\n\nInteger\n\nThe handle that identifies the new waveform. This handle is used later when referring to this waveform.\n\n\n\n\n\nExample:\n\n$WaveformHandle = NI_Fgen_CreateWaveformFromFileHWS($NI_FgenHandle, \"0\", \"C:\\\\work\\\\NI Signal Generator Functions\\\\Sine2Volts40MSs_1000.hws\", \"TRUE\", \"TRUE\");\n\n\n\n\n\nNI_Fgen_CreateWaveformFromFileI16\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_Fgen_CreateWaveformFromFileI16": {
  "prefix": "NI_Fgen_CreateWaveformFromFileI16",
  "body": [
   "$$WaveformHandle=NI_Fgen_CreateWaveformFromFileI16($$NI_FgenHandle,$$ChannelName,$$WfmFile,$$ByteOrder);"
  ],
  "description": "\n\nThis function requires NI FGEN drivers to be installed on the system.\n\nThis function takes the binary I16 data from the specified file and creates an onboard waveform for use in Arbitrary Waveform mode or Arbitrary Sequence mode. The waveform handle returned can be used later for setting the active waveform, changing the data in the waveform, building sequences of waveforms or even deleting the waveform when it is no longer needed. You must set the output mode to arbitrary waveform output or arbitrary sequence output before calling this function. The i16 data (values between -32768 and +32767) is assumed to represent -1 to +1 volts. Use the Gain attribute to generate different voltage outputs.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PXI-5412 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Fgen functions, Jabil Test will fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\n$WaveformHandle = NI_Fgen_CreateWaveformFromFileI16($NI_FgenHandle, $ChannelName, $WfmFile, $ByteOrder);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_FgenHandle\n\nObject\n\nThe instrument handle you obtain from NI_Fgen_Initialize that identifies a particular instrument's session.\n\n\n\n$ChannelName\n\nString\n\nPass the channel name for which you want to create a waveform.\n\n\n\n$WfmFile\n\nString\n\nThe full path and name of the file where the waveform data resides.\n\n\n\n$ByteOrder\n\nString\n\nSpecifies the byte order of the data in the file. Big Endian and Little Endian refer to the way data is stored in memory, which can differ on different processors.\n\nValid value(s) :\n\n\u00b7 \"BIG ENDIAN\"\n\n\u00b7 \"LITTLE ENDIAN\"\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$WaveformHandle\n\nInteger\n\nThe handle that identifies the new waveform. This handle is used later when referring to this waveform.\n\n\n\n\n\nExample:\n\n$WaveformHandle = NI_Fgen_CreateWaveformFromFileI16($NI_FgenHandle, \"0\", \"C:\\\\work\\\\NI Signal Generator Functions\\\\sine.bin\", \"BIG ENDIAN\");\n\n\n\n\n\nNI_Fgen_DefineUserStandardWaveform\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_Fgen_DefineUserStandardWaveform": {
  "prefix": "NI_Fgen_DefineUserStandardWaveform",
  "body": [
   "NI_Fgen_DefineUserStandardWaveform($$NI_FgenHandle,$$ChannelName,$$waveformSize,$$waveformDataArray);"
  ],
  "description": "\n\nThis function requires NI FGEN drivers to be installed on the system.\n\nThis function defines a user waveform for either standard function output or frequency list output.\n\nTo select the waveform, set the waveform parameter to user with either NI_Fgen_ConfigureStandardWaveform or NI_Fgen_CreateFreqList.\n\nThe waveform data must be scaled between -1.0 and 1.0. Use the amplitude parameter to generate different output voltages.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PXI-5412 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Fgen functions, Jabil Test will fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\u00b7 You must set outputMode to func or frequency list using NI_Fgen_ConfigureOutputMode before calling this function.\n\n\n\nResult:\n\nNI_Fgen_DefineUserStandardWaveform($NI_FgenHandle, $ChannelName, $waveformSize, $waveformDataArray);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_FgenHandle\n\nObject\n\nThe instrument handle you obtain from NI_Fgen_Initialize that identifies a particular instrument's session.\n\n\n\n$ChannelName\n\nString\n\nPass the channel name for which you want to configure an arbitrary sequence.\n\n\n\n$waveformSize\n\nInteger\n\nPass the size of the arbitrary waveform you want to create.\n\n\n\n$waveformDataArray\n\nArray\n\nSpecify the array of data you want to use for the new arbitrary waveform. The array must have at least as many elements as the value that you specify in waveformSize.\n\nYou must normalize the data points in the array to be between \u20131.00 and +1.00.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n\n\nExample:\n\n$ChannelName = New(\"String\", \"0\");\n\n$waveformSize = New(\"Integer\", 1000);\n\n$waveformDataArray = ArraySimulateWaveFormData(11000,0,10,50000,25000,0);\n\n\n\n\n\nNI_Fgen_DefineUserStandardWaveform($NI_FgenHandle, $ChannelName, $waveformSize, $waveformDataArray);\n\n\n\n\n\nNI_Fgen_Disable\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_Fgen_Disable": {
  "prefix": "NI_Fgen_Disable",
  "body": [
   "NI_Fgen_Disable($$NI_FgenHandle);"
  ],
  "description": "\n\nThis function requires NI FGEN drivers to be installed on the system.\n\nThis function places the instrument in a quiescent state where it has minimal or no impact on the system to which it is connected.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PXI-5412 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Fgen functions, Jabil Test will fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\nNI_Fgen_Disable($NI_FgenHandle);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_FgenHandle\n\nObject\n\nThe instrument handle you obtain from NI_Fgen_Initialize that identifies a particular instrument's session.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n\n\nExample:\n\nNI_Fgen_Disable($NI_FgenHandle);\n\n\n\n\n\nNI_Fgen_DisableAnalogFilter\n\n\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_Fgen_DisableAnalogFilter": {
  "prefix": "NI_Fgen_DisableAnalogFilter",
  "body": [
   "NI_Fgen_DisableAnalogFilter($$NI_FgenHandle,$$ChannelName);"
  ],
  "description": "\n\nThis function requires NI FGEN drivers to be installed on the system.\n\nThis function disables the analog filter.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PXI-5412 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Fgen functions, Jabil Test will fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\nNI_Fgen_DisableAnalogFilter($NI_FgenHandle, $ChannelName);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_FgenHandle\n\nObject\n\nThe instrument handle you obtain from NI_Fgen_Initialize that identifies a particular instrument's session.\n\n\n\n$ChannelName\n\nString\n\nPass the channel name for which you want to disable the analog filter.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n\n\nExample:\n\nNI_Fgen_DisableAnalogFilter($NI_FgenHandle, \"0\");\n\n\n\n\n\nNI_Fgen_DisableDigitalFilter\n\n\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_Fgen_DisableDigitalFilter": {
  "prefix": "NI_Fgen_DisableDigitalFilter",
  "body": [
   "NI_Fgen_DisableDigitalFilter($$NI_FgenHandle,$$ChannelName);"
  ],
  "description": "\n\nThis function requires NI FGEN drivers to be installed on the system.\n\nThis function disables the digital filter.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PXI-5412 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Fgen functions, Jabil Test will fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\nNI_Fgen_DisableDigitalFilter($NI_FgenHandle, $ChannelName);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_FgenHandle\n\nObject\n\nThe instrument handle you obtain from NI_Fgen_Initialize that identifies a particular instrument's session.\n\n\n\n$ChannelName\n\nString\n\nPass the channel name for which you want to disable the digital filter.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n\n\nExample:\n\nNI_Fgen_DisableDigitalFilter($NI_FgenHandle, \"0\");\n\n\n\n\n\nNI_Fgen_DisableDigitalPatterning\n\n\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_Fgen_DisableDigitalPatterning": {
  "prefix": "NI_Fgen_DisableDigitalPatterning",
  "body": [
   "NI_Fgen_DisableDigitalPatterning($$NI_FgenHandle,$$ChannelName);"
  ],
  "description": "\n\nThis function requires NI FGEN drivers to be installed on the system.\n\nThis function disables digital patterning on the signal generator.\n\n\n\nSome NI signal generators support 16-bit digital pattern generation outputs at a digital connector. The digital pattern generation provides a digital representation of the waveforms generated on the analog connector of the device, and at the same rates as the analog signal.\n\n\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PXI-5412 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Fgen functions, Jabil Test will fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\nNI_Fgen_DisableDigitalPatterning($NI_FgenHandle, $ChannelName);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_FgenHandle\n\nObject\n\nThe instrument handle you obtain from NI_Fgen_Initialize that identifies a particular instrument's session.\n\n\n\n$ChannelName\n\nString\n\nPass the channel name for which you want to disable the digital pattern output.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n\n\nExample:\n\nNI_Fgen_DisableDigitalPatterning($NI_FgenHandle, \"0\");\n\n\n\n\n\nNI_Fgen_EnableAnalogFilter\n\n\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_Fgen_EnableAnalogFilter": {
  "prefix": "NI_Fgen_EnableAnalogFilter",
  "body": [
   "NI_Fgen_EnableAnalogFilter($$NI_FgenHandle,$$ChannelName,$$filterCorrectionFrequency);"
  ],
  "description": "\n\nThis function requires NI FGEN drivers to be installed on the system.\n\nThis function enables the analog filter. You can also specify the filter correction frequency of the analog filter.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PXI-5412 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Fgen functions, Jabil Test will fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\nNI_Fgen_EnableAnalogFilter($NI_FgenHandle, $ChannelName, $CorrectionFrequency);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_FgenHandle\n\nObject\n\nThe instrument handle you obtain from NI_Fgen_Initialize that identifies a particular instrument's session.\n\n\n\n$ChannelName\n\nString\n\nPass the channel name for which you want to enable the analog filter.\n\n\n\n$filterCorrectionFrequency\n\nFloat\n\nSpecifies the filter correction frequency of the analog filter. On the NI 5411 and NI 5431, NI-FGEN adjusts signal amplitude to compensate for the filter's attenuation at that frequency. To disable amplitude correction, set filterCorrectionFrequency to 0. For Standard Waveform Output, the filter correction frequency should typically be set to be the same as the frequency of the standard waveform.\n\nUnit : Hz\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n\n\nExample:\n\nNI_Fgen_EnableAnalogFilter($NI_FgenHandle, \"0\", 0.0);\n\n\n\n\n\nNI_Fgen_EnableDigitalFilter\n\n\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_Fgen_EnableDigitalFilter": {
  "prefix": "NI_Fgen_EnableDigitalFilter",
  "body": [
   "NI_Fgen_EnableDigitalFilter($$NI_FgenHandle,$$ChannelName);"
  ],
  "description": "\n\nThis function requires NI FGEN drivers to be installed on the system.\n\nThis function enables the digital filter.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PXI-5412 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Fgen functions, Jabil Test will fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\nNI_Fgen_EnableDigitalFilter($NI_FgenHandle, $ChannelName);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_FgenHandle\n\nObject\n\nThe instrument handle you obtain from NI_Fgen_Initialize that identifies a particular instrument's session.\n\n\n\n$ChannelName\n\nString\n\nPass the channel name for which you want to enable the digital filter.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n\n\nExample:\n\nNI_Fgen_EnableDigitalFilter($NI_FgenHandle, \"0\");\n\n\n\n\n\nNI_Fgen_EnableDigitalPatterning\n\n\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_Fgen_EnableDigitalPatterning": {
  "prefix": "NI_Fgen_EnableDigitalPatterning",
  "body": [
   "NI_Fgen_EnableDigitalPatterning($$NI_FgenHandle,$$ChannelName);"
  ],
  "description": "\n\nThis function requires NI FGEN drivers to be installed on the system.\n\nThis function enables digital patterning on the signal generator.\n\n\n\nSome NI signal generators support 16-bit digital pattern generation outputs at a digital connector. The digital pattern generation provides a digital representation of the waveforms generated on the analog connector of the device, and at the same rates as the analog signal.\n\n\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PXI-5412 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Fgen functions, Jabil Test will fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\nNI_Fgen_EnableDigitalPatterning($NI_FgenHandle, $ChannelName);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_FgenHandle\n\nObject\n\nThe instrument handle you obtain from NI_Fgen_Initialize that identifies a particular instrument's session.\n\n\n\n$ChannelName\n\nString\n\nPass the channel name for which you want to enable the digital pattern output.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n\n\nExample:\n\nNI_Fgen_EnableDigitalPatterning($NI_FgenHandle, \"0\");\n\n\n\n\n\nNI_Fgen_GetHardwareState\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_Fgen_GetHardwareState": {
  "prefix": "NI_Fgen_GetHardwareState",
  "body": [
   "($$State,$$StringState)=NI_Fgen_GetHardwareState($$NI_FgenHandle);"
  ],
  "description": "\n\nThis function requires NI FGEN drivers to be installed on the system.\n\nThis function returns the current hardware state of the device and, if the device is in the hardware error state, the current hardware error.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PXI-5412 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Fgen functions, Jabil Test will fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\n($State, $StringState) = NI_Fgen_GetHardwareState($NI_FgenHandle);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_FgenHandle\n\nObject\n\nThe instrument handle you obtain from NI_Fgen_Initialize that identifies a particular instrument's session.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$State\n\nInteger\n\nHardware state code.\n\n\n\n$StringState\n\nString\n\nHardware state string. Possible values:\n\n\u00b7 \"DONE\"\n\n\u00b7 \"IDLE\"\n\n\u00b7 \"RUNNING\"\n\n\u00b7 \"WAITING FOR START TRIGGER\"\n\n\u00b7 \"HARDWARE ERROR\"\n\n\u00b7 \"UNKNOWN STATE\"\n\n\n\n\n\nExample:\n\n($State, $StringState) = NI_Fgen_GetHardwareState($NI_FgenHandle);\n\n\n\n\n\nNI_Fgen_GetRevision\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_Fgen_GetRevision": {
  "prefix": "NI_Fgen_GetRevision",
  "body": [
   "($$instrumentDriverRevision,$$firmwareRevision)=NI_Fgen_GetRevision($$NI_FgenHandle);"
  ],
  "description": "\n\nThis function requires NI FGEN drivers to be installed on the system.\n\nThis function returns the revision numbers of the NI-FGEN and instrument firmware.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PXI-5412 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Fgen functions, Jabil Test will fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\n($instrumentDriverRevision, $firmwareRevision) = NI_Fgen_GetRevision($Session);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_FgenHandle\n\nObject\n\nThe instrument handle you obtain from NI_Fgen_Initialize that identifies a particular instrument's session.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$instrumentDriverRevision\n\nString\n\nA string containing the NI-FGEN software revision numbers.\n\n\n\n$firmwareRevision\n\nString\n\nA string containing the instrument firmware revision numbers.\n\n\n\n\n\nExample:\n\n($instrumentDriverRevision, $firmwareRevision) = NI_Fgen_GetRevision($NI_FgenHandle);\n\n\n\n\n\nStringCompare($instrumentDriverRevision, \"Driver: niFgen 2.4, Engine: IVI 2.04, Compiler: MSVC 7.10, Components: VISA-Spec 3.00\");\n\n\n\n\n\nStringCompare($firmwareRevision, \"Not Available\");\n\n\n\n\n\nNI_Fgen_Initialize\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_Fgen_Initialize": {
  "prefix": "NI_Fgen_Initialize",
  "body": [
   "$$NI_FgenHandle=NI_Fgen_Initialize($$DeviceName,$$IdQuery,$$ResetDevice);"
  ],
  "description": "\n\nThis function requires NI FGEN drivers to be installed on the system.\n\nThis function opens a session to the specified device using the interface and address that you specify with the parameter $DeviceName. For Traditional NI-DAQ devices, the syntax is DAQ::n, where n is the device number assigned by MAX. For NI-DAQmx devices, the syntax is just the device name specified in MAX. Typical default names for NI-DAQmx devices in MAX are Dev1 or PXI1Slot1. You can rename an NI-DAQmx device by right-clicking on the name in MAX and entering a new name. When you pass the value \"true\" to the parameter $IdQuery, NI-FGEN driver will verify if he supports the device you want to initialize. Passing \"true\" to the parameter $ResetDevice will reset the device during initialization.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PXI-5412 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Fgen functions, Jabil Test will fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\n$NI_FgenHandle = NI_Fgen_Initialize($DeviceName, $IdQuery, $ResetDevice);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$DeviceName\n\nString\n\nSpecifies the resource name of the device to initialize. This value has to be the same as the name in the Measurement & Automation Explorer.\n\n\n\n$IdQuery\n\nBoolean\n\nSpecify whether you want NI-FGEN to perform an ID query.\n\nWhen you set this parameter to true, NI-FGEN verifies that the device you initialize is a type that it supports. When you set this parameter to false, the function initializes the device without performing an ID query.\n\nValid values :\n\n\u00b7 True : Perform ID query.\n\n\u00b7 False : Do not perform ID query.\n\n\n\n$ResetDevice\n\nBoolean\n\nSpecify whether you want to reset the device during the initialization procedure.\n\nValid values :\n\n\u00b7 True : Reset the device.\n\n\u00b7 False : Do not reset the device.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_FgenHandle\n\nObject\n\nHandle that you can use to identify the device in all the other NI_Fgen functions.\n\n\n\n\n\nExample:\n\n$NI_FgenHandle = NI_Fgen_Initialize(\"Dev4\", \"true\", \"true\");\n\n\n\n\n\nNI_Fgen_InitiateGeneration\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_Fgen_InitiateGeneration": {
  "prefix": "NI_Fgen_InitiateGeneration",
  "body": [
   "NI_Fgen_InitiateGeneration($$NI_FgenHandle);"
  ],
  "description": "\n\nThis function requires NI FGEN drivers to be installed on the system.\n\nThis function initiates signal generation.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PXI-5412 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Fgen functions, Jabil Test will fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\nNI_Fgen_InitiateGeneration($NI_FgenHandle);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_FgenHandle\n\nObject\n\nThe instrument handle you obtain from NI_Fgen_Initialize that identifies a particular instrument's session.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n\n\nExample:\n\nNI_Fgen_InitiateGeneration($NI_FgenHandle);\n\n\n\n\n\nNI_Fgen_IsDone\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_Fgen_IsDone": {
  "prefix": "NI_Fgen_IsDone",
  "body": [
   "$$Done=NI_Fgen_IsDone($$NI_FgenHandle);"
  ],
  "description": "\n\nThis function requires NI FGEN drivers to be installed on the system.\n\nThis function determines whether the current generation has completed. This function sets the done parameter to be true if the session is in the Idle or Committed states.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PXI-5412 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Fgen functions, Jabil Test will fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\n$Done = NI_Fgen_IsDone($NI_FgenHandle);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_FgenHandle\n\nObject\n\nThe instrument handle you obtain from NI_Fgen_Initialize that identifies a particular instrument's session.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Done\n\nBoolean\n\nTrue if the generation has completed, false otherwise.\n\n\n\n\n\nExample:\n\n$Done = NI_Fgen_IsDone($NI_FgenHandle);\n\n\n\n\n\nScriptIf($Done, \"GOTO\", \"FgenIsDonePassed\", \"FgenIsDoneFailed\");\n\nLabel FgenIsDonePassed:\n\n$resultInteger = New(\"Integer\", 0);\n\nRecordMeasurementWithLimits(\"NI_Fgen_IsDone\", $resultInteger, \"N/A\", \"true\", 0, 0, \"true\");\n\nreturn;\n\nLabel FgenIsDoneFailed:\n\n$resultInteger = New(\"Integer\", -1);\n\nRecordMeasurementWithLimits(\"NI_Fgen_IsDone\", $resultInteger, \"N/A\", \"true\", 0, 0, \"true\");\n\n\n\n\n\nNI_Fgen_Reset\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_Fgen_Reset": {
  "prefix": "NI_Fgen_Reset",
  "body": [
   "NI_Fgen_Reset($$NI_FgenHandle);"
  ],
  "description": "\n\nThis function requires NI FGEN drivers to be installed on the system.\n\nThis function resets the instrument to a known state. This function aborts the generation, clears all routes, and resets session attributes to the default values. This function does not, however, commit the session properties or configure the device hardware to its default state.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PXI-5412 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Fgen functions, Jabil Test will fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\nNI_Fgen_Reset($NI_FgenHandle);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_FgenHandle\n\nObject\n\nThe instrument handle you obtain from NI_Fgen_Initialize that identifies a particular instrument's session.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n\n\nExample:\n\nNI_Fgen_Reset($NI_FgenHandle);\n\n\n\n\n\nNI_Fgen_ResetDevice\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_Fgen_ResetDevice": {
  "prefix": "NI_Fgen_ResetDevice",
  "body": [
   "NI_Fgen_ResetDevice($$NI_FgenHandle);"
  ],
  "description": "\n\nThis function requires NI FGEN drivers to be installed on the system.\n\nThis function performs a hard reset on the device. Generation is stopped, all routes are released, external bi-directional terminals are tri-stated, FPGAs are reset, hardware is configured to its default state, and all session attributes are reset to their default states.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PXI-5412 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Fgen functions, Jabil Test will fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\nNI_Fgen_ResetDevice($NI_FgenHandle);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_FgenHandle\n\nObject\n\nThe instrument handle you obtain from NI_Fgen_Initialize that identifies a particular instrument's session.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n\n\nExample:\n\nNI_Fgen_ResetDevice($NI_FgenHandle);\n\n\n\n\n\nNI_Fgen_ResetWithDefaults\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_Fgen_ResetWithDefaults": {
  "prefix": "NI_Fgen_ResetWithDefaults",
  "body": [
   "NI_Fgen_ResetWithDefaults($$NI_FgenHandle);"
  ],
  "description": "\n\nThis function requires NI FGEN drivers to be installed on the system.\n\nThis function resets the instrument and applies initial user specified settings from the logical name that was used to initialize the session.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PXI-5412 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Fgen functions, Jabil Test will fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\nNI_Fgen_ResetWithDefaults($NI_FgenHandle);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_FgenHandle\n\nObject\n\nThe instrument handle you obtain from NI_Fgen_Initialize that identifies a particular instrument's session.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n\n\nExample:\n\nNI_Fgen_ResetWithDefaults($NI_FgenHandle);\n\n\n\n\n\nNI_Fgen_RouteSignalOut\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_Fgen_RouteSignalOut": {
  "prefix": "NI_Fgen_RouteSignalOut",
  "body": [
   "NI_Fgen_RouteSignalOut($$NI_FgenHandle,$$ChannelName,$$RouteSignalFrom,$$RouteSignalTo);"
  ],
  "description": "\n\nThis function requires NI FGEN drivers to be installed on the system.\n\nThis function routes various signals in the signal generator to the RTSI lines and front panel terminals.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PXI-5412 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Fgen functions, Jabil Test will fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\u00b7 The signal generator must not be in the Generating state when you call this function.\n\n\n\nResult:\n\nNI_Fgen_RouteSignalOut($NI_FgenHandle, $ChannelName, $RouteSignalFrom, $RouteSignalTo);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_FgenHandle\n\nObject\n\nThe instrument handle you obtain from NI_Fgen_Initialize that identifies a particular instrument's session.\n\n\n\n$ChannelName\n\nString\n\nPass the channel name for which you want to route a signal.\n\n\n\n$RouteSignalFrom\n\nString\n\nVarious signals can be routed out the RTSI lines. Possible values:\n\n\u00b7 \"NONE\" : Route nothing to the RTSI line. Clears the line.\n\n\u00b7 \"MARKER\" : The marker as specified by the markers parameter in NI_Fgen_CreateAdvancedArbSequence.\n\n\u00b7 \"SYNC OUT\" : The SYNC signal that normally appears on the SYNC_OUT front panel connector.\n\n\u00b7 \"OUT START TRIGGER\" : The trigger generated at the start of the sequence. Call NI_Fgen_ConfigureTriggerSource to receive this trigger.\n\n\u00b7 \"BOARD CLOCK\" : The signal generator board clock, which is 20 MHz for the NI PCI-5401/5411/5431. The NI PXI-5404 has a 20 MHz board clock, and the NI PXI-5421 has integer divisors of 100 MHz. The NI PXI-5401/5411/5431 does not support routing a Board Clock out.\n\n\u00b7 \"SYNCHRONIZATION\" : A synchronization strobe used to guarantee absolute synchronization between two or more signal generators. Call NI_Fgen_ConfigureSynchronization to receive the strobe.\n\n\u00b7 \"SOFTWARE TRIGGER\" : Software trigger\n\n\u00b7 \"REF CLOCK OUT\" : Reference clock out\n\n\u00b7 \"PXI 10MHZ CLOCK\" : PXI 10 MHz clock\n\n\u00b7 \"PXI STAR\" : PXI Star\n\n\u00b7 \"PFI0\" : PFI 0\n\n\u00b7 \"RTSI0\" : RTSI 0 or PXI_Trig 0\n\n\u00b7 \"RTSI1\" : RTSI 1 or PXI_Trig 1\n\n\u00b7 \"RTSI2\" : RTSI 2 or PXI_Trig 2\n\n\u00b7 \"RTSI3\" : RTSI 3 or PXI_Trig 3\n\n\u00b7 \"RTSI4\" : RTSI 4 or PXI_Trig 4\n\n\u00b7 \"RTSI5\" : RTSI 5 or PXI_Trig 5\n\n\u00b7 \"RTSI6\" : RTSI 6 or PXI_Trig 6\n\n\u00b7 \"RTSI7\" : RTSI 7 or PXI_Trig 7\n\n\u00b7 \"REF CLK RTSI CLK\" : RTSI clock\n\n\u00b7 \"CLK OUT\" : Clock out\n\n\u00b7 \"UPDATE CLK\" : Sample clock\n\n\u00b7 \"PLL REFERENCE CLK\" : PLL reference clock\n\n\n\n$RouteSignalTo\n\nString\n\nThe possible RTSI lines to which you can route a signal. Possible values:\n\n\"RTSI0\" : RTSI 0 or PXI_Trig 0\n\n\"RTSI1\" : RTSI 1 or PXI_Trig 1\n\n\"RTSI2\" : RTSI 2 or PXI_Trig 2\n\n\"RTSI3\" : RTSI 3 or PXI_Trig 3\n\n\"RTSI4\" : RTSI 4 or PXI_Trig 4\n\n\"RTSI5\" : RTSI 5 or PXI_Trig 5\n\n\"RTSI6\" : RTSI 6 or PXI_Trig 6\n\n\"RTSI CLOCK\" : RTSI clock\n\n\"REFERENCE CLK OUT\" : Reference clock out\n\n\"PFI0\" : PFI 0\n\n\"PFI1\" : PFI 1\n\n\"PFI4\" : PFI 4\n\n\"PFI5\" : PFI 5\n\n\"PXI STAR\" : PXI Star\n\n\"PXI 10MHZ CLK\" : PXI 10 MHz clock\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n\n\nExample:\n\n$ChannelName = New(\"String\", \"0\");\n\n$RouteSignalFrom = New(\"String\", \"MARKER\");\n\n$RouteSignalTo = New(\"String\", \"PFI0\");\n\nNI_Fgen_RouteSignalOut($NI_FgenHandle, $ChannelName, $RouteSignalFrom, $RouteSignalTo);\n\n\n\n\n\nNI_Fgen_SelfTest\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_Fgen_SelfTest": {
  "prefix": "NI_Fgen_SelfTest",
  "body": [
   "($$selfTestResult,$$selfTestMessage)=NI_Fgen_SelfTest($$NI_FgenHandle);"
  ],
  "description": "\n\nThis function requires NI FGEN drivers to be installed on the system.\n\nThis function runs the instrument self-test routine and returns the test result(s).\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PXI-5412 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Fgen functions, Jabil Test will fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\n($selfTestResult, $selfTestMessage) = NI_Fgen_SelfTest($NI_FgenHandle);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_FgenHandle\n\nObject\n\nThe instrument handle you obtain from NI_Fgen_Initialize that identifies a particular instrument's session.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$selfTestResult\n\nInteger\n\nThis control contains the value returned from the instrument self-test.\n\n\n\n$selfTestMessage\n\nString\n\nReturns the self-test response string from the instrument.\n\n\n\n\n\nExample:\n\n($selfTestResult, $selfTestMessage) = NI_Fgen_SelfTest($NI_FgenHandle);\n\n\n\n\n\nUpdateStatus($selfTestMessage);\n\nNumericLimitTest($selfTestResult, 0, 0);\n\n\n\n\n\nNI_Fgen_SendSoftwareTrigger\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_Fgen_SendSoftwareTrigger": {
  "prefix": "NI_Fgen_SendSoftwareTrigger",
  "body": [
   "NI_Fgen_SendSoftwareTrigger($$NI_FgenHandle);"
  ],
  "description": "\n\nThis function requires NI FGEN drivers to be installed on the system.\n\nThis function sends a command to trigger the signal generator.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PXI-5412 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Fgen functions, Jabil Test will fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\nNI_Fgen_SendSoftwareTrigger($NI_FgenHandle);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_FgenHandle\n\nObject\n\nThe instrument handle you obtain from NI_Fgen_Initialize that identifies a particular instrument's session.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n\n\nExample:\n\nNI_Fgen_SendSoftwareTrigger($NI_FgenHandle);\n\n\n\n\n\nNI_Fgen_WaitUntilDone\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_Fgen_WaitUntilDone": {
  "prefix": "NI_Fgen_WaitUntilDone",
  "body": [
   "NI_Fgen_WaitUntilDone($$NI_FgenHandle,$$maxTime);"
  ],
  "description": "\n\nThis function requires NI FGEN drivers to be installed on the system.\n\nThis function waits until the device is done generating or until the maximum time has expired.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PXI-5412 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Fgen functions, Jabil Test will fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\nNI_Fgen_WaitUntilDone($NI_FgenHandle, $maxTime);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_FgenHandle\n\nObject\n\nThe instrument handle you obtain from NI_Fgen_Initialize that identifies a particular instrument's session.\n\n\n\n$maxTime\n\nInteger\n\nThe timeout value (in milliseconds).\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n\n\nExample:\n\nNI_Fgen_WaitUntilDone($NI_FgenHandle, 1000);\n\n\n\n\n\nRS_SMB_Close\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS RS_SMB_Close": {
  "prefix": "RS_SMB_Close",
  "body": [
   "RS_SMB_Close($$RS_SMB);"
  ],
  "description": "\n\nThis function requires the installation of Rohde&Schwarz Signal Generator VXI plug&play instrument driver on the system.\n\nCloses the I/O session to the instrument.\n\n\n\nResult:\n\nRS_SMB_Close($RS_SMB);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$RS_SMB\n\nobject\n\nThe object representing the instance of the Rohde & Schwarz SMB signal generator.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n\n\nExample:\n\nRS_SMB_Close($RS_SMB);\n\n\n\n\n\nRS_SMB_Init\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS RS_SMB_Init": {
  "prefix": "RS_SMB_Init",
  "body": [
   "$$RS_SMB=RS_SMB_Init($$ResourceName,$$ID_Query,$$Reset);"
  ],
  "description": "\n\nThis function requires the installation of Rohde&Schwarz Signal Generator VXI plug&play instrument driver on the system.\n\nThis function performs the following initialization actions:\n\n\u00b7 Opens a session to the Default Resource Manager resource and a session to the specified device using the interface and address specified in the Resource_Name control.\n\n\u00b7 Performs an identification query on the Instrument.\n\n\u00b7 Resets the instrument to a known state.\n\n\u00b7 Sends initialization commands to the instrument that set any necessary programmatic variables such as Headers Off, Short Command form, and Data Transfer Binary to the state necessary for the operation of the instrument driver.\n\n\u00b7 Returns an Instrument Handle which is used to differentiate between different sessions of this instrument driver.\n\n\u00b7 Each time this function is invoked a Unique Session is opened. It is possible to have more than one session open for the same resource.\n\n\n\nResult:\n\n$RS_SMB = RS_SMB_Init($ResourceName,$ID_Query,$Reset);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ResourceName\n\nstring\n\nThis control specifies the interface and address of the device that is to be initialized (Instrument Descriptor). The exact grammar to be used in this control is shown in the note below.\n\nBased on the Instrument Descriptor, this operation establishes a communication session with a device. The grammar for the Instrument Descriptor is shown below. Optional parameters are shown in square brackets ([]).\n\n\n\n\n\nInterface Grammar\n\nGPIB GPIB[board]::primary address[::secondary address]\n\n[::INSTR]\n\nVXI-11 TCPIP::remote_host::INSTR\n\nUSB USB::<vendor Id>::<product Id>::<serial number>\n\nThe GPIB keyword is used for GPIB interface.\n\nThe TCPIP keyword is used for VXI-11 interface.\n\nThe USB keyword is used for USB interface, where\n\n<vendor Id> is 0x0AAD for Rohde&Schwarz\n\n<product Id> is 0x0054 for SMB100A\n\n<serial number> is Serial number (on the rear panel of\n\nthe instrument). For example 100001.\n\n\n\n\n\nExamples:\n\n(1) GPIB - \"GPIB::28::INSTR\"\n\n(2) VXI-11 - \"TCPIP::192.168.1.33::INSTR\"\n\n(3) USB - \"USB::0xAAD::0x0054::100001::INSTR\"\n\n\n\n$ID_Query\n\nboolean\n\nThis control specifies if an ID Query is sent to the instrument during the initialization procedure.\n\n\n\n\n\nboolean\n\nThis control specifies if the instrument is to be reset to its power-on settings during the initialization procedure.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$RS_SMB\n\nobject\n\nThe object representing the instance of the Rohde & Schwarz SMB signal generator.\n\n\n\n\n\nExample:\n\n$RS_SMB = RS_SMB_Init(\"USB0::0x0AAD::0x0054::103732::0::INSTR\",true,true);\n\n\n\n\n\nRS_SMB_Read\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS RS_SMB_Read": {
  "prefix": "RS_SMB_Read",
  "body": [
   "$$Data=RS_SMB_Read($$RS_SMB,$$NumberBytesToRead);"
  ],
  "description": "\n\nThis function requires the installation of Rohde&Schwarz Signal Generator VXI plug&play instrument driver on the system.\n\nThis function reads data from the instrument's output buffer and returns it to the specified variable in memory.\n\nIf valid data is not available at the instrument's output buffer when this function is called the instrument will hang up and the function will not return until it times out. If the time-out is disabled this function will hang indefinitely and it may be necessary to reboot the computer to break out.\n\n\n\n\n\nResult:\n\n$Data = RS_SMB_Read($RS_SMB,$NumberBytesToRead);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$RS_SMB\n\nobject\n\nThe object representing the instance of the Rohde & Schwarz signal generator.\n\n\n\n$NumberBytesToRead\n\ninteger\n\nThis variable contains the actual number of bytes read from the instrument. This is the value which is returned by the read function.\n\nIf the actual number of bytes read is less than the number of bytes specified in the Number Bytes To Read control then the output buffer has probably been emptied. If the read function fails and the number of bytes read is 0, the most probable cause for the failure is there was no data available at the instrument's output buffer.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n\n\nExample:\n\nRS_SMB_Write($RS_SMB,\""
 }
,
 "JTS RS_SMB_Reset": {
  "prefix": "RS_SMB_Reset",
  "body": [
   "RS_SMB_Reset($$RS_SMB);"
  ],
  "description": "\n\nThis function requires the installation of Rohde&Schwarz Signal Generator VXI plug&play instrument driver on the system.\n\nThis function resets the instrument to a defined default state. The function has the same effect as pressing the PRESET key.\n\n\n\n\n\nEquivalent remote-control command(s):\n\n\u00b7 "
 }
,
 "JTS RS_SMB_SelfTest": {
  "prefix": "RS_SMB_SelfTest",
  "body": [
   "($$TestResultCode,$$TestResultMessage)=RS_SMB_SelfTest($$RS_SMB);"
  ],
  "description": "\n\nThis function requires the installation of Rohde&Schwarz Signal Generator VXI plug&play instrument driver on the system.\n\nThis function runs the instrument's self test routine and returns the test result(s).\n\n\n\n\n\nResult:\n\n($TestResultCode,$TestResultMessage) = RS_SMB_SelfTest($RS_SMB);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$RS_SMB\n\nobject\n\nThe object representing the instance of the Rohde & Schwarz signal generator.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n\n\nExample:\n\n($TestResultCode,$TestResultMessage) = RS_SMB_SelfTest($RS_SMB);\n\nUpdateStatus($TestResultCode);\n\nUpdateStatus($TestResultMessage);\n\n\n\n\n\nRS_SMB_SetKeyboardLock\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS RS_SMB_SetKeyboardLock": {
  "prefix": "RS_SMB_SetKeyboardLock",
  "body": [
   "RS_SMB_SetKeyboardLock($$RS_SMB,$$Lock);"
  ],
  "description": "\n\nThis function requires the installation of Rohde&Schwarz Signal Generator VXI plug&play instrument driver on the system.\n\nThis function disables the front panel keyboard of the R&S Signal Generator including the LOCAL key, or enables it again.\n\n\n\n\n\nEquivalent remote-control command(s):\n\n\u00b7 SYST:KLOC ON\n\n\u00b7 SYST:KLOC OFF\n\n\n\n\n\nResult:\n\nRS_SMB_SetKeyboardLock($RS_SMB,$Lock);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$RS_SMB\n\nobject\n\nThe object representing the instance of the Rohde & Schwarz signal generator.\n\n\n\n$Lock\n\nboolean\n\nEnable/disable the keyboard.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n\n\nExample:\n\nRS_SMB_SetKeyboardLock($RS_SMB,true);\n\nRS_SMB_SetKeyboardLock($RS_SMB,false);\n\n\n\n\n\nRS_SMB_Write\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS RS_SMB_Write": {
  "prefix": "RS_SMB_Write",
  "body": [
   "RS_SMB_Write($$RS_SMB,$$Data);"
  ],
  "description": "\n\nThis function requires the installation of Rohde&Schwarz Signal Generator VXI plug&play instrument driver on the system.\n\nThis function writes commands and queries to the instrument to modify parameters and query device settings.\n\n\n\n\n\nResult:\n\nRS_SMB_Write($RS_SMB,$Data);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$RS_SMB\n\nobject\n\nThe object representing the instance of the Rohde & Schwarz signal generator.\n\n\n\n$Data\n\nstring\n\nThe user can use this control to send common commands and queries to the instrument.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n\n\nExample:\n\nRS_SMB_Write($RS_SMB,\""
 }
,
 "JTS RS_SigGen_Close": {
  "prefix": "RS_SigGen_Close",
  "body": [
   "RS_SigGen_Close($$Handle_SigGen);"
  ],
  "description": "\n\nCloses the I/O session to the instrument. Driver methods and properties that access the instrument are not accessible after Close is called.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle_SigGen\n\nObject\n\nInstrument handle returned by the RS_SigGen_Init function.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n--\n\n--\n\n\n\n\n\nExample:\n\nRS_SigGen_Close($Handle_SigGen);\n\n\n\n\n\nRS_SigGen_CustomDigitalModulationEnabled\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS RS_SigGen_CustomDigitalModulationEnabled": {
  "prefix": "RS_SigGen_CustomDigitalModulationEnabled",
  "body": [
   "RS_SigGen_CustomDigitalModulationEnabled($$Handle_SigGen,$$Enabled);"
  ],
  "description": "\n\nThis property enables or disables digital modulation. Switching on digital modulation turns off all the other digital standards on the same.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle_SigGen\n\nObject\n\nThe object representing the instance of the Rohde & Schwarz signal generator.\n\n\n\n$Enabled\n\nBoolean\n\nDigital modulation on/off\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n--\n\n--\n\n\n\n\n\nExample:\n\nRS_SigGen_CustomDigitalModulationEnabled($Handle_SigGen, true);\n\n\n\n\n\nRS_SigGen_Init\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS RS_SigGen_Init": {
  "prefix": "RS_SigGen_Init",
  "body": [
   "$$Handle_SigGen=RS_SigGen_Init($$ResourceName,$$ID_Query,$$Reset,$$optionsString);"
  ],
  "description": "\n\nThis function performs the following initialization actions:\n\n\u00b7 Opens a session to the Default Resource Manager resource and a session to the specified device using the interface and address specified in the Resource_Name control.\n\n\u00b7 Performs an identification query on the Instrument.\n\n\u00b7 Resets the instrument to a known state.\n\n\u00b7 Returns an Instrument Handle which is used to differentiate between different sessions of this instrument driver.\n\n\u00b7 Each time this function is invoked a Unique Session is opened. It is possible to have more than one session open for the same resource.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ResourceName\n\nString\n\nAn IVI logical name or an instrument specific string that identifies the address of the instrument, such as a VISA resource descriptor string.\n\n\n\n\n\nExamples:\n\n(1) GPIB - \"GPIB::28::INSTR\"\n\n(2) VXI-11 - \"TCPIP::192.168.1.33::INSTR\"\n\n(3) USB - \"USB::0xAAD::0x0054::100001::INSTR\"\n\n\n\n$ID_Query\n\nBoolean\n\nThis control specifies if an ID Query is sent to the instrument during the initialization procedure.\n\n\n\n$Reset\n\n\n\nBoolean\n\nThis control specifies if the instrument is to be reset to its power-on settings during the initialization procedure.\n\n\n\n$optionsString\n\nString\n\nThe user can use the OptionsString parameter to specify the initial values of certain IVI inherent attributes for the session. The format of an assignment in the OptionsString parameteris 'Name=Value', where Name is one of: RangeCheck, QuerytInstrStatus, Cache, Simulate, RecordCoercions, InterchangeCheck,or DriverSetup. Value is either true or false except for DriverSetup. If the Options String parameter contains an assignment for the Driver Setup attribute, the Initialize function assumes that everything following 'DriverSetup=' is part of the assignment.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle_SigGen\n\nObject\n\nThe object representing the instance of the Rohde & Schwarz SMB signal generator.\n\n\n\n\n\nExample:\n\n$SigGenHandle = RS_SigGen_Init(\"GPIB::10::INSTR\", true, true, \"\");\n\n\n\n\n\nRS_SigGen_LoadCustomDigitalModulationDataList\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS RS_SigGen_LoadCustomDigitalModulationDataList": {
  "prefix": "RS_SigGen_LoadCustomDigitalModulationDataList",
  "body": [
   "RS_SigGen_LoadCustomDigitalModulationDataList($$Handle_SigGen,$$path);"
  ],
  "description": "\n\nLoads the values for the custom digital modulation base data source from a data list loaded onto the instrument at the given path. If a data list with the specified name does not yet exist, it is created. The file extension may be omitted. Only files with the file extension "
 }
,
 "JTS RS_SigGen_OutputEnabled": {
  "prefix": "RS_SigGen_OutputEnabled",
  "body": [
   "RS_SigGen_OutputEnabled($$Handle_SigGen,$$Output);"
  ],
  "description": "\n\nEnables or disables the RF output signal.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle_SigGen\n\nObject\n\nThe object representing the instance of the Rohde & Schwarz signal generator.\n\n\n\n$Output\n\nBoolean\n\nThis control specifies if an ID Query is sent to the instrument during the initialization procedure.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n--\n\n--\n\n\n\n\n\nExample:\n\nRS_SigGen_OutputEnabled($Handle_SigGen,true);\n\n\n\n\n\nRS_SigGen_QuerySCPI\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS RS_SigGen_QuerySCPI": {
  "prefix": "RS_SigGen_QuerySCPI",
  "body": [
   "$$Response=RS_SigGen_QuerySCPI($$Handle_SigGen,$$Command,$$DesiredCount);"
  ],
  "description": "\n\nOutputs the supplied SCPI to the instrument and returns the respond as a string\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle_SigGen\n\nString\n\nThe object representing the instance of the Rohde & Schwarz signal generator.\n\n\n\n$Command\n\nString\n\nSCPI Command\n\n\n\n$DesiredCount\n\nInteger\n\nNumber of Bytes to read back\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Response\n\nString\n\nInstrument Response\n\n\n\n\n\nExample:\n\n$Response = RS_SigGen_QuerySCPI($Handle_SigGen,$Command,$DesiredCount);\n\n\n\n\n\nRS_SigGen_Reset\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS RS_SigGen_Reset": {
  "prefix": "RS_SigGen_Reset",
  "body": [
   "RS_SigGen_Reset($$Handle_SigGen);"
  ],
  "description": "\n\nPlaces the instrument in a known state and configures instrument options on which the IVI specific driver depends (for example, enabling/disabling headers). For an IEEE 488.2 instrument, Reset sends the command string "
 }
,
 "JTS RS_SigGen_SetAmplitude": {
  "prefix": "RS_SigGen_SetAmplitude",
  "body": [
   "RS_SigGen_SetAmplitude($$Handle_SigGen,$$Amplitude);"
  ],
  "description": "\n\nSpecifies the amplitude (power/level) of the RF output signal.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle_SigGen\n\nObject\n\nThe object representing the instance of the Rohde & Schwarz signal generator.\n\n\n\n$Amplitude\n\nFloat\n\nAmplitude (power/level) of the RF output signal\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n--\n\n--\n\n\n\n\n\nExample:\n\nRS_SigGen_SetAmplitude($Handle_SigGen,-30);\n\n\n\n\n\nRS_SigGen_SetCustomDigitalModulationCoding\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS RS_SigGen_SetCustomDigitalModulationCoding": {
  "prefix": "RS_SigGen_SetCustomDigitalModulationCoding",
  "body": [
   "RS_SigGen_SetCustomDigitalModulationCoding($$Handle_SigGen,$$Coding);"
  ],
  "description": "\n\nThis property selects the custom modulation coding.\n\nRequired Option(s): R&S SMU-B10/B11 and R&S SMU-B13\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle_SigGen\n\nObject\n\nThe object representing the instance of the Rohde & Schwarz signal generator.\n\n\n\n$Coding\n\nString\n\nModulation coding. Not all options are valid for all modulation types. Valid values:\n\n\u00b7 OFF - Sets modulation coding to off.\n\n\u00b7 APCO25 - modulation coding to APCO25.\n\n\u00b7 APCO25FSK - Sets modulation coding to APCO25FSK.\n\n\u00b7 CDMA2000 - Sets modulation coding to CDMA2000.\n\n\u00b7 DIFF - Sets modulation coding to Differential.\n\n\u00b7 DPHS - Sets modulation coding to Phase Difference.\n\n\u00b7 DGRAY- Sets modulation coding to Difference + Gray.\n\n\u00b7 EDGE - Sets modulation coding to edge.\n\n\u00b7 GRAY - Sets modulation coding to gray.\n\n\u00b7 GSM - Sets modulation coding to GSM.\n\n\u00b7 ICO - Sets modulation coding to ICO.\n\n\u00b7 NADC - Sets modulation coding to NADC.\n\n\u00b7 PDC - Sets modulation coding to PDC.\n\n\u00b7 PHS - Sets modulation coding to PHS.\n\n\u00b7 TETRA - Sets modulation coding to TETRA.\n\n\u00b7 PWT - Sets modulation coding to PWT.\n\n\u00b7 TFTS - Sets modulation coding to TFTS.\n\n\u00b7 INMARSAT - Sets modulation coding to INMarsat.\n\n\u00b7 VDL - Sets modulation coding to VDL.\n\n\u00b7 WCDMA - Sets modulation coding to WCDMA.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n--\n\n--\n\n\n\n\n\nExample:\n\nRS_SigGen_SetCustomDigitalModulationCoding($Handle_SigGen,\"VDL\");\n\n\n\n\n\nRS_SigGen_SetCustomDigitalModulationType\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS RS_SigGen_SetCustomDigitalModulationType": {
  "prefix": "RS_SigGen_SetCustomDigitalModulationType",
  "body": [
   "RS_SigGen_SetCustomDigitalModulationType($$Handle_SigGen,$$Modulation);"
  ],
  "description": "\n\nThis property selects the custom modulation type.\n\nRequired Option(s): R&S SMU-B10/B11 and R&S SMU-B13\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle_SigGen\n\nObject\n\nThe object representing the instance of the Rohde & Schwarz signal generator.\n\n\n\n$Modulation\n\nString\n\nModulation type. Valid values:\n\n\u00b7 ASK = Selects modulation type ASK.\n\n\u00b7 BPSK = Selects modulation type BPSK.\n\n\u00b7 QPSK = Selects modulation type QPSK.\n\n\u00b7 QPSK45 = Selects modulation type QPSK 45deg Offset.\n\n\u00b7 OQPSK = Selects modulation type OQPSK.\n\n\u00b7 P4QPSK = Selects modulation type p/4-QPSK.\n\n\u00b7 P2DBPSK = Selects modulation type p/2-DBPSK.\n\n\u00b7 P4DQPSK = Selects modulation type p/4-DQPSK.\n\n\u00b7 P8D8PSK = Selects modulation type p/8-D8PSK.\n\n\u00b7 PSK8 = Selects modulation type 8PSK.\n\n\u00b7 P8EDGE = Selects modulation type 8PSKEDGE.\n\n\u00b7 QAM16 = Selects modulation type 16QAM.\n\n\u00b7 QAM32 = Selects modulation type 32QAM.\n\n\u00b7 QAM64 = Selects modulation type 64QAM.\n\n\u00b7 QAM128 = Selects modulation type 128QAM.\n\n\u00b7 QAM256 = Selects modulation type 256QAM.\n\n\u00b7 QAM1024 = Selects modulation type 1024QAM.\n\n\u00b7 MSK = Selects modulation type MSK.\n\n\u00b7 FSK2 = Selects modulation type 2FSK.\n\n\u00b7 FSK4 = Selects modulation type 4FSK.\n\n\u00b7 FSKVar = Selects modulation type Variable FSK.\n\n\u00b7 QAM16EDGE = Selects modulation type 16QAM Edge.\n\n\u00b7 QAM32EDGE = Selects modulation type 32 QAM Edge.\n\n\u00b7 QEDGE = Selects modulation type Q Edge.\n\n\u00b7 USER = Selects modulation type User.\n\n\u00b7 AQPSK = Selects modulation type AQPSK.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n--\n\n--\n\n\n\n\n\nExample:\n\nRS_SigGen_SetCustomDigitalModulationType($Handle_SigGen,\"FSK2\");\n\n\n\n\n\nRS_SigGen_SetFrequency\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS RS_SigGen_SetFrequency": {
  "prefix": "RS_SigGen_SetFrequency",
  "body": [
   "RS_SigGen_SetFrequency($$Handle_SigGen,$$Frequency);"
  ],
  "description": "\n\nSpecifies the frequency of the generated RF output signal.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle_SigGen\n\nObject\n\nThe object representing the instance of the Rohde & Schwarz signal generator.\n\n\n\n$Frequency\n\nFloat\n\nFrequency of the RF output signal\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n--\n\n--\n\n\n\n\n\nExample:\n\nRS_SigGen_SetFrequency($Handle_SigGen,1000000);\n\n\n\n\n\nRS_SigGen_WriteSCPI\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS RS_SigGen_WriteSCPI": {
  "prefix": "RS_SigGen_WriteSCPI",
  "body": [
   "RS_SigGen_WriteSCPI($$Handle_SigGen,$$Command);"
  ],
  "description": "\n\nWrites raw string (SCPI command) to the instrument input.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle_SigGen\n\nString\n\nThe object representing the instance of the Rohde & Schwarz signal generator.\n\n\n\n$Command\n\nString\n\nSCPI Command\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n--\n\n--\n\n\n\n\n\nExample:\n\nRS_SigGen_WriteSCPI($SigGenHandle, \"MMEM:CDIR '/hdd/RxFER'\");\n\n\n\n\n\nSupported Instruments\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AVR31XX_Close": {
  "prefix": "AVR31XX_Close",
  "body": [
   "AVR31XX_Close($$Handle);"
  ],
  "description": "\n\nThis function supports the Advantest R3131, R3132 and R3162 Spectrum Analyzers. The use the AVR31XX functions requires NI-VISA to be installed.\n\nCloses the I/O session to the instrument.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nHandle of the instrument.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\nNone\n\nNone\n\n\n\n\n\nAVR31XX_Init\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AVR31XX_Init": {
  "prefix": "AVR31XX_Init",
  "body": [
   "$$Handle=AVR31XX_Init($$IntrumentID,$$Reset);"
  ],
  "description": "\n\nThis function supports the Advantest R3131, R3132 and R3162 Spectrum Analyzers. The use the AVR31XX functions requires NI-VISA to be installed.\n\n\n\nThis function performs the following initialization actions:\n\n1. Opens a session to the Default Resource Manager resource and a session\n\nto the specified device using the interface and address specified in the\n\nResource_Name control.\n\n2. Performs an identification query on the Instrument.\n\n3. Resets the instrument to a known state.\n\n4. Sends initialization commands to the instrument that set any necessary\n\nprogrammatic variables such as Headers Off, Short Command form, and Data\n\nTransfer Binary to the state necessary for the operation of the\n\ninstrument driver.\n\n5. Returns an Instrument Handle which is used to differentiate between\n\ndifferent sessions of this instrument driver.\n\n6. Each time this function is invoked a Unique Session is opened. It is\n\npossible to have more than one session open for the same resource.\n\n\n\n\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentID\n\nString\n\nThis is a string that indicates the instrument interface as it is identified by NI-VISA. For instance \"GPIB0::9\" for GPIB or \"ASR:0::1\" for Serial Interfaces\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nA handle to the instrument\n\n\n\n\n\nAVR31XX_PeakSearch\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AVR31XX_PeakSearch": {
  "prefix": "AVR31XX_PeakSearch",
  "body": [
   "($$DifferenceOfPositionMinMax,$$DifferenceOfLevelMinMax)=AVR31XX_PeakSearch($$Handle,$$SearchType);"
  ],
  "description": "\n\nThis function supports the Advantest R3131, R3132 and R3162 Spectrum Analyzers. The use the AVR31XX functions requires NI-VISA to be installed.\n\nThis function performs different types of peak marker search, see the parameter details for more information.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nA handle for the instrument, created by using the AVR31XX_Init function.\n\n\n\n$SearchType\n\nString\n\nThe search-type parameter has the following valid values:\n\n\"PeakSearch\"\n\n\"NextPeak\"\n\n\"NextPeakLeft\"\n\n\"NextPeakRight\"\n\n\"MinimumSearch\"\n\n\"PeakMinMax\"\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$DifferenceOfPositionMinMax\n\nDouble\n\nReturns the difference of position between the highest peak and the lowest peak of the signal\n\n\n\n$DifferenceOfLevelMinMax\n\nDouble\n\nReturns the difference of level between the highest peak and the lowest peak of the signal\n\n\n\n\n\nAVR31XX_SetFrequency\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AVR31XX_SetFrequency": {
  "prefix": "AVR31XX_SetFrequency",
  "body": [
   "AVR31XX_SetFrequency($$Handle,$$FrequencyType,$$FrequencyHertz);"
  ],
  "description": "\n\nThis function supports the Advantest R3131, R3132 and R3162 Spectrum Analyzers. The use the AVR31XX functions requires NI-VISA to be installed.\n\nThis function sets the starting, center, and stop frequency of the spectrum analyzer.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nA handle for the instrument, created by using the AVR31XX_Init function.\n\n\n\n$FrequencyType\n\nString\n\nA string indicating the frequency to set. The valid values are:\n\n\u00b7 \"CENTER\"\n\n\u00b7 \"START\"\n\n\u00b7 \"STOP\"\n\n\n\n$FrequencyHertz\n\nDouble\n\nThe value in Hertz to set the selected frequency\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nAVR31XX_SetReferenceLevel\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AVR31XX.SetReferenceLevel": {
  "prefix": "AVR31XX.SetReferenceLevel",
  "body": [
   "AVR31XX.SetReferenceLevel($$Handle,$$ReferenceLevel);"
  ],
  "description": "\n\nThis function supports the Advantest R3131, R3132 and R3162 Spectrum Analyzers. The use the AVR31XX functions requires NI-VISA to be installed.\n\nThis function sets the reference level of th spectrum analyzer. It uses the current unit of measure that the instrument is set (default is dBm).\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nA handle for the instrument, created by using the AVR31XX_Init function.\n\n\n\n$ReferenceLevel\n\nDouble\n\nThe value for the reference level in the instruments current unit mode.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nAVR31XX_SetSpan\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AVR31XX_SetSpan": {
  "prefix": "AVR31XX_SetSpan",
  "body": [
   "AVR31XX_SetSpan($$Handle,$$SpanType,$$SpanHertz);"
  ],
  "description": "\n\nThis function supports the Advantest R3131, R3132 and R3162 Spectrum Analyzers. The use the AVR31XX functions requires NI-VISA to be installed.\n\nThis function sets the overall frequency span of the Spectrum Analyzer\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nA handle for the instrument, created by using the AVR31XX_Init function.\n\n\n\n$SpanType\n\nString\n\nThe type of span to set for the Spectrum Analyzer. Valid values are:\n\n\"MANUAL\" = Sets the Span to the value passed in for the second parameter\n\n\"FULL\"\n\n\"ZERO\" = Sets the instrument to time domain mode\n\n\"LAST\"\n\n\n\n$SpanHertz\n\nDouble\n\nIf the $SpanType parameter is specified as \"MANUAL\", this parameter sets the frequency span of the instrument.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nAeroFlexDigitizer_Close\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AeroFlexDigitizer_Close": {
  "prefix": "AeroFlexDigitizer_Close",
  "body": [
   "AeroFlexDigitizer_Close($$handle);"
  ],
  "description": "\n\n\n\n\n\nThis method closes and frees up all resources used by the Digitizer.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$handle\n\nObject\n\nThe handle of the instrument returned from the AeroFlex Digitizer_Open function\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nnone\n\n\n\n\n\nExample:\n\n\n\n\n\nAeroFlexDigitizer_Close($handle);\n\n\n\n\n\nAeroFlexDigitizer_GetCenterFreqLOAboveMax\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AeroFlexDigitizer_GetCenterFreqLOAboveMax": {
  "prefix": "AeroFlexDigitizer_GetCenterFreqLOAboveMax",
  "body": [
   "$$handle=AeroFlexDigitizer_GetCenterFreqLOAboveMax($$handle,$$CenterfrequencyLOAboveMax);Note:TheseareadvancedlowlevelcontrolfunctionfortheAeroFlexPXIRFDigitizer.ItisrecommendedtousetheAeroFlexSpectrumAnalyzer_XXXfunctionlibraryforgeneralmeasurementsandtesting.Thesefunctionsareintendedforcustomtestscenariosforexpertuserswhorequireafinerlevelofcontroloverthetestequipment."
  ],
  "description": "\n\nThis method gets the maximum Center Frequency if LOPosition is set to afDigitizerDll_lopAbove.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$handle\n\nObject\n\nThe handle of the instrument returned from the AeroFlex Digitizer open function\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$CenterfrequencyLOAboveMax\n\nFloat\n\nCenter Frequency Number\n\n\n\n\n\nExample:\n\n\n\n\n\nAeroFlexDigitizer_GetCenterFreqLOAboveMax($handle,$CenterfrequencyLOAboveMax);\n\n\n\n\n\nAeroFlexDigitizer_GetCenterFreqLOBelowMin\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AeroFlexDigitizer_GetCenterFreqLOBelowMin": {
  "prefix": "AeroFlexDigitizer_GetCenterFreqLOBelowMin",
  "body": [
   "$$handle=AeroFlexDigitizer_GetCenterFreqLOBelowMin($$handle,$$CenterfrequencyLOAboveMin);Note:TheseareadvancedlowlevelcontrolfunctionfortheAeroFlexPXIRFDigitizer.ItisrecommendedtousetheAeroFlexSpectrumAnalyzer_XXXfunctionlibraryforgeneralmeasurementsandtesting.Thesefunctionsareintendedforcustomtestscenariosforexpertuserswhorequireafinerlevelofcontroloverthetestequipment."
  ],
  "description": "\n\nThis method gets the minimum Center Frequency if LOPosition is set to afDigitizerDll_lopBelow.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$handle\n\nObject\n\nThe handle of the instrument returned from the AeroFlex Digitizer open function\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$CenterfrequencyLOAboveMin\n\nFloat\n\nMinimum center frequency number\n\n\n\n\n\nExample:\n\n\n\n\n\nAeroFlexDigitizer_GetCenterFreqLOBelowMin($handle,$CenterfrequencyLOAboveMin);\n\n\n\n\n\nAeroFlexDigitizer_GetCenterFrequency\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AeroFlexDigitizer_GetCenterFrequency": {
  "prefix": "AeroFlexDigitizer_GetCenterFrequency",
  "body": [
   "$$handle=AeroFlexDigitizer_GetCenterFrequency($$handle,$$CenterFreq);Note:TheseareadvancedlowlevelcontrolfunctionfortheAeroFlexPXIRFDigitizer.ItisrecommendedtousetheAeroFlexSpectrumAnalyzer_XXXfunctionlibraryforgeneralmeasurementsandtesting.Thesefunctionsareintendedforcustomtestscenariosforexpertuserswhorequireafinerlevelofcontroloverthetestequipment."
  ],
  "description": "\n\nThis method gets the center frequency (in Hz) of the active channel being used by the digitizer when in manual mode.\n\nNote: It sets the AF303x to the specified center frequency and the synthesizer (for example AF301x) to the corresponding local oscillator frequency\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$handle\n\nObject\n\nThe handle of the instrument returned from the AeroFlex Digitizer open function\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$CenterFreq\n\nFloat\n\nCenter Frequency Number\n\n\n\n\n\nExample:\n\n\n\n\n\n$CenterFreq = AeroFlexDigitizer_Set_CenterFrequency($handle);\n\n\n\n\n\nAeroFlexDigitizer_GetFreqMax\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AeroFlexDigitizer_GetFreqMax": {
  "prefix": "AeroFlexDigitizer_GetFreqMax",
  "body": [
   "$$FreqMax=AeroFlexDigitizer_GetFreqMax($$handle);Note:TheseareadvancedlowlevelcontrolfunctionfortheAeroFlexPXIRFDigitizer.ItisrecommendedtousetheAeroFlexSpectrumAnalyzer_XXXfunctionlibraryforgeneralmeasurementsandtesting.Thesefunctionsareintendedforcustomtestscenariosforexpertuserswhorequireafinerlevelofcontroloverthetestequipment."
  ],
  "description": "\n\nThis method gets the maximum center frequency (in Hz) of the digitizer.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$handle\n\nObject\n\nThe handle of the instrument returned from the AeroFlex Digitizer open function\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$FreqMax\n\nFloat\n\nMax center frequency number\n\n\n\n\n\nExample:\n\n\n\n\n\n$FreqMax = AeroFlexDigitizer_GetFreqMax($handle);\n\n\n\n\n\nAeroFlexDigitizer_GetFreqMin\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AeroFlexDigitizer_GetFreqMin": {
  "prefix": "AeroFlexDigitizer_GetFreqMin",
  "body": [
   "$$FreqMin=AeroFlexDigitizer_GetFreqMin($$handle);Note:TheseareadvancedlowlevelcontrolfunctionfortheAeroFlexPXIRFDigitizer.ItisrecommendedtousetheAeroFlexSpectrumAnalyzer_XXXfunctionlibraryforgeneralmeasurementsandtesting.Thesefunctionsareintendedforcustomtestscenariosforexpertuserswhorequireuserswhorequireafinerlevelofcontroloverthetestequipment."
  ],
  "description": "\n\nThis method gets the minimum center frequency (in Hz) of the digitizer.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$handle\n\nObject\n\nThe handle of the instrument returned from the AeroFlex Digitizer open function\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$FreqMin\n\nFloat\n\nMin center frequency number\n\n\n\n\n\nExample:\n\n\n\n\n\n$FreqMin = AeroFlexDigitizer_GetFreqMin($handle);\n\n\n\n\n\nAeroFlexDigitizer_GetIFAttenuation\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AeroFlexDigitizer_GetIFAttenuation": {
  "prefix": "AeroFlexDigitizer_GetIFAttenuation",
  "body": [
   "$$Attenuation=AeroFlexDigitizer_GetIFAttenuation($$handle);Note:TheseareadvancedlowlevelcontrolfunctionfortheAeroFlexPXIRFDigitizer.ItisrecommendedtousetheAeroFlexSpectrumAnalyzer_XXXfunctionlibraryforgeneralmeasurementsandtesting.Thesefunctionsareintendedforcustomtestscenariosforexpertuserswhorequireafinerlevelofcontroloverthetestequipment."
  ],
  "description": "\n\nThis method gets the IF Attenuation (in dB) of the active channel being used by the digitizer when in manual mode.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$handle\n\nObject\n\nThe handle of the instrument returned from the AeroFlex Digitizer open function\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$attenuation\n\nInteger\n\nIF attenuation value (0 to 35) in 1dB increments )\n\n\n\n\n\nExample:\n\n\n\n\n\n$Attenuation = AeroFlexDigitizer_GetIFAttenuation($handle);\n\n\n\n\n\nAeroFlexDigitizer_GetIQADCOverload\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AeroFlexDigitizer_GetIQADCOverload": {
  "prefix": "AeroFlexDigitizer_GetIQADCOverload",
  "body": [
   "$$adcoverload=AeroFlexDigitizer_GetIQADCOverload($$handle);Note:TheseareadvancedlowlevelcontrolfunctionfortheAeroFlexPXIRFDigitizer.ItisrecommendedtousetheAeroFlexSpectrumAnalyzer_XXXfunctionlibraryforgeneralmeasurementsandtesting.Thesefunctionsareintendedforcustomtestscenariosforexpertuserswhorequireafinerlevelofcontroloverthetestequipment."
  ],
  "description": "\n\nThis method gets the ADC Overload status.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$handle\n\nObject\n\nThe handle of the instrument returned from the AeroFlex Digitizer open function\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$adcoverload\n\nBoolean\n\nTRUE is no ADC overload and FALSE is ADC overload\n\n\n\n\n\nExample:\n\n\n\n\n\n$ADCOverload = AeroFlexDigitizer_GetIQADCOverload($handle);\n\n\n\n\n\nAeroFlexDigitizer_GetIQCaptureSampleCount\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AeroFlexDigitizer_GetIQCaptureSampleCount": {
  "prefix": "AeroFlexDigitizer_GetIQCaptureSampleCount",
  "body": [
   "$$IQCaptureSampleCount=AeroFlexDigitizer_GetIQCaptureSampleCount($$handle);Note:TheseareadvancedlowlevelcontrolfunctionfortheAeroFlexPXIRFDigitizer.ItisrecommendedtousetheAeroFlexSpectrumAnalyzer_XXXfunctionlibraryforgeneralmeasurementsandtesting.Thesefunctionsareintendedforcustomtestscenariosforexpertuserswhorequireafinerlevelofcontroloverthetestequipment."
  ],
  "description": "\n\nThis method gets the number of I and Q sample pairs that have been captured.\n\nNote:\n\nFollowing the use of Abort, afDigitzerDll_ciqeCompleted event will be issued but the CapturedSampleCount will be less than the numberOfIQSamples requested.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$handle\n\nObject\n\nThe handle of the instrument returned from the AeroFlex Digitizer open function\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$IQCaptureSampleCount\n\nInteger\n\nNumber of IQ sample pairs\n\n\n\n\n\nExample:\n\n\n\n\n\n$SampleCount = AeroFlexDigitizer_GetIQCaptureSampleCount($handle);\n\n\n\n\n\nAeroFlexDigitizer_GetRFAttenuation\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AeroFlexDigitizer_GetRFAttenuation": {
  "prefix": "AeroFlexDigitizer_GetRFAttenuation",
  "body": [
   "$$RFAttenuation=AeroFlexDigitizer_GetRFAttenuation($$handle);Note:TheseareadvancedlowlevelcontrolfunctionfortheAeroFlexPXIRFDigitizer.ItisrecommendedtousetheAeroFlexSpectrumAnalyzer_XXXfunctionlibraryforgeneralmeasurementsandtesting.Thesefunctionsareintendedforcustomtestscenariosforexpertuserswhorequireafinerlevelofcontroloverthetestequipment."
  ],
  "description": "\n\nThis method gets the RF Attenuation (in dB) of the active channel being used by the digitizer when in manual mode.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$handle\n\nObject\n\nThe handle of the instrument returned from the AeroFlex Digitizer open function\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$RFattenuation\n\nInteger\n\nRF attenuation value in (db)\n\n\n\n\n\nExample:\n\n\n\n\n\n$Attenuation = AeroFlexDigitizer_GetRFAttenuation($handle);\n\n\n\n\n\nAeroFlexDigitizer_GetRFInputLevel\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AeroFlexDigitizer_GetRFInputLevel": {
  "prefix": "AeroFlexDigitizer_GetRFInputLevel",
  "body": [
   "$$InputLevel=AeroFlexDigitizer_GetRFInputLevel($$handle);Note:TheseareadvancedlowlevelcontrolfunctionfortheAeroFlexPXIRFDigitizer.ItisrecommendedtousetheAeroFlexSpectrumAnalyzer_XXXfunctionlibraryforgeneralmeasurementsandtesting.Thesefunctionsareintendedforcustomtestscenariosforexpertuserswhorequireafinerlevelofcontroloverthetestequipment."
  ],
  "description": "\n\nThis method gets the RF Input Level (in dBm) of the active channel being used by the digitizer when in manual mode\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$handle\n\nObject\n\nThe handle of the instrument returned from the AeroFlex Digitizer function\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$inputlevel\n\nFloat\n\nRF input level\n\n\n\n\n\nExample:\n\n\n\n\n\n$InputLevel = AeroFlexDigitizer_GetRFInputLevel($handle);\n\n\n\n\n\nAeroFlexDigitizer_GetRFLevelCorrection\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AeroFlexDigitizer_GetRFLevelCorrection": {
  "prefix": "AeroFlexDigitizer_GetRFLevelCorrection",
  "body": [
   "$$handle=AeroFlexDigitizer_GetRFLevelCorrection($$handle,$$RFLevelCorrection);Note:TheseareadvancedlowlevelcontrolfunctionfortheAeroFlexPXIRFDigitizer.ItisrecommendedtousetheAeroFlexSpectrumAnalyzer_XXXfunctionlibraryforgeneralmeasurementsandtesting.Thesefunctionsareintendedforcustomtestscenariosforexpertuserswhorequireafinerlevelofcontroloverthetestequipment."
  ],
  "description": "\n\nThis method gets the level correction figure in dB that can be used in conjunction with IQ or IF data that has been captured by AF303x to calculate the power of the signal being applied to AF303x. This figure is only valid for the current hardware setting.\n\nNotes:\n\nTo calculate the absolute power associated to a captured IQ data pair, perform the following calculation\n\nPower (in dBm) = 10"
 }
,
 "JTS AeroFlexDigitizer_GetRFStepAttenuation": {
  "prefix": "AeroFlexDigitizer_GetRFStepAttenuation",
  "body": [
   "$$StepAttenuation=AeroFlexDigitizer_GetRFStepAttenuation($$handle);Note:TheseareadvancedlowlevelcontrolfunctionfortheAeroFlexPXIRFDigitizer.ItisrecommendedtousetheAeroFlexSpectrumAnalyzer_XXXfunctionlibraryforgeneralmeasurementsandtesting.Thesefunctionsareintendedforcustomtestscenariosforexpertuserswhorequireafinerlevelofcontroloverthetestequipment."
  ],
  "description": "\n\nThis method gets the IF attenuation step size (in dB) of the digitizer.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$handle\n\nObject\n\nThe handle of the instrument returned from the AeroFlex Digitizer open function\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$StepAttenuation\n\nInteger\n\nRF attenuation value in (dB)\n\n\n\n\n\nExample:\n\n\n\n\n\n$StepAttenuation = AeroFlexDigitizer_GetRFStepAttenuation($handle);\n\n\n\n\n\nAeroFlexDigitizer_Open\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AeroFlexDigitizer_Open": {
  "prefix": "AeroFlexDigitizer_Open",
  "body": [
   "$$handle=AeroFlexDigitizer_Open($$digititzerResource,$$oscResource,$$oscIsPlugin);"
  ],
  "description": "\n\nThis method attempts to boot the digitizer using the parameters provided.\n\n$DigitizerResource and $oscResource must be valid Visa resource strings.\n\n$oscIsPlugin must be set to true if an AF3010 is not being used for the LO, in which case the $oscResource must have been preset to a valid plugin.\n\nNote that using a plugin to drive the local oscillator will reduce the overall functionality of the digitizer.\n\nThis function initializes a session with the instrument and returns the handle to the test script.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$digitizerResource\n\nString\n\nThe resource name of the digitizer.\n\n\n\n$oscResource\n\nString\n\nThe resource name of the oscillator.\n\n\n\n$oscIsPlugin\n\nBoolean\n\nLocal Oscillator input to the digitizer is plugin [TRUE or FALSE]\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$handle\n\nObject\n\nThe handle to the instrument session.\n\n\n\n\n\nExample:\n\n\n\n\n\n$handle = AeroFlexDigitizer_Open(\"PXI4::14::INSTR\",\"PXI4::15::INSTR\", FALSE);\n\n\n\n\n\nAeroFlexDigitizer_SetCaptureIQTriggerArm\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AeroFlexDigitizer_SetCaptureIQTriggerArm": {
  "prefix": "AeroFlexDigitizer_SetCaptureIQTriggerArm",
  "body": [
   "AeroFlexDigitizer_SetCaptureIQTriggerArm($$handle,$$TriggerArmNumSamples);Note:TheseareadvancedlowlevelcontrolfunctionfortheAeroFlexPXIRFDigitizer.ItisrecommendedtousetheAeroFlexSpectrumAnalyzer_XXXfunctionlibraryforgeneralmeasurementsandtesting.Thesefunctionsareintendedforcustomtestscenariosforexpertuserswhorequireafinerlevelofcontroloverthetestequipment."
  ],
  "description": "\n\nThis method commands the AF303x to arm for a trigger event to capture the specified number of samples.\n\nNotes:\n\nThe TriggerArm method should be used in hardware trigger and armed software trigger modes. It is not applicable in immediate software trigger mode.\n\nOnce the AF303x is armed, the application software can then check whether a trigger event has happened (using Detected property) or whether data capture is complete (see CaptComplete). The data capture can also be aborted before capture is complete using Abort() method.\n\nIn hardware trigger mode, the first trigger after this function initiates the data capture. In 'Armed' software trigger mode (see Trigger.SwTriggerMode), this function initiates the data capture of the specified number of samples.\n\nThis method is equivalent to setting Capture.SampleDataType to afDigitizerDll_sdtIQData and calling Trigger Arm.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$handle\n\nObject\n\nThe handle of the instrument returned from the AeroFlex Digitizer Open function\n\n\n\n$TriggerArmNumSamples\n\nInteger\n\nsets a trigger event to capture the specified number of samples\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nnone\n\n\n\n\n\nExample:\n\nAeroFlexDigitizer_SetCaptureIQTriggerArm($handle,$TriggerArmNumSamples);\n\n\n\n\n\nAeroFlexDigitizer_SetCenterFreq\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AeroFlexDigitizer_SetCenterFreq": {
  "prefix": "AeroFlexDigitizer_SetCenterFreq",
  "body": [
   "AeroFlexDigitizer_SetCenterFreq($$handle,$$CenterFreq);Note:TheseareadvancedlowlevelcontrolfunctionfortheAeroFlexPXIRFDigitizer.ItisrecommendedtousetheAeroFlexSpectrumAnalyzer_XXXfunctionlibraryforgeneralmeasurementsandtesting.Thesefunctionsareintendedforcustomtestscenariosforexpertuserswhorequireafinerlevelofcontroloverthetestequipment."
  ],
  "description": "\n\nThis method sets the center frequency (in Hz) of the active channel being used by the digitizer when in manual mode.\n\nNotes:\n\nIt sets the AF303x to the specified centre frequency and the synthesizer (for example AF301x) to the corresponding local oscillator frequency.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$handle\n\nObject\n\nThe handle of the instrument returned from the AeroFlex Digitizer open function\n\n\n\n$CenterFreq\n\nDouble\n\nSets the desired frequency\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nnone\n\n\n\n\n\nExample:\n\nAeroFlexDigitizer_SetCenterFreq($handle, 850000000);\n\n\n\n\n\nAeroFlexDigitizer_SetIFAttenuation\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AeroFlexDigitizer_SetIFAttenuation": {
  "prefix": "AeroFlexDigitizer_SetIFAttenuation",
  "body": [
   "AeroFlexDigitizer_SetIFAttenuation($$handle,$$IFAttenuation);Note:TheseareadvancedlowlevelcontrolfunctionfortheAeroFlexPXIRFDigitizer.ItisrecommendedtousetheAeroFlexSpectrumAnalyzer_XXXfunctionlibraryforgeneralmeasurementsandtesting.Thesefunctionsareintendedforcustomtestscenariosforexpertuserswhorequireafinerlevelofcontroloverthetestequipment."
  ],
  "description": "\n\nThis method sets the IF Attenuation (in dB) of the active channel being used by the digitizer when in manual mode.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$handle\n\nObject\n\nThe handle of the instrument returned from the AeroFlex Digitizer open function\n\n\n\n$IFAttenuation\n\nInteger\n\nSets the desired attenuation from 0 to 35 dB in 1dB increments\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nnone\n\n\n\n\n\nExample:\n\nAeroFlexDigitizer_SetIFAttenuation($handle, 4);\n\n\n\n\n\nAeroFlexDigitizer_SetLOReference\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AeroFlexDigitizer_SetLOReference": {
  "prefix": "AeroFlexDigitizer_SetLOReference",
  "body": [
   "AeroFlexDigitizer_SetLOReference($$handle,$$LOReferenceMode);"
  ],
  "description": "\n\nThis function sets the LO external reference mode.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$handle\n\nObject\n\nThe handle of the instrument returned from the AeroFlexDigitizer_Open function\n\n\n\n$LOReferenceMode\n\nString\n\nSets the desired LO reference mode:\n\n\u00b7 \"OCXO\" = Internal\n\n\u00b7 \"INTERNAL\" = Internal\n\n\u00b7 \"EXTERNALDAISY\" = External\n\n\u00b7 \"EXTERNALTERMINATED\" = External\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nnone\n\n\n\n\n\nExample:\n\n\n\n\n\nAeroFlexDigitizer_SetLOReference($handle,\"INTERNAL\");\n\n\n\n\n\nAeroFlexDigitizer_SetRFAttenuation\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AeroFlexDigitizer_SetRFAttenuation": {
  "prefix": "AeroFlexDigitizer_SetRFAttenuation",
  "body": [
   "AeroFlexDigitizer_SetRFAttenuation($$handle,$$RFAttenuation);Note:TheseareadvancedlowlevelcontrolfunctionfortheAeroFlexPXIRFDigitizer.ItisrecommendedtousetheAeroFlexSpectrumAnalyzer_XXXfunctionlibraryforgeneralmeasurementsandtesting.Thesefunctionsareintendedforcustomtestscenariosforexpertuserswhorequireafinerlevelofcontroloverthetestequipment."
  ],
  "description": "\n\nThis method sets the RF Attenuation (in dB) of the active channel being used by the digitizer when in manual mode.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$handle\n\nObject\n\nThe handle of the instrument returned from the AeroFlex Digitizer Open function\n\n\n\n$RFAttenuation\n\nInteger\n\nSets the desired attenuation\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nnone\n\n\n\n\n\nExample:\n\nAeroFlexDigitizer_SetRFAttenuation($handle, 10);\n\n\n\n\n\nAeroFlexDigitizer_SetRFExternalReferenceMode\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AeroFlexDigitizer_SetRFExternalReferenceMode": {
  "prefix": "AeroFlexDigitizer_SetRFExternalReferenceMode",
  "body": [
   "AeroFlexDigitizer_SetRFExternalReferenceMode($$handle,$$RFReferenceMode);"
  ],
  "description": "\n\nThis function sets the RF External reference mode.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$handle\n\nObject\n\nThe handle of the instrument returned from the AeroFlexDigitizer_Open function\n\n\n\n$RFExternalReferenceMode\n\nString\n\nSets the desired RF external reference mode:\n\n\u00b7 \"FREERUN\" = Free Run\n\n\u00b7 \"LOCKEDTO10MHZ\" = Lock to 10Mhz Reference\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nnone\n\n\n\n\n\nExample:\n\n\n\n\n\nAeroFlexDigitizer_SetRFExternalReferenceMode($handle,\"LOCKEDTO10MHZ\");\n\n\n\n\n\nAeroFlexDigitizer_SetRFInputLevel\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AeroFlexDigitizer_SetRFInputLevel": {
  "prefix": "AeroFlexDigitizer_SetRFInputLevel",
  "body": [
   "AeroFlexDigitizer_SetRFInputLevel($$handle,$$RFinputLevel);Note:TheseareadvancedlowlevelcontrolfunctionfortheAeroFlexPXIRFDigitizer.ItisrecommendedtousetheAeroFlexSpectrumAnalyzer_XXXfunctionlibraryforgeneralmeasurementsandtesting.Thesefunctionsareintendedforcustomtestscenariosforexpertuserswhorequireafinerlevelofcontroloverthetestequipment."
  ],
  "description": "\n\nThis method sets the RF Input Level (in dBm) of the active channel being used by the digitizer when in manual mode.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$handle\n\nObject\n\nThe handle of the instrument returned from the AeroFlex Digitizer Open function\n\n\n\n$RFinputLevel\n\nFloat\n\nSets the desired RF input level in dBm\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nnone\n\n\n\n\n\nExample:\n\n\n\n\n\nAeroFlexDigitizer_SetRFInputLevel($handle, 10);\n\n\n\n\n\nAeroFlexDigitizer_SetRFReference\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AeroFlexDigitizer_SetRFReference": {
  "prefix": "AeroFlexDigitizer_SetRFReference",
  "body": [
   "AeroFlexDigitizer_SetRFReference($$handle,$$RFReferenceMode);"
  ],
  "description": "\n\nThis function sets the RF reference mode.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$handle\n\nObject\n\nThe handle of the instrument returned from the AeroFlexDigitizer_Open function\n\n\n\n$RFReferenceMode\n\nString\n\nSets the desiredRF reference mode:\n\n\u00b7 \"INTERNAL\" = Internal\n\n\u00b7 \"EXTERNALPCIBACKPLANE\" = External\n\n\u00b7 \"EXTERNALDAISY\" = External\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nnone\n\n\n\n\n\nExample:\n\n\n\n\n\nAeroFlexDigitizer_SetRFReference($handle,\"INTERNAL\");\n\n\n\n\n\nAeroFlexSpectrumAnalyzer_AbortMeasurement\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AeroFlexSpectrumAnalyzer_AbortMeasurement": {
  "prefix": "AeroFlexSpectrumAnalyzer_AbortMeasurement",
  "body": [
   "AeroFlexSpectrumAnalyzer_AbortMeasurement($$SpecAn);"
  ],
  "description": "\n\nThis function aborts all the enabled measurements.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$SpecAn\n\nObject\n\nSpectrum Analyzer Object\n\n\n\n\n\nExample:\n\n\n\n\n\ncall Initialize();\n\nSetFinalizeFunction(\"CloseInstruments\");\n\nAeroFlexCombiner_SetMode($Combiner, \"AtoB\");\n\nAeroFlexSigGen_SetFrequency($SigGen,2100000000);\n\nAeroFlexSigGen_SetLevel($SigGen, -10);\n\nAeroFlexSigGen_EnableOutput($SigGen, \"TRUE\");\n\nSleep(1);\n\n\n\n\n\n$CaptureState = AeroFlexSpectrumAnalyzer_GetCaptureState($SpecAn);\n\n$Locked = AeroFlexSpectrumAnalyzer_CheckRFReferenceLocked($SpecAn);\n\nAeroFlexSpectrumAnalyzer_SetTriggerSource($SpecAn,\"IMMEDIATE\");\n\nAeroFlexSpectrumAnalyzer_SetReferenceLevel($SpecAn,0);\n\nAeroFlexSpectrumAnalyzer_SetEnabledMeasurement($SpecAn,\"POWERVSFREQ\",true);\n\nAeroFlexSpectrumAnalyzer_SetEnabledMeasurement($SpecAn,\"NPEAKS\",true);\n\nAeroFlexSpectrumAnalyzer_SetStartFrequency($SpecAn,2000000000);\n\nAeroFlexSpectrumAnalyzer_SetStopFrequency($SpecAn,2200000000);\n\nAeroFlexSpectrumAnalyzer_SetCenterFrequency($SpecAn,2100000000);\n\n//AeroFlexSpectrumAnalyzer_SetMeasurementSpan($SpecAn,10000000);\n\nAeroFlexSpectrumAnalyzer_SetMeasurementRBW($SpecAn,200000);\n\nAeroFlexSpectrumAnalyzer_SetMeasurementAveraging($SpecAn,25);\n\nAeroFlexSpectrumAnalyzer_SetWindowMode($SpecAn,\"GUASSIAN3DB\");\n\nAeroFlexSpectrumAnalyzer_SetRunMode($SpecAn,\"CONTINUOUS\");\n\nAeroFlexSpectrumAnalyzer_StartMeasurement($SpecAn);\n\n$Power = AeroFlexSpectrumAnalyzer_GetPowerAtFrequency($SpecAn,2100000000); //2.1G\n\n($PeakFreq,$PeakPower) = AeroFlexSpectrumAnalyzer_GetPeak($SpecAn);\n\n$Valid = AeroFlexSpectrumAnalyzer_GetMeasurementValidity($SpecAn,\"POWERVSFREQ\");\n\n$Valid = AeroFlexSpectrumAnalyzer_GetMeasurementValidity($SpecAn,\"NPEAKS\");\n\n$Locked = AeroFlexSpectrumAnalyzer_CheckRFReferenceLocked($SpecAn);\n\nAeroFlexSpectrumAnalyzer_AbortMeasurement($SpecAn);\n\nEnd;\n\n\n\n\n\nfunction Initialize()\n\n{\n\n$Combiner = AeroFlexCombiner_Open(\"PXI4::12::INSTR\");\n\n$SpecAn = AeroFlexSpectrumAnalyzer_Open(\"PXI4::14::INSTR\",\"PXI4::15::INSTR\",false);\n\n$SigGen = AeroflexSigGen_Open(\"PXI4::10::INSTR\",\"PXI4::11::INSTR\",false);\n\nreturn;\n\n}\n\n\n\n\n\nfunction CloseInstruments()\n\n{\n\nAeroFlexSpectrumAnalyzer_Close($SpecAn);\n\nAeroFlexSigGen_Close($SigGen);\n\nAeroFlexCombiner_Close($Combiner);\n\nEnd;\n\n}\n\n\n\n\n\nAeroFlexSpectrumAnalyzer_CheckRFReferenceLocked\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AeroFlexSpectrumAnalyzer_CheckRFReferenceLocked": {
  "prefix": "AeroFlexSpectrumAnalyzer_CheckRFReferenceLocked",
  "body": [
   "$$reflocked=AeroFlexSpectrumAnalyzer_CheckRFReferenceLocked($$SpecAn);"
  ],
  "description": "\n\nThis functions returns a boolean value indicating whether or not the RF reference is currently locked for the digitizer device.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$SpecAn\n\nObject\n\nSpectrum Analyzer Object\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$reflocked\n\nBoolean\n\nThe return value is a Boolean value indicating whether or not the RF reference signal has been locked.\n\n\n\n\n\nExample:\n\n\n\n\n\ncall Initialize();\n\nSetFinalizeFunction(\"CloseInstruments\");\n\nAeroFlexCombiner_SetMode($Combiner, \"AtoB\");\n\nAeroFlexSigGen_SetFrequency($SigGen,2100000000);\n\nAeroFlexSigGen_SetLevel($SigGen, -10);\n\nAeroFlexSigGen_EnableOutput($SigGen, \"TRUE\");\n\nSleep(1);\n\n\n\n\n\n$CaptureState = AeroFlexSpectrumAnalyzer_GetCaptureState($SpecAn);\n\n$Locked = AeroFlexSpectrumAnalyzer_CheckRFReferenceLocked($SpecAn);\n\nAeroFlexSpectrumAnalyzer_SetTriggerSource($SpecAn,\"IMMEDIATE\");\n\nAeroFlexSpectrumAnalyzer_SetReferenceLevel($SpecAn,0);\n\nAeroFlexSpectrumAnalyzer_SetEnabledMeasurement($SpecAn,\"POWERVSFREQ\",true);\n\nAeroFlexSpectrumAnalyzer_SetEnabledMeasurement($SpecAn,\"NPEAKS\",true);\n\nAeroFlexSpectrumAnalyzer_SetStartFrequency($SpecAn,2000000000);\n\nAeroFlexSpectrumAnalyzer_SetStopFrequency($SpecAn,2200000000);\n\nAeroFlexSpectrumAnalyzer_SetCenterFrequency($SpecAn,2100000000);\n\n//AeroFlexSpectrumAnalyzer_SetMeasurementSpan($SpecAn,10000000);\n\nAeroFlexSpectrumAnalyzer_SetMeasurementRBW($SpecAn,200000);\n\nAeroFlexSpectrumAnalyzer_SetMeasurementAveraging($SpecAn,25);\n\nAeroFlexSpectrumAnalyzer_SetWindowMode($SpecAn,\"GUASSIAN3DB\");\n\nAeroFlexSpectrumAnalyzer_SetRunMode($SpecAn,\"CONTINUOUS\");\n\nAeroFlexSpectrumAnalyzer_StartMeasurement($SpecAn);\n\n$Power = AeroFlexSpectrumAnalyzer_GetPowerAtFrequency($SpecAn,2100000000); //2.1G\n\n($PeakFreq,$PeakPower) = AeroFlexSpectrumAnalyzer_GetPeak($SpecAn);\n\n$Valid = AeroFlexSpectrumAnalyzer_GetMeasurementValidity($SpecAn,\"POWERVSFREQ\");\n\n$Valid = AeroFlexSpectrumAnalyzer_GetMeasurementValidity($SpecAn,\"NPEAKS\");\n\n$Locked = AeroFlexSpectrumAnalyzer_CheckRFReferenceLocked($SpecAn);\n\nAeroFlexSpectrumAnalyzer_AbortMeasurement($SpecAn);\n\nEnd;\n\n\n\n\n\nfunction Initialize()\n\n{\n\n$Combiner = AeroFlexCombiner_Open(\"PXI4::12::INSTR\");\n\n$SpecAn = AeroFlexSpectrumAnalyzer_Open(\"PXI4::14::INSTR\",\"PXI4::15::INSTR\",false);\n\n$SigGen = AeroflexSigGen_Open(\"PXI4::10::INSTR\",\"PXI4::11::INSTR\",false);\n\nreturn;\n\n}\n\n\n\n\n\nfunction CloseInstruments()\n\n{\n\nAeroFlexSpectrumAnalyzer_Close($SpecAn);\n\nAeroFlexSigGen_Close($SigGen);\n\nAeroFlexCombiner_Close($Combiner);\n\nEnd;\n\n}\n\n\n\n\n\nAeroFlexSpectrumAnalyzer_Close\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AeroFlexSpectrumAnalyzer_Close": {
  "prefix": "AeroFlexSpectrumAnalyzer_Close",
  "body": [
   "AeroFlexSpectrumAnalyzer_Close($$SpecAn);"
  ],
  "description": "\n\nThis function closes the AeroFlex spectrum analyzer, aborts any running measurements,a nd frees the instrument resources.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$SpectrumAnalyzer\n\nObject\n\nSpectrum Analyzer Object\n\n\n\n\n\nExample:\n\n\n\n\n\ncall Initialize();\n\nSetFinalizeFunction(\"CloseInstruments\");\n\nAeroFlexCombiner_SetMode($Combiner, \"AtoB\");\n\nAeroFlexSigGen_SetFrequency($SigGen,2100000000);\n\nAeroFlexSigGen_SetLevel($SigGen, -10);\n\nAeroFlexSigGen_EnableOutput($SigGen, \"TRUE\");\n\nSleep(1);\n\n\n\n\n\n$CaptureState = AeroFlexSpectrumAnalyzer_GetCaptureState($SpecAn);\n\n$Locked = AeroFlexSpectrumAnalyzer_CheckRFReferenceLocked($SpecAn);\n\nAeroFlexSpectrumAnalyzer_SetTriggerSource($SpecAn,\"IMMEDIATE\");\n\nAeroFlexSpectrumAnalyzer_SetReferenceLevel($SpecAn,0);\n\nAeroFlexSpectrumAnalyzer_SetEnabledMeasurement($SpecAn,\"POWERVSFREQ\",true);\n\nAeroFlexSpectrumAnalyzer_SetEnabledMeasurement($SpecAn,\"NPEAKS\",true);\n\nAeroFlexSpectrumAnalyzer_SetStartFrequency($SpecAn,2000000000);\n\nAeroFlexSpectrumAnalyzer_SetStopFrequency($SpecAn,2200000000);\n\nAeroFlexSpectrumAnalyzer_SetCenterFrequency($SpecAn,2100000000);\n\n//AeroFlexSpectrumAnalyzer_SetMeasurementSpan($SpecAn,10000000);\n\nAeroFlexSpectrumAnalyzer_SetMeasurementRBW($SpecAn,200000);\n\nAeroFlexSpectrumAnalyzer_SetMeasurementAveraging($SpecAn,25);\n\nAeroFlexSpectrumAnalyzer_SetWindowMode($SpecAn,\"GUASSIAN3DB\");\n\nAeroFlexSpectrumAnalyzer_SetRunMode($SpecAn,\"CONTINUOUS\");\n\nAeroFlexSpectrumAnalyzer_StartMeasurement($SpecAn);\n\n$Power = AeroFlexSpectrumAnalyzer_GetPowerAtFrequency($SpecAn,2100000000); //2.1G\n\n($PeakFreq,$PeakPower) = AeroFlexSpectrumAnalyzer_GetPeak($SpecAn);\n\n$Valid = AeroFlexSpectrumAnalyzer_GetMeasurementValidity($SpecAn,\"POWERVSFREQ\");\n\n$Valid = AeroFlexSpectrumAnalyzer_GetMeasurementValidity($SpecAn,\"NPEAKS\");\n\n$Locked = AeroFlexSpectrumAnalyzer_CheckRFReferenceLocked($SpecAn);\n\nAeroFlexSpectrumAnalyzer_AbortMeasurement($SpecAn);\n\nEnd;\n\n\n\n\n\nfunction Initialize()\n\n{\n\n$Combiner = AeroFlexCombiner_Open(\"PXI4::12::INSTR\");\n\n$SpecAn = AeroFlexSpectrumAnalyzer_Open(\"PXI4::14::INSTR\",\"PXI4::15::INSTR\",false);\n\n$SigGen = AeroflexSigGen_Open(\"PXI4::10::INSTR\",\"PXI4::11::INSTR\",false);\n\nreturn;\n\n}\n\n\n\n\n\nfunction CloseInstruments()\n\n{\n\nAeroFlexSpectrumAnalyzer_Close($SpecAn);\n\nAeroFlexSigGen_Close($SigGen);\n\nAeroFlexCombiner_Close($Combiner);\n\nEnd;\n\n}\n\n\n\n\n\nAeroFlexSpectrumAnalyzer_ConfigureOBWMeasurement\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AeroFlexSpectrumAnalyzer_ConfigureOBWMeasurement": {
  "prefix": "AeroFlexSpectrumAnalyzer_ConfigureOBWMeasurement",
  "body": [
   "AeroFlexSpectrumAnalyzer_ConfigureOBWMeasurement($$SpecAn,$$OBWWidth,$$OBWPercentage);"
  ],
  "description": "\n\n\n\n\n\nThis function sets the OBW measurement parameters to configure the instrument's Occupied Bandwidth Measurement.\n\n\n\n\n\nThe measurement width expressed in hertz must be less than or equal to the instruments currently measurement span. The system places this centrally within the span.\n\n\n\n\n\nThe OBW percentage must be a floating point value between 0-99.\n\n\n\n\n\nIn addition to setting these two parameters, you must also set the following generic measurement parameters before performing an occupied bandwidth measurement:\n\n\n\n\n\n\u00b7 Window Type\n\n\u00b7 Input Level and Attenuation\n\n\u00b7 Resolution Bandwidth\n\n\u00b7 Number of Averages (If this value is set to greater than 1, the returned OBW measurement is based on RMS power)\n\n\u00b7 Max Hold (If Max Hold is enabled, the OBW will be based on the maximum values found during the measurement sampling).\n\n\n\n\n\nFinally, the OBW measurement must be enabled to complete the measurement.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$SpecAn\n\nObject\n\nSpectrum Analyzer Object\n\n\n\n$OBWWidth\n\nFloat\n\nOBW Measurement Width (expressed in Hertz)\n\n\n\n$OBWPercentage\n\nFloat\n\nOBW Measurement Percentage (Expressed as a percentage 0-99)\n\n\n\n\n\nExample:\n\nAeroFlexSpectrumAnalyzer_ConfigureOBWMeasurement($SpecAn, 5000,99.0);\n\n\n\n\n\nAeroFlexSpectrumAnalyzer_EnableMaxHold\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AeroFlexSpectrumAnalyzer_EnableMaxHold": {
  "prefix": "AeroFlexSpectrumAnalyzer_EnableMaxHold",
  "body": [
   "AeroFlexSpectrumAnalyzer_EnableMaxHold($$SpectrumAnalyzer,$$maxHold);"
  ],
  "description": "\n\nThis function configures the Max or Peak hold setting on the instrument. This function has been deprecated in favor of the new statistical measurement configurations, but is retained for it's simplicity and usefulness.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$SpectrumAnalyzer\n\nObject\n\nSpectrum Analyzer Object\n\n\n\n$maxHold\n\nBoolean\n\nSets Peak Hold configuration:\n\n'True' = ON\n\n'False' = OFF\n\n\n\n\n\nExample:\n\nAeroFlexSpectrumAnalyzer_EnableMaxHold($SpectrumAnalyzer, false);\n\n\n\n\n\nAeroFlexSpectrumAnalyzer_EnableRFPreAmplifier\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AeroFlexSpectrumAnalyzer_EnableRFPreAmplifier": {
  "prefix": "AeroFlexSpectrumAnalyzer_EnableRFPreAmplifier",
  "body": [
   "AeroFlexSpectrumAnalyzer_EnableRFPreAmplifier($$SpectrumAnalyzer,$$Enabled);"
  ],
  "description": "\n\n\n\nThis function sets the RF pre-amplifier state. The RF pre-amplifier state is not supported by all AF303x digitizer resources. This value only takes affect of the 'Attenuator Mode' property is set to 'Manual', otherwise the value is ignored in automatic mode.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$SpectrumAnalyzer\n\nObject\n\nSpectrum Analyzer Object\n\n\n\n$Enabled\n\nBoolean\n\nEnables/Disables the PreAmplifier\n\n\n\n\n\nExample:\n\nAeroFlexSpectrumAnalyzer_EnableRFPreAmplifier($SpectrumAnalyzer, false);\n\n\n\n\n\nAeroFlexSpectrumAnalyzer_GetAverageSpectralPower\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AeroFlexSpectrumAnalyzer_GetAverageSpectralPower": {
  "prefix": "AeroFlexSpectrumAnalyzer_GetAverageSpectralPower",
  "body": [
   "$$averageSpectralPower=AeroFlexSpectrumAnalyzer_GetAverageSpectralPower($$SpectrumAnalyzer,$$MeasurementType);"
  ],
  "description": "\n\nThis function returns the average power measurement for the selected measurement. Linear power (watts) values are summed across the spectrum trace before conversion to DB.\n\n\n\nNote: This operation is performed on the averaged or peak held trace and so the averaging and peak hold will affect the result obtained.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$SpectrumAnalyzer\n\nObject\n\nSpectrum Analyzer Object\n\n\n\n$Measurement Type\n\nString\n\nThe type of measurement. Valid values are:\n\n\u00b7 \"ABSMAXHOLD\"\n\n\u00b7 \"ABSMINHOLD\"\n\n\u00b7 \"ALL\"\n\n\u00b7 \"LIVE\"\n\n\u00b7 \"MAXHOLD\"\n\n\u00b7 \"MEAN\"\n\n\u00b7 \"MINHOLD\"\n\n\u00b7 \"NONE\"\n\n\u00b7 \"STDDEV\"\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$averageSpectralPower\n\nFloat\n\nReturns a float value indicating the Spectral Power.\n\n\n\n\n\nExample:\n\n$averageSpectralPower = AeroFlexSpectrumAnalyzer_GetAverageSpectralPower($SpectrumAnalyzer,\"MEAN\");\n\n\n\n\n\nAeroFlexSpectrumAnalyzer_GetCaptureState\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AeroFlexSpectrumAnalyzer_GetCaptureState": {
  "prefix": "AeroFlexSpectrumAnalyzer_GetCaptureState",
  "body": [
   "$$captureState=AeroFlexSpectrumAnalyzer_GetCaptureState($$SpectrumAnalyzer);"
  ],
  "description": "\n\nThis function returns a string indicating the measurement capture state.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$SpectrumAnalyzer\n\nObject\n\nSpectrum Analyzer Object\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$captureState\n\nString\n\nReturns a String Specifying the Capture State. Possible values are:\n\n\u00b7 \"IDLE\"\n\n\u00b7 \"TRIGGERING\"\n\n\u00b7 \"CAPTURING\"\n\n\u00b7 \"ANALYZING\"\n\n\n\n\n\nExample:\n\n\n\n\n\ncall Initialize();\n\nSetFinalizeFunction(\"CloseInstruments\");\n\nAeroFlexCombiner_SetMode($Combiner, \"AtoB\");\n\nAeroFlexSigGen_SetFrequency($SigGen,2100000000);\n\nAeroFlexSigGen_SetLevel($SigGen, -10);\n\nAeroFlexSigGen_EnableOutput($SigGen, \"TRUE\");\n\nSleep(1);\n\n\n\n\n\n$CaptureState = AeroFlexSpectrumAnalyzer_GetCaptureState($SpecAn);\n\n$Locked = AeroFlexSpectrumAnalyzer_CheckRFReferenceLocked($SpecAn);\n\nAeroFlexSpectrumAnalyzer_SetTriggerSource($SpecAn,\"IMMEDIATE\");\n\nAeroFlexSpectrumAnalyzer_SetReferenceLevel($SpecAn,0);\n\nAeroFlexSpectrumAnalyzer_SetEnabledMeasurement($SpecAn,\"POWERVSFREQ\",true);\n\nAeroFlexSpectrumAnalyzer_SetEnabledMeasurement($SpecAn,\"NPEAKS\",true);\n\nAeroFlexSpectrumAnalyzer_SetStartFrequency($SpecAn,2000000000);\n\nAeroFlexSpectrumAnalyzer_SetStopFrequency($SpecAn,2200000000);\n\nAeroFlexSpectrumAnalyzer_SetCenterFrequency($SpecAn,2100000000);\n\n//AeroFlexSpectrumAnalyzer_SetMeasurementSpan($SpecAn,10000000);\n\nAeroFlexSpectrumAnalyzer_SetMeasurementRBW($SpecAn,200000);\n\nAeroFlexSpectrumAnalyzer_SetMeasurementAveraging($SpecAn,25);\n\nAeroFlexSpectrumAnalyzer_SetWindowMode($SpecAn,\"GUASSIAN3DB\");\n\nAeroFlexSpectrumAnalyzer_SetRunMode($SpecAn,\"CONTINUOUS\");\n\nAeroFlexSpectrumAnalyzer_StartMeasurement($SpecAn);\n\n$Power = AeroFlexSpectrumAnalyzer_GetPowerAtFrequency($SpecAn,2100000000); //2.1G\n\n($PeakFreq,$PeakPower) = AeroFlexSpectrumAnalyzer_GetPeak($SpecAn);\n\n$Valid = AeroFlexSpectrumAnalyzer_GetMeasurementValidity($SpecAn,\"POWERVSFREQ\");\n\n$Valid = AeroFlexSpectrumAnalyzer_GetMeasurementValidity($SpecAn,\"NPEAKS\");\n\n$Locked = AeroFlexSpectrumAnalyzer_CheckRFReferenceLocked($SpecAn);\n\nAeroFlexSpectrumAnalyzer_AbortMeasurement($SpecAn);\n\nEnd;\n\n\n\n\n\nfunction Initialize()\n\n{\n\n$Combiner = AeroFlexCombiner_Open(\"PXI4::12::INSTR\");\n\n$SpecAn = AeroFlexSpectrumAnalyzer_Open(\"PXI4::14::INSTR\",\"PXI4::15::INSTR\",false);\n\n$SigGen = AeroflexSigGen_Open(\"PXI4::10::INSTR\",\"PXI4::11::INSTR\",false);\n\nreturn;\n\n}\n\n\n\n\n\nfunction CloseInstruments()\n\n{\n\nAeroFlexSpectrumAnalyzer_Close($SpecAn);\n\nAeroFlexSigGen_Close($SigGen);\n\nAeroFlexCombiner_Close($Combiner);\n\nEnd;\n\n}\n\n\n\n\n\nAeroFlexSpectrumAnalyzer_GetMeasurementValidity\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AeroFlexSpectrumAnalyzer_GetMeasurementValidity": {
  "prefix": "AeroFlexSpectrumAnalyzer_GetMeasurementValidity",
  "body": [
   "$$isvalid=AeroFlexSpectrumAnalyzer_GetMeasurementValidity($$SpectrumAnalyzer,$$MeasurementType);"
  ],
  "description": "\n\nThis function returns a boolean value indicating whether or not the configuration parameters for the specified measurement type are currently valid. If the measurement has a valid configuration a value of 'TRUE' is returned, otherwise a value of 'FALSE' is returned.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$SpectrumAnalyzer\n\nObject\n\nSpectrum Analyzer Object\n\n\n\n$MeasurementType\n\nString\n\nThe measurement type to check for valid configuration parameters. Valid values are:\n\n\u00b7 \"ALL\"\n\n\u00b7 \"ACP\"\n\n\u00b7 \"AVERAGEPOWER\"\n\n\u00b7 \"FREQVSTIME\"\n\n\u00b7 \"NPEAKS\"\n\n\u00b7 \"OBW\"\n\n\u00b7 \"PHASEVSTIME\"\n\n\u00b7 \"POWERVSFREQ\"\n\n\u00b7 \"POWERVSTIME\"\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$IsValid\n\nBoolean\n\n\u00b7 Returns 'TRUE' or 'FALSE' depending on whether or not the measurement is configured properly.\n\n\n\n\n\nExample:\n\n\n\n\n\ncall Initialize();\n\nSetFinalizeFunction(\"CloseInstruments\");\n\nAeroFlexCombiner_SetMode($Combiner, \"AtoB\");\n\nAeroFlexSigGen_SetFrequency($SigGen,2100000000);\n\nAeroFlexSigGen_SetLevel($SigGen, -10);\n\nAeroFlexSigGen_EnableOutput($SigGen, \"TRUE\");\n\nSleep(1);\n\n\n\n\n\n$CaptureState = AeroFlexSpectrumAnalyzer_GetCaptureState($SpecAn);\n\n$Locked = AeroFlexSpectrumAnalyzer_CheckRFReferenceLocked($SpecAn);\n\nAeroFlexSpectrumAnalyzer_SetTriggerSource($SpecAn,\"IMMEDIATE\");\n\nAeroFlexSpectrumAnalyzer_SetReferenceLevel($SpecAn,0);\n\nAeroFlexSpectrumAnalyzer_SetEnabledMeasurement($SpecAn,\"POWERVSFREQ\",true);\n\nAeroFlexSpectrumAnalyzer_SetEnabledMeasurement($SpecAn,\"NPEAKS\",true);\n\nAeroFlexSpectrumAnalyzer_SetStartFrequency($SpecAn,2000000000);\n\nAeroFlexSpectrumAnalyzer_SetStopFrequency($SpecAn,2200000000);\n\nAeroFlexSpectrumAnalyzer_SetCenterFrequency($SpecAn,2100000000);\n\n//AeroFlexSpectrumAnalyzer_SetMeasurementSpan($SpecAn,10000000);\n\nAeroFlexSpectrumAnalyzer_SetMeasurementRBW($SpecAn,200000);\n\nAeroFlexSpectrumAnalyzer_SetMeasurementAveraging($SpecAn,25);\n\nAeroFlexSpectrumAnalyzer_SetWindowMode($SpecAn,\"GUASSIAN3DB\");\n\nAeroFlexSpectrumAnalyzer_SetRunMode($SpecAn,\"CONTINUOUS\");\n\nAeroFlexSpectrumAnalyzer_StartMeasurement($SpecAn);\n\n$Power = AeroFlexSpectrumAnalyzer_GetPowerAtFrequency($SpecAn,2100000000); //2.1G\n\n($PeakFreq,$PeakPower) = AeroFlexSpectrumAnalyzer_GetPeak($SpecAn);\n\n$Valid = AeroFlexSpectrumAnalyzer_GetMeasurementValidity($SpecAn,\"POWERVSFREQ\");\n\n$Valid = AeroFlexSpectrumAnalyzer_GetMeasurementValidity($SpecAn,\"NPEAKS\");\n\n$Locked = AeroFlexSpectrumAnalyzer_CheckRFReferenceLocked($SpecAn);\n\nAeroFlexSpectrumAnalyzer_AbortMeasurement($SpecAn);\n\nEnd;\n\n\n\n\n\nfunction Initialize()\n\n{\n\n$Combiner = AeroFlexCombiner_Open(\"PXI4::12::INSTR\");\n\n$SpecAn = AeroFlexSpectrumAnalyzer_Open(\"PXI4::14::INSTR\",\"PXI4::15::INSTR\",false);\n\n$SigGen = AeroflexSigGen_Open(\"PXI4::10::INSTR\",\"PXI4::11::INSTR\",false);\n\nreturn;\n\n}\n\n\n\n\n\nfunction CloseInstruments()\n\n{\n\nAeroFlexSpectrumAnalyzer_Close($SpecAn);\n\nAeroFlexSigGen_Close($SigGen);\n\nAeroFlexCombiner_Close($Combiner);\n\nEnd;\n\n}\n\n\n\n\n\nAeroFlexSpectrumAnalyzer_GetNextPeak\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AeroFlexSpectrumAnalyzer_GetNextPeak": {
  "prefix": "AeroFlexSpectrumAnalyzer_GetNextPeak",
  "body": [
   "($$peakFrequency,$$peakLevel)=AeroFlexSpectrumAnalyzer_GetNextPeak($$SpecAn);"
  ],
  "description": "\n\nThis function locates the peak signal present in the calculated spectrum. It gets the frequency and power at the ne next highest point of the trace, between the search start and stop points, following an earlier 'PeakFind' or 'PeakFindNext'.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$SpecAn\n\nObject\n\nSpectrum Analyzer Object\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$peakFrequency\n\nFloat\n\nReturns the Peak Frequency (Hertz) of the next peak.\n\n\n\n$peakLevel\n\nFloat\n\nReturns the Peak Level (dBm) of the next peak.\n\n\n\n\n\nExample:\n\n\n\n($Freq,$Level) = AeroFlexSpectrumAnalyzer_GetNextPeak($SpecAn);\n\nUpdateStatus($Freq);\n\nUpdateStatus($Level);\n\n\n\n\n\nAeroFlexSpectrumAnalyzer_GetOBWMeasurement\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AeroFlexSpectrumAnalyzer_GetOBWMeasurement": {
  "prefix": "AeroFlexSpectrumAnalyzer_GetOBWMeasurement",
  "body": [
   "$$OBWMeasurement=AeroFlexSpectrumAnalyzer_GetOBWMeasurement($$SpecAn,$$MeasurementType);"
  ],
  "description": "\n\nThis function gets the Occupied Bandwidth Measurement Result. The type of measurement result returned is based on the value passed to the measurement type parameter.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$SpecAn\n\nObject\n\nSpectrum Analyzer Object\n\n\n\n$MeasurementType\n\nString\n\nThe type of OBW measurement. Valid values are:\n\n\u00b7 \"ABSMAXHOLD\"\n\n\u00b7 \"ABSMINHOLD\"\n\n\u00b7 \"ALL\"\n\n\u00b7 \"LIVE\"\n\n\u00b7 \"MAXHOLD\"\n\n\u00b7 \"MEAN\"\n\n\u00b7 \"MINHOLD\"\n\n\u00b7 \"NONE\"\n\n\u00b7 \"STDDEV\"\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$OBWMeasurement\n\nFloat\n\nReturns the OBW measurement (unit depends on the type of measurement requested)\n\n\n\n\n\nExample:\n\n\n\n$OBWMeasurement = AeroFlexSpectrumAnalyzer_GetOBWMeasurement($SpecAn,\"MEAN\");\n\n\n\n\n\nAeroFlexSpectrumAnalyzer_GetPeak\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AeroFlexSpectrumAnalyzer_GetPeak": {
  "prefix": "AeroFlexSpectrumAnalyzer_GetPeak",
  "body": [
   "($$peakFrequency,$$peakLevel)=AeroFlexSpectrumAnalyzer_GetPeak($$SpecAn);"
  ],
  "description": "\n\nThis function locates the greatest peak signal present in the calculated spectrum. It gets the frequency and power at the highest point of the trace, between the search start and stop points. This function call can be followed by a call to 'PeakFindNext'.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$SpecAn\n\nObject\n\nSpectrum Analyzer Object\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$peakFrequency\n\nFloat\n\nReturns the Peak Frequency (Hertz) of the greatest peak.\n\n\n\n$peakLevel\n\nFloat\n\nReturns the Peak Level (dBm) of the greatest peak.\n\n\n\n\n\nExample:\n\n\n\n($Freq,$Level) = AeroFlexSpectrumAnalyzer_GetPeak($SpecAn);\n\nUpdateStatus($Freq);\n\nUpdateStatus($Level);\n\n\n\n\n\nAeroFlexSpectrumAnalyzer_Open\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AeroFlexSpectrumAnalyzer_Open": {
  "prefix": "AeroFlexSpectrumAnalyzer_Open",
  "body": [
   "$$Handle=AeroFlexSpectrumAnalyzer_Open($$DigitizerResourceString,$$OscillatorResourceString,$$LOisLocal);"
  ],
  "description": "\n\n\n\nThis function creates a handle to a spectrum analyzer object (actually an enhanced version of the AeroFlex digitizer object).\n\n\n\n\n\nAfter calling the AeroFlexSpectrumAnalyzer_Open function, you must close the instrument using the AeroFlexSpectrumAnalyzer_Close function to release the instrument resources.\n\n\n\n\n\nNote: Notice that the third parameter for specifying the LO resource is different from the functionality of the AeroFlex digitizer and AeroFlex Signal Generator open functions. In most cases, this calue needs to be set to 'TRUE', whereas in most cases it will be set to false for the other function libraries.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$DigitizerResourceString\n\nString\n\nDigitizer Resource String for the RF resource (301x module) that is to be created and used by the spectrum measurement library\n\n\n\n$OscillatorResourceString\n\nString\n\nOscillator Resource String for the LO (303x module) that is to be created and used by the spectrum measurement library.\n\n\n\n$LOisLocal\n\nBoolean\n\nIf set to false, an external standard is used, otherwise an internal standard is used.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$OBWMeasurement\n\nFloat\n\nReturns the OBW measurement (unit depends on the type of measurement requested)\n\n\n\n\n\nExample:\n\n$SpecAn = AeroFlexSpectrumAnalyzer_Open(\"PXI4::14::INSTR\",\"PXI4::15::INSTR\",true);\n\n\n\n\n\nAeroFlexSpectrumAnalyzer_Reset\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AeroFlexSpectrumAnalyzer_Reset": {
  "prefix": "AeroFlexSpectrumAnalyzer_Reset",
  "body": [
   "AeroFlexSpectrumAnalyzer_Reset($$SpectrumAnalyzer);"
  ],
  "description": "\n\nThis function is to reset the AeroFlex Spectrum Analyzer to it's initial \"power-on\" defaults.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$SpectrumAnalyzer\n\nObject\n\nSpectrum Analyzer Object\n\n\n\n\n\nExample:\n\n\n\n\n\nAeroFlexSpectrumAnalyzer_Reset($SpecAn);\n\n\n\n\n\nAeroFlexSpectrumAnalyzer_SetAttenuation\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AeroFlexSpectrumAnalyzer_SetAttenuation": {
  "prefix": "AeroFlexSpectrumAnalyzer_SetAttenuation",
  "body": [
   "AeroFlexSpectrumAnalyzer_SetAttenuation($$SpectrumAnalyzer,$$Attenuation);"
  ],
  "description": "\n\n\n\nThis function sets the value of the RF Attenuation (specified in DB). This value only takes affect is the Attenuation Mode is set to MANUAL, otherwise the value for this setting is ignored by the instrument.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$SpectrumAnalyzer\n\nObject\n\nSpectrum Analyzer Object\n\n\n\n$Attenuation\n\nInteger\n\nAttenuation (specified in DB)\n\n\n\n\n\nExample:\n\n\n\n\n\nAeroFlexSpectrumAnalyzer_SetAttenuation($SpectrumAnalyzer,-2);\n\n\n\n\n\nAeroFlexSpectrumAnalyzer_SetAttenuationMode\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AeroFlexSpectrumAnalyzer_SetAttenuationMode": {
  "prefix": "AeroFlexSpectrumAnalyzer_SetAttenuationMode",
  "body": [
   "AeroFlexSpectrumAnalyzer_SetAttenuationMode($$SpectrumAnalyzer,$$AttenuationMode);"
  ],
  "description": "\n\n\n\nThis function sets the attenuation mode on the spectrum analyzer to 'automatic' or 'manual' mode.\n\n\n\n\n\nWith the attenuator mode set to 'AUTO', the reference level can be set manually. The attenuation is coupled with the reference level, so there is no direct control of the attenuation in Auto Mode.\n\n\n\n\n\nWith the attenuator mode set to 'MANUAL', direct control is provided for both the reference level, and the RF attenuation. This is required because the reference level and the RF attenuation together, determine how other gain and attenuation settings within the digitizer should be set.\n\n\n\n\n\nIf the attenuation mode is set to automatic, then the 'AeroFlexSpectrumAnalyzer_SetAttenuation' command has no effect on the instrument.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$SpectrumAnalyzer\n\nObject\n\nSpectrum Analyzer Object\n\n\n\n$AttenuationMode\n\nString\n\nThe desired attenuation mode. Valid values are:\n\n\u00b7 \"AUTO\" = Automatic Attenuation\n\n\u00b7 \"MANUAL\" = Attenuation settings are determined using the 'SetAttenuation' function\n\n\n\n\n\nExample:\n\n\n\n\n\nAeroFlexSpectrumAnalyzer_SetAttenuation($SpectrumAnalyzer,\"AUTO\");\n\n\n\n\n\nAeroFlexSpectrumAnalyzer_SetCenterFrequency\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AeroFlexSpectrumAnalyzer_SetCenterFrequency": {
  "prefix": "AeroFlexSpectrumAnalyzer_SetCenterFrequency",
  "body": [
   "AeroFlexSpectrumAnalyzer_SetCenterFrequency($$SpecAn,$$Frequency);"
  ],
  "description": "\n\n\n\nThis function sets the center frequency (specified in Hertz) to the given value.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$SpectrumAnalyzer\n\nObject\n\nSpectrum Analyzer Object\n\n\n\n$Frequency\n\nFloat\n\nThe desired center frequency for the instrument.\n\n\n\n\n\nExample:\n\n\n\n\n\nAeroFlexSpectrumAnalyzer_SetCenterFrequency($SpecAn,2100000000); //2.1Ghz\n\n\n\n\n\nAeroFlexSpectrumAnalyzer_SetEnabledMeasurement\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AeroFlexSpectrumAnalyzer_SetEnabledMeasurement": {
  "prefix": "AeroFlexSpectrumAnalyzer_SetEnabledMeasurement",
  "body": [
   "AeroFlexSpectrumAnalyzer_SetEnabledMeasurement($$SpectrumAnalyzer,$$MeasurementType,$$Enabled);"
  ],
  "description": "\n\n\n\nThis function sets the given measurement type to enabled or disabled depending on the value supplied for the $Enabled parameter.\n\n\n\n\n\nWithin the spectrum measurement library, there is a range of available measurements that may be performed. One or more of these measurements may therefore be enabled, however, the more measurements that are enabled will increase the duration required to complete the measurement due to the additional analysis time required.\n\n\n\nThe default setting is that all measurements are disabled, and the order in which specific measurements are enabled or disabled is immaterial and has no effect.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$SpectrumAnalyzer\n\nObject\n\nSpectrum Analyzer Object\n\n\n\n$MeasurementType\n\nString\n\nThe desired measurement type. Valid values are:\n\n\u00b7 \"ALL\"\n\n\u00b7 \"ACP\"\n\n\u00b7 \"AVERAGEPOWER\"\n\n\u00b7 \"FREQVSTIME\"\n\n\u00b7 \"NPEAKS\"\n\n\u00b7 \"OBW\"\n\n\u00b7 \"PHASEVSTIME\"\n\n\u00b7 \"POWERVSFREQ\"\n\n\u00b7 \"POWERVSTIME\"\n\n\n\n$Enabled\n\nBoolean\n\nA true/false value indicating whether or not the measurement should be enabled.\n\n\n\n\n\nExample:\n\n\n\n\n\nAeroFlexSpectrumAnalyzer_SetEnabledMeasurement($SpecAn,\"POWERVSFREQ\",true);\n\n\n\n\n\nAeroFlexSpectrumAnalyzer_SetMeasurementAveraging\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AeroFlexSpectrumAnalyzer_SetMeasurementAveraging": {
  "prefix": "AeroFlexSpectrumAnalyzer_SetMeasurementAveraging",
  "body": [
   "AeroFlexSpectrumAnalyzer_SetMeasurementAveraging($$SpecAn,$$AveragingCount);"
  ],
  "description": "\n\nThis function sets the number of averages to be performed on the spectrum. This property is actually deprecated, but is included in the function library for it's ease of use, and convenience for user's familiar with configuring the averaging settings on a conventional spectrum analyzer.\n\n\n\n\n\nSetting this value to greater than one disables 'Max (Peak) Hold'. Setting 'Max (Peak) Hold' to enabled, will disable averaging.\n\n\n\n\n\nSetting the number of averages to a very large value will increase the measurement duration.\n\n\n\n\n\nNote: Trace linear power (watts) values are averaged (arithmetic mean) before conversion to dB.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$SpectrumAnalyzer\n\nObject\n\nSpectrum Analyzer Object\n\n\n\n$AveragingCount\n\nInteger\n\nThe number of averages.\n\n\n\n\n\nExample:\n\n\n\n\n\nAeroFlexSpectrumAnalyzer_SetMeasurementAveraging($SpectrumAnalyzer,10);\n\n\n\n\n\nAeroFlexSpectrumAnalyzer_SetMeasurementRBW\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AeroFlexSpectrumAnalyzer_SetMeasurementRBW": {
  "prefix": "AeroFlexSpectrumAnalyzer_SetMeasurementRBW",
  "body": [
   "AeroFlexSpectrumAnalyzer_SetMeasurementRBW($$SpecAn,$$RBWValue);"
  ],
  "description": "\n\nThis function sets the resolution bandwidth for the instrument specified in Hertz.\n\n\n\nThe valid values for the resolution bandwidth are dependent on the instruments current span setting. For example, a 30Khz span allows for a minimum RBW setting of 2 Hz, and a maximum RBW setting of 10 Mhz.\n\n\n\nThe default initial value is 1.0 Mhz.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$SpectrumAnalyzer\n\nObject\n\nSpectrum Analyzer Object\n\n\n\n$RBWValue\n\nFloat\n\nThe desired resolution bandwidth\n\n\n\n\n\nExample:\n\n\n\n\n\nAeroFlexSpectrumAnalyzer_SetMeasurementRBW($SpectrumAnalyzer,1000000);\n\n\n\n\n\nAeroFlexSpectrumAnalyzer_SetMeasurementSpan\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AeroFlexSpectrumAnalyzer_SetReferenceLevel": {
  "prefix": "AeroFlexSpectrumAnalyzer_SetReferenceLevel",
  "body": [
   "AeroFlexSpectrumAnalyzer_SetReferenceLevel($$SpecAn,$$RefLevel);"
  ],
  "description": "\n\nThis function sets the size of the instrument span, specified in Hertz, which is the value of the area on either side of the center frequency that will be visible on the trace display.\n\nThe permitted span will depend upon the minimum and maximum limits of the frequency range, and also upon spectrum stitching and the currently set resolution bandwidth.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$SpectrumAnalyzer\n\nObject\n\nSpectrum Analyzer Object\n\n\n\n$Span\n\nFloat\n\nThe desired instrument span (Hertz)\n\n\n\n\n\nExample:\n\n\n\n\n\nAeroFlexSpectrumAnalyzer_SetMeasurementSpan($SpectrumAnalyzer,10000000);\n\n\n\n\n\nAeroFlexSpectrumAnalyzer_SetRunMode\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AeroFlexSpectrumAnalyzer_SetRunMode": {
  "prefix": "AeroFlexSpectrumAnalyzer_SetRunMode",
  "body": [
   "AeroFlexSpectrumAnalyzer_SetRunMode($$SpecAn,$$RunMode);"
  ],
  "description": "\n\n\n\nThis function sets the run mode for the instrument to either perform a single or continuous measurement. Averaging and max hold are performed over multiple single measurements. If measurement mode is set to continuous, measurements are performed until the AeroFlex_AbortMeasurement function is called.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$SpectrumAnalyzer\n\nObject\n\nSpectrum Analyzer Object\n\n\n\n$RunMode\n\nString\n\nThe desired run mode for measurements. Valid values are:\n\n\u00b7 \"SINGLE\" = Takes a single measurement\n\n\u00b7 \"CONTINUOUS\" = repeats the specified measurement until Abort is called.\n\n\u00b7 \"REPEATNTIMES\" = Repeats the specified measurmenent until the required averaging has been completed.\n\n\n\n\n\nExample:\n\n\n\n\n\nAeroFlexSpectrumAnalyzer_SetRunMode($SpectrumAnalyzer,\"CONTINUOUS\");\n\n\n\n\n\nAeroFlexSpectrumAnalyzer_SetStartFrequency\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AeroFlexSpectrumAnalyzer_SetStartFrequency": {
  "prefix": "AeroFlexSpectrumAnalyzer_SetStartFrequency",
  "body": [
   "AeroFlexSpectrumAnalyzer_SetStartFrequency($$SpecAn,$$StartFrequency);"
  ],
  "description": "\n\nThis function sets the starting frequency of the instruments span specified in Hertz.\n\n\n\nThe SetStartFrequency and SetStopFrequency are an alternative to using the SetSpan and SetCenterFrequency functions.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$SpectrumAnalyzer\n\nObject\n\nSpectrum Analyzer Object\n\n\n\n$StartFrequency\n\nFloat\n\nThe desired starting frequency, expressed in Hertz.\n\n\n\n\n\nExample:\n\n\n\n\n\nAeroFlexSpectrumAnalyzer_SetStartFrequency($SpecAn,10000000);\n\n\n\n\n\nAeroFlexSpectrumAnalyzer_SetStopFrequency\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AeroFlexSpectrumAnalyzer_SetStopFrequency": {
  "prefix": "AeroFlexSpectrumAnalyzer_SetStopFrequency",
  "body": [
   "AeroFlexSpectrumAnalyzer_SetStopFrequency($$SpecAn,$$StopFrequency);"
  ],
  "description": "\n\nThis function sets the stopping frequency of the instrument span specified in Hertz.\n\n\n\nThe SetStartFrequency and SetStopFrequency are an alternative to using the SetSpan and SetCenterFrequency functions.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$SpectrumAnalyzer\n\nObject\n\nSpectrum Analyzer Object\n\n\n\n$StopFrequency\n\nFloat\n\nThe desired stopping frequency, expressed in Hertz.\n\n\n\n\n\nExample:\n\n\n\n\n\nAeroFlexSpectrumAnalyzer_SetStopFrequency($SpecAn,20000000);\n\n\n\n\n\nAeroFlexSpectrumAnalyzer_SetTriggerMode\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AeroFlexSpectrumAnalyzer_SetTriggerSource": {
  "prefix": "AeroFlexSpectrumAnalyzer_SetTriggerSource",
  "body": [
   "AeroFlexSpectrumAnalyzer_SetTriggerSource($$SpecAn,$$TriggerMode);"
  ],
  "description": "\n\n\n\nThis function sets the instrument's current trigger source to Video, Immediate, or External.\n\n\n\n\n\nNote: Immediate triggering is equivalent to a free-run mode.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$SpectrumAnalyzer\n\nObject\n\nSpectrum Analyzer Object\n\n\n\n$TriggerMode\n\nString\n\nThe desired triggering mode for the instrument. Valid values are:\n\n\u00b7 \"IMMEDIATE\"\n\n\u00b7 \"EXTERNAL\"\n\n\u00b7 \"VIDEO\"\n\n\n\n\n\nExample:\n\n\n\n\n\ncall Initialize();\n\nSetFinalizeFunction(\"CloseInstruments\");\n\nAeroFlexCombiner_SetMode($Combiner, \"AtoB\");\n\nAeroFlexSigGen_SetFrequency($SigGen,2100000000);\n\nAeroFlexSigGen_SetLevel($SigGen, -10);\n\nAeroFlexSigGen_EnableOutput($SigGen, \"TRUE\");\n\nSleep(1);\n\n\n\n\n\n$CaptureState = AeroFlexSpectrumAnalyzer_GetCaptureState($SpecAn);\n\n$Locked = AeroFlexSpectrumAnalyzer_CheckRFReferenceLocked($SpecAn);\n\nAeroFlexSpectrumAnalyzer_SetTriggerSource($SpecAn,\"IMMEDIATE\");\n\nAeroFlexSpectrumAnalyzer_SetReferenceLevel($SpecAn,0);\n\nAeroFlexSpectrumAnalyzer_SetEnabledMeasurement($SpecAn,\"POWERVSFREQ\",true);\n\nAeroFlexSpectrumAnalyzer_SetEnabledMeasurement($SpecAn,\"NPEAKS\",true);\n\nAeroFlexSpectrumAnalyzer_SetStartFrequency($SpecAn,2000000000);\n\nAeroFlexSpectrumAnalyzer_SetStopFrequency($SpecAn,2200000000);\n\nAeroFlexSpectrumAnalyzer_SetCenterFrequency($SpecAn,2100000000);\n\n//AeroFlexSpectrumAnalyzer_SetMeasurementSpan($SpecAn,10000000);\n\nAeroFlexSpectrumAnalyzer_SetMeasurementRBW($SpecAn,200000);\n\nAeroFlexSpectrumAnalyzer_SetMeasurementAveraging($SpecAn,25);\n\nAeroFlexSpectrumAnalyzer_SetWindowMode($SpecAn,\"GUASSIAN3DB\");\n\nAeroFlexSpectrumAnalyzer_SetRunMode($SpecAn,\"CONTINUOUS\");\n\nAeroFlexSpectrumAnalyzer_StartMeasurement($SpecAn);\n\n$Power = AeroFlexSpectrumAnalyzer_GetPowerAtFrequency($SpecAn,2100000000); //2.1G\n\n($PeakFreq,$PeakPower) = AeroFlexSpectrumAnalyzer_GetPeak($SpecAn);\n\n$Valid = AeroFlexSpectrumAnalyzer_GetMeasurementValidity($SpecAn,\"POWERVSFREQ\");\n\n$Valid = AeroFlexSpectrumAnalyzer_GetMeasurementValidity($SpecAn,\"NPEAKS\");\n\n$Locked = AeroFlexSpectrumAnalyzer_CheckRFReferenceLocked($SpecAn);\n\nAeroFlexSpectrumAnalyzer_AbortMeasurement($SpecAn);\n\nEnd;\n\n\n\n\n\nfunction Initialize()\n\n{\n\n$Combiner = AeroFlexCombiner_Open(\"PXI4::12::INSTR\");\n\n$SpecAn = AeroFlexSpectrumAnalyzer_Open(\"PXI4::14::INSTR\",\"PXI4::15::INSTR\",false);\n\n$SigGen = AeroflexSigGen_Open(\"PXI4::10::INSTR\",\"PXI4::11::INSTR\",false);\n\nreturn;\n\n}\n\n\n\n\n\nfunction CloseInstruments()\n\n{\n\nAeroFlexSpectrumAnalyzer_Close($SpecAn);\n\nAeroFlexSigGen_Close($SigGen);\n\nAeroFlexCombiner_Close($Combiner);\n\nEnd;\n\n}\n\n\n\n\n\nAeroFlexSpectrumAnalyzer_SetWindowMode\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AeroFlexSpectrumAnalyzer_SetWindowMode": {
  "prefix": "AeroFlexSpectrumAnalyzer_SetWindowMode",
  "body": [
   "AeroFlexSpectrumAnalyzer_SetWindowMode($$SpecAn,$$WindowMode);"
  ],
  "description": "\n\n\n\nThis function sets the window type to be used when performing the analysis on the capture digitizer data.\n\n\n\n\n\nGaussian windows determine their shape from the values of measurmeent resolution bandwidth and sampling frequency.\n\n\n\nThe default power-on value is set to Blackman-Harris.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$SpectrumAnalyzer\n\nObject\n\nSpectrum Analyzer Object\n\n\n\n$TriggerMode\n\nString\n\nThe desired windowing mode for the instrument's data analysis. Valid values are:\n\n\u00b7 \"BLACKMANHARRIS\"\n\n\u00b7 \"GUASSIAN3DB\"\n\n\u00b7 \"GAUSSIANNOISE\"\n\n\n\n\n\nExample:\n\n\n\n\n\ncall Initialize();\n\nSetFinalizeFunction(\"CloseInstruments\");\n\nAeroFlexCombiner_SetMode($Combiner, \"AtoB\");\n\nAeroFlexSigGen_SetFrequency($SigGen,2100000000);\n\nAeroFlexSigGen_SetLevel($SigGen, -10);\n\nAeroFlexSigGen_EnableOutput($SigGen, \"TRUE\");\n\nSleep(1);\n\n\n\n\n\n$CaptureState = AeroFlexSpectrumAnalyzer_GetCaptureState($SpecAn);\n\n$Locked = AeroFlexSpectrumAnalyzer_CheckRFReferenceLocked($SpecAn);\n\nAeroFlexSpectrumAnalyzer_SetTriggerSource($SpecAn,\"IMMEDIATE\");\n\nAeroFlexSpectrumAnalyzer_SetReferenceLevel($SpecAn,0);\n\nAeroFlexSpectrumAnalyzer_SetEnabledMeasurement($SpecAn,\"POWERVSFREQ\",true);\n\nAeroFlexSpectrumAnalyzer_SetEnabledMeasurement($SpecAn,\"NPEAKS\",true);\n\nAeroFlexSpectrumAnalyzer_SetStartFrequency($SpecAn,2000000000);\n\nAeroFlexSpectrumAnalyzer_SetStopFrequency($SpecAn,2200000000);\n\nAeroFlexSpectrumAnalyzer_SetCenterFrequency($SpecAn,2100000000);\n\n//AeroFlexSpectrumAnalyzer_SetMeasurementSpan($SpecAn,10000000);\n\nAeroFlexSpectrumAnalyzer_SetMeasurementRBW($SpecAn,200000);\n\nAeroFlexSpectrumAnalyzer_SetMeasurementAveraging($SpecAn,25);\n\nAeroFlexSpectrumAnalyzer_SetWindowMode($SpecAn,\"GUASSIAN3DB\");\n\nAeroFlexSpectrumAnalyzer_SetRunMode($SpecAn,\"CONTINUOUS\");\n\nAeroFlexSpectrumAnalyzer_StartMeasurement($SpecAn);\n\n$Power = AeroFlexSpectrumAnalyzer_GetPowerAtFrequency($SpecAn,2100000000); //2.1G\n\n($PeakFreq,$PeakPower) = AeroFlexSpectrumAnalyzer_GetPeak($SpecAn);\n\n$Valid = AeroFlexSpectrumAnalyzer_GetMeasurementValidity($SpecAn,\"POWERVSFREQ\");\n\n$Valid = AeroFlexSpectrumAnalyzer_GetMeasurementValidity($SpecAn,\"NPEAKS\");\n\n$Locked = AeroFlexSpectrumAnalyzer_CheckRFReferenceLocked($SpecAn);\n\nAeroFlexSpectrumAnalyzer_AbortMeasurement($SpecAn);\n\nEnd;\n\n\n\n\n\nfunction Initialize()\n\n{\n\n$Combiner = AeroFlexCombiner_Open(\"PXI4::12::INSTR\");\n\n$SpecAn = AeroFlexSpectrumAnalyzer_Open(\"PXI4::14::INSTR\",\"PXI4::15::INSTR\",false);\n\n$SigGen = AeroflexSigGen_Open(\"PXI4::10::INSTR\",\"PXI4::11::INSTR\",false);\n\nreturn;\n\n}\n\n\n\n\n\nfunction CloseInstruments()\n\n{\n\nAeroFlexSpectrumAnalyzer_Close($SpecAn);\n\nAeroFlexSigGen_Close($SigGen);\n\nAeroFlexCombiner_Close($Combiner);\n\nEnd;\n\n}\n\n\n\n\n\nAeroFlexSpectrumAnalyzer_StartMeasurement\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AeroFlexSpectrumAnalyzer_StartMeasurement": {
  "prefix": "AeroFlexSpectrumAnalyzer_StartMeasurement",
  "body": [
   "AeroFlexSpectrumAnalyzer_StartMeasurement($$SpecAn);"
  ],
  "description": "\n\n\n\nThis function will start the measurement process on any configured enabled measurements. If a measurement is enabled, and it's configuration values are specified improperly, this function will not return an error message, or generate a script failure.\n\n\n\n\n\nInstead, you should check the configuration of each enabled measurement using the AeroFlexSpectrumAnalyzer_GetMeasurementValidity function to ensure that the returned measurements are accurate and configured properly.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$SpectrumAnalyzer\n\nObject\n\nSpectrum Analyzer Object\n\n\n\n\n\nExample:\n\n\n\n\n\ncall Initialize();\n\nSetFinalizeFunction(\"CloseInstruments\");\n\nAeroFlexCombiner_SetMode($Combiner, \"AtoB\");\n\nAeroFlexSigGen_SetFrequency($SigGen,2100000000);\n\nAeroFlexSigGen_SetLevel($SigGen, -10);\n\nAeroFlexSigGen_EnableOutput($SigGen, \"TRUE\");\n\nSleep(1);\n\n\n\n\n\n$CaptureState = AeroFlexSpectrumAnalyzer_GetCaptureState($SpecAn);\n\n$Locked = AeroFlexSpectrumAnalyzer_CheckRFReferenceLocked($SpecAn);\n\nAeroFlexSpectrumAnalyzer_SetTriggerSource($SpecAn,\"IMMEDIATE\");\n\nAeroFlexSpectrumAnalyzer_SetReferenceLevel($SpecAn,0);\n\nAeroFlexSpectrumAnalyzer_SetEnabledMeasurement($SpecAn,\"POWERVSFREQ\",true);\n\nAeroFlexSpectrumAnalyzer_SetEnabledMeasurement($SpecAn,\"NPEAKS\",true);\n\nAeroFlexSpectrumAnalyzer_SetStartFrequency($SpecAn,2000000000);\n\nAeroFlexSpectrumAnalyzer_SetStopFrequency($SpecAn,2200000000);\n\nAeroFlexSpectrumAnalyzer_SetCenterFrequency($SpecAn,2100000000);\n\n//AeroFlexSpectrumAnalyzer_SetMeasurementSpan($SpecAn,10000000);\n\nAeroFlexSpectrumAnalyzer_SetMeasurementRBW($SpecAn,200000);\n\nAeroFlexSpectrumAnalyzer_SetMeasurementAveraging($SpecAn,25);\n\nAeroFlexSpectrumAnalyzer_SetWindowMode($SpecAn,\"GUASSIAN3DB\");\n\nAeroFlexSpectrumAnalyzer_SetRunMode($SpecAn,\"CONTINUOUS\");\n\nAeroFlexSpectrumAnalyzer_StartMeasurement($SpecAn);\n\n$Power = AeroFlexSpectrumAnalyzer_GetPowerAtFrequency($SpecAn,2100000000); //2.1G\n\n($PeakFreq,$PeakPower) = AeroFlexSpectrumAnalyzer_GetPeak($SpecAn);\n\n$Valid = AeroFlexSpectrumAnalyzer_GetMeasurementValidity($SpecAn,\"POWERVSFREQ\");\n\n$Valid = AeroFlexSpectrumAnalyzer_GetMeasurementValidity($SpecAn,\"NPEAKS\");\n\n$Locked = AeroFlexSpectrumAnalyzer_CheckRFReferenceLocked($SpecAn);\n\nAeroFlexSpectrumAnalyzer_AbortMeasurement($SpecAn);\n\nEnd;\n\n\n\n\n\nfunction Initialize()\n\n{\n\n$Combiner = AeroFlexCombiner_Open(\"PXI4::12::INSTR\");\n\n$SpecAn = AeroFlexSpectrumAnalyzer_Open(\"PXI4::14::INSTR\",\"PXI4::15::INSTR\",false);\n\n$SigGen = AeroflexSigGen_Open(\"PXI4::10::INSTR\",\"PXI4::11::INSTR\",false);\n\nreturn;\n\n}\n\n\n\n\n\nfunction CloseInstruments()\n\n{\n\nAeroFlexSpectrumAnalyzer_Close($SpecAn);\n\nAeroFlexSigGen_Close($SigGen);\n\nAeroFlexCombiner_Close($Combiner);\n\nEnd;\n\n}\n\n\n\n\n\nHP856XE_Close\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS HP856XE_GetMarkerXValue": {
  "prefix": "HP856XE_GetMarkerXValue",
  "body": [
   "$$Value=HP856XE_GetMarkerXValue($$Handle,$$Marker);"
  ],
  "description": "\n\nThis function controls the Agilent 856x Series of spectrum Analyzers. In order to use these function the VXI pnp driver for the instrument must be installed on the system running Jabil Test. The latest version of this driver can be downloaded from Agilent.\n\nThis method measures the current X value of the designated marker on its assigned trace. The value is in the X-axis units for the current trace (which is often frequency (Hz) or time (seconds)).If the selected marker is not currently active, this method will return a value without any valid meaning.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nA Handle to the Resource object\n\n\n\n$Marker\n\nInteger\n\nThe Marker # to set to a specific peak. Valid marker numbers are (1)\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Value\n\nFloat\n\nCurrent X-axis value in the X-axis units for the current trace (which is often Hz or seconds).\n\n\n\n\n\nHP856XE_GetMarkerYValue\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS HP856XE_GetMarkerYValue": {
  "prefix": "HP856XE_GetMarkerYValue",
  "body": [
   "$$Value=HP856XE_GetMarkerYValue($$Handle,$$Marker);"
  ],
  "description": "\n\nThis function controls the Agilent 856x Series of spectrum Analyzers. In order to use these function the VXI pnp driver for the instrument must be installed on the system running Jabil Test. The latest version of this driver can be downloaded from Agilent.\n\nThis method measures the current Y value for the designated marker on its assigned trace. The trace is in the Y-axis units for the current trace (which is often dBm).\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nA Handle to the Resource object\n\n\n\n$Marker\n\nInteger\n\nThe Marker # to set to a specific peak. Valid marker numbers are (1)\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Value\n\nFloat\n\nThe trace is in the Y-axis units for the current trace (which is often dBm).\n\n\n\n\n\nHP856XE_Init\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS HP856XE_Init": {
  "prefix": "HP856XE_Init",
  "body": [
   "$$Handle=HP856XE_Init($$ResourceString,$$Reset);"
  ],
  "description": "\n\nThis function controls the Agilent 856x Series of spectrum Analyzers. In order to use these function the VXI pnp driver for the instrument must be installed on the system running Jabil Test. The latest version of this driver can be downloaded from Agilent.\n\nThis function initializes the Spectrum Analyzer, and returns a handle to the instrument. If the $Reset argument is set to TRUE, the instrument is reset to it's default configuration.\n\nExample:\n\n$Handle = HP856XE_Init(\"GPIB0::5::INSTR\",\"TRUE\");\n\n\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ResourceString\n\nString\n\nThe Resource string of the instrument, for instance \"GPIB0::18::INSTR\"\n\n\n\n$Reset\n\nBoolean\n\nSpecifies whether or not to reset the instrument upon initialization.\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nA reference handle to the Spectrum Analyzer\n\n\n\n\n\nHP856XE_MarkerPeakSearch\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS HP856XE_MarkerPeakSearch": {
  "prefix": "HP856XE_MarkerPeakSearch",
  "body": [
   "HP856XE_MarkerPeakSearch($$Handle,$$Marker,$$SearchType);"
  ],
  "description": "\n\nThis function controls the Agilent 856x Series of spectrum Analyzers. In order to use these function the VXI pnp driver for the instrument must be installed on the system running Jabil Test. The latest version of this driver can be downloaded from Agilent.\n\nThis method sets the specified marker to the peak found specified by the search algorithm requested.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nA Handle to the Resource object\n\n\n\n$Marker\n\nInteger\n\nThe Marker # to set to a specific peak. Valid marker numbers are (1)\n\n\n\n$SearchType\n\nString\n\nSpecifies the type of peak search to perform. Please refer to the User's manual for additional information about the peak search algorithms. Allowable values for $SearchType are:\n\n\u00b7 \"MARKER_PEAK\"\n\n\u00b7 \"MARKER_PEAKNEXT\"\n\n\u00b7 \"MARKER_PEAKLEFT\"\n\n\u00b7 \"MARKER_PEAKRIGHT\"\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nHP856XE_SetBWResolution\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS HP856XE_SetBWResolution": {
  "prefix": "HP856XE_SetBWResolution",
  "body": [
   "HP856XE_SetBWResolution($$Handle,$$Mode,$$Resolution);"
  ],
  "description": "\n\nThis function controls the Agilent 856x Series of spectrum Analyzers. In order to use these function the VXI pnp driver for the instrument must be installed on the system running Jabil Test. The latest version of this driver can be downloaded from Agilent.\n\nThis function sets the resolution bandwidth mode or value of the instrument IF.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nA Handle to the Resource object\n\n\n\n$Mode\n\nString\n\nSets the BW resolution mode; Allowed Values are:\n\n\u00b7 \"AUTO\"\n\n\u00b7 \"MANUAL\"\n\n\u00b7 \"IGNORE\"\n\n\n\n$Resolution\n\nInteger\n\nThe bandwidth resolution in Hertz.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nHP856XE_SetCenterFrequency\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS HP856XE_SetCenterFrequency": {
  "prefix": "HP856XE_SetCenterFrequency",
  "body": [
   "HP856XE_SetCenterFrequency($$Handle,$$CenterFreq);"
  ],
  "description": "\n\nThis function controls the Agilent 856x Series of spectrum Analyzers. In order to use these function the VXI pnp driver for the instrument must be installed on the system running Jabil Test. The latest version of this driver can be downloaded from Agilent.\n\nSets the center frequency on the spectrum analyzer.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nA Handle to the Resource object\n\n\n\n$CenterFreq\n\nInteger\n\nSets the center frequency of the spectrum analyzer, specified in Hertz.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nHP856XE_SetFreqSpan\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS HP856XE_SetFreqSpan": {
  "prefix": "HP856XE_SetFreqSpan",
  "body": [
   "HP856XE_SetFreqSpan($$Handle,$$Span);"
  ],
  "description": "\n\nThis function controls the Agilent 856x Series of spectrum Analyzers. In order to use these function the VXI pnp driver for the instrument must be installed on the system running Jabil Test. The latest version of this driver can be downloaded from Agilent.\n\nThis function sets the horizontal frequency span of the spectrum analyzer.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nA Handle to the Resource object\n\n\n\n$Span\n\nInteger\n\nThe frequency span specified in Hertz.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nHP856XE_SetReferenceAmplitude\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS HP856XE_SetReferenceAmplitude($Handle,$ReferenceLevel);ThisfunctioncontrolstheAgilent856XESeriesofspectrumAnalyzers.InordertousethesefunctiontheVXIpnpdriverfortheinstrumentmustbeinstalledonthesystemrunningJabilTest.ThelatestversionofthisdrivercanbedownloadedfromAgilent.Thismethodsetsthespectrumanalyzer'samplitudereferencelevel.FunctionArgumentsParameterVariableTypeDescription$HandleObjectTheresourcehandleoftheSpectrumAnalyzer$ReferenceLevelFloatInstrument'snewamplitudereferencelevelincurrentamplitudedisplayunits.ReturnParametersParameterVariableTypeDescriptionNoneHP856XE_SetVideoAveragingPreviousTopNext***HP856XE_SetVideoAveragingUsage:HP856XE_SetVideoAveraging": {
  "prefix": "HP856XE_SetReferenceAmplitude($Handle,$ReferenceLevel);ThisfunctioncontrolstheAgilent856XESeriesofspectrumAnalyzers.InordertousethesefunctiontheVXIpnpdriverfortheinstrumentmustbeinstalledonthesystemrunningJabilTest.ThelatestversionofthisdrivercanbedownloadedfromAgilent.Thismethodsetsthespectrumanalyzer'samplitudereferencelevel.FunctionArgumentsParameterVariableTypeDescription$HandleObjectTheresourcehandleoftheSpectrumAnalyzer$ReferenceLevelFloatInstrument'snewamplitudereferencelevelincurrentamplitudedisplayunits.ReturnParametersParameterVariableTypeDescriptionNoneHP856XE_SetVideoAveragingPreviousTopNext***HP856XE_SetVideoAveragingUsage:HP856XE_SetVideoAveraging",
  "body": [
   "HP856XE_SetReferenceAmplitude($$Handle,$$ReferenceLevel);ThisfunctioncontrolstheAgilent856XESeriesofspectrumAnalyzers.InordertousethesefunctiontheVXIpnpdriverfortheinstrumentmustbeinstalledonthesystemrunningJabilTest.ThelatestversionofthisdrivercanbedownloadedfromAgilent.Thismethodsetsthespectrumanalyzer'samplitudereferencelevel.FunctionArgumentsParameterVariableTypeDescription$$HandleObjectTheresourcehandleoftheSpectrumAnalyzer$$ReferenceLevelFloatInstrument'snewamplitudereferencelevelincurrentamplitudedisplayunits.ReturnParametersParameterVariableTypeDescriptionNoneHP856XE_SetVideoAveragingPreviousTopNext***HP856XE_SetVideoAveragingUsage:HP856XE_SetVideoAveraging($$Handle,$$Mode,$$NumberOfSamples);"
  ],
  "description": "\n\nThis function controls the Agilent 856x Series of spectrum Analyzers. In order to use these function the VXI pnp driver for the instrument must be installed on the system running Jabil Test. The latest version of this driver can be downloaded from Agilent.\n\nThis function sets the video averaging mode on the HP856XE instrument.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nA Handle to the Resource object\n\n\n\n$Mode\n\nString\n\nSets the averaging mode; Allowed Values are:\n\n\u00b7 \"OFF\"\n\n\u00b7 \"ON\"\n\n\u00b7 \"SETAVERAGES\"\n\n\n\n$NumberOfSamples\n\nInteger\n\nThe number of samples to be used in the video averaging algorithm\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nHP859XE_CenterFreqToMarker\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS HP859XE_CenterFreqToMarker": {
  "prefix": "HP859XE_CenterFreqToMarker",
  "body": [
   "HP859XE_CenterFreqToMarker($$HpInstance);"
  ],
  "description": "\n\nThis function uses the Agilent VXI PNP 859XE driver in order to use the HP859XE functions in JabilTest.\n\nThis function centers the display output to the frequency of the active marker. Function Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$HpInstance\n\nObject\n\nThe Object representing the instance of the HP859XE.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nHP859XE_Close\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS HP859XE_Close": {
  "prefix": "HP859XE_Close",
  "body": [
   "HP859XE_Close($$HpInstance);"
  ],
  "description": "\n\nThis function uses the Agilent VXI PNP 859XE driver in order to use the HP859XE functions in JabilTest.\n\nThis function closes the HP859XE and recovers used resources. It does not reset the unit or change it's existing settings. This function returns a passing result if the instrument can be closed successfully, otherwise a failure is generated by the script function.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$HpInstance\n\nObject\n\nThe Object representing the instance of the HP859XE to be closed. Closing the instrument releases all resources.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nHP859XE_Cmd\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS HP859XE_Cmd": {
  "prefix": "HP859XE_Cmd",
  "body": [
   "HP859XE_Cmd($$HpInstance,$$Command);"
  ],
  "description": "\n\nThis function uses the Agilent VXI PNP 859XE driver in order to use the HP859XE functions in JabilTest.\n\nThis function executes a suppiled GPIB command directly on the analyzer.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$HpInstance\n\nObject\n\nThe Object representing the instance of the HP859XE.\n\n\n\n$Command\n\nString\n\nRaw GPIB command for the HP859E to run.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nHP859XE_Init\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS HP859XE_Init": {
  "prefix": "HP859XE_Init",
  "body": [
   "$$HpInstance=HP859XE_Init($$ResourceString);"
  ],
  "description": "\n\nThis function uses the Agilent VXI PNP 859XE driver in order to use the HP859XE functions in JabilTest.\n\nThis function initializes the HP859XE for operation. The insturment is reset after using this command. This function returns a passing result if the instrument can be initialized successfully, otherwise a failure is generated by the script function.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ResourceString\n\nString\n\nThe resource string identifying the instrument. For example, \"GPIB0::9::Instr\".\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AgInstance\n\nObject\n\nThe object representing the instance of the HP859XE.\n\n\n\n\n\nHP859XE_MarkerToPeak\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS HP859XE_MarkerToPeak": {
  "prefix": "HP859XE_MarkerToPeak",
  "body": [
   "HP859XE_MarkerToPeak($$HpInstance);"
  ],
  "description": "\n\nThis function uses the Agilent VXI PNP 859XE driver in order to use the HP859XE functions in JabilTest.\n\nThis function moves the active marker to the peak currently visable on the 859XE.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$HpInstance\n\nObject\n\nThe Object representing the instance of the HP859XE.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nHP859XE_MeasureMarkerAmp\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS HP859XE_MeasureMarkerAmp": {
  "prefix": "HP859XE_MeasureMarkerAmp",
  "body": [
   "$$Amplitude=HP859XE_MeasureMarkerAmp($$HpInstance,$$Units);"
  ],
  "description": "\n\nThis function uses the Agilent VXI PNP 859XE driver in order to use the HP859XE functions in JabilTest.\n\nThis function returns an amplitiude measurement at the current active marker.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$HpInstance\n\nObject\n\nThe Object representing the instance of the HP859XE.\n\n\n\n$Units\n\nInt\n\n1 = DBm\n\n2 = DBmV\n\n3 = DBuV\n\n4 = V\n\n5 = W\n\nany other value causes the function to fail due to an invalid parameter\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Amplitude\n\nInt\n\nThe amplitude at the active marker. Returned in the units specified in $Unit.\n\n\n\n\n\nHP859XE_MeasureMarkerFreq\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS HP859XE_MeasureMarkerFreq": {
  "prefix": "HP859XE_MeasureMarkerFreq",
  "body": [
   "$$Frequency=HP859XE_MeasureMarkerFreq($$HpInstance);"
  ],
  "description": "\n\nThis function uses the Agilent VXI PNP 859XE driver in order to use the HP859XE functions in JabilTest.\n\nThis function returns a frequency measurement at the current active marker.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$HpInstance\n\nObject\n\nThe Object representing the instance of the HP859XE.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Frequency\n\nInt\n\nThe frequency at the active marker in Hz.\n\n\n\n\n\nHP859XE_PeakClear\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS HP859XE_PeakClear": {
  "prefix": "HP859XE_PeakClear",
  "body": [
   "HP859XE_PeakClear($$HpInstance);"
  ],
  "description": "\n\nThis function uses the Agilent VXI PNP 859XE driver in order to use the HP859XE functions in JabilTest.\n\nThis function clears the spectrum analyzer trace. Removes a peak hold command.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$HpInstance\n\nObject\n\nThe Object representing the instance of the HP859XE.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nHP859XE_PeakHold\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS HP859XE_PeakHold": {
  "prefix": "HP859XE_PeakHold",
  "body": [
   "HP859XE_PeakHold($$HpInstance);"
  ],
  "description": "\n\nThis function uses the Agilent VXI PNP 859XE driver in order to use the HP859XE functions in JabilTest.\n\nPuts the spectrum analyzer in peak hold mode.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$HpInstance\n\nObject\n\nThe Object representing the instance of the HP859XE.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nHP859XE_SetAmpScaleAndUnits\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS HP859XE_SetAmpScaleAndUnits": {
  "prefix": "HP859XE_SetAmpScaleAndUnits",
  "body": [
   "HP859XE_SetAmpScaleAndUnits($$HpInstance,$$LogLin,$$Scale,$$Units);"
  ],
  "description": "\n\nThis function uses the Agilent VXI PNP 859XE driver in order to use the HP859XE functions in JabilTest.\n\nThis function sets the amplitude scale and units.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$HpInstance\n\nObject\n\nThe Object representing the instance of the HP859XE.\n\n\n\n$LogLin\n\nInt\n\n0 = Logritmic\n\n1 = Linear\n\nany other value causes the function to fail due to an invalid parameter\n\n\n\n$Scale\n\nInt\n\n1 = 1 unit\n\n10 = 10 units\n\n17 = 0.1 units\n\n2 = 2 units\n\n20 = 20 units\n\n26 = 0.2 units\n\n5 = 5 units\n\n55 = 0.5 units\n\nany other value causes the function to fail due to an invalid parameter\n\n\n\n$Units\n\nInt\n\n0 = Auto\n\n1 = DBm\n\n2 = DBmV\n\n3 = DBuV\n\n4 = V\n\n5 = W\n\nany other value causes the function to fail due to an invalid parameter\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nHP856XE_SetFreqCenter\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS HP859XE_SetFreqCenter": {
  "prefix": "HP859XE_SetFreqCenter",
  "body": [
   "HP859XE_SetFreqCenter($$HpInstance,$$Frequency);"
  ],
  "description": "\n\nThis function uses the Agilent VXI PNP 859XE driver in order to use the HP859XE functions in JabilTest.\n\nThis function sets the center frequency to $Frequency Hz.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$HpInstance\n\nObject\n\nThe Object representing the instance of the HP859XE.\n\n\n\n$Frequency\n\nDouble\n\nFrequency to center the Hp859XE on in Hz.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nHP859XE_SetFreqSpan\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS HP859XE_SetFreqSpan": {
  "prefix": "HP859XE_SetFreqSpan",
  "body": [
   "HP859XE_SetFreqSpan($$HpInstance,$$Span);"
  ],
  "description": "\n\nThis function uses the Agilent VXI PNP 859XE driver in order to use the HP859XE functions in JabilTest.\n\nThis function sets the frequency span to $Span Hz wide.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$HpInstance\n\nObject\n\nThe Object representing the instance of the HP859XE.\n\n\n\n$Span\n\nDouble\n\nFrequency span for the active window on the Hp859XE in Hz.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nHP859XE_TriggerExternal\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS HP859XE_TriggerExternal": {
  "prefix": "HP859XE_TriggerExternal",
  "body": [
   "HP859XE_TriggerExternal($$HpInstance);"
  ],
  "description": "\n\nThis function uses the Agilent VXI PNP 859XE driver in order to use the HP859XE functions in JabilTest.\n\nPuts the spectrum analyzer in external trigger mode.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$HpInstance\n\nObject\n\nThe Object representing the instance of the HP859XE.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nHP859XE_TriggerFree\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS HP859XE_TriggerFree": {
  "prefix": "HP859XE_TriggerFree",
  "body": [
   "HP859XE_TriggerFree($$HpInstance);"
  ],
  "description": "\n\nThis function uses the Agilent VXI PNP 859XE driver in order to use the HP859XE functions in JabilTest.\n\nTakes the spectrum analyzer out of external trigger mode.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$HpInstance\n\nObject\n\nThe Object representing the instance of the HP859XE.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nHPESA_Close\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS HPESA_Close": {
  "prefix": "HPESA_Close",
  "body": [
   "$$Handle=HPESA_Close($$Handle);"
  ],
  "description": "\n\nThis function controls the Agilent ESA Series of spectrum Analyzers. In order to use these function the VXI pnp driver for the instrument must be installed on the system running Jabil Test. The latest version of this driver can be downloaded from Agilent.\n\nThis function closes the ESA Spectrum Analyzer, and releases thehandle to the instrument.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nA Handle to the HPESA Resource object\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nHPESA_ConfigChannelPower\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS HPESA_ConfigChannelPower": {
  "prefix": "HPESA_ConfigChannelPower",
  "body": [
   "HPESA_ConfigChannelPower($$Handle,$$AverageOn,$$AverageCount,$$IntegrationSpan,$$Span);"
  ],
  "description": "\n\nThis function controls the Agilent ESA Series of spectrum Analyzers. In order to use these function the VXI pnp driver for the instrument must be installed on the system running Jabil Test. The latest version of this driver can be downloaded from Agilent.\n\nThis method sets up the channel power measurement operation.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nA Handle to the HPESA Resource object\n\n\n\n$AveragingOn\n\nString\n\nInstrument's new CHP average state.\n\n\u00b7 \"ON\"\n\n\u00b7 \"OFF\"\n\n\n\n$AverageCount\n\nInteger\n\nSpecifies the number of CHP measurements that are combined.\n\n\n\n$IntegrationSpan\n\nFloat\n\nInstrument's new frequency span (bandwidth) over which to integrate power.\n\n\n\n$Span\n\nFloat\n\nInstrument's new channel power span.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nHPESA_DoSweep\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS HPESA_DoSweep": {
  "prefix": "HPESA_DoSweep",
  "body": [
   "$$sweepComplete=HPESA_DoSweep($$HPESA_handle,$$timeout);"
  ],
  "description": "\n\nThis method causes a sweep to start and waits for it to complete. If sweep mode is continuous, the sweep will be re-started. If sweep is single, then the sweep is started.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$HPESA_handle\n\nObject\n\nThe instrument's VISA session handle returned from hpesa_init().\n\n\n\n$timeout\n\nFloat\n\nTime in seconds for this method to wait for the sweep to complete.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$sweepComplete\n\nBoolean\n\nStatus indicating whether sweep completed successfully.\n\n\n\n\n\nHPESA_GetAmplitudeScale\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS HPESA_GetAmplitudeScale": {
  "prefix": "HPESA_GetAmplitudeScale",
  "body": [
   "$$scale=HPESA_GetAmplitudeScale($$HPESA_handle);"
  ],
  "description": "\n\nThis method gets the spectrum analyzer's per division display scaling for the y-axis (amplitude). This setting is only applicable to y-axis (amplitude) logarithmic scale format. The setting has no meaning for linear scale format.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$HPESA_handle\n\nObject\n\nThe instrument's VISA session handle returned from hpesa_init().\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$scale\n\nFloat\n\nInstrument's current per division display scaling for y-axis in dB.\n\n\n\n\n\nHPESA_GetMarkerXValue\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS HPESA_GetMarkerXValue": {
  "prefix": "HPESA_GetMarkerXValue",
  "body": [
   "$$Value=HPESA_GetMarkerXValue($$Handle,$$Marker);"
  ],
  "description": "\n\nThis function controls the Agilent ESA Series of spectrum Analyzers. In order to use these function the VXI pnp driver for the instrument must be installed on the system running Jabil Test. The latest version of this driver can be downloaded from Agilent.\n\nThis method measures the current X value of the designated marker on its assigned trace. The value is in the X-axis units for the current trace (which is often frequency (Hz) or time (seconds)).If the selected marker is not currently active, this method will return a value without any valid meaning.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nA Handle to the HPESA Resource object\n\n\n\n$Marker\n\nInteger\n\nThe Marker # to set to a specific peak. Valid marker numbers are (0,1,2,3)\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Value\n\nFloat\n\nCurrent X-axis value in the X-axis units for the current trace (which is often Hz or seconds).\n\n\n\n\n\nHPESA_GetMarkerYValue\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS HPESA_GetMarkerYValue": {
  "prefix": "HPESA_GetMarkerYValue",
  "body": [
   "$$Value=HPESA_GetMarkerYValue($$Handle,$$Marker);"
  ],
  "description": "\n\nThis function controls the Agilent ESA Series of spectrum Analyzers. In order to use these function the VXI pnp driver for the instrument must be installed on the system running Jabil Test. The latest version of this driver can be downloaded from Agilent.\n\nThis method measures the current Y value for the designated marker on its assigned trace. The trace is in the Y-axis units for the current trace (which is often dBm).\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nA Handle to the HPESA Resource object\n\n\n\n$Marker\n\nInteger\n\nThe Marker # to set to a specific peak. Valid marker numbers are (0,1,2,3)\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Value\n\nFloat\n\nThe trace is in the Y-axis units for the current trace (which is often dBm).\n\n\n\n\n\nHPESA_GetTimeoutValue\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS HPESA_GetTimeoutValue": {
  "prefix": "HPESA_GetTimeoutValue",
  "body": [
   "$$TimeoutValue=HPESA_GetTimeoutValue($$InstrumentHandle);"
  ],
  "description": "\n\n\n\n\n\nThe HPESA_GetTimeoutValue function returns the timeout value for driver I/O transactions in milliseconds. The timeout period may vary on computer platforms.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThe instrument handle for the HP ESA Instrument\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$TimeoutValue\n\nInteger\n\nThe value for the I/O timeout for all functions for the instrument. It is specified in Milliseconds\n\n\n\n\n\nHPESA_Init\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS HPESA_Init": {
  "prefix": "HPESA_Init",
  "body": [
   "$$Handle=HPESA_Init($$ResourceString,$$Reset);"
  ],
  "description": "\n\nThis function controls the Agilent ESA Series of spectrum Analyzers. In order to use these function the VXI pnp driver for the instrument must be installed on the system running Jabil Test. The latest version of this driver can be downloaded from Agilent.\n\nThis function initializes the ESA Spectrum Analyzer, and returns a handle to the instrument. If the $Reset argument is set to TRUE, the instrument is reset to it's default configuration.\n\nExample:\n\n$Handle = HPESA_Init(\"GPIB0::5::INSTR\",\"TRUE\");\n\n\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ResourceString\n\nString\n\nThe Resource string of the instrument, for instance \"GPIB0::18::INSTR\"\n\n\n\n$Reset\n\nBoolean\n\nSpecifies whether or not to reset the instrument upon initialization.\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nA reference handle to the HP-ESA Spectrum Analyzer\n\n\n\n\n\nHPESA_MarkerPeakSearch\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS HPESA_MarkerPeakSearch": {
  "prefix": "HPESA_MarkerPeakSearch",
  "body": [
   "HPESA_MarkerPeakSearch($$Handle,$$Marker,$$SearchType);"
  ],
  "description": "\n\nThis function controls the Agilent ESA Series of spectrum Analyzers. In order to use these function the VXI pnp driver for the instrument must be installed on the system running Jabil Test. The latest version of this driver can be downloaded from Agilent.\n\nThis method sets the specified marker to the peak found specified by the search algorithm requested.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nA Handle to the HPESA Resource object\n\n\n\n$Marker\n\nInteger\n\nThe Marker # to set to a specific peak. Valid marker numbers are (0,1,2,3)\n\n\n\n$SearchType\n\nString\n\nSpecifies the type of peak search to perform. Please refer to the User's manual for additional information about the peak search algorithms. Allowable values for $SearchType are:\n\n\u00b7 \"MARKER_PEAK\"\n\n\u00b7 \"MARKER_PEAKNEXT\"\n\n\u00b7 \"MARKER_PEAKLEFT\"\n\n\u00b7 \"MARKER_PEAKRIGHT\"\n\n\u00b7 \"MARKER_MIN\"\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nHPESA_MeasureChannelPower\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS HPESA_MeasureChannelPower": {
  "prefix": "HPESA_MeasureChannelPower",
  "body": [
   "($$ChannelPower,$$PowerDensity)=HPESA_MeasureChannelPower($$Handle,$$MeasureTimeout,$$MeasureMode);"
  ],
  "description": "\n\nThis function controls the Agilent ESA Series of spectrum Analyzers. In order to use these function the VXI pnp driver for the instrument must be installed on the system running Jabil Test. The latest version of this driver can be downloaded from Agilent.\n\nThis method retrieves the scalar results of the main channel power and power density from the instrument, based on the method of retrieval (measure, read, or fetch).\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nA Handle to the HPESA Resource object\n\n\n\n$MeasureTimeout\n\nFloat\n\nTemporary timeout value in seconds for measurement.\n\n\n\n$MeasureMode\n\nString\n\nSpecifies the Measurment Type; Allowed Values are:\n\n\u00b7 \"READ\"\n\n\u00b7 \"FETCH\"\n\n\u00b7 \"MEASURE\"\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ChannelPower\n\nFloat\n\nThe value of the channel power in the current amplitude units.\n\n\n\n$PowerDensity\n\nFloat\n\nThe value of the channel power density in amplitude units/Hz.\n\n\n\n\n\nHPESA_SetAmplitudeScale\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS HPESA_SetAmplitudeScale": {
  "prefix": "HPESA_SetAmplitudeScale",
  "body": [
   "HPESA_SetAmplitudeScale($$HPESA_handle,$$scale);"
  ],
  "description": "\n\nThis method sets the spectrum analyzer's per division display scaling for the y-axis (amplitude) logarithmic scale format (type). This setting doesn't affect the y-axis linear scale format, where the per division display scaling is always the reference level divided by 10.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$HPESA_handle\n\nObject\n\nThe instrument's VISA session handle returned from hpesa_init().\n\n\n\n$scale\n\nFloat\n\nInstrument's new per division display scaling for y-axis logarithmic scale. Units are in dB.\n\nLog amplitude per division range is:\n\n\u00b7 0.1 dB for steps 0.1 to 0.9\n\n\u00b7 1.0 dB for steps 1.0 to 20.0\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n-\n\n-\n\n\n\n\n\nHPESA_SetCenterFrequency\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS HPESA_SetCenterFrequency": {
  "prefix": "HPESA_SetCenterFrequency",
  "body": [
   "HPESA_SetCenterFrequency($$Handle,$$CenterFreq);"
  ],
  "description": "\n\nThis function controls the Agilent ESA Series of spectrum Analyzers. In order to use these function the VXI pnp driver for the instrument must be installed on the system running Jabil Test. The latest version of this driver can be downloaded from Agilent.\n\nSets the center frequency on the spectrum analyzer.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nA Handle to the HPESA Resource object\n\n\n\n$CenterFreq\n\nInteger\n\nSets the center frequency of the spectrum analyzer, specified in Hertz.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nHPESA.SetFreqSpan\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS HPESA_SetFreqSpan": {
  "prefix": "HPESA_SetFreqSpan",
  "body": [
   "HPESA_SetFreqSpan($$Handle,$$Span);"
  ],
  "description": "\n\nThis function controls the Agilent ESA Series of spectrum Analyzers. In order to use these function the VXI pnp driver for the instrument must be installed on the system running Jabil Test. The latest version of this driver can be downloaded from Agilent.\n\nThis function sets the horizontal frequency span of the spectrum analyzer.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nA Handle to the HPESA Resource object\n\n\n\n$Span\n\nInteger\n\nThe frequency span specified in Hertz.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nHPESA_SetMarkerXPosition\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AdjacentChannelPower\u00b7\"Channel\"=ChannelPower\u00b7\"Emission\"=SpuriousEmission\u00b7\"Occupied\"=OccupiedPower\u00b7\"Harmonic\"=Harmonic\u00b7\"Off\"=MeasurementModeOffReturnParametersParameterVariableTypeDescriptionNoneHPESA_SetReferenceAmplitudePreviousTopNext***HPESA_SetReferenceAmplitudeUsage:HPESA_SetReferenceAmplitude($Handle,$ReferenceLevel);ThisfunctioncontrolstheAgilentESGSeriesofspectrumAnalyzers.InordertousethesefunctiontheVXIpnpdriverfortheinstrumentmustbeinstalledonthesystemrunningJabilTest.ThelatestversionofthisdrivercanbedownloadedfromAgilent.Thisfunctionsupportsthefollowinginstruments:ESG-1000B,ESG-2000B,ESG-3000B,ESG-4000B,ESG-D1000B,ESG-D2000B,ESG-D3000B,ESG-D4000B,ESG-1000A,ESG-2000A,ESG-3000A,ESG-4000A,ESG-D1000A,ESG-D2000A,ESG-D3000A,ESG-D4000A,E4423B,E4424B,E4425B,E4426B,E4434B,E4435B,E4436B,andE4437B.Thismethodsetsthespectrumanalyzer'samplitudereferencelevel.FunctionArgumentsParameterVariableTypeDescription$HandleObjectTheresourcehandleoftheSpectrumAnalyzer$ReferenceLevelFloatInstrument'snewamplitudereferencelevelincurrentamplitudedisplayunits.ReturnParametersParameterVariableTypeDescriptionNoneHPESA_SetResolutionBWPreviousTopNext***HPESA_SetResolutionBWUsage:HPESA_SetResolutionBW": {
  "prefix": "AdjacentChannelPower\u00b7\"Channel\"=ChannelPower\u00b7\"Emission\"=SpuriousEmission\u00b7\"Occupied\"=OccupiedPower\u00b7\"Harmonic\"=Harmonic\u00b7\"Off\"=MeasurementModeOffReturnParametersParameterVariableTypeDescriptionNoneHPESA_SetReferenceAmplitudePreviousTopNext***HPESA_SetReferenceAmplitudeUsage:HPESA_SetReferenceAmplitude($Handle,$ReferenceLevel);ThisfunctioncontrolstheAgilentESGSeriesofspectrumAnalyzers.InordertousethesefunctiontheVXIpnpdriverfortheinstrumentmustbeinstalledonthesystemrunningJabilTest.ThelatestversionofthisdrivercanbedownloadedfromAgilent.Thisfunctionsupportsthefollowinginstruments:ESG-1000B,ESG-2000B,ESG-3000B,ESG-4000B,ESG-D1000B,ESG-D2000B,ESG-D3000B,ESG-D4000B,ESG-1000A,ESG-2000A,ESG-3000A,ESG-4000A,ESG-D1000A,ESG-D2000A,ESG-D3000A,ESG-D4000A,E4423B,E4424B,E4425B,E4426B,E4434B,E4435B,E4436B,andE4437B.Thismethodsetsthespectrumanalyzer'samplitudereferencelevel.FunctionArgumentsParameterVariableTypeDescription$HandleObjectTheresourcehandleoftheSpectrumAnalyzer$ReferenceLevelFloatInstrument'snewamplitudereferencelevelincurrentamplitudedisplayunits.ReturnParametersParameterVariableTypeDescriptionNoneHPESA_SetResolutionBWPreviousTopNext***HPESA_SetResolutionBWUsage:HPESA_SetResolutionBW",
  "body": [
   "HPESA_SetMarkerXPosition($$Handle,$$MarkerNumber,$$Position);ThisfunctioncontrolstheAgilentESASeriesofspectrumAnalyzers.InordertousethesefunctiontheVXIpnpdriverfortheinstrumentmustbeinstalledonthesystemrunningJabilTest.ThelatestversionofthisdrivercanbedownloadedfromAgilent.Thismethodsetsoneofthespectrumanalyzer'smarkerstothespecifiedXPositionFunctionArgumentsParameterVariableTypeDescription$$HandleObjectTheresourcehandleoftheSpectrumAnalyzer$$MarkerNumberIntegerThemarkernumberoftheinstrument$$PositionIntegerTheXpositionforthemarkerindisplaypoints.ReturnParametersParameterVariableTypeDescriptionNoneHPESA_SetMeasureModePreviousTopNext***HPESA_SetMeasureModeUsage:HPESA_SetMeasureMode($$Handle,$$Mode);ThisfunctioncontrolstheAgilentESASeriesofspectrumAnalyzers.InordertousethesefunctiontheVXIpnpdriverfortheinstrumentmustbeinstalledonthesystemrunningJabilTest.ThelatestversionofthisdrivercanbedownloadedfromAgilent.ThismethodconfiguresthemeasurementmodeoftheSpectrumAnalyzer.FunctionArgumentsParameterVariableTypeDescription$$HandleObjectTheresourcehandleoftheSpectrumAnalyzer$$ModeStringSelectsthemeasurementmodeoftheinstrument;ValidOptionsare:\u00b7\"Adjacent\"=AdjacentChannelPower\u00b7\"Channel\"=ChannelPower\u00b7\"Emission\"=SpuriousEmission\u00b7\"Occupied\"=OccupiedPower\u00b7\"Harmonic\"=Harmonic\u00b7\"Off\"=MeasurementModeOffReturnParametersParameterVariableTypeDescriptionNoneHPESA_SetReferenceAmplitudePreviousTopNext***HPESA_SetReferenceAmplitudeUsage:HPESA_SetReferenceAmplitude($$Handle,$$ReferenceLevel);ThisfunctioncontrolstheAgilentESGSeriesofspectrumAnalyzers.InordertousethesefunctiontheVXIpnpdriverfortheinstrumentmustbeinstalledonthesystemrunningJabilTest.ThelatestversionofthisdrivercanbedownloadedfromAgilent.Thisfunctionsupportsthefollowinginstruments:ESG-1000B,ESG-2000B,ESG-3000B,ESG-4000B,ESG-D1000B,ESG-D2000B,ESG-D3000B,ESG-D4000B,ESG-1000A,ESG-2000A,ESG-3000A,ESG-4000A,ESG-D1000A,ESG-D2000A,ESG-D3000A,ESG-D4000A,E4423B,E4424B,E4425B,E4426B,E4434B,E4435B,E4436B,andE4437B.Thismethodsetsthespectrumanalyzer'samplitudereferencelevel.FunctionArgumentsParameterVariableTypeDescription$$HandleObjectTheresourcehandleoftheSpectrumAnalyzer$$ReferenceLevelFloatInstrument'snewamplitudereferencelevelincurrentamplitudedisplayunits.ReturnParametersParameterVariableTypeDescriptionNoneHPESA_SetResolutionBWPreviousTopNext***HPESA_SetResolutionBWUsage:HPESA_SetResolutionBW($$Handle,$$Resolution);"
  ],
  "description": "\n\nThis method sets the spectrum analyzer's resolution bandwidth. Setting the resolution bandwidth uncouples the setting from the frequency span.\n\n\n\n\n\nThis function controls the Agilent ESA Series of spectrum Analyzers. In order to use these function the VXI pnp driver for the instrument must be installed on the system running Jabil Test. The latest version of this driver can be downloaded from Agilent.\n\n\n\n\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nA Handle to the HPESA Resource object\n\n\n\n$Resolution\n\nFloat\n\nThe instruments selected resolution bandwith specified in Hertz\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nHPESA_SetResolutionBWAuto\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS HPESA_SetResolutionBWAuto": {
  "prefix": "HPESA_SetResolutionBWAuto",
  "body": [
   "HPESA_SetResolutionBWAuto($$Handle);"
  ],
  "description": "\n\nThis method sets the spectrum analyzer's resolution bandwidth mode to AUTO, where the resolution bandwidth is coupled to the frequency span.\n\n\n\n\n\nThis function controls the Agilent ESA Series of spectrum Analyzers. In order to use these function the VXI pnp driver for the instrument must be installed on the system running Jabil Test. The latest version of this driver can be downloaded from Agilent.\n\n\n\n\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nA Handle to the HPESA Resource object\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nHPESA_SetSweepMode\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS HPESA_SetSweepMode": {
  "prefix": "HPESA_SetSweepMode",
  "body": [
   "HPESA_SetSweepMode($$Handle,$$SweepMode);"
  ],
  "description": "\n\nThis function controls the Agilent ESA Series of spectrum Analyzers. In order to use these function the VXI pnp driver for the instrument must be installed on the system running Jabil Test. The latest version of this driver can be downloaded from Agilent.\n\nThis function sets the sweep mode of the Spectrum Analyzer\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nA Handle to the HPESA Resource object\n\n\n\n$SweepMode\n\nString\n\nSpecifies the sweep mode of the instrument. Allowable Values are:\n\n\u00b7 \"SINGLE\"\n\n\u00b7 \"CONTINUOUS\"\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nHPESA_SetSweepTime\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS HPESA_SetSweepTime($Handle,$Sweeptime);ThisfunctioncontrolstheAgilentESGSeriesofspectrumAnalyzers.InordertousethesefunctiontheVXIpnpdriverfortheinstrumentmustbeinstalledonthesystemrunningJabilTest.ThelatestversionofthisdrivercanbedownloadedfromAgilent.Thisfunctionsupportsthefollowinginstruments:ESG-1000B,ESG-2000B,ESG-3000B,ESG-4000B,ESG-D1000B,ESG-D2000B,ESG-D3000B,ESG-D4000B,ESG-1000A,ESG-2000A,ESG-3000A,ESG-4000A,ESG-D1000A,ESG-D2000A,ESG-D3000A,ESG-D4000A,E4423B,E4424B,E4425B,E4426B,E4434B,E4435B,E4436B,andE4437B.Thismethodsetsthespectrumanalyzer'ssweeptime.FunctionArgumentsParameterVariableTypeDescription$HandleObjectTheresourcehandleoftheSpectrumAnalyzer$SweepTimeFloatInstrument'snewsweeptimeinseconds.ReturnParametersParameterVariableTypeDescriptionNoneHPESA_SetTimeoutValuePreviousTopNext***HPESA_SetTimeoutValueUsage:HPESA_SetTimeoutValue": {
  "prefix": "HPESA_SetSweepTime($Handle,$Sweeptime);ThisfunctioncontrolstheAgilentESGSeriesofspectrumAnalyzers.InordertousethesefunctiontheVXIpnpdriverfortheinstrumentmustbeinstalledonthesystemrunningJabilTest.ThelatestversionofthisdrivercanbedownloadedfromAgilent.Thisfunctionsupportsthefollowinginstruments:ESG-1000B,ESG-2000B,ESG-3000B,ESG-4000B,ESG-D1000B,ESG-D2000B,ESG-D3000B,ESG-D4000B,ESG-1000A,ESG-2000A,ESG-3000A,ESG-4000A,ESG-D1000A,ESG-D2000A,ESG-D3000A,ESG-D4000A,E4423B,E4424B,E4425B,E4426B,E4434B,E4435B,E4436B,andE4437B.Thismethodsetsthespectrumanalyzer'ssweeptime.FunctionArgumentsParameterVariableTypeDescription$HandleObjectTheresourcehandleoftheSpectrumAnalyzer$SweepTimeFloatInstrument'snewsweeptimeinseconds.ReturnParametersParameterVariableTypeDescriptionNoneHPESA_SetTimeoutValuePreviousTopNext***HPESA_SetTimeoutValueUsage:HPESA_SetTimeoutValue",
  "body": [
   "HPESA_SetSweepTime($$Handle,$$Sweeptime);ThisfunctioncontrolstheAgilentESGSeriesofspectrumAnalyzers.InordertousethesefunctiontheVXIpnpdriverfortheinstrumentmustbeinstalledonthesystemrunningJabilTest.ThelatestversionofthisdrivercanbedownloadedfromAgilent.Thisfunctionsupportsthefollowinginstruments:ESG-1000B,ESG-2000B,ESG-3000B,ESG-4000B,ESG-D1000B,ESG-D2000B,ESG-D3000B,ESG-D4000B,ESG-1000A,ESG-2000A,ESG-3000A,ESG-4000A,ESG-D1000A,ESG-D2000A,ESG-D3000A,ESG-D4000A,E4423B,E4424B,E4425B,E4426B,E4434B,E4435B,E4436B,andE4437B.Thismethodsetsthespectrumanalyzer'ssweeptime.FunctionArgumentsParameterVariableTypeDescription$$HandleObjectTheresourcehandleoftheSpectrumAnalyzer$$SweepTimeFloatInstrument'snewsweeptimeinseconds.ReturnParametersParameterVariableTypeDescriptionNoneHPESA_SetTimeoutValuePreviousTopNext***HPESA_SetTimeoutValueUsage:HPESA_SetTimeoutValue($$InstrumentHandle,$$TimeoutValue);"
  ],
  "description": "\n\n\n\n\n\nThe timeout function sets the timeout value for driver I/O transactions in milliseconds. The timeout period may vary on computer platforms.\n\n\n\n\n\nThe default timeout period varies by VISA implementation. For HP VISA, it is 2 seconds.\n\n\n\n\n\nSome implementations of VISA will only accept a limited number of timeout values. If you set the VISA timeout to a given value using one of those implementations, and then query the timeout, you may find that the query returns a different value than the one you set. HP VISA sets the timeout to the precise value you specify, and returns that value when queried.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThe instrument handle for the HP ESA Instrument\n\n\n\n$TimeoutValue\n\nInteger\n\nThe timeout value for all I/O operations with the instrument, specified in milliseconds.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n\n\n\n\nHPESA_SetTimeoutValue($Handle,5000); // Set Timeout Value to 5 Seconds\n\n\n\n\n\nHPESA_SetTraceMode\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS averagesthelinearpowerofthesuccessivemeasurements.\u00b7\"LOGPOWER\"=logarithmicallyaveragesthepowerofthevideodata(default)$AverageCountIntegerSpecifiesthenumberofmeasurementsthatarecombined.ReturnParametersParameterVariableTypeDescriptionNoneHPESA_SetVideoAverageOnPreviousTopNext***HPESA_SetVideoAverageOnUsage:HPESA_SetVideoAverageOn($Handle,$AveragingOn);ThisfunctioncontrolstheAgilentESASeriesofspectrumAnalyzers.InordertousethesefunctiontheVXIpnpdriverfortheinstrumentmustbeinstalledonthesystemrunningJabilTest.ThelatestversionofthisdrivercanbedownloadedfromAgilent.Thismethodturnsthespectrumanalyzer'svideoaveragingmodeon/off.FunctionArgumentsParameterVariableTypeDescription$HandleObjectTheresourcehandleoftheSpectrumAnalyzer$AveragingOnStringVideoAveragingOn/Off.AllowedValues:\u00b7\"OFF\"\u00b7\"ON\"ReturnParametersParameterVariableTypeDescriptionNoneHPESA_SetVideoBWPreviousTopNext***HPESA_SetVideoBWUsage:HPESA_SetVideoBW($Handle,$Bandwidth);ThisfunctioncontrolstheAgilentESGSeriesofspectrumAnalyzers.InordertousethesefunctiontheVXIpnpdriverfortheinstrumentmustbeinstalledonthesystemrunningJabilTest.ThelatestversionofthisdrivercanbedownloadedfromAgilent.Thisfunctionsupportsthefollowinginstruments:ESG-1000B,ESG-2000B,ESG-3000B,ESG-4000B,ESG-D1000B,ESG-D2000B,ESG-D3000B,ESG-D4000B,ESG-1000A,ESG-2000A,ESG-3000A,ESG-4000A,ESG-D1000A,ESG-D2000A,ESG-D3000A,ESG-D4000A,E4423B,E4424B,E4425B,E4426B,E4434B,E4435B,E4436B,andE4437B.Thismethodsetsthespectrumanalyzer'svideobandwidth.FunctionArgumentsParameterVariableTypeDescription$HandleObjectTheresourcehandleoftheSpectrumAnalyzer$BandwidthFloatInstrument'snewvideobandwidthinhertz.ReturnParametersParameterVariableTypeDescriptionNoneHPESA_StartSweepPreviousTopNext***HPESA_StartSweepUsage:HPESA_StartSweep": {
  "prefix": "averagesthelinearpowerofthesuccessivemeasurements.\u00b7\"LOGPOWER\"=logarithmicallyaveragesthepowerofthevideodata(default)$AverageCountIntegerSpecifiesthenumberofmeasurementsthatarecombined.ReturnParametersParameterVariableTypeDescriptionNoneHPESA_SetVideoAverageOnPreviousTopNext***HPESA_SetVideoAverageOnUsage:HPESA_SetVideoAverageOn($Handle,$AveragingOn);ThisfunctioncontrolstheAgilentESASeriesofspectrumAnalyzers.InordertousethesefunctiontheVXIpnpdriverfortheinstrumentmustbeinstalledonthesystemrunningJabilTest.ThelatestversionofthisdrivercanbedownloadedfromAgilent.Thismethodturnsthespectrumanalyzer'svideoaveragingmodeon/off.FunctionArgumentsParameterVariableTypeDescription$HandleObjectTheresourcehandleoftheSpectrumAnalyzer$AveragingOnStringVideoAveragingOn/Off.AllowedValues:\u00b7\"OFF\"\u00b7\"ON\"ReturnParametersParameterVariableTypeDescriptionNoneHPESA_SetVideoBWPreviousTopNext***HPESA_SetVideoBWUsage:HPESA_SetVideoBW($Handle,$Bandwidth);ThisfunctioncontrolstheAgilentESGSeriesofspectrumAnalyzers.InordertousethesefunctiontheVXIpnpdriverfortheinstrumentmustbeinstalledonthesystemrunningJabilTest.ThelatestversionofthisdrivercanbedownloadedfromAgilent.Thisfunctionsupportsthefollowinginstruments:ESG-1000B,ESG-2000B,ESG-3000B,ESG-4000B,ESG-D1000B,ESG-D2000B,ESG-D3000B,ESG-D4000B,ESG-1000A,ESG-2000A,ESG-3000A,ESG-4000A,ESG-D1000A,ESG-D2000A,ESG-D3000A,ESG-D4000A,E4423B,E4424B,E4425B,E4426B,E4434B,E4435B,E4436B,andE4437B.Thismethodsetsthespectrumanalyzer'svideobandwidth.FunctionArgumentsParameterVariableTypeDescription$HandleObjectTheresourcehandleoftheSpectrumAnalyzer$BandwidthFloatInstrument'snewvideobandwidthinhertz.ReturnParametersParameterVariableTypeDescriptionNoneHPESA_StartSweepPreviousTopNext***HPESA_StartSweepUsage:HPESA_StartSweep",
  "body": [
   "HPESA_SetTraceMode($$Handle,$$TraceNumber,$$TraceMode);ThisfunctioncontrolstheAgilentESASeriesofspectrumAnalyzers.InordertousethesefunctiontheVXIpnpdriverfortheinstrumentmustbeinstalledonthesystemrunningJabilTest.ThelatestversionofthisdrivercanbedownloadedfromAgilent.Thismethodselectsthespectrumanalyzer'stracemodefortheselectedtrace.FunctionArgumentsParameterVariableTypeDescription$$HandleObjectTheresourcehandleoftheSpectrumAnalyzer$$TraceNumberIntegerInstrument'stracenumbertomodify.Trace1-0Trace2-1Trace3-2$$TraceModeStringInstrument'snewtracemode.Thedifferentmodesare\"WRITE\",\"MAXHOLD\",\"MINHOLD\",\"VIEW\",\"BLANK\".ReturnParametersParameterVariableTypeDescriptionNoneHPESA_SetTriggerSourcePreviousTopNext***HPESA_SetTriggerSourceUsage:HPESA_SetTriggerSource($$Handle,$$TriggerSource);ThisfunctioncontrolstheAgilentESASeriesofspectrumAnalyzers.InordertousethesefunctiontheVXIpnpdriverfortheinstrumentmustbeinstalledonthesystemrunningJabilTest.ThelatestversionofthisdrivercanbedownloadedfromAgilent.Thismethodselectsthespectrumanalyzer'striggersource.FunctionArgumentsParameterVariableTypeDescription$$HandleObjectTheresourcehandleoftheSpectrumAnalyzer$$TriggerSourceStringThetriggersource.ValidvaluesareIMMEDIATEVIDEOLINEEXTERNALReturnParametersParameterVariableTypeDescriptionNoneHPESA_SetVideoAverageModePreviousTopNext***HPESA_SetVideoAverageModeUsage:HPESA_SetVideoAverageMode($$Handle,$$AveragingMode,$$AverageCount);ThisfunctioncontrolstheAgilentESASeriesofspectrumAnalyzers.InordertousethesefunctiontheVXIpnpdriverfortheinstrumentmustbeinstalledonthesystemrunningJabilTest.ThelatestversionofthisdrivercanbedownloadedfromAgilent.Thismethodsetsthespectrumanalyzer'saveragetypeandcount.FunctionArgumentsParameterVariableTypeDescription$$HandleObjectTheresourcehandleoftheSpectrumAnalyzer$$AveragingModeStringVideoAveragingMode.AllowedValues:\u00b7\"AVERAGEPOWER\"=averagesthelinearpowerofthesuccessivemeasurements.\u00b7\"LOGPOWER\"=logarithmicallyaveragesthepowerofthevideodata(default)$$AverageCountIntegerSpecifiesthenumberofmeasurementsthatarecombined.ReturnParametersParameterVariableTypeDescriptionNoneHPESA_SetVideoAverageOnPreviousTopNext***HPESA_SetVideoAverageOnUsage:HPESA_SetVideoAverageOn($$Handle,$$AveragingOn);ThisfunctioncontrolstheAgilentESASeriesofspectrumAnalyzers.InordertousethesefunctiontheVXIpnpdriverfortheinstrumentmustbeinstalledonthesystemrunningJabilTest.ThelatestversionofthisdrivercanbedownloadedfromAgilent.Thismethodturnsthespectrumanalyzer'svideoaveragingmodeon/off.FunctionArgumentsParameterVariableTypeDescription$$HandleObjectTheresourcehandleoftheSpectrumAnalyzer$$AveragingOnStringVideoAveragingOn/Off.AllowedValues:\u00b7\"OFF\"\u00b7\"ON\"ReturnParametersParameterVariableTypeDescriptionNoneHPESA_SetVideoBWPreviousTopNext***HPESA_SetVideoBWUsage:HPESA_SetVideoBW($$Handle,$$Bandwidth);ThisfunctioncontrolstheAgilentESGSeriesofspectrumAnalyzers.InordertousethesefunctiontheVXIpnpdriverfortheinstrumentmustbeinstalledonthesystemrunningJabilTest.ThelatestversionofthisdrivercanbedownloadedfromAgilent.Thisfunctionsupportsthefollowinginstruments:ESG-1000B,ESG-2000B,ESG-3000B,ESG-4000B,ESG-D1000B,ESG-D2000B,ESG-D3000B,ESG-D4000B,ESG-1000A,ESG-2000A,ESG-3000A,ESG-4000A,ESG-D1000A,ESG-D2000A,ESG-D3000A,ESG-D4000A,E4423B,E4424B,E4425B,E4426B,E4434B,E4435B,E4436B,andE4437B.Thismethodsetsthespectrumanalyzer'svideobandwidth.FunctionArgumentsParameterVariableTypeDescription$$HandleObjectTheresourcehandleoftheSpectrumAnalyzer$$BandwidthFloatInstrument'snewvideobandwidthinhertz.ReturnParametersParameterVariableTypeDescriptionNoneHPESA_StartSweepPreviousTopNext***HPESA_StartSweepUsage:HPESA_StartSweep($$Handle);"
  ],
  "description": "\n\nThis function controls the Agilent ESA Series of spectrum Analyzers. In order to use these function the VXI pnp driver for the instrument must be installed on the system running Jabil Test. The latest version of this driver can be downloaded from Agilent.\n\nThis function starts a sweep on the Spectrum Analyzer\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nA Handle to the HPESA Resource object\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nRS_FSL_Close\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS RS_FSL_Close": {
  "prefix": "RS_FSL_Close",
  "body": [
   "RS_FSL_Close($$DeviceHandle);"
  ],
  "description": "\n\nThis function performs the following operations:\n\n\u00b7 Closes the instrument I/O session.\n\n\u00b7 Destroys the instrument driver session and all of its attributes.\n\n\u00b7 Deallocates any memory resources the driver uses.\n\n\n\n\n\nNote: After calling rsspecan_close, you cannot use the instrument driver again until you call RS_FSL_Init\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$DeviceHandle\n\nObject\n\nThe device handle object returned by RS_FSL_Init\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\nRS_FSL_Close($Handle);\n\n\n\n\n\nRS_FSL_ConfigureAveraging\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS RS_FSL_ConfigureAveraging": {
  "prefix": "RS_FSL_ConfigureAveraging",
  "body": [
   "RS_FSL_ConfigureAveraging($$DeviceHandle,$$Window,$$Trace,$$AveragingType,$$Enabled);"
  ],
  "description": "\n\nThis function switches on or off the average calculation for the selected trace.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$DeviceHandle\n\nObject\n\nThe device handle object returned by the RS_FSL_Init function.\n\n\n\n$Window\n\nInteger\n\nThe measurement window [1,2]\n\n\n\n$Trace\n\nInteger\n\nThe trace to perform the average calculation on.\n\n\n\n$AveragingType\n\nString\n\nThe average function to implement.If Video is selected, the logarithmic power is averaged and, if Linear is selected, the power values are averaged before they are converted to logarithmic values. Allowable values are:\n\n\u00b7 LIN - Linear\n\n\u00b7 VID - Video\n\n\u00b7 POW - Power\n\n\n\n$Active\n\nBoolean\n\nEnable the averaging function [TRUE,FALSE]\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\nRS_FSL_ConfigureAveraging($handle,1,1,\"POW\",true);\n\n\n\n\n\nRS_FSL_ConfigureCenterFrequencyAndSpan\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS RS_FSL_ConfigureCenterFrequencyAndSpan": {
  "prefix": "RS_FSL_ConfigureCenterFrequencyAndSpan",
  "body": [
   "RS_FSL_ConfigureCenterFrequencyAndSpan($$DeviceHandle,$$Window,$$CenterFrequency,$$Span);"
  ],
  "description": "\n\nThis function configures the frequency range of the spectrum analyzer using the center frequency and the frequency span. If span corresponds to zero hertz, then the spectrum analyzer is in time-domain.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$DeviceHandle\n\nObject\n\nThe device handle object returned by the RS_FSL_Init function.\n\n\n\n&Window\n\nInteger\n\nThe measurement window [1,2]\n\n\n\n$CenterFrequency\n\nFloat\n\nThe center frequency of the frequency sweep (Hz).\n\n\n\n$Span\n\nFloat\n\nThe frequency span of the frequency sweep (Hz).\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\nRS_FSL_ConfigureCenterFrequencyAndSpan($handle,1,2440000000,10000000);\n\n\n\n\n\nRS_FSL_ConfigureMarker\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS RS_FSL_ConfigureMarker": {
  "prefix": "RS_FSL_ConfigureMarker",
  "body": [
   "RS_FSL_ConfigureMarker($$DeviceHandle,$$Window,$$Marker,$$Trace,$$Enabled);"
  ],
  "description": "\n\nThis function enables the active marker on the selected trace.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$DeviceHandle\n\nObject\n\nThe device handle object returned by the RS_FSL_Init function.\n\n\n\n$Window\n\nInteger\n\nThe measurement window [1,2]\n\n\n\n$Marker\n\nInteger\n\nThis control sets and selects the active marker.\n\n\n\n$Trace\n\nInteger\n\nThis controls sets the trace for the configured marker.\n\n\n\n$Enabled\n\nBoolean\n\nEnable the configured marker\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\nRS_FSL_ConfigureMarker($handle,1,1,1,true);\n\n\n\n\n\nRS_FSL_ConfigureChannelSpacing\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS RS_FSL_ConfigurePowerChannelSpacing": {
  "prefix": "RS_FSL_ConfigurePowerChannelSpacing",
  "body": [
   "RS_FSL_ConfigurePowerChannelSpacing($$Handle,$$Window,$$Spacing,$$ChanType,$$Channel);"
  ],
  "description": "\n\nThis function configures the adjacent channel power spacing.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$DeviceHandle\n\nObject\n\nThe device handle object returned by the RS_FSL_Init function.\n\n\n\n$Window\n\nInteger\n\nThe measurement window [1,2]\n\n\n\n$Spacing\n\nFloat\n\nThe selected channel spacing value (Hz).\n\n\n\n$ChanType\n\nString\n\nThe channel type. Allowable values are:\n\n\u00b7 TX - Separate Channel\n\n\u00b7 ADJ - Adjacent Channel\n\n\u00b7 ALT - Alternate Channel\n\n\n\n$Channel\n\nInteger\n\nThe channel number to configure.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\nRS_FSL_ConfigurePowerChannelSpacing($handle,1,1000000,\"ADJ\",1);\n\n\n\n\n\nRS_FSL_ConfigurePowerMeasurement\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS RS_FSL_ConfigurePowerMeasurement": {
  "prefix": "RS_FSL_ConfigurePowerMeasurement",
  "body": [
   "RS_FSL_ConfigurePowerMeasurement($$Handle,$$Window,$$NumChannels,$$ChanMode,$$PowMode);"
  ],
  "description": "\n\nThis function configures the adjacent power channels measurement.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$DeviceHandle\n\nObject\n\nThe device handle object returned by the RS_FSL_Init function.\n\n\n\n$Window\n\nInteger\n\nThe measurement window [1,2]\n\n\n\n$NumChannels\n\nInteger\n\nThe start frequency of the frequency sweep [0-12]\n\n\n\n$ChanMode\n\nString\n\nSets absolute and relative adjacent channel measurement. Allowable values are:\n\n\u00b7 ABS - Absolute\n\n\u00b7 REL - Relative\n\n\n\n$PowMode\n\nString\n\nSets the clear write or max hold for channel power values. Allowable values are:\n\n\u00b7 WRITE - Clear/Write\n\n\u00b7 HOLD - Max Hold\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\nRS_FSL_ConfigurePowerMeasurement($handle,1,5,\"REL\",\"WRITE\");\n\n\n\n\n\nRS_FSL_ConfigureSweepAndBandwidth\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS RS_FSL_ConfigureSweepAndBandwidth": {
  "prefix": "RS_FSL_ConfigureSweepAndBandwidth",
  "body": [
   "RS_FSL_ConfigureSweepAndBandwidth($$Handle,$$Window,$$Sweep,$$RBW,$$VBW);"
  ],
  "description": "\n\nThis function configures the coupling values of the spectrum analyzer.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$DeviceHandle\n\nObject\n\nThe device handle object returned by the RS_FSL_Init function.\n\n\n\n$Window\n\nInteger\n\nThe measurement window [1,2]\n\n\n\n$Sweep\n\nFloat\n\nThe length of time to complete one sweep (s).\n\n\n\n$RBW\n\nFloat\n\nSpecifies the measurement resolution bandwidth (Hz).\n\n\n\n$VBW\n\nFloat\n\nSpecifies the video bandwidth of the post-detection filter (Hz).\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\nRS_FSL_ConfigureSweepAndBandwidth($handle,1,.015,30000,30000);\n\n\n\n\n\nRS_FSL_DisableAllMarkers\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS RS_FSL_DisableAllMarkers": {
  "prefix": "RS_FSL_DisableAllMarkers",
  "body": [
   "RS_FSL_DisableAllMarkers($$DeviceHandle,$$Window);"
  ],
  "description": "\n\nThis function turns off all the markers in the specified measurement window.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$DeviceHandle\n\nObject\n\nThe device handle object returned by RS_FSL_Init\n\n\n\n$Window\n\nInteger\n\nThe measurement window [1,2]\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\nRS_FSL_DisableAllMarkers($Handle,1);\n\n\n\n\n\nRS_FSL_EnableDisplay\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS RS_FSL_EnableDisplay": {
  "prefix": "RS_FSL_EnableDisplay",
  "body": [
   "RS_FSL_EnableDisplay($$DeviceHandle,$$Enable,$$ShowButtons);"
  ],
  "description": "\n\nThis function switches on or off the update of all display elements and buttons during remote control.\n\nNote: The $Enable parameter must be set to TRUE for the $ShowButtons parameter to become active.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$DeviceHandle\n\nObject\n\nThe device handle returned by RS_FSL_Init\n\n\n\n$Enable\n\nBoolean\n\nThis control enables or disables instrument display when in remote control [TRUE,FALSE]\n\n\n\n$ShowButtons\n\nBoolean\n\nThis control enables or disables front panel keys on the screen when in remote control mode [TRUE,FALSE]\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\nRS_FSL_EnableDisplay($handle,true,false);\n\n\n\n\n\nRS_FSL_GetActiveWindow\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS RS_FSL_GetActiveWindow": {
  "prefix": "RS_FSL_GetActiveWindow",
  "body": [
   "$$Window=RS_FSL_GetActiveWindow($$DeviceHandle);"
  ],
  "description": "\n\nThis function returns the active measurement window ID to be used in other functions.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$DeviceHandle\n\nObject\n\nThe device handle object returned by RS_FSL_Init\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Window\n\nInteger\n\nThe active window measurement ID.\n\n\n\n\n\nExamples:\n\n$win = RS_FSL_GetActiveWindow($Handle);\n\n\n\n\n\nRS_FSL_GetMarkerAmplitude\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS RS_FSL_GetMarkerAmplitude": {
  "prefix": "RS_FSL_GetMarkerAmplitude",
  "body": [
   "$$Amp=RS_FSL_GetMarkerAmplitude($$DeviceHandle,$$Window,$$Marker);"
  ],
  "description": "\n\nThis function returns the amplitude level of the selected marker.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$DeviceHandle\n\nObject\n\nThe device handle returned by RS_FSL_Init\n\n\n\n$Window\n\nInteger\n\nThe measurement window [1,2]\n\n\n\n$Marker\n\nInteger\n\nThe marker ID to be queried.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Amp\n\nFloat\n\nThe amplitude value of the selected marker.\n\n\n\n\n\nExamples:\n\n$amp = RS_FSL_GetMarkerAmplitude($handle,1,1);\n\n\n\n\n\nRS_FSL_GetMarkerFrequency\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS RS_FSL_GetMarkerFrequency": {
  "prefix": "RS_FSL_GetMarkerFrequency",
  "body": [
   "$$Freq=RS_FSL_GetMarkerFrequency($$DeviceHandle,$$Window,$$Marker);"
  ],
  "description": "\n\nThis function returns the horizontal position of the selected marker.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$DeviceHandle\n\nObject\n\nThe device handle returned by RS_FSL_Init\n\n\n\n$Window\n\nInteger\n\nThe measurement window [1,2]\n\n\n\n$Marker\n\nInteger\n\nThe marker ID to be queried.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Freq\n\nFloat\n\nThe horizontal position of the selected marker (Hz)\n\n\n\n\n\nExamples:\n\n$freq = RS_FSL_GetMarkerFrequency($handle,1,1);\n\n\n\n\n\nRS_FSL_GetPowerChannelMeasure\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS RS_FSL_GetPowerChannelMeasure": {
  "prefix": "RS_FSL_GetPowerChannelMeasure",
  "body": [
   "$$Lower,$$Upper=RS_FSL_GetPowerChannelMeasure($$DeviceHandle,$$Window,$$Channel);"
  ],
  "description": "\n\nThis function returns the power measurement results for the selected channel. If the selected channel equals '0', the power measurement for the transmission channel will be returned in the $Lower return variable and the $Upper return variable will equal '0'.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$DeviceHandle\n\nObject\n\nThe device handle returned by RS_FSL_Init\n\n\n\n$Window\n\nInteger\n\nThe measurement window [1,2]\n\n\n\n$Channel\n\nInteger\n\nThe marker ID to be queried.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Lower\n\nFloat\n\nThe lower power measurement for the channel.\n\n\n\n$Upper\n\nFloat\n\nThe upper power measurement for the channel.\n\n\n\n\n\nExamples:\n\n$pow = RS_FSL_GetPowerChannelMeasure($handle,1,0);\n\n\n\n\n\nRS_FSL_Init\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS RS_FSL_Init": {
  "prefix": "RS_FSL_Init",
  "body": [
   "$$DeviceHandle=RS_FSL_Init($$ResourceString$$IdQuery,$$Reset);"
  ],
  "description": "\n\nThis function performs the following initialization actions:\n\n\u00b7 Creates a new instrument driver session.\n\n\u00b7 Opens a session to the specified device using the interface and address you specify for the Resource Name parameter.\n\n\u00b7 If the ID Query parameter is set to VI_TRUE, this function queries the instrument ID and checks that it is valid for this instrument driver.\n\n\u00b7 If the Reset parameter is set to VI_TRUE, this function resets the instrument to a known state.\n\n\u00b7 Sends initialization commands to set the instrument to the state necessary for the operation of the instrument driver.\n\n\n\n\n\nNote: It is generally a good programming habit to close the instrument handle when the program is done using the instrument. This can be done with the RS_FSL_Close function.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$DeviceName\n\nString\n\nResource string of the R&S Spectrum Analyzer\n\n\n\n$IDQuery\n\nBoolean\n\nSpecify whether you want the instrument driver to perform an ID Query.\n\n\n\n$Reset\n\nBoolean\n\nSpecify whether you want to restart the instrument during the initialization procedure.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$DeviceHandle\n\nObject\n\nThe handle of the device\n\n\n\n\n\nExamples:\n\n$DeviceHandle = RS_FSL_Init(\"TCPIP::192.168.1.3::INSTR\",false,true);\n\n\n\n\n\nRS_FSL_Reset\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS RS_FSL_Reset": {
  "prefix": "RS_FSL_Reset",
  "body": [
   "RS_FSL_Reset($$DeviceHandle);"
  ],
  "description": "\n\nThis function resets the instrument.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$DeviceHandle\n\nObject\n\nThe device handle object returned by RS_FSL_Init\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\nRS_FSL_Reset($Handle);\n\n\n\n\n\nRS_FSL_SelfTest\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS RS_FSL_SelfTest": {
  "prefix": "RS_FSL_SelfTest",
  "body": [
   "RS_FSL_SelfTest($$DeviceHandle);"
  ],
  "description": "\n\nThis function runs the instrument's self test function and displays the test result(s).\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$DeviceHandle\n\nObject\n\nThe device handle object returned by RS_FSL_Init\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\nRS_FSL_SelfTest($Handle);\n\n\n\n\n\nRS_FSL_SetActiveWindow\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS RS_FSL_SetActiveWindow": {
  "prefix": "RS_FSL_SetActiveWindow",
  "body": [
   "RS_FSL_SetActiveWindow($$DeviceHandle,$$Window);"
  ],
  "description": "\n\nThis function sets the active measurement window to be used in other functions.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$DeviceHandle\n\nObject\n\nThe device handle object returned by RS_FSL_Init\n\n\n\n$Window\n\nInteger\n\nThe measurement window to set active [1,2]\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\nRS_FSL_SetActiveWindow($Handle,1);\n\n\n\n\n\nRS_FSL_SetInstrumentFromMarker\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS RS_FSL_SetInstrumentFromMarker": {
  "prefix": "RS_FSL_SetInstrumentFromMarker",
  "body": [
   "RS_FSL_SetInstrumentFromMarker($$DeviceHandle,$$Window,$$Marker,$$Setting);"
  ],
  "description": "\n\nThis function makes the selected marker frequency to be the center frequency or step width of the center frequency. It can also make the active marker amplitude the to be the reference level.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$DeviceHandle\n\nObject\n\nThe device handle returned by RS_FSL_Init\n\n\n\n$Window\n\nInteger\n\nThe measurement window [1,2]\n\n\n\n$Marker\n\nInteger\n\nThe selected marker ID.\n\n\n\n$Setting\n\nString\n\nSpecifies the instrument setting to be set from the marker position. Allowable values are:\n\n\u00b7 CENTER - Center Frequency\n\n\u00b7 STEP - Step Width of Center Freq\n\n\u00b7 REF - Reference Level\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\nRS_FSL_SetInstrumentFromMarker($handle,1,1,\"CENTER\");\n\n\n\n\n\nRS_FSL_SetMarkerFrequency\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS RS_FSL_SetMarkerFrequency": {
  "prefix": "RS_FSL_SetMarkerFrequency",
  "body": [
   "RS_FSL_SetMarkerFrequency($$DeviceHandle,$$Window,$$Marker,$$Frequency);"
  ],
  "description": "\n\nThis function moves the selected marker to the specified horizontal frequency position.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$DeviceHandle\n\nObject\n\nThe device handle returned by RS_FSL_Init\n\n\n\n$Window\n\nInteger\n\nThe measurement window [1,2]\n\n\n\n$Marker\n\nInteger\n\nThe selected marker ID.\n\n\n\n$Frequency\n\nFloat\n\nThe horizontal frequency position to move the maker (Hz).\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\nRS_FSL_SetMarkerFrequency($handle,1,$mkr,2440000000);\n\n\n\n\n\nRS_FSL_SetReferenceAmplitude\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS RS_FSL_SetReferenceAmplitude": {
  "prefix": "RS_FSL_SetReferenceAmplitude",
  "body": [
   "RS_FSL_SetReferenceAmplitude($$DeviceHandle,$$Window,$$RefLevel);"
  ],
  "description": "\n\nThis function configures the reference level for the specified window.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$DeviceHandle\n\nObject\n\nThe device handle returned by RS_FSL_Init\n\n\n\n$Window\n\nInteger\n\nThe measurement window [1,2]\n\n\n\n$RefLevel\n\nFloat\n\nThe calibrated vertical position of the captured data used as a reference for amplitude measurements.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\nRS_FSL_SetReferenceAmplitude($handle,0);\n\n\n\n\n\nRS_FSL_SetSweepTime\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS RS_FSL_SetSweepTime": {
  "prefix": "RS_FSL_SetSweepTime",
  "body": [
   "RS_FSL_SetSweepTime($$DeviceHandle,$$Window,$$SweepTime);"
  ],
  "description": "\n\nThis function configures the sweep time values of the spectrum analyzer.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$DeviceHandle\n\nObject\n\nThe device handle returned by RS_FSL_Init\n\n\n\n$Window\n\nInteger\n\nThe measurement window [1,2]\n\n\n\n$SweepTime\n\nFloat\n\nThe length of time to complete one sweep (s).\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\nRS_FSL_SetSweepTime($handle,1,.015);\n\n\n\n\n\nRS_SpecAn_Close\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS RS_SpecAn_Close": {
  "prefix": "RS_SpecAn_Close",
  "body": [
   "RS_SpecAn_Close($$DeviceHandle);"
  ],
  "description": "\n\nThis function performs the following operations:\n\n\u00b7 Closes the instrument I/O session.\n\n\u00b7 Destroys the instrument driver session and all of its attributes.\n\n\u00b7 Deallocates any memory resources the driver uses.\n\n\n\n\n\nNote: After calling RS_SpecAn_Close, you cannot use the instrument driver again until you call RS_SpecAn_Init\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$DeviceHandle\n\nObject\n\nThe device handle object returned by RS_SpecAn_Init()\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n--\n\n--\n\n\n\n\n\nExamples:\n\nRS_SpecAn_Close($Handle);\n\n\n\n\n\nRS_SpecAn_DisableMarker\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS RS_SpecAn_DisableMarker": {
  "prefix": "RS_SpecAn_DisableMarker",
  "body": [
   "RS_SpecAn_DisableMarker($$DeviceHandle);"
  ],
  "description": "\n\nThis function turns off all the markers in the specified measurement window.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$DeviceHandle\n\nObject\n\nThe device handle object returned by RS_SpecAn_Init\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n--\n\n--\n\n\n\n\n\nExamples:\n\nRS_SpecAn_DisableMarker($DeviceHandle);\n\n\n\n\n\nRS_SpecAn_GetMarkerAmplitude\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS RS_SpecAn_GetMarkerAmplitude": {
  "prefix": "RS_SpecAn_GetMarkerAmplitude",
  "body": [
   "$$Amp=RS_SpecAn_GetMarkerAmplitude($$DeviceHandle);"
  ],
  "description": "\n\nThis function returns the amplitude level of the active marker. Function arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$DeviceHandle\n\nObject\n\nThe device handle returned by RS_SpecAn_Init\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Amp\n\nFloat\n\nThe amplitude value of the active marker in current units.\n\n\n\n\n\nExamples:\n\n$Amplitude = RS_SpecAn_GetMarkerAmplitude($handle);\n\n\n\n\n\nRS_SpecAn_GetMarkerPostion\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS RS_SpecAn_GetMarkerPostion": {
  "prefix": "RS_SpecAn_GetMarkerPostion",
  "body": [
   "$$Freq=RS_SpecAn_GetMarkerPostion($$DeviceHandle);"
  ],
  "description": "\n\nThis function returns the horizontal position of the selected marker in current units.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$DeviceHandle\n\nObject\n\nThe device handle returned by RS_FSL_Init\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Freq\n\nFloat\n\nThe horizontal position of the active marker in current units.\n\n\n\n\n\nExamples:\n\n$Freq = RS_SpecAn_GetMarkerPostion($DeviceHandle);\n\n\n\n\n\nRS_SpecAn_Init\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS RS_SpecAn_Init": {
  "prefix": "RS_SpecAn_Init",
  "body": [
   "$$DeviceHandle=RS_SpecAn_Init($$ResourceString$$IdQuery,$$Reset,$$OptionString);"
  ],
  "description": "\n\nThis function performs the following initialization actions:\n\n\u00b7 Creates a new instrument driver session.\n\n\u00b7 Opens a session to the specified device using the interface and address you specify for the Resource Name parameter.\n\n\u00b7 If the ID Query parameter is set to TRUE, this function queries the instrument ID and checks that it is valid for this instrument driver.\n\n\u00b7 If the Reset parameter is set to TRUE, this function resets the instrument to a known state.\n\n\u00b7 The user can use the OptionsString parameter to specify the initial values of certain IVI inherent attributes for the session\n\n\u00b7 Sends initialization commands to set the instrument to the state necessary for the operation of the instrument driver.\n\n\n\n\n\nNote: It is generally a good programming habit to close the instrument handle when the program is done using the instrument. This can be done with the RS_SpecAn_Close function.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$DeviceName\n\nString\n\nResource string of the R&S Spectrum Analyzer\n\n\n\n$IDQuery\n\nBoolean\n\nSpecify whether you want the instrument driver to perform an ID Query.\n\n\n\n$Reset\n\nBoolean\n\nSpecify whether you want to restart the instrument during the initialization procedure.\n\n\n\n$OptionString\n\nString\n\nThe format of an assignment in the OptionsString parameteris \"Name=Value\", where Name is one of: RangeCheck, QuerytInstrStatus, Cache, Simulate, RecordCoercions, InterchangeCheck,or DriverSetup. Value is either true or false except for DriverSetup. If the Options String parameter contains an assignment for the Driver Setup attribute, the Initialize function assumes that everything following \"DriverSetup=\" is part of the assignment.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$DeviceHandle\n\nObject\n\nThe handle of the device\n\n\n\n\n\nExamples:\n\n$DeviceHandle = RS_SpecAn_Init($ResourceString true, true, \"\");\n\n\n\n\n\nRS_SpecAn_InitiateSweep\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS RS_SpecAn_InitiateSweep": {
  "prefix": "RS_SpecAn_InitiateSweep",
  "body": [
   "RS_SpecAn_InitiateSweep($$DeviceHandle,$$timeoutms);"
  ],
  "description": "\n\nInitiates an acquisition and waits until the sweep completes or the timeout occurs. If an acquisition is already in progress, it is restarted.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$DeviceHandle\n\nObject\n\nThe device handle returned by RS_SpecAn_Init\n\n\n\n$timeoutms\n\nInteger\n\nTimeout period in milliseconds\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n--\n\n--\n\n\n\n\n\nExamples:\n\nRS_SpecAn_InitiateSweep($DeviceHandle,1000);\n\n\n\n\n\nRS_SpecAn_MarkerSearch\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS RS_SpecAn_MarkerSearch": {
  "prefix": "RS_SpecAn_MarkerSearch",
  "body": [
   "RS_SpecAn_MarkerSearch($$DeviceHandle,$$SearchType);"
  ],
  "description": "\n\nPerforms the selected search for the active marker.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$DeviceHandle\n\nObject\n\nThe device handle returned by RS_SpecAn_Init\n\n\n\n$SearchType\n\nString\n\nType of marker search to perform. Valid values are:\n\n\u00b7 \"PEAK\"\n\n\u00b7 \"MINIMUM\"\n\n\u00b7 \"NEXTPEAK\"\n\n\u00b7 \"NEXTPEAKLEFT\"\n\n\u00b7 \"NEXTPEAKRIGHT\"\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n--\n\n--\n\n\n\n\n\nExamples:\n\nRS_SpecAn_MarkerSearch($DeviceHandle,\"PEAK\");\n\n\n\n\n\nRS_SpecAn_MeasureChannelPower\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS RS_SpecAn_MeasureChannelPower": {
  "prefix": "RS_SpecAn_MeasureChannelPower",
  "body": [
   "$$Ch_Power=RS_SpecAn_MeasureChannelPower($$DeviceHandle,$$Bandwidth,$$timeoutms);"
  ],
  "description": "\n\nThis function Performs a power measurement of a Tx channel of the given bandwidth, centered around the current frequency.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$DeviceHandle\n\nObject\n\nThe device handle returned by RS_FSL_Init\n\n\n\n$Bandwidth\n\nFloat\n\nBandwidth of Tx channel to measure power of\n\n\n\n$timeoutms\n\nInteger\n\nTimeout in ms to wait for power measurement to complete\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Ch_Power\n\nFloat\n\nPower in dBm.\n\n\n\n\n\nExamples:\n\n$Ch_Power = RS_SpecAn_MeasureChannelPower($DeviceHandle,100000,500);\n\n\n\n\n\nRS_SpecAn_QuerySCPI\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS RS_SpecAn_QuerySCPI": {
  "prefix": "RS_SpecAn_QuerySCPI",
  "body": [
   "$$response=RS_SpecAn_QuerySCPI($$DeviceHandle,$$Command,$$desiredCount);"
  ],
  "description": "\n\nOutputs the supplied SCPI to the instrument and returns the respond as a string\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$DeviceHandle\n\nObject\n\nThe device handle returned by RS_SpecAn_Init\n\n\n\n$Command\n\nString\n\nSCPI command\n\n\n\n$desiredCount\n\nInteger\n\nNumber of bytes to read back\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$response\n\nString\n\nInstrument response\n\n\n\n\n\nExamples:\n\n$response = RS_SpecAn_QuerySCPI($DeviceHandle,$Command,$desiredCount);\n\n\n\n\n\nRS_SpecAn_Reset\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS RS_SpecAn_Reset": {
  "prefix": "RS_SpecAn_Reset",
  "body": [
   "RS_SpecAn_Reset($$DeviceHandle);"
  ],
  "description": "\n\nThis function resets the instrument.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$DeviceHandle\n\nObject\n\nThe device handle object returned by RS_SpecAn_Init\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n--\n\n--\n\n\n\n\n\nExamples:\n\nRS_SpecAn_Reset($Handle);\n\n\n\n\n\nRS_SpecAn_SetActiveMarker\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS RS_SpecAn_SetActiveMarker": {
  "prefix": "RS_SpecAn_SetActiveMarker",
  "body": [
   "RS_SpecAn_SetActiveMarker($$DeviceHandle,$$Marker);"
  ],
  "description": "\n\nSets the active marker for use in the marker functions.. This must be done prior to using any Marker Functions.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$DeviceHandle\n\nObject\n\nThe device handle object returned by the RS_SpecAn_Init function.\n\n\n\n$Marker\n\nInteger\n\nThe marker number to set to active.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n--\n\n--\n\n\n\n\n\nExamples:\n\nRS_SpecAn_SetActiveMarker($DeviceHandle, 1);\n\n\n\n\n\nRS_SpecAn_SetAmplitudeScale\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS RS_SpecAn_SetAmplitudeScale": {
  "prefix": "RS_SpecAn_SetAmplitudeScale",
  "body": [
   "RS_SpecAn_SetAmplitudeScale($$DeviceHandle,$$Scale);"
  ],
  "description": "\n\nSets or gets the scaling of the Y axis in the current unit. If an invalid value is entered, it is coerced to the nearest valid value.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$DeviceHandle\n\nObject\n\nThe device handle object returned by the RS_SpecAn_Init function.\n\n\n\n$Scale\n\nDouble\n\nY axis range (min - max) in current units.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n--\n\n--\n\n\n\n\n\nExamples:\n\nRS_SpecAn_SetAmplitudeScale($DeviceHandle, 50);\n\n\n\n\n\nRS_SpecAn_SetAmplitudeUnits\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS RS_SpecAn_SetAmplitudeUnits": {
  "prefix": "RS_SpecAn_SetAmplitudeUnits",
  "body": [
   "RS_SpecAn_SetAmplitudeUnits($$DeviceHandle,$$Units);"
  ],
  "description": "\n\nSpecifies the units of the Y-axis (amplitude).\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$DeviceHandle\n\nObject\n\nThe device handle object returned by the RS_SpecAn_Init function.\n\n\n\n$Units\n\nString\n\nUnits of amplitude (vertical scale). Valid values are:\n\n\u00b7 \"DBM\"\n\n\u00b7 \"DBMV\"\n\n\u00b7 \"DBPW\"\n\n\u00b7 \"DBUA\"\n\n\u00b7 \"DBUV\"\n\n\u00b7 \"VOLTS\"\n\n\u00b7 \"WATTS\"\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n--\n\n--\n\n\n\n\n\nExamples:\n\nRS_SpecAn_SetAmplitudeUnits($DeviceHandle, \"DBM\");\n\n\n\n\n\nRS_SpecAn_SetCenterSpan\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS RS_SpecAn_SetCenterSpan": {
  "prefix": "RS_SpecAn_SetCenterSpan",
  "body": [
   "RS_SpecAn_SetCenterSpan($$DeviceHandle,$$Freq,$$Span);"
  ],
  "description": "\n\nThis function configures the frequency range using the center frequency and frequency span. If span corresponds to zero hertz, then the spectrum analyzer is in time-domain.\n\n\n\n\n\nThis function modifies the Frequency Start and Frequency Stop attributes as follows:\n\n\u00b7 Frequency Start = center frequency - span/2\n\n\u00b7 Frequency Stop = center frequency + span/2\n\n\n\n\n\nNote:\n\nIn auto-coupled mode, RBW, VBW and sweep time may be affected by this function.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$DeviceHandle\n\nObject\n\nThe device handle object returned by the RS_SpecAn_Init function.\n\n\n\n$Freq\n\nFloat\n\nThe Center Frequency\n\n\n\n$Span\n\nFloat\n\nThe Span.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n--\n\n--\n\n\n\n\n\nExamples:\n\nRS_SpecAn_SetCenterSpan($DeviceHandle, 1000000,100000);\n\n\n\n\n\nRS_SpecAn_SetMarkerPosition\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS RS_SpecAn_SetMarkerPosition": {
  "prefix": "RS_SpecAn_SetMarkerPosition",
  "body": [
   "RS_SpecAn_SetMarkerPosition($$DeviceHandle,$$Position);"
  ],
  "description": "\n\nSpecifies the frequency or time position of the active marker.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$DeviceHandle\n\nObject\n\nThe device handle returned by RS_SpecAn_Init\n\n\n\n$Position\n\nDouble\n\nPosition\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n--\n\n--\n\n\n\n\n\nExamples:\n\nRS_SpecAn_SetMarkerPosition($DeviceHandle,1000000);\n\n\n\n\n\nRS_SpecAn_SetReferenceLevel\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS RS_SpecAn_SetReferenceLevel": {
  "prefix": "RS_SpecAn_SetReferenceLevel",
  "body": [
   "RS_SpecAn_SetReferenceLevel($$DeviceHandle,$$Ref_Level);"
  ],
  "description": "\n\nSpecifies the amplitude value of the reference level.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$DeviceHandle\n\nObject\n\nThe device handle returned by RS_SpecAn_Init\n\n\n\n$Ref_Level\n\nDouble\n\nReference level.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n--\n\n--\n\n\n\n\n\nExamples:\n\nRS_SpecAn_SetReferenceLevel($DeviceHandle,$Ref_Level);\n\n\n\n\n\nRS_SpecAn_SetResolutionBW\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS RS_SpecAn_SetResolutionBW": {
  "prefix": "RS_SpecAn_SetResolutionBW",
  "body": [
   "RS_SpecAn_SetResolutionBW($$DeviceHandle,$$resBW);"
  ],
  "description": "\n\nSpecifies the width of the IF filter in Hertz.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$DeviceHandle\n\nObject\n\nThe device handle object returned by the RS_SpecAn_Init function.\n\n\n\n$resBW\n\nDouble\n\nWidth of the IF filter in Hertz.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n--\n\n--\n\n\n\n\n\nExamples:\n\nRS_SpecAn_SetResolutionBW($DeviceHandle, 500);\n\n\n\n\n\nRS_SpecAn_SetResolutionBWAuto\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS RS_SpecAn_SetResolutionBWAuto": {
  "prefix": "RS_SpecAn_SetResolutionBWAuto",
  "body": [
   "RS_SpecAn_SetResolutionBWAuto($$DeviceHandle,$$auto);"
  ],
  "description": "\n\nTurns resolution bandwith auto coupling on/off.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$DeviceHandle\n\nObject\n\nThe device handle object returned by the RS_SpecAn_Init function.\n\n\n\n$auto\n\nBoolean\n\nTrue/False\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n--\n\n--\n\n\n\n\n\nExamples:\n\nRS_SpecAn_SetResolutionBWAuto($DeviceHandle, true);\n\n\n\n\n\nRS_SpecAn_SetStartStopFrequency\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS RS_SpecAn_SetStartStopFrequency": {
  "prefix": "RS_SpecAn_SetStartStopFrequency",
  "body": [
   "RS_SpecAn_SetStartStopFrequency($$DeviceHandle,$$startFreq,$$stopFreq);"
  ],
  "description": "\n\nThis function configures the frequency range of using start frequency and stop frequency. If start frequency is equal to the stop frequency, then the spectrum analyzer is in time-domain mode.\n\n\n\n\n\nNote:\n\nIn auto-coupled mode, resolution bandwidth (RBW), video bandwidth (VBW), and sweep time may be affected .\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$DeviceHandle\n\nObject\n\nThe device handle returned by RS_SpecAn_Init\n\n\n\n$startFreq\n\nFloat\n\nStart Frequency\n\n\n\n$stopFreq\n\nFloat\n\nStop Frequency\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n--\n\n--\n\n\n\n\n\nExamples:\n\nRS_SpecAn_SetStartStopFrequency($DeviceHandle,900000,1100000);\n\n\n\n\n\nRS_SpecAn_SetSweepModeContinuous\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS RS_SpecAn_SetSweepModeContinuous": {
  "prefix": "RS_SpecAn_SetSweepModeContinuous",
  "body": [
   "RS_SpecAn_SetSweepModeContinuous($$DeviceHandle,$$SweepModeContinuous);"
  ],
  "description": "\n\nTurns continuous sweep on/off.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$DeviceHandle\n\nObject\n\nThe device handle returned by RS_SpecAn_Init\n\n\n\n$SweepModeContinuous\n\nBoolean\n\nTrue/false\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n--\n\n--\n\n\n\n\n\nExamples:\n\nRS_SpecAn_SetSweepModeContinuous($DeviceHandle,true);\n\n\n\n\n\nRS_SpecAn_SetVideoBW\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS RS_SpecAn_SetVideoBW": {
  "prefix": "RS_SpecAn_SetVideoBW",
  "body": [
   "RS_SpecAn_SetVideoBW($$DeviceHandle,$$vidBW);"
  ],
  "description": "\n\nSpecifies the video bandwidth of the post-detection filter in Hertz.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$DeviceHandle\n\nObject\n\nThe device handle object returned by the RS_SpecAn_Init function.\n\n\n\n$vidBW\n\nFloat\n\nBandwidth in Hertz.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n--\n\n--\n\n\n\n\n\nExamples:\n\nRS_SpecAn_SetVideoBW($DeviceHandle, 500);\n\n\n\n\n\nRS_SpecAn_SetVideoBWAuto\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS RS_SpecAn_SetVideoBWAuto": {
  "prefix": "RS_SpecAn_SetVideoBWAuto",
  "body": [
   "RS_SpecAn_SetVideoBWAuto($$DeviceHandle,$$auto);"
  ],
  "description": "\n\nTurns video bandwith auto coupling on/off.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$DeviceHandle\n\nObject\n\nThe device handle object returned by the RS_SpecAn_Init function.\n\n\n\n$auto\n\nBoolean\n\nTrue/False\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n--\n\n--\n\n\n\n\n\nExamples:\n\nRS_SpecAn_SetVideoBWAuto($DeviceHandle, true);\n\n\n\n\n\nRS_SpecAn_SignalTrackEnabled\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS RS_SpecAn_SignalTrackEnabled": {
  "prefix": "RS_SpecAn_SignalTrackEnabled",
  "body": [
   "RS_SpecAn_SignalTrackEnabled($$DeviceHandle,$$SignalTrackEnabled);"
  ],
  "description": "\n\nEnables/disables signal tracking of the marker.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$DeviceHandle\n\nObject\n\nThe device handle object returned by the RS_SpecAn_Init function.\n\n\n\n$SignalTrackEnabled\n\nBoolean\n\nTrue/False\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n--\n\n--\n\n\n\n\n\nExamples:\n\nRS_SpecAn_SignalTrackEnabled($DeviceHandle, true);\n\n\n\n\n\nRS_SpecAn_WriteSCPI\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS RS_SpecAn_WriteSCPI": {
  "prefix": "RS_SpecAn_WriteSCPI",
  "body": [
   "RS_SpecAn_WriteSCPI($$DeviceHandle,$$command);"
  ],
  "description": "\n\nWrites raw string (SCPI command) to the instrument input.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$DeviceHandle\n\nObject\n\nThe device handle object returned by the RS_SpecAn_Init function.\n\n\n\n$command\n\nString\n\nSCPI command.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n--\n\n--\n\n\n\n\n\nExamples:\n\nRS_SpecAn_WriteSCPI($DeviceHandle, $command);\n\n\n\n\n\nSupported Instruments\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ST400NT_GetConnectedControllers": {
  "prefix": "ST400NT_GetConnectedControllers",
  "body": [
   "$$value=ST400NT_GetConnectedControllers();"
  ],
  "description": "\n\nThis function enables the motor controllers on all stations and returns a string representing the number of controllers connected. This function must be done after ST400NT_MotorStationsInit() and before the controller can be used.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$none\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$value\n\nString\n\nA string representing the number of controllers connected. Example: \"0,1,2,3,N,N,N,N,N,N,N,N,N,N,N,N\" indicates that there are 4 controllers connected and are addressed as \"0\" \"1\" \"2\" and \"3\".\n\n\n\n\n\nST400NT_MotorChangeJogSpeed\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ST400NT_MotorChangeJogSpeed": {
  "prefix": "ST400NT_MotorChangeJogSpeed",
  "body": [
   "ST400NT_MotorChangeJogSpeed($$address,$$speed);"
  ],
  "description": "\n\nThis function will change the JOG speed for the addressed motor.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$address\n\nString\n\nMotor address for new jog speed\n\n\n\n$speed\n\nInteger\n\nSpeed\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$none\n\n\n\n\n\nST400NT_MotorGetPosition\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ST400NT_MotorGetPosition": {
  "prefix": "ST400NT_MotorGetPosition",
  "body": [
   "$$position=ST400NT_MotorGetPosition($$address);"
  ],
  "description": "\n\nThis function will get the internal position counter of the addressed motor.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$address\n\nString\n\nMotor address to get position of.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$position\n\nInteger\n\nInternal position counter for addressed motor.\n\n\n\n\n\nST400NT_MotorGetStatusRegister\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ST400NT_MotorGetStatusRegister": {
  "prefix": "ST400NT_MotorGetStatusRegister",
  "body": [
   "$$status=ST400NT_MotorGetStatusRegister($$address);"
  ],
  "description": "\n\nThis function will get the internal status register of the addressed motor.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$address\n\nString\n\nMotor address to get status register of.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$status\n\nInteger\n\nStatus register for the addressed motor. The bits are defined as:\n\n\u00b7 Bit 0 Trigger on\n\n\u00b7 Bit 1 Motor Paused\n\n\u00b7 Bit 2 Motor Stopped\n\n\u00b7 Bit 3 Motor Moving\n\n\u00b7 Bit 4 CCW Limit reached\n\n\u00b7 Bit 5 CW Limit reached\n\n\u00b7 Bit 6 Home Switch is on\n\n\u00b7 Bit 7 Motor Motion Complete\n\n\u00b7 Bit 8 Direction (1 = CW, 0 = CCW)\n\n\u00b7 Bit 9 Position error > 2 steps\n\n\n\n\n\nST400NT_MotorGoAbsPos\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ST400NT_MotorGoAbsPos": {
  "prefix": "ST400NT_MotorGoAbsPos",
  "body": [
   "ST400NT_MotorGoAbsPos($$address,$$position);"
  ],
  "description": "\n\nThis function will move the motor to the specified absolute position.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$address\n\nString\n\nAddress of the motor to move.\n\n\n\n$position\n\nInteger\n\nAbsolute position\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$none\n\n\n\n\n\nST400NT_MotorJog\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ST400NT_MotorJog": {
  "prefix": "ST400NT_MotorJog",
  "body": [
   "ST400NT_MotorJog($$address,$$direction);"
  ],
  "description": "\n\nThis function will set the addressed motor in JOG mode.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$address\n\nString\n\nAddress of the motor to set in JOG mode. (\"0\" \"1\" ... Max controller number connected.\n\n\n\n$direction\n\nInteger\n\nDirection of motor movement (0 = CW 1 = CWW)\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$none\n\n\n\n\n\nST400NT_MotorNumberStepRel\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ST400NT_MotorNumberStepRel": {
  "prefix": "ST400NT_MotorNumberStepRel",
  "body": [
   "ST400NT_MotorNumberStepRel($$address,$$stepstogo);"
  ],
  "description": "\n\nThis function will move the motor the specified number of relative steps.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$address\n\nString\n\nAddress of the motor to move.\n\n\n\n$stepstogo\n\nInteger\n\nRelative number of steps to move.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$none\n\n\n\n\n\nST400NT_MotorPauseOff\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ST400NT_MotorPauseOff": {
  "prefix": "ST400NT_MotorPauseOff",
  "body": [
   "ST400NT_MotorPauseOff($$address);"
  ],
  "description": "\n\nThis function will un-pause the addressed motor.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$address\n\nString\n\nAddress of the motor to un-pause.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$none\n\n\n\n\n\nST400NT_MotorPauseOn\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ST400NT_MotorPauseOn": {
  "prefix": "ST400NT_MotorPauseOn",
  "body": [
   "ST400NT_MotorPauseOn($$address);"
  ],
  "description": "\n\nThis function will pause the addressed motor.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$address\n\nString\n\nAddress of the motor to pause.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$none\n\n\n\n\n\nST400NT_MotorPowerOff\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ST400NT_MotorPowerOff": {
  "prefix": "ST400NT_MotorPowerOff",
  "body": [
   "ST400NT_MotorPowerOff($$address);"
  ],
  "description": "\n\nThis function will turn the power to the addressed motor off.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$address\n\nString\n\nAddress of the motor to power off.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$none\n\n\n\n\n\nST400NT_MotorPowerOn\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ST400NT_MotorPowerOn": {
  "prefix": "ST400NT_MotorPowerOn",
  "body": [
   "ST400NT_MotorPowerOn($$address,$$powerdowntime);"
  ],
  "description": "\n\nThis function will turn the power to the addressed motor on and set the auto power down time.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$address\n\nString\n\nAddress of the motor to power on.\n\n\n\n$powerdowntime\n\nInteger\n\nAuto power down time in seconds.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$none\n\n\n\n\n\nST400NT_MotorSetCurrent\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ST400NT_MotorSetCurrent": {
  "prefix": "ST400NT_MotorSetCurrent",
  "body": [
   "ST400NT_MotorSetCurrent($$address,$$current);"
  ],
  "description": "\n\nThis function will set the winding current of the addressed motor.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$address\n\nString\n\nMotor address to set current\n\n\n\n$current\n\nInteger\n\nCurrent in MilliAmps\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$none\n\n\n\n\n\nST400NT_MotorSetPosition\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ST400NT_MotorSetPosition": {
  "prefix": "ST400NT_MotorSetPosition",
  "body": [
   "ST400NT_MotorSetPosition($$address,$$position);"
  ],
  "description": "\n\nThis function will set the internal position counter for the addressed motor to the specified position.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$address\n\nString\n\nMotor address for new position\n\n\n\n$position\n\nInteger\n\nPosition\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$none\n\n\n\n\n\nST400NT_MotorStationsInit\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ST400NT_MotorStationsInit": {
  "prefix": "ST400NT_MotorStationsInit",
  "body": [
   "ST400NT_MotorStationsInit();"
  ],
  "description": "\n\nThis function initalizes the motor controllers on all stations to the default values. This function must be done before the controller can be used.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$none\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$none\n\n\n\n\n\nST400NT_MotorStop\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ST400NT_MotorStop": {
  "prefix": "ST400NT_MotorStop",
  "body": [
   "ST400NT_MotorStop($$address);"
  ],
  "description": "\n\nThis function will stop the addressed motor's movement.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$address\n\nString\n\nAddress of the motor to stop.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$none\n\n\n\n\n\nST400NT_MotorTriggerOff\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ST400NT_MotorTriggerOff": {
  "prefix": "ST400NT_MotorTriggerOff",
  "body": [
   "ST400NT_MotorTriggerOff($$address);"
  ],
  "description": "\n\nThis function will clear the addressed motor's trigger.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$address\n\nString\n\nAddress of the motor to clear the trigger.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$none\n\n\n\n\n\nST400NT_MotorTriggerOn\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ST400NT_MotorTriggerOn": {
  "prefix": "ST400NT_MotorTriggerOn",
  "body": [
   "ST400NT_MotorTriggerOn($$address);"
  ],
  "description": "\n\nThis function will set the addressed motor's trigger.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$address\n\nString\n\nAddress of the motor to set the trigger.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$none\n\n\n\n\n\nST400NT_PortClose\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ST400NT_PortClose": {
  "prefix": "ST400NT_PortClose",
  "body": [
   "ST400NT_PortClose();"
  ],
  "description": "\n\nThis function closes the com port used by the ST400NT Stepper Motor controller board.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$none\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$none\n\n\n\n\n\nST400NT_PortOpen\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ST400NT_PortOpen": {
  "prefix": "ST400NT_PortOpen",
  "body": [
   "ST400NT_PortOpen($$comportnumber,$$baudrate);"
  ],
  "description": "\n\nThis function opens the com port connected to the ST400NT Stepper Motor controller board.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$comportnumber\n\nInteger\n\nThe comport number used by the ST400NT\n\n\n\n$baudrate\n\nInteger\n\nBaud Rate\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$none\n\n\n\n\n\nAeroFlexCombiner_Close\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AeroFlexCombiner_Close": {
  "prefix": "AeroFlexCombiner_Close",
  "body": [
   "AeroFlexCombiner_Close($$handle);"
  ],
  "description": "\n\n\n\n\n\nThis method closes and frees up all resources used by the RF Switch/Combiner.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$handle\n\nObject\n\nThe handle of the instrument returned from the AeroFlexCombiner_Open function\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nnone\n\n\n\n\n\nExample:\n\n\n\n\n\nAeroFlexCombiner_Close($handle);\n\n\n\n\n\nAeroFlexCombiner_Open\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AeroFlexCombiner_Open": {
  "prefix": "AeroFlexCombiner_Open",
  "body": [
   "$$handle=AeroFlexCombiner_Open($$CombinerResource);"
  ],
  "description": "\n\nThis method attempts to boot the RF combiner using the resource string provided.\n\n$CombinerResource must be valid Visa resource strings.\n\nThis function initializes a session with the instrument and returns the handle to the test script.\n\n\n\n\n\nNote: The \"boot\" time of this instrument (like any PXI instrument) if fairly time consuming, so it's suggested to place any initializations for these instruments in a global initialization script to cut test time significantly, which can be up to 60 seconds when booting a common configuration consisting of an AeroFlex RF Signal Generator, Digitizer, and Combiner.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$CombinerResource\n\nString\n\nThe resource name of the RF Combiner.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$handle\n\nObject\n\nThe handle to the instrument session.\n\n\n\n\n\nExample:\n\n\n\n\n\n$handle = AeroFlexCombiner_Open(\"PXI2::12::INSTR\");\n\n\n\n\n\nAeroFlexCombiner_SetMode\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AeroFlexCombiner_SetMode": {
  "prefix": "AeroFlexCombiner_SetMode",
  "body": [
   "AeroFlexCombiner_SetMode($$handle,$$mode);"
  ],
  "description": "\n\n\n\n\n\nThis function configures the RF combiner/switch for the desired signal routing. Please note that although this function supports all possible signal routings, not all routing modes are supported on each instrument. The supported modes for each instrument are listed in the parameter description below:\n\nNote: The $Mode string parameter is not case sensitive, and the suggested character capitalization examples below are merely suggested to improve readability of the script.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$handle\n\nObject\n\nThe handle of the instrument returned from the AeroFlexCombiner_Open function\n\n\n\n$mode\n\nString\n\nThe desired setting of the RF combiner/switch:\n\n\n\n\n\n\u00b7 \"ABCtoSUM\" = Switches inputs A,B,C to the SUM output (Applies to 3060 and 3065)\n\n\u00b7 \"AtoB\" = Routes Signal A to B (Applies to 3060 and 3065)\n\n\u00b7 \"BtoC\" = Routes Signal B to C (Applies to 3060 and 3065)\n\n\u00b7 \"BCtoSUMandAtoD\" = Routes signals B and C to SUM, and routes A to D (Applies to 3065 only)\n\n\u00b7 \"ABtoSUMandCtoD\" = Routes signals A and B to SUM, and C to D (Applies to 3065 only)\n\n\u00b7 \"BtoCandAtoSUM\" = Routes Signal B to C, and A to SUM (Applies to 3065 only)\n\n\u00b7 \"AtoBandCtoSUM\" = Routes signal A to B, and C to SUM (Applies to 3065 only)\n\n\u00b7 \"BtoCandAtoD\" = Routes signal B to C, and A to D (Applies to 3065 only)\n\n\u00b7 \"AtoBandCtoD\" = Routes signal A to B, and C to D (Applies to 3065 Only)\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nnone\n\n\n\n\n\nExample:\n\n\n\n\n\nAeroFlexCombiner_SetMode($handle, \"ABtoSUMandAtoD\");\n\n\n\n\n\nNI_SWITCH_AbortScan\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_SWITCH_AbortScan": {
  "prefix": "NI_SWITCH_AbortScan",
  "body": [
   "NI_SWITCH_AbortScan($$NI_SwitchHandle);"
  ],
  "description": "\n\nThis function requires NI Switch drivers to be installed on the system.\n\nAborts the scan in progress.\n\nInitiate a scan with NI_SWITCH_InitiateScan.\n\n\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PXI-2569 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Switch functions, Jabil Test while fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\nNI_SWITCH_AbortScan($NI_SwitchHandle);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_SwitchHandle\n\nObject\n\nA particular NI-SWITCH session established with NI_SWITCH_InitWithTopology, NI_SWITCH_InitializeWithOptions, or NI_SWITCH_Initialize and used for all subsequent NI-SWITCH calls.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n\n\nExample:\n\nNI_SWITCH_AbortScan($NI_SwitchHandle);\n\n\n\n\n\nNI_SWITCH_CanConnect\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_SWITCH_CanConnect": {
  "prefix": "NI_SWITCH_CanConnect",
  "body": [
   "($$pathCapability1,$$pathCapability2)=NI_SWITCH_CanConnect($$NI_SwitchHandle,$$channel1,$$channel2);"
  ],
  "description": "\n\nThis function requires NI Switch drivers to be installed on the system.\n\nVerifies that a path between channel1 and channel2 can be created.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PXI-2569 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Switch functions, Jabil Test while fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\n($pathCapability1, $pathCapability2) = NI_SWITCH_CanConnect($NI_SwitchHandle, $channel1, $channel2);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_SwitchHandle\n\nObject\n\nA particular NI-SWITCH session established with NI_SWITCH_InitWithTopology, NI_SWITCH_InitializeWithOptions, or NI_SWITCH_Initialize and used for all subsequent NI-SWITCH calls.\n\n\n\n$channel1\n\nString\n\nInput one of the channel names of the desired path.\n\n\n\n$channel2\n\nString\n\nInput two of the channel names of the desired path.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$pathCapability1\n\nInteger\n\nIndicates whether a path is valid.\n\nPossible returned values:\n\n\u00b7 1: Indicates that NI-SWITCH can create the path at this time.\n\n\u00b7 2: Indicates that the path already exists.\n\n\u00b7 3: Indicates that the instrument is not capable of creating a path between the channels you specify.\n\n\u00b7 4: Indicates that although the path is valid, NI-SWITCH cannot create the path at this moment because the switch is currently using one or more of the required channels to create another path. You must destroy the other path before creating this one.\n\n\u00b7 5: Indicates that the instrument cannot create a path because both channels are connected to different source channels.\n\n\u00b7 6: Indicates that NI-SWITCH cannot create a path between the two channels because one of the channels is a configuration channel and unavailable for external connections.\n\n\n\n$pathCapability2\n\nString\n\nIndicates whether a path is valid\n\nPossible returned values:\n\n\u00b7 Path available: Indicates that NI-SWITCH can create the path at this time.\n\n\u00b7 Path exists: Indicates that the path already exists.\n\n\u00b7 Path unsupported: Indicates that the instrument is not capable of creating a path between the channels you specify.\n\n\u00b7 Path resource in use: Indicates that although the path is valid, NI-SWITCH cannot create the path at this moment because the switch is currently using one or more of the required channels to create another path. You must destroy the other path before creating this one.\n\n\u00b7 Source conflict: Indicates that the instrument cannot create a path because both channels are connected to different source channels.\n\n\u00b7 Channel not available: Indicates that NI-SWITCH cannot create a path between the two channels because one of the channels is a configuration channel and unavailable for external connections.\n\n\n\n\n\nExample:\n\n($pathCapability1, $pathCapability2) = NI_SWITCH_CanConnect($NI_SwitchHandle, \"ch0\", \"com0\");\n\n\n\n\n\nNI_SWITCH_Close\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_SWITCH_Close": {
  "prefix": "NI_SWITCH_Close",
  "body": [
   "NI_SWITCH_Close($$NI_SwitchHandle);"
  ],
  "description": "\n\nThis function requires NI Switch drivers to be installed on the system.\n\nTerminates the NI-SWITCH session and all of its attributes and deallocates any memory resources the driver uses. You must unlock the session before calling NI_SWITCH_Close. After calling NI_SWITCH_Close, you cannot use the NI-SWITCH again until you call NI_SWITCH_Initialize or NI_SWITCH_InitializeWithOptions.\n\nRemarks:\n\n\u00b7 This function is tested with a NI PXI-2569 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Switch functions, Jabil Test while fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\nNI_SWITCH_Close($NI_SwitchHandle);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_SwitchHandle\n\nObject\n\nA particular NI-SWITCH session established with NI_SWITCH_InitWithTopology, NI_SWITCH_InitializeWithOptions, or NI_SWITCH_Initialize and used for all subsequent NI-SWITCH calls.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n\n\nExample:\n\nNI_SWITCH_Close($NI_SwitchHandle);\n\n\n\n\n\nNI_SWITCH_CloseMultiRelais\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_SWITCH_CloseMultiRelais": {
  "prefix": "NI_SWITCH_CloseMultiRelais",
  "body": [
   "NI_SWITCH_CloseMultiRelais($$NI_SwitchHandle,$$relayList,$$waitTime);"
  ],
  "description": "\n\nThis function requires NI Switch drivers to be installed on the system.\n\nThis function checks if the relay names exists. If not, the test will fail. Otherwise the relais will be closed. With the parameter waitTime, the function pauses untill all created paths have settled.\n\nRemarks:\n\n\u00b7 This function is tested with a NI PXI-2569 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Switch functions, Jabil Test while fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\nNI_SWITCH_CloseMultiRelais($NI_SwitchHandle, $relayList, $waitTime);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_SwitchHandle\n\nObject\n\nA particular NI-SWITCH session established with NI_SWITCH_InitWithTopology, NI_SWITCH_InitializeWithOptions, or NI_SWITCH_Initialize and used for all subsequent NI-SWITCH calls.\n\n\n\n$relayList\n\nString\n\nA enumeration of all the relais you want to open.\n\n\n\n$waitTime\n\nInteger\n\nSpecifies the maximum length of time to wait for all relays in the switch module to activate or deactivate. The wait time unit is milliseconds (ms).\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n\n\nExample:\n\nNI_SWITCH_CloseMultiRelais($NI_SwitchHandle, \"k20, k1, k2, k3\", 20);\n\n\n\n\n\nNI_SWITCH_Commit\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_SWITCH_Commit": {
  "prefix": "NI_SWITCH_Commit",
  "body": [
   "NI_SWITCH_Commit($$NI_SwitchHandle);"
  ],
  "description": "\n\nThis function requires NI Switch drivers to be installed on the system.\n\nDownloads the configured scan list and trigger settings to hardware. Calling NI_SWITCH_Commit is optional as it is implicitly called during NI_SWITCH_InitiateScan. Use NI_SWITCH_Commit to arm triggers in a given order or to control when expensive hardware operations are performed.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PXI-2569 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Switch functions, Jabil Test while fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\nNI_SWITCH_Commit($NI_SwitchHandle);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_SwitchHandle\n\nObject\n\nA particular NI-SWITCH session established with NI_SWITCH_InitWithTopology, NI_SWITCH_InitializeWithOptions, or NI_SWITCH_Initialize and used for all subsequent NI-SWITCH calls.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n\n\nExample:\n\nNI_SWITCH_Commit($NI_SwitchHandle);\n\n\n\n\n\nNI_SWITCH_ConfigureScanList\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_SWITCH_ConfigureScanList": {
  "prefix": "NI_SWITCH_ConfigureScanList",
  "body": [
   "NI_SWITCH_ConfigureScanList($$NI_SwitchHandle,$$scanList,$$scanMode);"
  ],
  "description": "\n\nThis function requires NI Switch drivers to be installed on the system.\n\nConfigures the scan list and scan mode used for scanning.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PXI-2569 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Switch functions, Jabil Test while fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\nNI_SWITCH_ConfigureScanList($NI_SwitchHandle, $scanList, $scanMode);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_SwitchHandle\n\nObject\n\nA particular NI-SWITCH session established with NI_SWITCH_InitWithTopology, NI_SWITCH_InitializeWithOptions, or NI_SWITCH_Initialize and used for all subsequent NI-SWITCH calls.\n\n\n\n$scanList\n\nString\n\nThe scan list to use.\n\n\n\n\n\nScan list characters:\n\n\u00b7 -> is used in a connect action (channel1->channel2). For example, the string ch0->com0 connects CH0 to COM0.\n\n\u00b7 ~ is used with '->' in a disconnect action (~channel1->channel2). Valid only in No Action mode. For example, ~ch0->com0 means disconnect CH0 and COM0.\n\n\u00b7 ; means waiting for debounce, send scan advanced output signal, then wait for trigger input.\n\n\u00b7 & Separates connect and/or disconnect actions. For example, the string ch0->com0 & ch9->com1 means connect CH0 to COM0 and CH9 to COM1 (in no particular order).\n\n\u00b7 && means waiting for debounce. For example, ch0->com0 && ch9->com1 means connect CH0 to COM0, wait for the relays to settle, then connect CH9 to COM1.\n\n\u00b7 : is Used in a channel range (channelX:Y, where X and Y are integers). Text containing a channel range represents multiple scan list entries. For example, the string ch0:7->com0; represents eight scan list entries. A semicolon must appear after the connect action using a channel range.\n\n\n\n$scanMode\n\nString\n\nSpecifies how the switch module breaks existing connections when scanning.\n\nPossible values:\n\n\u00b7 No action: Connections remain connected until they are explicitly disconnected by a disconnect action.\n\n\u00b7 Break before make: Connections from the previous scan list entry are automatically disconnected before executing the current scan list entry.\n\n\u00b7 Break after make: Currently not supported.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n\n\nExample:\n\nNI_SWITCH_ConfigureScanList($NI_SwitchHandle, \"ch0->com0; ~ch0->com0 && ch1->com0; ~ch1->com0 &&\", \"No action\");\n\n\n\n\n\nMeaning:\n\n\n\n\n\n1 Connect ch0 to com0.\n\n2 Wait for debounce, send scan advanced signal, then wait for trigger input.\n\n3 Disconnect ch0 from com0 and wait for debounce.\n\n4 Connect ch1 to com0.\n\n5 Wait for debounce, send scan advanced signal, then wait for trigger input.\n\n6 Disconnect ch1 from com0 and wait for debounce.\n\n7 If the scan is set to continuous, return to step 1; otherwise, end the scan.\n\n\n\n\n\nNI_SWITCH_ConfigureScanList($NI_SwitchHandle, \"ch0->com0; ch1->com0;\", \"Break Before Make\");\n\n\n\n\n\nMeaning:\n\nThe scan list in this example is equivalent to the scan list in Example 1. Notice that the disconnect actions in Example 1 are no longer required.\n\n\n\n\n\nNI_SWITCH_ConfigureScanTrigger\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_SWITCH_ConfigureScanTrigger": {
  "prefix": "NI_SWITCH_ConfigureScanTrigger",
  "body": [
   "NI_SWITCH_ConfigureScanTrigger($$NI_SwitchHandle,$$scanDelay,$$triggerInput,$$scanAdvancedOutput);"
  ],
  "description": "\n\nThis function requires NI Switch drivers to be installed on the system.\n\nConfigures the scan triggers for the scan list established with NI_SWITCH_ConfigureScanList.\n\nNI_SWITCH_ConfigureScanTrigger sets the location that the switch expects to receive an input trigger to advance through the scan list. This function also sets the location where it outputs a scan advanced signal after it completes an entry in the scan list.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PXI-2569 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Switch functions, Jabil Test while fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\nNI_SWITCH_ConfigureScanTrigger($NI_SwitchHandle, $scanDelay, $triggerInput, $scanAdvancedOutput);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_SwitchHandle\n\nObject\n\nA particular NI-SWITCH session established with NI_SWITCH_InitWithTopology, NI_SWITCH_InitializeWithOptions, or NI_SWITCH_Initialize and used for all subsequent NI-SWITCH calls.\n\n\n\n$scanDelay\n\nFloat\n\nThe minimum length of time you want the switch to wait after it creates a path until it asserts a trigger on the scan advanced output line.\n\n\n\n$triggerInput\n\nString\n\nTrigger source you want the switch module to use during scanning.\n\nPossible values:\n\n\u00b7 IMMEDIATE\n\n\u00b7 EXTERNAL\n\n\u00b7 SOFTWARE TRIGGER\n\n\u00b7 TTL0\n\n\u00b7 TTL1\n\n\u00b7 TTL2\n\n\u00b7 TTL3\n\n\u00b7 TTL4\n\n\u00b7 TTL5\n\n\u00b7 TTL6\n\n\u00b7 TTL7\n\n\u00b7 PXI STAR\n\n\u00b7 REAR CONNECTOR\n\n\u00b7 REAR CONNECTOR MODULE 1\n\n\u00b7 REAR CONNECTOR MODULE 2\n\n\u00b7 REAR CONNECTOR MODULE 3\n\n\u00b7 REAR CONNECTOR MODULE 4\n\n\u00b7 REAR CONNECTOR MODULE 5\n\n\u00b7 REAR CONNECTOR MODULE 6\n\n\u00b7 REAR CONNECTOR MODULE 7\n\n\u00b7 REAR CONNECTOR MODULE 8\n\n\u00b7 REAR CONNECTOR MODULE 9\n\n\u00b7 REAR CONNECTOR MODULE 10\n\n\u00b7 REAR CONNECTOR MODULE 11\n\n\u00b7 REAR CONNECTOR MODULE 12\n\n\u00b7 FRONT CONNECTOR\n\n\u00b7 FRONT CONNECTOR MODULE 1\n\n\u00b7 FRONT CONNECTOR MODULE 2\n\n\u00b7 FRONT CONNECTOR MODULE 3\n\n\u00b7 FRONT CONNECTOR MODULE 4\n\n\u00b7 FRONT CONNECTOR MODULE 5\n\n\u00b7 FRONT CONNECTOR MODULE 6\n\n\u00b7 FRONT CONNECTOR MODULE 7\n\n\u00b7 FRONT CONNECTOR MODULE 8\n\n\u00b7 FRONT CONNECTOR MODULE 9\n\n\u00b7 FRONT CONNECTOR MODULE 10\n\n\u00b7 FRONT CONNECTOR MODULE 11\n\n\u00b7 FRONT CONNECTOR MODULE 12\n\n\n\n$scanAdvancedOutput\n\nString\n\nOutput destination of the scan advanced trigger signal.\n\nPossible values:\n\n\u00b7 NONE\n\n\u00b7 EXTERNAL\n\n\u00b7 TTL0\n\n\u00b7 TTL1\n\n\u00b7 TTL2\n\n\u00b7 TTL3\n\n\u00b7 TTL4\n\n\u00b7 TTL5\n\n\u00b7 TTL6\n\n\u00b7 TTL7\n\n\u00b7 PXI STAR\n\n\u00b7 REAR CONNECTOR\n\n\u00b7 REAR CONNECTOR MODULE 1\n\n\u00b7 REAR CONNECTOR MODULE 2\n\n\u00b7 REAR CONNECTOR MODULE 3\n\n\u00b7 REAR CONNECTOR MODULE 4\n\n\u00b7 REAR CONNECTOR MODULE 5\n\n\u00b7 REAR CONNECTOR MODULE 6\n\n\u00b7 REAR CONNECTOR MODULE 7\n\n\u00b7 REAR CONNECTOR MODULE 8\n\n\u00b7 REAR CONNECTOR MODULE 9\n\n\u00b7 REAR CONNECTOR MODULE 10\n\n\u00b7 REAR CONNECTOR MODULE 11\n\n\u00b7 REAR CONNECTOR MODULE 12\n\n\u00b7 FRONT CONNECTOR\n\n\u00b7 FRONT CONNECTOR MODULE 1\n\n\u00b7 FRONT CONNECTOR MODULE 2\n\n\u00b7 FRONT CONNECTOR MODULE 3\n\n\u00b7 FRONT CONNECTOR MODULE 4\n\n\u00b7 FRONT CONNECTOR MODULE 5\n\n\u00b7 FRONT CONNECTOR MODULE 6\n\n\u00b7 FRONT CONNECTOR MODULE 7\n\n\u00b7 FRONT CONNECTOR MODULE 8\n\n\u00b7 FRONT CONNECTOR MODULE 9\n\n\u00b7 FRONT CONNECTOR MODULE 10\n\n\u00b7 FRONT CONNECTOR MODULE 11\n\n\u00b7 FRONT CONNECTOR MODULE 12\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n\n\nExample:\n\nNI_SWITCH_ConfigureScanTrigger($NI_SwitchHandle, 2.0, \"FRONT CONNECTOR\", \"REAR CONNECTOR\");\n\n\n\n\n\nNI_SWITCH_Connect\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_SWITCH_Connect": {
  "prefix": "NI_SWITCH_Connect",
  "body": [
   "NI_SWITCH_Connect($$NI_SwitchHandle,$$channel1,$$channel2);"
  ],
  "description": "\n\nThis function requires NI Switch drivers to be installed on the system.\n\nCreates a path between channel1 and channel2. NI-SWITCH calculates and uses the shortest path between the two channels.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PXI-2569 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Switch functions, Jabil Test while fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\nNI_SWITCH_Connect($NI_SwitchHandle, $channel1, $channel2);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_SwitchHandle\n\nObject\n\nA particular NI-SWITCH session established with NI_SWITCH_InitWithTopology, NI_SWITCH_InitializeWithOptions, or NI_SWITCH_Initialize and used for all subsequent NI-SWITCH calls.\n\n\n\n$channel1\n\nString\n\nInput one of the channel names of the desired path.\n\n\n\n$channel2\n\nString\n\nInput two of the channel names of the desired path.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n\n\nExample:\n\nNI_SWITCH_Connect($NI_SwitchHandle, \"ch0\", \"com0\");\n\n\n\n\n\nNI_SWITCH_Disable\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_SWITCH_Disable": {
  "prefix": "NI_SWITCH_Disable",
  "body": [
   "NI_SWITCH_Disable($$NI_SwitchHandle);"
  ],
  "description": "\n\nThis function requires NI Switch drivers to be installed on the system.\n\nPlaces the switch module in a quiescent state, where it has minimal or no impact on the system to which it is connected. All channels are disconnected and any scan in progress is aborted.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PXI-2569 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Switch functions, Jabil Test while fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\nNI_SWITCH_Disable($NI_SwitchHandle);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_SwitchHandle\n\nObject\n\nA particular NI-SWITCH session established with NI_SWITCH_InitWithTopology, NI_SWITCH_InitializeWithOptions, or NI_SWITCH_Initialize and used for all subsequent NI-SWITCH calls.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n\n\nExample:\n\nNI_SWITCH_Disable($NI_SwitchHandle);\n\n\n\n\n\nNI_SWITCH_Disconnect\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_SWITCH_Disconnect": {
  "prefix": "NI_SWITCH_Disconnect",
  "body": [
   "NI_SWITCH_Disconnect($$NI_SwitchHandle,$$channel1,$$channel2);"
  ],
  "description": "\n\nThis function requires NI Switch drivers to be installed on the system.\n\nDestroys the path between two channels that you create with the NI_SWITCH_Connect or NI_SWITCH_SetPath function.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PXI-2569 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Switch functions, Jabil Test while fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\nNI_SWITCH_Disconnect($NI_SwitchHandle, $channel1, $channel2);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_SwitchHandle\n\nObject\n\nA particular NI-SWITCH session established with NI_SWITCH_InitWithTopology, NI_SWITCH_InitializeWithOptions, or NI_SWITCH_Initialize and used for all subsequent NI-SWITCH calls.\n\n\n\n$channel1\n\nString\n\nInput one of the channel names of the desired path.\n\n\n\n$channel2\n\nString\n\nInput two of the channel names of the desired path.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n\n\nExample:\n\nNI_SWITCH_Disconnect($NI_SwitchHandle, \"ch0\", \"com0\");\n\n\n\n\n\nNI_SWITCH_DisconnectAll\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_SWITCH_DisconnectAll": {
  "prefix": "NI_SWITCH_DisconnectAll",
  "body": [
   "NI_SWITCH_DisconnectAll($$NI_SwitchHandle);"
  ],
  "description": "\n\nThis function requires NI Switch drivers to be installed on the system.\n\nBreaks all existing paths.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PXI-2569 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Switch functions, Jabil Test while fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\nNI_SWITCH_DisconnectAll($NI_SwitchHandle);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_SwitchHandle\n\nObject\n\nA particular NI-SWITCH session established with NI_SWITCH_InitWithTopology, NI_SWITCH_InitializeWithOptions, or NI_SWITCH_Initialize and used for all subsequent NI-SWITCH calls.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n\n\nExample:\n\nNI_SWITCH_DisconnectAll($NI_SwitchHandle);\n\n\n\n\n\nNI_SWITCH_GetPath\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_SWITCH_GetPath": {
  "prefix": "NI_SWITCH_GetPath",
  "body": [
   "$$path=NI_SWITCH_GetPath($$NI_SwitchHandle,$$channel1,$$channel2,$$bufferSize);"
  ],
  "description": "\n\nThis function requires NI Switch drivers to be installed on the system.\n\nReturns a string that identifies the explicit path created with NI_SWITCH_Connect. Pass this string to NI_SWITCH_SetPath to establish the exact same path in future connections. In some cases, multiple paths are available between two channels. When you call NI_SWITCH_Connect, NI-SWITCH selects an available path; however, the driver may not always select the same path through the switch module. NI_SWITCH_GetPath only returns those paths explicitly created by NI_SWITCH_Connect or NI_SWITCH_SetPath. For example, if you connect channels CH1 and CH3, and then channels CH2 and CH3, an explicit path between channels CH1 and CH2 does not exist and an error is returned.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PXI-2569 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Switch functions, Jabil Test while fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\n$path = NI_SWITCH_GetPath($NI_SwitchHandle, $channel1, $channel2, $bufferSize);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_SwitchHandle\n\nObject\n\nA particular NI-SWITCH session established with NI_SWITCH_InitWithTopology, NI_SWITCH_InitializeWithOptions, or NI_SWITCH_Initialize and used for all subsequent NI-SWITCH calls.\n\n\n\n$channel1\n\nString\n\nInput one of the channel names of the desired path. Pass the other channel name as channel2.\n\n\n\n$channel2\n\nString\n\nInput two of the channel names of the desired path. Pass the other channel name as channel1.\n\n\n\n$bufferSize\n\nInteger\n\nPass the number of bytes for the returned path.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$path\n\nString\n\nA string composed of comma-separated paths between channel1 and channel2. The first and last names in the path are the endpoints of the path. All other channels in the path are configuration channels.\n\n\n\n\n\nExample:\n\n$path = NI_SWITCH_GetPath($NI_SwitchHandle, \"ch0\", \"com0\", 256);\n\n\n\n\n\nNI_SWITCH_GetRelayCount\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_SWITCH_GetRelayCount": {
  "prefix": "NI_SWITCH_GetRelayCount",
  "body": [
   "$$relayCount=NI_SWITCH_GetRelayCount($$NI_SwitchHandle,$$relayName);"
  ],
  "description": "\n\nThis function requires NI Switch drivers to be installed on the system.\n\nReturns the number of times the relay has changed from closed to open. Relay count is useful for tracking relay lifetime and usage. Call NI_SWITCH_WaitForDebounce before NI_SWITCH_GetRelayCount to ensure an accurate count.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PXI-2569 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Switch functions, Jabil Test while fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\n$relayCount = NI_SWITCH_GetRelayCount($NI_SwitchHandle, $relayName);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_SwitchHandle\n\nObject\n\nA particular NI-SWITCH session established with NI_SWITCH_InitWithTopology, NI_SWITCH_InitializeWithOptions, or NI_SWITCH_Initialize and used for all subsequent NI-SWITCH calls.\n\n\n\n$relayName\n\nString\n\nName of the relay.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$relayCount\n\nInteger\n\nThe number of relay cycles.\n\n\n\n\n\nExample:\n\n$relayCount = NI_SWITCH_GetRelayCount($NI_SwitchHandle, \"k2\");\n\n\n\n\n\nNI_SWITCH_GetRelayName\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_SWITCH_GetRelayName": {
  "prefix": "NI_SWITCH_GetRelayName",
  "body": [
   "$$relayName=NI_SWITCH_GetRelayName($$NI_SwitchHandle,$$index,$$relayNameBufferSize);"
  ],
  "description": "\n\nThis function requires NI Switch drivers to be installed on the system.\n\nReturns the relay name string that is in the relay list at the specified index.\n\n\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PXI-2569 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Switch functions, Jabil Test while fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\n$relayName = NI_SWITCH_GetRelayName($NI_SwitchHandle, $index, $relayNameBufferSize);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_SwitchHandle\n\nObject\n\nA particular NI-SWITCH session established with NI_SWITCH_InitWithTopology, NI_SWITCH_InitializeWithOptions, or NI_SWITCH_Initialize and used for all subsequent NI-SWITCH calls.\n\n\n\n$index\n\nInteger\n\nA 1-based index into the channel table. The default value is 1.\n\n\n\n$relayNameBufferSize\n\nInteger\n\nPass the number of bytes for the relayNameBuffer parameter.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$relayName\n\nString\n\nReturns the relay name for the index you specify.\n\n\n\n\n\nExample:\n\n$relayName = NI_SWITCH_GetRelayName($NI_SwitchHandle, 3, 256);\n\n\n\n\n\nNI_SWITCH_GetRelayPosition\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_SWITCH_GetRelayPosition": {
  "prefix": "NI_SWITCH_GetRelayPosition",
  "body": [
   "($$relayPosition1,$$relayPosition2)=NI_SWITCH_GetRelayPosition($$NI_SwitchHandle,$$relayName);"
  ],
  "description": "\n\nThis function requires NI Switch drivers to be installed on the system.\n\nReturns the relay position for the relay specified in the relayName parameter.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PXI-2569 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Switch functions, Jabil Test while fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\n($relayPosition1, $relayPosition2) = NI_SWITCH_GetRelayPosition($NI_SwitchHandle, $relayName);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_SwitchHandle\n\nObject\n\nA particular NI-SWITCH session established with NI_SWITCH_InitWithTopology, NI_SWITCH_InitializeWithOptions, or NI_SWITCH_Initialize and used for all subsequent NI-SWITCH calls.\n\n\n\n$relayName\n\nString\n\nName of the relay.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$relayPosition1\n\nInteger\n\nIndicates whether the relay is open or closed\n\n\n\n$relayPosition2\n\nString\n\nIndicates whether the relay is open or closed\n\n\n\n\n\nExample:\n\n($relayPosition1, $relayPosition2) = NI_SWITCH_GetRelayPosition($NI_SwitchHandle, \"k1\");\n\n\n\n\n\nNI_SWITCH_GetRevision\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_SWITCH_GetRevision": {
  "prefix": "NI_SWITCH_GetRevision",
  "body": [
   "($$instrumentDriverRevision,$$firmwareRevision)=NI_SWITCH_GetRevision($$NI_SwitchHandle);"
  ],
  "description": "\n\nThis function requires NI Switch drivers to be installed on the system.\n\nReturns the revision of the NI-SWITCH driver.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PXI-2569 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Switch functions, Jabil Test while fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\n($instrumentDriverRevision, $firmwareRevision) = NI_SWITCH_GetRevision($NI_SwitchHandle);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_SwitchHandle\n\nObject\n\nA particular NI-SWITCH session established with NI_SWITCH_InitWithTopology, NI_SWITCH_InitializeWithOptions, or NI_SWITCH_Initialize and used for all subsequent NI-SWITCH calls.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$instrumentDriverRevision\n\nString\n\nNI-SWITCH software revision numbers in the form of a string.\n\n\n\n$firmwareRevision\n\nString\n\nCurrently unsupported.\n\n\n\n\n\nExample:\n\n($instrumentDriverRevision, $firmwareRevision) = NI_SWITCH_GetRevision($NI_SwitchHandle);\n\n\n\n\n\nNI_SWITCH_Initialize\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_SWITCH_Initialize": {
  "prefix": "NI_SWITCH_Initialize",
  "body": [
   "$$NI_SwitchHandle=NI_SWITCH_Initialize($$resourceName,$$idQuery,$$resetDevice);"
  ],
  "description": "\n\nThis function requires NI Switch drivers to be installed on the system.\n\nReturns a session handle used to identify the switch module in all subsequent instrument driver calls. NI_SWITCH_Initialize creates a new IVI instrument driver session for the switch module specified in the resourceName parameter. If multiple topologies are valid for that device, NI-SWITCH uses the default topology specified in MAX. By default, the switch module is reset to a known state. An error is returned if a session to the specified resource exists in another process. The same session is returned if NI_SWITCH_Initialize is called twice in the same process for the same resource with the same topology.\n\n\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PXI-2569 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Switch functions, Jabil Test while fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\n$NI_SwitchHandle = NI_SWITCH_Initialize($resourceName, $idQuery, $resetDevice);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$resourceName\n\nString\n\nResource name of the switch module to initialize. The resource name is assigned in Measurement & Automation Explorer (MAX).\n\n\n\n$idQuery\n\nBoolean\n\nSpecifies whether the driver performs an ID query. When this parameter is set to \"true\", the driver verifies that the instrument is of a type that this driver supports.\n\n\n\n$resetDevice\n\nBoolean\n\nSpecifies whether to reset the switch module during the initialization process.\n\nPossible values:\n\n\u00b7 True: reset the device.\n\n\u00b7 False: Currently unsupported. The device will not reset.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_SwitchHandle\n\nObject\n\nReturns a handle that you use to identify the instrument in all subsequent instrument driver function calls.\n\n\n\n\n\nExample:\n\n$NI_SwitchHandle = NI_SWITCH_Initialize(\"Dev2\", \"true\", \"true\");\n\n\n\n\n\nNI_SWITCH_InitializeWithOptions\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_SWITCH_InitializeWithOptions": {
  "prefix": "NI_SWITCH_InitializeWithOptions",
  "body": [
   "$$NI_SwitchHandle=NI_SWITCH_InitializeWithOptions($$resourceName,$$idQuery,$$resetDevice,$$optionString);"
  ],
  "description": "\n\nThis function requires NI Switch drivers to be installed on the system.\n\nReturns a session handle used to identify the switch module in all subsequent instrument driver calls and optionally sets the initial state of the session. NI_SWITCH_InitializeWithOptions creates a new IVI instrument driver session for the switch module specified in the resourceName parameter. If multiple topologies are valid for that device, NI-SWITCH uses the default topology specified in MAX. The topology is also configurable in the optionString parameter. By default, the switch module is reset to a known state. Enable simulation in the optionString parameter. An error is returned if a session to the specified resource exists in another process. The same session is returned if NI_SWITCH_InitializeWithOptions is called twice in the same process for the same resource with the same topology.\n\n\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PXI-2569 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Switch functions, Jabil Test while fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\n$NI_SwitchHandle = NI_SWITCH_InitializeWithOptions($resourceName, $idQuery, $resetDevice, $optionString);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$resourceName\n\nString\n\nResource name of the switch module to initialize. The resource name is assigned in Measurement & Automation Explorer (MAX).\n\n\n\n$idQuery\n\nBoolean\n\nSpecifies whether the driver performs an ID query. When this parameter is set to \"true\", the driver verifies that the instrument is of a type that this driver supports.\n\n\n\n$resetDevice\n\nBoolean\n\nSpecifies whether to reset the switch module during the initialization process.\n\nPossible values:\n\n\u00b7 True: reset the device.\n\n\u00b7 False: The device will not reset.\n\n\n\n$optionString\n\nString\n\nSets initial values of certain attributes for the NI-SWITCH session. The format of the optionString is, \"AttributeStringName=Value\" where AttributeStringName is the name of the attribute shown above and Value is the value to which the attribute will be set. To set multiple attributes, separate assignments with a comma. If you pass an empty string for this parameter, the NI-SWITCH session uses the default values for the attributes. You can override the default values by explicitly assigning a value. You do not have to specify all of the available attributes. If you do not specify an attribute, its default value is used.\n\nPossible attribute string names with default value:\n\n\u00b7 RangeCheck : 1\n\n\u00b7 QueryInstrStatus : 1\n\n\u00b7 Cache : 1\n\n\u00b7 Simulate : 0\n\n\u00b7 RecordCoercions : 0\n\n\u00b7 DriverSetup : topology 1127/2-Wire 32x1 Mux\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_SwitchHandle\n\nObject\n\nReturns a handle that you use to identify the instrument in all subsequent instrument driver function calls.\n\n\n\n\n\nExample:\n\n$NI_SwitchHandle = NI_SWITCH_InitializeWithOptions(\"Dev2\", \"true\", \"true\", \"Simulate=1, DriverSetup=topology:1127/2-Wire 32x1 Mux\");\n\n\n\n\n\nNI_SWITCH_InitiateScan\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_SWITCH_InitiateScan": {
  "prefix": "NI_SWITCH_InitiateScan",
  "body": [
   "NI_SWITCH_InitiateScan($$NI_SwitchHandle);"
  ],
  "description": "\n\nThis function requires NI Switch drivers to be installed on the system.\n\nCommits the configured scan list and trigger settings to hardware and initiates the scan. If NI_SWITCH_Commit was called earlier, NI_SWITCH_InitiateScan only initiates the scan and returns immediately.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PXI-2569 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Switch functions, Jabil Test while fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\nNI_SWITCH_InitiateScan($NI_SwitchHandle);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_SwitchHandle\n\nObject\n\nA particular NI-SWITCH session established with NI_SWITCH_InitWithTopology, NI_SWITCH_InitializeWithOptions, or NI_SWITCH_Initialize and used for all subsequent NI-SWITCH calls.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n\n\nExample:\n\nNI_SWITCH_InitiateScan($NI_SwitchHandle);\n\n\n\n\n\nNI_SWITCH_InitializeWithTopology\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_SWITCH_InitializeWithTopology": {
  "prefix": "NI_SWITCH_InitializeWithTopology",
  "body": [
   "$$NI_SwitchHandle=NI_SWITCH_InitializeWithTopology($$resourceName,$$topology,$$simulate,$$resetDevice);"
  ],
  "description": "\n\nThis function requires NI Switch drivers to be installed on the system.\n\nReturns a session handle used to identify the switch module in all subsequent instrument driver calls and sets the topology of the switch module.\n\n\n\nNI_SWITCH_InitializeWithTopology creates a new IVI instrument driver session for the switch module specified in the resourceName parameter. The driver uses the topology specified in the topology parameter and overrides the topology specified in MAX. By default, the switch module is reset to a known state. Enable simulation by specifying the topology and setting the simulate parameter to true;\n\n\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PXI-2569 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Switch functions, Jabil Test while fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\n$NI_SwitchHandle = NI_SWITCH_InitializeWithTopology($resourceName, $topology, $simulate, $resetDevice);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$resourceName\n\nString\n\nResource name of the switch module to initialize. The resource name is assigned in Measurement & Automation Explorer (MAX).\n\n\n\n$topology\n\nString\n\nPass the topology name you want to use for the switch you specify with the resourceName parameter.\n\n\n\n$simulate\n\nBoolean\n\nEnables simulation of the switch module specified in the resourceName parameter.\n\nPossible values:\n\n\u00b7 True: Simulate\n\n\u00b7 False: Do not simulate\n\n\n\n$resetDevice\n\nBoolean\n\nSpecifies whether to reset the switch module during the initialization process.\n\nPossible values:\n\n\u00b7 True: reset the device.\n\n\u00b7 False: The device will not reset.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_SwitchHandle\n\nObject\n\nReturns a handle that you use to identify the instrument in all subsequent instrument driver function calls.\n\n\n\n\n\nExample:\n\n$NI_SwitchHandle = NI_SWITCH_InitializeWithTopology(\"Dev2\", \"100-SPST topology\", \"false\", \"true\");\n\n\n\n\n\nNI_SWITCH_IsDebounced\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_SWITCH_IsDebounced": {
  "prefix": "NI_SWITCH_IsDebounced",
  "body": [
   "$$isDebounced=NI_SWITCH_IsDebounced($$NI_SwitchHandle);"
  ],
  "description": "\n\nThis function requires NI Switch drivers to be installed on the system.\n\nIndicates if all created paths have settled.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PXI-2569 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Switch functions, Jabil Test while fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\n$isDebounced = NI_SWITCH_IsDebounced($NI_SwitchHandle);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_SwitchHandle\n\nObject\n\nA particular NI-SWITCH session established with NI_SWITCH_InitWithTopology, NI_SWITCH_InitializeWithOptions, or NI_SWITCH_Initialize and used for all subsequent NI-SWITCH calls.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$isDebounced\n\nBoolean\n\nTrue indicates that all created paths have settled. False indicates that all created paths have not settled.\n\n\n\n\n\nExample:\n\n$isDebounced = NI_SWITCH_IsDebounced($NI_SwitchHandle);\n\n\n\n\n\nNI_SWITCH_IsScanning\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_SWITCH_IsScanning": {
  "prefix": "NI_SWITCH_IsScanning",
  "body": [
   "$$isScanning=NI_SWITCH_IsScanning($$NI_SwitchHandle);"
  ],
  "description": "\n\nThis function requires NI Switch drivers to be installed on the system.\n\nIndicates the status of the scan.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PXI-2569 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Switch functions, Jabil Test while fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\n$isScanning = NI_SWITCH_IsScanning($NI_SwitchHandle);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_SwitchHandle\n\nObject\n\nA particular NI-SWITCH session established with NI_SWITCH_InitWithTopology, NI_SWITCH_InitializeWithOptions, or NI_SWITCH_Initialize and used for all subsequent NI-SWITCH calls.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$isScanning\n\nBoolean\n\nTrue indicates that the switch is scanning. False indicates that the switch is idle.\n\n\n\n\n\nExample:\n\n$= NI_SWITCH_IsScanning($NI_SwitchHandle);\n\n\n\n\n\nNI_SWITCH_Get\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_SWITCH_OpenAllRelais": {
  "prefix": "NI_SWITCH_OpenAllRelais",
  "body": [
   "NI_SWITCH_OpenAllRelais($$NI_SwitchHandle,$$waitTime);"
  ],
  "description": "\n\nThis function requires NI Switch drivers to be installed on the system.\n\nThe function will open all the relais of associated with the created handle $Handle.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PXI-2569 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Switch functions, Jabil Test while fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\nNI_SWITCH_OpenAllRelais($NI_SwitchHandle, $waitTime);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_SwitchHandle\n\nObject\n\nA particular NI-SWITCH session established with NI_SWITCH_InitWithTopology, NI_SWITCH_InitializeWithOptions, or NI_SWITCH_Initialize and used for all subsequent NI-SWITCH calls.\n\n\n\n$waitTime\n\nInteger\n\nSpecifies the maximum length of time to wait for all relays in the switch module to activate or deactivate. The wait time unit is milliseconds (ms).\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n\n\nExample:\n\nNI_SWITCH_OpenAllRelais($NI_SwitchHandle, 20);\n\n\n\n\n\nNI_SWITCH_OpenMultiRelais\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_SWITCH_OpenMultiRelais": {
  "prefix": "NI_SWITCH_OpenMultiRelais",
  "body": [
   "NI_SWITCH_OpenMultiRelais($$NI_SwitchHandle,$$relayList,$$waitTime);"
  ],
  "description": "\n\nThis function requires NI Switch drivers to be installed on the system.\n\nThis function checks if the relay names exists. If not, the test will fail. Otherwise the relais will be opened. With the parameter waitTime, the function pauses untill all created paths have settled.\n\nRemarks:\n\n\u00b7 This function is tested with a NI PXI-2569 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Switch functions, Jabil Test while fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\nNI_SWITCH_OpenMultiRelais($NI_SwitchHandle, $relayList, $waitTime);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_SwitchHandle\n\nObject\n\nA particular NI-SWITCH session established with NI_SWITCH_InitWithTopology, NI_SWITCH_InitializeWithOptions, or NI_SWITCH_Initialize and used for all subsequent NI-SWITCH calls.\n\n\n\n$relayList\n\nString\n\nA enumeration of all the relais you want to open.\n\n\n\n$waitTime\n\nInteger\n\nSpecifies the maximum length of time to wait for all relays in the switch module to activate or deactivate. The wait time unit is milliseconds (ms).\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n\n\nExample:\n\nNI_SWITCH_OpenMultiRelais($NI_SwitchHandle, \"k20, k1, k2, k3\", 20);\n\n\n\n\n\nNI_SWITCH_RelayControl\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_SWITCH_RelayControl": {
  "prefix": "NI_SWITCH_RelayControl",
  "body": [
   "NI_SWITCH_RelayControl($$NI_SwitchHandle,$$relayName,$$relayAction);"
  ],
  "description": "\n\nThis function requires NI Switch drivers to be installed on the system.\n\nControls individual relays of the switch.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PXI-2569 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Switch functions, Jabil Test while fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\nNI_SWITCH_RelayControl($NI_SwitchHandle, $relayName, $relayAction);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_SwitchHandle\n\nObject\n\nA particular NI-SWITCH session established with NI_SWITCH_InitWithTopology, NI_SWITCH_InitializeWithOptions, or NI_SWITCH_Initialize and used for all subsequent NI-SWITCH calls.\n\n\n\n$relayName\n\nString\n\nName of the relay.\n\n\n\n$relayAction\n\nString\n\nSpecifies whether to open or close a given relay.\n\nPossible values:\n\n\u00b7 Open\n\n\u00b7 Close\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n\n\nExample:\n\nNI_SWITCH_RelayControl($NI_SwitchHandle, \"k1\", \"Open\");\n\n\n\n\n\nNI_SWITCH_Reset\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_SWITCH_Reset": {
  "prefix": "NI_SWITCH_Reset",
  "body": [
   "NI_SWITCH_Reset($$NI_SwitchHandle);"
  ],
  "description": "\n\nThis function requires NI Switch drivers to be installed on the system.\n\nDisconnects all created paths and returns the switch module to the state at initialization. Configuration channel and source channel settings remain unchanged.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PXI-2569 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Switch functions, Jabil Test while fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\nNI_SWITCH_Reset($NI_SwitchHandle);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_SwitchHandle\n\nObject\n\nA particular NI-SWITCH session established with NI_SWITCH_InitWithTopology, NI_SWITCH_InitializeWithOptions, or NI_SWITCH_Initialize and used for all subsequent NI-SWITCH calls.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n\n\nExample:\n\nNI_SWITCH_Reset($NI_SwitchHandle);\n\n\n\n\n\nNI_SWITCH_ResetWithDefaults\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_SWITCH_ResetWithDefaults": {
  "prefix": "NI_SWITCH_ResetWithDefaults",
  "body": [
   "NI_SWITCH_ResetWithDefaults($$NI_SwitchHandle);"
  ],
  "description": "\n\nThis function requires NI Switch drivers to be installed on the system.\n\nResets the switch module and applies initial user specified settings from the logical name used to initialize the session. If the session was created without a logical name, this function is equivalent to NI_SWITCH_Reset.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PXI-2569 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Switch functions, Jabil Test while fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\nNI_SWITCH_ResetWithDefaults($NI_SwitchHandle);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_SwitchHandle\n\nObject\n\nA particular NI-SWITCH session established with NI_SWITCH_InitWithTopology, NI_SWITCH_InitializeWithOptions, or NI_SWITCH_Initialize and used for all subsequent NI-SWITCH calls.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n\n\nExample:\n\nNI_SWITCH_ResetWithDefaults($NI_SwitchHandle);\n\n\n\n\n\nNI_SWITCH_RouteScanAdvancedOutput\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_SWITCH_RouteScanAdvancedOutput": {
  "prefix": "NI_SWITCH_RouteScanAdvancedOutput",
  "body": [
   "NI_SWITCH_RouteScanAdvancedOutput($$NI_SwitchHandle,$$scanAdvancedOutputConnector,$$scanAdvancedOutputBusLine,$$invert);"
  ],
  "description": "\n\nThis function requires NI Switch drivers to be installed on the system.\n\nRoutes the scan advanced output trigger from a trigger bus line (TTLx) to the front or rear connector.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PXI-2569 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Switch functions, Jabil Test while fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\nNI_SWITCH_RouteScanAdvancedOutput($NI_SwitchHandle, $scanAdvancedOutputConnector, $scanAdvancedOutputBusLine, $invert);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_SwitchHandle\n\nObject\n\nA particular NI-SWITCH session established with NI_SWITCH_InitWithTopology, NI_SWITCH_InitializeWithOptions, or NI_SWITCH_Initialize and used for all subsequent NI-SWITCH calls.\n\n\n\n$scanAdvancedOutputConnector\n\nString\n\nThe scan advanced output trigger destination.\n\nPossible values:\n\n\u00b7 FRONT: front connector\n\n\u00b7 REAR: rear connector\n\n\n\n$scanAdvancedOutputBusLine\n\nString\n\nThe trigger line to route the scan advanced output trigger from the front or rear connector.\n\nPossible values:\n\n\u00b7 NONE\n\n\u00b7 TTL0\n\n\u00b7 TTL1\n\n\u00b7 TTL2\n\n\u00b7 TTL3\n\n\u00b7 TTL4\n\n\u00b7 TTL5\n\n\u00b7 TTL6\n\n\u00b7 TTL7\n\n\n\n$invert\n\nBoolean\n\nIf true, inverts the input trigger signal from falling to rising or vice versa.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n\n\nExample:\n\nNI_SWITCH_RouteScanAdvancedOutput($NI_SwitchHandle, \"FRONT\", \"TTL1\", \"true\");\n\n\n\n\n\nNI_SWITCH_RouteTriggerInput\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_SWITCH_RouteTriggerInput": {
  "prefix": "NI_SWITCH_RouteTriggerInput",
  "body": [
   "NI_SWITCH_RouteTriggerInput($$NI_SwitchHandle,$$triggerInputConnector,$$triggerInputBusLine,$$invert);"
  ],
  "description": "\n\nThis function requires NI Switch drivers to be installed on the system.\n\nRoutes the input trigger from the front or rear connector to a trigger bus line (TTLx). To disconnect the route, call this function again and specify None for trigger bus line parameter.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PXI-2569 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Switch functions, Jabil Test while fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\nNI_SWITCH_RouteTriggerInput($NI_SwitchHandle, $triggerInputConnector, $triggerInputBusLine, $invert);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_SwitchHandle\n\nObject\n\nA particular NI-SWITCH session established with NI_SWITCH_InitWithTopology, NI_SWITCH_InitializeWithOptions, or NI_SWITCH_Initialize and used for all subsequent NI-SWITCH calls.\n\n\n\n$triggerInputConnector\n\nString\n\nThe location of the input trigger source on the switch module.\n\nPossible values:\n\n\u00b7 FRONT: front connector\n\n\u00b7 REAR: rear connector\n\n\n\n$triggerInputBusLine\n\nString\n\nThe trigger line to route the input trigger.\n\nPossible values:\n\n\u00b7 NONE\n\n\u00b7 TTL0\n\n\u00b7 TTL1\n\n\u00b7 TTL2\n\n\u00b7 TTL3\n\n\u00b7 TTL4\n\n\u00b7 TTL5\n\n\u00b7 TTL6\n\n\u00b7 TTL7\n\n\n\n$invert\n\nBoolean\n\nIf true, inverts the input trigger signal from falling to rising or vice versa.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n\n\nExample:\n\nNI_SWITCH_RouteTriggerInput($NI_SwitchHandle, \"FRONT\", \"TTL0\", \"false\");\n\n\n\n\n\nNI_SWITCH_Scan\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_SWITCH_Scan": {
  "prefix": "NI_SWITCH_Scan",
  "body": [
   "NI_SWITCH_Scan($$NI_SwitchHandle,$$scanList,$$initiation);"
  ],
  "description": "\n\nThis function requires NI Switch drivers to be installed on the system.\n\nTakes the scan list provided, programs the switching hardware and initiates the scan. Once initiation is complete, the operation will return. The scan list itself is comprised of a list of channel connections separated by semicolons. For example, the following scan list would scan the first three channels of a multiplexer. Example: com0->ch0; com0->ch1; com0->ch2;. Refer to scan lists for additional information. To see the status of the scan, you can call either NI_SWITCH_IsScanning or NI_SWITCH_WaitForScanComplete. Use the NI_SWITCH_ConfigureScanTrigger function to configure the scan trigger. Use the NI_SWITCH_AbortScan function to stop the scan if you are in continuous scan mode (Refer to NI_SWITCH_SetContinuousScan); otherwise the scan halts automatically when the end of the scan list is reached.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PXI-2569 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Switch functions, Jabil Test while fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\nNI_SWITCH_Scan($NI_SwitchHandle, $scanList, $initiation);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_SwitchHandle\n\nObject\n\nA particular NI-SWITCH session established with NI_SWITCH_InitWithTopology, NI_SWITCH_InitializeWithOptions, or NI_SWITCH_Initialize and used for all subsequent NI-SWITCH calls.\n\n\n\n$scanList\n\nString\n\nPass the scan list you want the instrument to use.\n\n\n\n$initiation\n\nString\n\nUse the initiation parameter to specify whether the switch or the measurement device initiates the scan trigger handshake. This parameter determines whether to wait for the scan to reach a trigger point before completing.\n\nPossible values:\n\n\u00b7 MEASUREMENT DEVICE INITIATED: the measurement device initiates the scan. This function then waits until the switch is waiting for a trigger from the measurement device before completing.\n\n\u00b7 SWITCH INITIATED: the switch initiates the scan. This function then completes immediately after initiating the scan.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n\n\nExample:\n\nNI_SWITCH_Scan($NI_SwitchHandle, $scanList, $initiation);\n\n\n\n\n\nNI_SWITCH_SelfTest\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_SWITCH_SelfTest": {
  "prefix": "NI_SWITCH_SelfTest",
  "body": [
   "($$selfTestResult,$$selfTestMessage)=NI_SWITCH_SelfTest($$NI_SwitchHandle);"
  ],
  "description": "\n\nThis function requires NI Switch drivers to be installed on the system.\n\nResets the switch module and applies initial user specified settings from the logical name used to initialize the session. If the session was created without a logical name, this function is equivalent to NI_SWITCH_Reset.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PXI-2569 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Switch functions, Jabil Test while fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\n($selfTestResult, $selfTestMessage) = NI_SWITCH_SelfTest($NI_SwitchHandle);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_SwitchHandle\n\nObject\n\nA particular NI-SWITCH session established with NI_SWITCH_InitWithTopology, NI_SWITCH_InitializeWithOptions, or NI_SWITCH_Initialize and used for all subsequent NI-SWITCH calls.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$selfTestResult\n\nInteger\n\nValue returned from the switch self-test.\n\nPossible values:\n\n\u00b7 0: Passed\n\n\u00b7 1: Failed\n\n\n\n$selfTestMessage\n\nString\n\nSelf-test response string from the switch.\n\n\n\n\n\nExample:\n\n($selfTestResult, $selfTestMessage) = NI_SWITCH_SelfTest($NI_SwitchHandle);\n\n\n\n\n\nNI_SWITCH_SendSoftwareTrigger\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_SWITCH_SendSoftwareTrigger": {
  "prefix": "NI_SWITCH_SendSoftwareTrigger",
  "body": [
   "NI_SWITCH_SendSoftwareTrigger($$NI_SwitchHandle);"
  ],
  "description": "\n\nThis function requires NI Switch drivers to be installed on the system.\n\nSends a software trigger to the switch specified in the NI-SWITCH session. When the trigger input is set to software trigger through the NI_SWITCH_ConfigureScanTrigger function, the scan does not proceed from a semicolon (wait for trigger) until NI_SWITCH_SendSoftwareTrigger is called.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PXI-2569 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Switch functions, Jabil Test while fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\nNI_SWITCH_SendSoftwareTrigger($NI_SwitchHandle);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_SwitchHandle\n\nObject\n\nA particular NI-SWITCH session established with NI_SWITCH_InitWithTopology, NI_SWITCH_InitializeWithOptions, or NI_SWITCH_Initialize and used for all subsequent NI-SWITCH calls.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n\n\nExample:\n\nNI_SWITCH_SendSoftwareTrigger($NI_SwitchHandle);\n\n\n\n\n\nNI_SWITCH_SetContinuousScan\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_SWITCH_SetContinuousScan": {
  "prefix": "NI_SWITCH_SetContinuousScan",
  "body": [
   "NI_SWITCH_SetContinuousScan($$NI_SwitchHandle,$$continuousScan);"
  ],
  "description": "\n\nThis function requires NI Switch drivers to be installed on the system.\n\nSets the to loop continuously through the scan list or to stop scanning after one pass through the scan list.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PXI-2569 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Switch functions, Jabil Test while fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\nNI_SWITCH_SetContinuousScan($NI_SwitchHandle, $continuousScan);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_SwitchHandle\n\nObject\n\nA particular NI-SWITCH session established with NI_SWITCH_InitWithTopology, NI_SWITCH_InitializeWithOptions, or NI_SWITCH_Initialize and used for all subsequent NI-SWITCH calls.\n\n\n\n$continuousScan\n\nBoolean\n\nIf true, loops continuously through the scan list during scanning. If false, the scan stops after one pass through the scan list\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n\n\nExample:\n\nNI_SWITCH_SetContinuousScan($NI_SwitchHandle, \"true\");\n\n\n\n\n\nNI_SWITCH_SetPath\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_SWITCH_SetPath": {
  "prefix": "NI_SWITCH_SetPath",
  "body": [
   "NI_SWITCH_SetPath($$NI_SwitchHandle,$$pathList);"
  ],
  "description": "\n\nThis function requires NI Switch drivers to be installed on the system.\n\nConnects two channels by specifying an explicit path in pathList. NI_SWITCH_SetPath is particularly useful where path repeatability is important, such as in calibrated signal paths. If this is not necessary, use NI_SWITCH_Connect.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PXI-2569 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Switch functions, Jabil Test while fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\nNI_SWITCH_SetPath($NI_SwitchHandle, $pathList);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_SwitchHandle\n\nObject\n\nA particular NI-SWITCH session established with NI_SWITCH_InitWithTopology, NI_SWITCH_InitializeWithOptions, or NI_SWITCH_Initialize and used for all subsequent NI-SWITCH calls.\n\n\n\n$pathList\n\nString\n\nA string composed of comma-separated paths between channel 1 and channel 2. The first and last names in the path are the endpoints of the path. Every other channel in the path are configuration channels.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n\n\nExample:\n\nNI_SWITCH_SetPath($NI_SwitchHandle, \"ch0->com0\");\n\n\n\n\n\nNI_SWITCH_SetRelayPosition\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_SWITCH_SetRelayPosition": {
  "prefix": "NI_SWITCH_SetRelayPosition",
  "body": [
   "NI_SWITCH_SetRelayPosition($$NI_SwitchHandle,$$relayName,$$relayAction,$$waitTime);"
  ],
  "description": "\n\nThis function requires NI Switch drivers to be installed on the system.\n\nControls individual relays of the switch.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PXI-2569 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Switch functions, Jabil Test while fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\nNI_SWITCH_SetRelayPosition($NI_SwitchHandle, $relayName, $relayAction, $waitTime);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_SwitchHandle\n\nObject\n\nA particular NI-SWITCH session established with NI_SWITCH_InitWithTopology, NI_SWITCH_InitializeWithOptions, or NI_SWITCH_Initialize and used for all subsequent NI-SWITCH calls.\n\n\n\n$relayName\n\nString\n\nName of the relay.\n\n\n\n$relayAction\n\nString\n\nSpecifies whether to open or close a given relay.\n\nPossible values:\n\n\u00b7 Open\n\n\u00b7 Close\n\n\n\n$waitTime\n\nInteger\n\nSpecifies the maximum length of time to wait for all relays in the switch module to activate or deactivate. The wait time unit is milliseconds (ms).\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n\n\nExample:\n\nNI_SWITCH_SetRelayPosition($NI_SwitchHandle, \"k1\", \"Open\", 20);\n\n\n\n\n\nNI_SWITCH_WaitForDebounce\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_SWITCH_WaitForDebounce": {
  "prefix": "NI_SWITCH_WaitForDebounce",
  "body": [
   "NI_SWITCH_WaitForDebounce($$NI_SwitchHandle,$$waitTime);"
  ],
  "description": "\n\nThis function requires NI Switch drivers to be installed on the system.\n\nPauses until all created paths have settled.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PXI-2569 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Switch functions, Jabil Test while fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\nNI_SWITCH_WaitForDebounce($NI_SwitchHandle, $waitTime);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_SwitchHandle\n\nObject\n\nA particular NI-SWITCH session established with NI_SWITCH_InitWithTopology, NI_SWITCH_InitializeWithOptions, or NI_SWITCH_Initialize and used for all subsequent NI-SWITCH calls.\n\n\n\n$waitTime\n\nInteger\n\nSpecifies the maximum length of time to wait for all relays in the switch module to activate or deactivate. The wait time unit is milliseconds (ms).\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n\n\nExample:\n\nNI_SWITCH_WaitForDebounce($NI_SwitchHandle, 20);\n\n\n\n\n\nNI_SWITCH_WaitForScanComplete\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_SWITCH_WaitForScanComplete": {
  "prefix": "NI_SWITCH_WaitForScanComplete",
  "body": [
   "NI_SWITCH_WaitForScanComplete($$NI_SwitchHandle,$$maximumTime);"
  ],
  "description": "\n\nThis function requires NI Switch drivers to be installed on the system.\n\nPauses until the switch stops scanning or until the maximum time has elapsed.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a NI PXI-2569 device.\n\n\u00b7 When there occurs an error during the execution of the low level NI-Switch functions, Jabil Test while fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\nNI_SWITCH_WaitForScanComplete($NI_SwitchHandle, $maximumTime);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NI_SwitchHandle\n\nObject\n\nA particular NI-SWITCH session established with NI_SWITCH_InitWithTopology, NI_SWITCH_InitializeWithOptions, or NI_SWITCH_Initialize and used for all subsequent NI-SWITCH calls.\n\n\n\n$maximumTime\n\nInteger\n\nSpecifies the maximum length of time to wait for the switch module to stop scanning.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n\n\nExample:\n\nNI_SWITCH_WaitForScanComplete($NI_SwitchHandle, 20);\n\n\n\n\n\nSMX_SWITCH_Abort\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SMX_SWITCH_Abort": {
  "prefix": "SMX_SWITCH_Abort",
  "body": [
   "SMX_SWITCH_Abort($$ResourceNumber);"
  ],
  "description": "\n\nThis function requires SMX4032 drivers to be installed on the system.\n\nAborts the current operation and prepares the scanner to accept new commands.\n\nInitiate a scan with SMX_SWITCH_AutoScan.\n\n\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a SMX4032 device.\n\n\u00b7 When there occurs an error during the execution of the low level SMX-Switch functions, Jabil Test while fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\nSMX_SWITCH_Abort($ResourceNumber);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ResourceNumber\n\nInteger\n\nThe number of the SMX4032 device to be used. (i.e. Device 0, 1, etc.)\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n\n\nExample:\n\nSMX_SWITCH_Abort($ResourceNumber);\n\n\n\n\n\nSMX_SWITCH_AutoScan\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SMX_SWITCH_AutoScan": {
  "prefix": "SMX_SWITCH_AutoScan",
  "body": [
   "SMX_SWITCH_AutoScan($$ResourceNumber);"
  ],
  "description": "\n\nThis function requires SMX4032 drivers to be installed on the system.\n\nScans iPoints of the ScanList. Steptime and Acutation time must be set prior to this call.\n\n\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a SMX4032 device.\n\n\u00b7 When there occurs an error during the execution of the low level SMX-Switch functions, Jabil Test while fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\nSMX_SWITCH_AutoScan($ResourceNumber,$iPoints);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ResourceNumber\n\nInteger\n\nThe number of the SMX4032 device to be used. (i.e. Device 0, 1, etc.)\n\n\n\n$iPoints\n\nInteger\n\nThe number of points in the scan. The number must be between 1 and 192, inclusive.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n\n\nExample:\n\nSMX_SWITCH_AutoScan($ResourceNumber,$iPoints);\n\n\n\n\n\nSMX_SWITCH_CleanRelays\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SMX_SWITCH_CleanRelays": {
  "prefix": "SMX_SWITCH_CleanRelays",
  "body": [
   "SMX_SWITCH_CleanRelays($$ResourceNumber);"
  ],
  "description": "\n\nThis function requires SMX4032 drivers to be installed on the system.\n\nCleans all Relays.\n\n\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a SMX4032 device.\n\n\u00b7 When there occurs an error during the execution of the low level SMX-Switch functions, Jabil Test while fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\nSMX_SWITCH_CleanRelays($ResourceNumber);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ResourceNumber\n\nInteger\n\nThe number of the SMX4032 device to be used. (i.e. Device 0, 1, etc.)\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n\n\nExample:\n\nSMX_SWITCH_CleanRelays($ResourceNumber);\n\n\n\n\n\nSMX_SWITCH_Delay\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SMX_SWITCH_Delay": {
  "prefix": "SMX_SWITCH_Delay",
  "body": [
   "SMX_SWITCH_Delay($$dTime);"
  ],
  "description": "\n\nThis function requires SMX4032 drivers to be installed on the system.\n\nWaits for the delay of dTime in seconds.\n\n\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a SMX4032 device.\n\n\u00b7 When there occurs an error during the execution of the low level SMX-Switch functions, Jabil Test while fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\nSMX_SWITCH_Delay($dTime);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$dTime\n\nFloat\n\nThe number of seconds to wait.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n\n\nExample:\n\nSMX_SWITCH_Delay($dTime);\n\n\n\n\n\nSMX_SWITCH_GetActuationTime\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SMX_SWITCH_GetActuationTime": {
  "prefix": "SMX_SWITCH_GetActuationTime",
  "body": [
   "$$ActuationTime=SMX_SWITCH_GetActuationTime($$ResourceNumber);"
  ],
  "description": "\n\nThis function requires SMX4032 drivers to be installed on the system.\n\nReads the currently set actuation time.\n\n\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a SMX4032 device.\n\n\u00b7 When there occurs an error during the execution of the low level SMX-Switch functions, Jabil Test while fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\n$ActuationTime = SMX_SWITCH_GetActuationTime($ResourceNumber);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ResourceNumber\n\nInteger\n\nThe number of the SMX4032 device to be used. (i.e. Device 0, 1, etc.)\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ActuationTime\n\nFloat\n\nThe currently set relay actuation time.\n\n\n\n\n\nExample:\n\n$ActuationTime = SMX_SWITCH_GetActuationTime($ResourceNumber);\n\n\n\n\n\nSMX_SWITCH_GetBusInfo\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SMX_SWITCH_GetBusInfo": {
  "prefix": "SMX_SWITCH_GetBusInfo",
  "body": [
   "($$Bus,$$Slot)=SMX_SWITCH_GetBusInfo($$ResourceNumber);"
  ],
  "description": "\n\nThis function requires SMX4032 drivers to be installed on the system.\n\nGets the PCI bus and slot number for the scanner.\n\n\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a SMX4032 device.\n\n\u00b7 When there occurs an error during the execution of the low level SMX-Switch functions, Jabil Test while fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\n($Bus, $Slot) = SMX_SWITCH_GetBusInfo($ResourceNumber);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ResourceNumber\n\nInteger\n\nThe number of the SMX4032 device to be used. (i.e. Device 0, 1, etc.)\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Bus\n\nInteger\n\nPCI Bus number for the scanner.\n\n\n\n$Slot\n\nInteger\n\nPCI slot number for the scanner.\n\n\n\n\n\nExample:\n\n($Bus, $Slot) = SMX_SWITCH_GetBusInfo($ResourceNumber);\n\n\n\n\n\nSMX_SWITCH_GetConfig\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SMX_SWITCH_GetConfig": {
  "prefix": "SMX_SWITCH_GetConfig",
  "body": [
   "($$ConfigCode)=SMX_SWITCH_GetConfig($$ResourceNumber);"
  ],
  "description": "\n\nThis function requires SMX4032 drivers to be installed on the system.\n\nGets the configuration code for the selected scanner.\n\n\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a SMX4032 device.\n\n\u00b7 When there occurs an error during the execution of the low level SMX-Switch functions, Jabil Test while fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\n($ConfigCode) = SMX_SWITCH_GetConfig($ResourceNumber);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ResourceNumber\n\nInteger\n\nThe number of the SMX4032 device to be used. (i.e. Device 0, 1, etc.)\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ConfigCode\n\nInteger\n\nThe configuration code for the scanner.\n\n\n\n\n\nExample:\n\n($ConfigCode) = SMX_SWITCH_GetConfig($ResourceNumber);\n\n\n\n\n\nSMX_SWITCH_GetGrdVer\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SMX_SWITCH_GetGrdVer": {
  "prefix": "SMX_SWITCH_GetGrdVer",
  "body": [
   "($$FirmwareVersion)=SMX_SWITCH_GetGrdVer($$ResourceNumber);"
  ],
  "description": "\n\nThis function requires SMX4032 drivers to be installed on the system.\n\nGets the scanner firmware version.\n\n\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a SMX4032 device.\n\n\u00b7 When there occurs an error during the execution of the low level SMX-Switch functions, Jabil Test while fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\n($FirmwareVersion) = SMX_SWITCH_GetGrdVer($ResourceNumber);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ResourceNumber\n\nInteger\n\nThe number of the SMX4032 device to be used. (i.e. Device 0, 1, etc.)\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$FirmwareVersion\n\nInteger\n\nThe firmware version for the scanner.\n\n\n\n\n\nExample:\n\n($FirmwareVersion) = SMX_SWITCH_GetGrdVer($ResourceNumber);\n\n\n\n\n\nSMX_SWITCH_GetHWVer\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SMX_SWITCH_GetHWVer": {
  "prefix": "SMX_SWITCH_GetHWVer",
  "body": [
   "($$HardwareRevision)=SMX_SWITCH_GetHWVer($$ResourceNumber);"
  ],
  "description": "\n\nThis function requires SMX4032 drivers to be installed on the system.\n\nGets the hardware version of the selected scanner.\n\n\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a SMX4032 device.\n\n\u00b7 When there occurs an error during the execution of the low level SMX-Switch functions, Jabil Test while fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\n($HardwareRevision) = SMX_SWITCH_GetHWVer($ResourceNumber);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ResourceNumber\n\nInteger\n\nThe number of the SMX4032 device to be used. (i.e. Device 0, 1, etc.)\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$HardwareRevision\n\nInteger\n\nThe hardware version for the scanner.\n\n\n\n\n\nExample:\n\n($HardwareRevision) = SMX_SWITCH_GetHWVer($ResourceNumber);\n\n\n\n\n\nSMX_SWITCH_GetID\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SMX_SWITCH_GetID": {
  "prefix": "SMX_SWITCH_GetID",
  "body": [
   "($$ID)=SMX_SWITCH_GetID($$ResourceNumber);"
  ],
  "description": "\n\nThis function requires SMX4032 drivers to be installed on the system.\n\nGets the identification code for the selected scanner.\n\n\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a SMX4032 device.\n\n\u00b7 When there occurs an error during the execution of the low level SMX-Switch functions, Jabil Test while fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\n($ID) = SMX_SWITCH_GetID($ResourceNumber);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ResourceNumber\n\nInteger\n\nThe number of the SMX4032 device to be used. (i.e. Device 0, 1, etc.)\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ID\n\nInteger\n\nThe unique ID code for the scanner.\n\n\n\n\n\nExample:\n\n($ID) = SMX_SWITCH_GetID($ResourceNumber);\n\n\n\n\n\nSMX_SWITCH_GetManDate\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SMX_SWITCH_GetManDate": {
  "prefix": "SMX_SWITCH_GetManDate",
  "body": [
   "($$Month,$$Day,$$Year)=SMX_SWITCH_GetManDate($$ResourceNumber);"
  ],
  "description": "\n\nThis function requires SMX4032 drivers to be installed on the system.\n\nGets the Manufacturing Date for the selected scanner.\n\n\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a SMX4032 device.\n\n\u00b7 When there occurs an error during the execution of the low level SMX-Switch functions, Jabil Test while fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\n($Month,$Day,$Year) = SMX_SWITCH_GetManDate($ResourceNumber);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ResourceNumber\n\nInteger\n\nThe number of the SMX4032 device to be used. (i.e. Device 0, 1, etc.)\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Month\n\nInteger\n\nThe Month of manufacture.\n\n\n\n$Day\n\nInteger\n\nThe Day of manufacture.\n\n\n\n$Year\n\nInteger\n\nThe Year of manufacture.\n\n\n\n\n\nExample:\n\n($Month,$Day,$Year) = SMX_SWITCH_GetManDate($ResourceNumber);\n\n\n\n\n\nSMX_SWITCH_GetScanList\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SMX_SWITCH_GetScanList": {
  "prefix": "SMX_SWITCH_GetScanList",
  "body": [
   "($$Address)=SMX_SWITCH_GetScanList($$ResourceNumber);"
  ],
  "description": "\n\nThis function requires SMX4032 drivers to be installed on the system.\n\nGets the address of the on board scan list selected scanner.\n\n\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a SMX4032 device.\n\n\u00b7 When there occurs an error during the execution of the low level SMX-Switch functions, Jabil Test while fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\n($Address) = SMX_SWITCH_GetScanList($ResourceNumber);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ResourceNumber\n\nInteger\n\nThe number of the SMX4032 device to be used. (i.e. Device 0, 1, etc.)\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Address\n\nInteger\n\nThe Address of the on board scan list.\n\n\n\n\n\nExample:\n\n($Address) = SMX_SWITCH_GetScanList($ResourceNumber);\n\n\n\n\n\nSMX_SWITCH_GetShortedChannel\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SMX_SWITCH_GetShortedChannel": {
  "prefix": "SMX_SWITCH_GetShortedChannel",
  "body": [
   "($$Shorted)=SMX_SWITCH_GetShortedChannel($$ResourceNumber);"
  ],
  "description": "\n\nThis function requires SMX4032 drivers to be installed on the system.\n\nGets the first shorted channel.\n\n\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a SMX4032 device.\n\n\u00b7 When there occurs an error during the execution of the low level SMX-Switch functions, Jabil Test while fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\n($Shorted) = SMX_SWITCH_GetShortedChannel($ResourceNumber);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ResourceNumber\n\nInteger\n\nThe number of the SMX4032 device to be used. (i.e. Device 0, 1, etc.)\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Shorted\n\nInteger\n\nThe first currently shorted channel.\n\n\n\n\n\nExample:\n\n($Shorted) = SMX_SWITCH_GetShortedChannel($ResourceNumber);\n\n\n\n\n\nSMX_SWITCH_GetStepTime\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SMX_SWITCH_GetStepTime": {
  "prefix": "SMX_SWITCH_GetStepTime",
  "body": [
   "($$StepTime)=SMX_SWITCH_GetStepTime($$ResourceNumber);"
  ],
  "description": "\n\nThis function requires SMX4032 drivers to be installed on the system.\n\nGets the currently set step time.\n\n\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a SMX4032 device.\n\n\u00b7 When there occurs an error during the execution of the low level SMX-Switch functions, Jabil Test while fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\n($StepTime) = SMX_SWITCH_GetStepTime($ResourceNumber);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ResourceNumber\n\nInteger\n\nThe number of the SMX4032 device to be used. (i.e. Device 0, 1, etc.)\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$StepTime\n\nFloat\n\nThe currently set Step Time.\n\n\n\n\n\nExample:\n\n($StepTime) = SMX_SWITCH_GetStepTime($ResourceNumber);\n\n\n\n\n\nSMX_SWITCH_GetTriggerIn\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SMX_SWITCH_GetTriggerIn": {
  "prefix": "SMX_SWITCH_GetTriggerIn",
  "body": [
   "($$State)=SMX_SWITCH_GetTriggerIn($$ResourceNumber);"
  ],
  "description": "\n\nThis function requires SMX4032 drivers to be installed on the system.\n\nGets the logic state of the Hardware Trigger Input line of the scanner.\n\n\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a SMX4032 device.\n\n\u00b7 When there occurs an error during the execution of the low level SMX-Switch functions, Jabil Test while fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\n($State) = SMX_SWITCH_GetTriggerIn($ResourceNumber);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ResourceNumber\n\nInteger\n\nThe number of the SMX4032 device to be used. (i.e. Device 0, 1, etc.)\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$State\n\nInteger\n\nThe logic state of the Hardware Trigger.\n\n\n\n\n\nExample:\n\n($State) = SMX_SWITCH_GetTriggerIn($ResourceNumber);\n\n\n\n\n\nSMX_SWITCH_GetType\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SMX_SWITCH_GetType": {
  "prefix": "SMX_SWITCH_GetType",
  "body": [
   "($$State)=SMX_SWITCH_GetType($$ResourceNumber);"
  ],
  "description": "\n\nThis function requires SMX4032 drivers to be installed on the system.\n\nGets the logic state of the Hardware Trigger Input line of the scanner.\n\n\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a SMX4032 device.\n\n\u00b7 When there occurs an error during the execution of the low level SMX-Switch functions, Jabil Test while fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\n($State) = SMX_SWITCH_GetType($ResourceNumber);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ResourceNumber\n\nInteger\n\nThe number of the SMX4032 device to be used. (i.e. Device 0, 1, etc.)\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$State\n\nInteger\n\nThe logic state of the Hardware Trigger.\n\n\n\n\n\nExample:\n\n($State) = SMX_SWITCH_GetType($ResourceNumber);\n\n\n\n\n\nSMX_SWITCH_GetVer\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SMX_SWITCH_GetVer": {
  "prefix": "SMX_SWITCH_GetVer",
  "body": [
   "($$DLLVersion)=SMX_SWITCH_GetVer($$ResourceNumber);"
  ],
  "description": "\n\nThis function requires SMX4032 drivers to be installed on the system.\n\nReturns the scanner's DLL software driver version.\n\n\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a SMX4032 device.\n\n\u00b7 When there occurs an error during the execution of the low level SMX-Switch functions, Jabil Test while fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\n($DLLVersion) = SMX_SWITCH_GetVer($ResourceNumber);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ResourceNumber\n\nInteger\n\nThe number of the SMX4032 device to be used. (i.e. Device 0, 1, etc.)\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$DLLVersion\n\nInteger\n\nThe DLL Version of the Scanner'd driver.\n\n\n\n\n\nExample:\n\n($DLLVersion) = SMX_SWITCH_GetVer($ResourceNumber);\n\n\n\n\n\nSMX_SWITCH_Init\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SMX_SWITCH_Init": {
  "prefix": "SMX_SWITCH_Init",
  "body": [
   "($$State)=SMX_SWITCH_Init($$ResourceNumber);"
  ],
  "description": "\n\nThis function requires SMX4032 drivers to be installed on the system.\n\nInitializes the scanner.\n\n\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a SMX4032 device.\n\n\u00b7 When there occurs an error during the execution of the low level SMX-Switch functions, Jabil Test while fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\n($State) = SMX_SWITCH_Init($ResourceNumber);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ResourceNumber\n\nInteger\n\nThe number of the SMX4032 device to be used. (i.e. Device 0, 1, etc.)\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$State\n\nInteger\n\nThe logic state of the Hardware Trigger.\n\n\n\n\n\nExample:\n\n($State) = SMX_SWITCH_Init($ResourceNumber);\n\n\n\n\n\nSMX_SWITCH_IsInitialized\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SMX_SWITCH_IsInitialized": {
  "prefix": "SMX_SWITCH_IsInitialized",
  "body": [
   "($$State)=SMX_SWITCH_IsInitialized($$ResourceNumber);"
  ],
  "description": "\n\nThis function requires SMX4032 drivers to be installed on the system.\n\nReturns the active state of the scanner.\n\n\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a SMX4032 device.\n\n\u00b7 When there occurs an error during the execution of the low level SMX-Switch functions, Jabil Test while fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\n($State) = SMX_SWITCH_IsInitialized($ResourceNumber);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ResourceNumber\n\nInteger\n\nThe number of the SMX4032 device to be used. (i.e. Device 0, 1, etc.)\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$State\n\nBoolean\n\nWhether or not the scanner is initialized.\n\n\n\n\n\nExample:\n\n($State) = SMX_SWITCH_IsInitialized($ResourceNumber);\n\n\n\n\n\nSMX_SWITCH_OpenAllChannels\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SMX_SWITCH_OpendAllChannels": {
  "prefix": "SMX_SWITCH_OpendAllChannels",
  "body": [
   "($$State)=SMX_SWITCH_OpendAllChannels($$ResourceNumber);"
  ],
  "description": "\n\nThis function requires SMX4032 drivers to be installed on the system.\n\nOpens all channel relays.\n\n\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a SMX4032 device.\n\n\u00b7 When there occurs an error during the execution of the low level SMX-Switch functions, Jabil Test while fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\n($State) = SMX_SWITCH_OpendAllChannels($ResourceNumber);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ResourceNumber\n\nInteger\n\nThe number of the SMX4032 device to be used. (i.e. Device 0, 1, etc.)\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$State\n\nInteger\n\nWhether or not the operation was successful. Negative value indicates failure. A zero value indicates success.\n\n\n\n\n\nExample:\n\n($State) = SMX_SWITCH_OpendAllChannels($ResourceNumber);\n\n\n\n\n\nSMX_SWITCH_Ready\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SMX_SWITCH_Ready": {
  "prefix": "SMX_SWITCH_Ready",
  "body": [
   "($$State)=SMX_SWITCH_Ready($$ResourceNumber);"
  ],
  "description": "\n\nThis function requires SMX4032 drivers to be installed on the system.\n\nWhether or not the scanner is done and ready to accept new commands.\n\n\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a SMX4032 device.\n\n\u00b7 When there occurs an error during the execution of the low level SMX-Switch functions, Jabil Test while fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\n($State) = SMX_SWITCH_Ready($ResourceNumber);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ResourceNumber\n\nInteger\n\nThe number of the SMX4032 device to be used. (i.e. Device 0, 1, etc.)\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$State\n\nBoolean\n\nWhether or not the scanner is done and ready to accept new commands.\n\n\n\n\n\nExample:\n\n($State) = SMX_SWITCH_Ready($ResourceNumber);\n\n\n\n\n\nSMX_SWITCH_SelectChannel\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SMX_SWITCH_SelectChannel": {
  "prefix": "SMX_SWITCH_SelectChannel",
  "body": [
   "($$State)=SMX_SWITCH_SelectChannel($$ResourceNumber,$$Channel);"
  ],
  "description": "\n\nThis function requires SMX4032 drivers to be installed on the system.\n\nOpens and closes relays based on the current channel configuration. (TwoWire, FourWire, etc.)\n\n\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a SMX4032 device.\n\n\u00b7 When there occurs an error during the execution of the low level SMX-Switch functions, Jabil Test while fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\n($State) = SMX_SWITCH_SelectChannel($ResourceNumber,$Channel);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ResourceNumber\n\nInteger\n\nThe number of the SMX4032 device to be used. (i.e. Device 0, 1, etc.)\n\n\n\n$Channel\n\nInteger\n\nInteger value based on the scanner config.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$State\n\nInteger\n\nWhether or not the operation was successful. Negative value indicates failure. A zero value indicates success.\n\n\n\n\n\nExample:\n\n($State) = SMX_SWITCH_SelectChannel($ResourceNumber,$Channel);\n\n\n\n\n\nSMX_SWITCH_SelectChannelCMD\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SMX_SWITCH_SelectChannelCMD": {
  "prefix": "SMX_SWITCH_SelectChannelCMD",
  "body": [
   "($$State)=SMX_SWITCH_SelectChannelCMD($$ResourceNumber,$$Channel);"
  ],
  "description": "\n\nThis function requires SMX4032 drivers to be installed on the system.\n\nThis is the polled version of the SelectChannel command.\n\n\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a SMX4032 device.\n\n\u00b7 When there occurs an error during the execution of the low level SMX-Switch functions, Jabil Test while fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\n($State) = SMX_SWITCH_SelectChannelCMD($ResourceNumber,$Channel);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ResourceNumber\n\nInteger\n\nThe number of the SMX4032 device to be used. (i.e. Device 0, 1, etc.)\n\n\n\n$Channel\n\nInteger\n\nInteger value based on the scanner config.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$State\n\nInteger\n\nWhether or not the operation was successful. Negative value indicates failure. A zero value indicates success.\n\n\n\n\n\nExample:\n\n($State) = SMX_SWITCH_SelectChannelCMD($ResourceNumber,$Channel);\n\n\n\n\n\nSMX_SWITCH_SetActuationTime\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SMX_SWITCH_SetActuationTime": {
  "prefix": "SMX_SWITCH_SetActuationTime",
  "body": [
   "($$State)=SMX_SWITCH_SetActuationTime($$ResourceNumber,$$dActuate);"
  ],
  "description": "\n\nThis function requires SMX4032 drivers to be installed on the system.\n\nThis is the polled version of the SelectChannel command.\n\n\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a SMX4032 device.\n\n\u00b7 When there occurs an error during the execution of the low level SMX-Switch functions, Jabil Test while fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\n($State) = SMX_SWITCH_SetActuationTime($ResourceNumber,$Channel);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ResourceNumber\n\nInteger\n\nThe number of the SMX4032 device to be used. (i.e. Device 0, 1, etc.)\n\n\n\n$dActuate\n\nDouble\n\nActuation time from 0.25ms to 800ms\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$State\n\nInteger\n\nWhether or not the operation was successful. Negative value indicates failure. A zero value indicates success.\n\n\n\n\n\nExample:\n\n($State) = SMX_SWITCH_SetActuationTime($ResourceNumber,$Channel);\n\n\n\n\n\nSMX_SWITCH_SetChannelRelay\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SMX_SWITCH_SetChannelRelay": {
  "prefix": "SMX_SWITCH_SetChannelRelay",
  "body": [
   "($$State)=SMX_SWITCH_SetChannelRelay($$ResourceNumber,$$RelayState,$$Channel);"
  ],
  "description": "\n\nThis function requires SMX4032 drivers to be installed on the system.\n\nClose or Open a channel relay.\n\n\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a SMX4032 device.\n\n\u00b7 When there occurs an error during the execution of the low level SMX-Switch functions, Jabil Test while fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\n($State) = SMX_SWITCH_SetChannelRelay($ResourceNumber,$RelayState,$Channel);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ResourceNumber\n\nInteger\n\nThe number of the SMX4032 device to be used. (i.e. Device 0, 1, etc.)\n\n\n\n$RelayState\n\nString\n\nOpen or Closed.\n\n\n\n$Channel\n\nInteger\n\nChannel number range (1 to 35) depending on the configuration.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$State\n\nInteger\n\nWhether or not the operation was successful. Negative value indicates failure. A zero value indicates success.\n\n\n\n\n\nExample:\n\n($State) = SMX_SWITCH_SetChannelRelay($ResourceNumber,$RelayState,$Channel);\n\n\n\n\n\nSMX_SWITCH_SetConfig\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SMX_SWITCH_SetConfig": {
  "prefix": "SMX_SWITCH_SetConfig",
  "body": [
   "($$State)=SMX_SWITCH_SetConfig($$ResourceNumber,$$Configuration);"
  ],
  "description": "\n\nThis function requires SMX4032 drivers to be installed on the system.\n\nSets the scanner configuration to one of the predefined modes. (TwoWire, FourWire, etc.)\n\n\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a SMX4032 device.\n\n\u00b7 When there occurs an error during the execution of the low level SMX-Switch functions, Jabil Test while fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\n($State) = SMX_SWITCH_SetConfig($ResourceNumber,$Configuration);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ResourceNumber\n\nInteger\n\nThe number of the SMX4032 device to be used. (i.e. Device 0, 1, etc.)\n\n\n\n$Configuration\n\nInteger\n\nTwoWire, FourWire, SixWire, TwoGroups, Universal, ColdJuction, or Disabled.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$State\n\nInteger\n\nWhether or not the operation was successful. Negative value indicates failure. A zero value indicates success.\n\n\n\n\n\nExample:\n\n($State) = SMX_SWITCH_SetConfig($ResourceNumber,$Configuration);\n\n\n\n\n\nSMX_SWITCH_SetConfigRelay\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SMX_SWITCH_SetConfigRelay": {
  "prefix": "SMX_SWITCH_SetConfigRelay",
  "body": [
   "($$State)=SMX_SWITCH_SetConfigRelay($$ResourceNumber,$$RelayState,$$Relay);"
  ],
  "description": "\n\nThis function requires SMX4032 drivers to be installed on the system.\n\nSets one of the configuration relays.\n\n\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a SMX4032 device.\n\n\u00b7 When there occurs an error during the execution of the low level SMX-Switch functions, Jabil Test while fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\n($State) = SMX_SWITCH_SetConfigRelay($ResourceNumber,$RelayState,$Relay);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ResourceNumber\n\nInteger\n\nThe number of the SMX4032 device to be used. (i.e. Device 0, 1, etc.)\n\n\n\n$RelayState\n\nString\n\nOpen or Closed.\n\n\n\n$Relay\n\nInteger\n\nRelay Tree - AtoA, BtoA, BtoB, CtoA, CtoC, DtoD, DtoC.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$State\n\nInteger\n\nWhether or not the operation was successful. Negative value indicates failure. A zero value indicates success.\n\n\n\n\n\nExample:\n\n($State) = SMX_SWITCH_SetConfigRelay($ResourceNumber,$RelayState,$Relay);\n\n\n\n\n\nSMX_SWITCH_SetScanList\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SMX_SWITCH_SetScanList": {
  "prefix": "SMX_SWITCH_SetScanList",
  "body": [
   "($$State)=SMX_SWITCH_SetScanList($$ResourceNumber,$$Address,$$Channel);"
  ],
  "description": "\n\nThis function requires SMX4032 drivers to be installed on the system.\n\nSet a single scan list entry.\n\n\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a SMX4032 device.\n\n\u00b7 When there occurs an error during the execution of the low level SMX-Switch functions, Jabil Test while fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\n($State) = SMX_SWITCH_SetScanList($ResourceNumber,$Address,$Relay);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ResourceNumber\n\nInteger\n\nThe number of the SMX4032 device to be used. (i.e. Device 0, 1, etc.)\n\n\n\n$Address\n\nString\n\nThe Address to write to (a value between 0 and 191).\n\n\n\n$Channel\n\nInteger\n\nThe Channel number (a value between 0 and 32).\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$State\n\nInteger\n\nWhether or not the operation was successful. Negative value indicates failure. A zero value indicates success.\n\n\n\n\n\nExample:\n\n($State) = SMX_SWITCH_SetScanList($ResourceNumber,$Address,$Channel);\n\n\n\n\n\nSMX_SWITCH_SetStepTime\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SMX_SWITCH_SetStepTime": {
  "prefix": "SMX_SWITCH_SetStepTime",
  "body": [
   "($$State)=SMX_SWITCH_SetStepTime($$ResourceNumber,$$Step);"
  ],
  "description": "\n\nThis function requires SMX4032 drivers to be installed on the system.\n\nSet auto scan step time.\n\n\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a SMX4032 device.\n\n\u00b7 When there occurs an error during the execution of the low level SMX-Switch functions, Jabil Test while fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\n($State) = SMX_SWITCH_SetStepTime($ResourceNumber,$Step);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ResourceNumber\n\nInteger\n\nThe number of the SMX4032 device to be used. (i.e. Device 0, 1, etc.)\n\n\n\n$Step\n\nDouble\n\nDefault step time is 100ms. The allowed range is from 1 ms to 850 ms. The resolution is 0.25ms.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$State\n\nInteger\n\nWhether or not the operation was successful. Negative value indicates failure. A zero value indicates success.\n\n\n\n\n\nExample:\n\n($State) = SMX_SWITCH_SetStepTime($ResourceNumber,$Step);\n\n\n\n\n\nSMX_SWITCH_SetTriggerOut\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SMX_SWITCH_SetTriggerOut": {
  "prefix": "SMX_SWITCH_SetTriggerOut",
  "body": [
   "($$State)=SMX_SWITCH_SetTriggerOut($$ResourceNumber,$$Level);"
  ],
  "description": "\n\nThis function requires SMX4032 drivers to be installed on the system.\n\nSet the scanner trigger output level.\n\n\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a SMX4032 device.\n\n\u00b7 When there occurs an error during the execution of the low level SMX-Switch functions, Jabil Test while fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\n($State) = SMX_SWITCH_SetTriggerOut($ResourceNumber,$Step);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ResourceNumber\n\nInteger\n\nThe number of the SMX4032 device to be used. (i.e. Device 0, 1, etc.)\n\n\n\n$Level\n\nString\n\nLevel may be \"LOW\" or \"HIGH.\"\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$State\n\nInteger\n\nWhether or not the operation was successful. Negative value indicates failure. A zero value indicates success.\n\n\n\n\n\nExample:\n\n($State) = SMX_SWITCH_SetTriggerOut($ResourceNumber,$Level);\n\n\n\n\n\nSMX_SWITCH_SetupStep\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SMX_SWITCH_SetupStep": {
  "prefix": "SMX_SWITCH_SetupStep",
  "body": [
   "($$State)=SMX_SWITCH_SetupStep($$ResourceNumber);"
  ],
  "description": "\n\nThis function requires SMX4032 drivers to be installed on the system.\n\nStep to the next channel in the scan list.\n\n\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a SMX4032 device.\n\n\u00b7 When there occurs an error during the execution of the low level SMX-Switch functions, Jabil Test while fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\n($State) = SMX_SWITCH_SetupStep($ResourceNumber);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ResourceNumber\n\nInteger\n\nThe number of the SMX4032 device to be used. (i.e. Device 0, 1, etc.)\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$State\n\nBoolean\n\nWhether or not the scanner is done and ready to accept new commands.\n\n\n\n\n\nExample:\n\n($State) = SMX_SWITCH_SetupStep($ResourceNumber);\n\n\n\n\n\nSMX_SWITCH_StepCMD\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SMX_SWITCH_SetupStepCMD": {
  "prefix": "SMX_SWITCH_SetupStepCMD",
  "body": [
   "($$State)=SMX_SWITCH_SetupStepCMD($$ResourceNumber);"
  ],
  "description": "\n\nThis function requires SMX4032 drivers to be installed on the system.\n\nStep to the next channel in the scan list. This is the polled version of the SMX_SWITCH_Step command.\n\n\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a SMX4032 device.\n\n\u00b7 When there occurs an error during the execution of the low level SMX-Switch functions, Jabil Test while fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\n($State) = SMX_SWITCH_SetupStepCMD($ResourceNumber);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ResourceNumber\n\nInteger\n\nThe number of the SMX4032 device to be used. (i.e. Device 0, 1, etc.)\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$State\n\nBoolean\n\nWhether or not the scanner is done and ready to accept new commands.\n\n\n\n\n\nExample:\n\n($State) = SMX_SWITCH_SetupStepCMD($ResourceNumber);\n\n\n\n\n\nSMX_SWITCH_Terminate\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SMX_SWITCH_Terminate": {
  "prefix": "SMX_SWITCH_Terminate",
  "body": [
   "($$State)=SMX_SWITCH_Terminate($$ResourceNumber);"
  ],
  "description": "\n\nThis function requires SMX4032 drivers to be installed on the system.\n\nTerminates scanner's operation, and removes it from PCI configuration.\n\n\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a SMX4032 device.\n\n\u00b7 When there occurs an error during the execution of the low level SMX-Switch functions, Jabil Test while fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\n($State) = SMX_SWITCH_Terminate($ResourceNumber);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ResourceNumber\n\nInteger\n\nThe number of the SMX4032 device to be used. (i.e. Device 0, 1, etc.)\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$State\n\nBoolean\n\nWhether or not the scanner is done and ready to accept new commands.\n\n\n\n\n\nExample:\n\n($State) = SMX_SWITCH_Terminate($ResourceNumber);\n\n\n\n\n\nSMX_SWITCH_TestChanIntegrity\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SMX_SWITCH_TestChanIntegrity": {
  "prefix": "SMX_SWITCH_TestChanIntegrity",
  "body": [
   "($$State)=SMX_SWITCH_TestChanIntegrity($$ResourceNumber,$$Channel);"
  ],
  "description": "\n\nThis function requires SMX4032 drivers to be installed on the system.\n\nTest a channel relay.\n\n\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a SMX4032 device.\n\n\u00b7 When there occurs an error during the execution of the low level SMX-Switch functions, Jabil Test while fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\n($State) = SMX_SWITCH_TestChanIntegrity($ResourceNumber,$Channel);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ResourceNumber\n\nInteger\n\nThe number of the SMX4032 device to be used. (i.e. Device 0, 1, etc.)\n\n\n\n$Channel\n\nInteger\n\nIdentifies the Channel relay to be tested (1 to 32).\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$State\n\nInteger\n\nWhether or not the operation was successful. Negative value indicates failure. A zero value indicates success.\n\n\n\n\n\nExample:\n\n($State) = SMX_SWITCH_TestChanIntegrity($ResourceNumber,$Channel);\n\n\n\n\n\nSMX_SWITCH_TestConfigRelay\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SMX_SWITCH_TestConfigRelay": {
  "prefix": "SMX_SWITCH_TestConfigRelay",
  "body": [
   "($$State)=SMX_SWITCH_TestConfigRelay($$ResourceNumber,$$Config);"
  ],
  "description": "\n\nThis function requires SMX4032 drivers to be installed on the system.\n\nTests a single configuration or a tree relay.\n\n\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a SMX4032 device.\n\n\u00b7 When there occurs an error during the execution of the low level SMX-Switch functions, Jabil Test while fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\n($State) = SMX_SWITCH_TestConfigRelay($ResourceNumber,$Config);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ResourceNumber\n\nInteger\n\nThe number of the SMX4032 device to be used. (i.e. Device 0, 1, etc.)\n\n\n\n$Config\n\nString\n\nThe relay tree (AtoA, BtoA, BtoB, CtoA, CtoC, DtoC, or DtoD)\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$State\n\nInteger\n\nWhether or not the operation was successful. Negative value indicates failure. A zero value indicates success.\n\n\n\n\n\nExample:\n\n($State) = SMX_SWITCH_TestConfigRelay($ResourceNumber,$Config);\n\n\n\n\n\nSMX_SWITCH_TrigAutoScan\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SMX_SWITCH_TrigAutoScan": {
  "prefix": "SMX_SWITCH_TrigAutoScan",
  "body": [
   "($$State)=SMX_SWITCH_TrigAutoScan($$ResourceNumber,$$Points);"
  ],
  "description": "\n\nThis function requires SMX4032 drivers to be installed on the system.\n\nSet scanner for triggered auto scan operation.\n\n\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a SMX4032 device.\n\n\u00b7 When there occurs an error during the execution of the low level SMX-Switch functions, Jabil Test while fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\n($State) = SMX_SWITCH_TrigAutoScan($ResourceNumber,$Points);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ResourceNumber\n\nInteger\n\nThe number of the SMX4032 device to be used. (i.e. Device 0, 1, etc.)\n\n\n\n$Points\n\nInteger\n\nThe number of points in the scan.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$State\n\nInteger\n\nWhether or not the operation was successful. Negative value indicates failure. A zero value indicates success.\n\n\n\n\n\nExample:\n\n($State) = SMX_SWITCH_TrigAutoScan($ResourceNumber,$Points);\n\n\n\n\n\nSMX_SWITCH_TrigScan\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SMX_SWITCH_TrigScan": {
  "prefix": "SMX_SWITCH_TrigScan",
  "body": [
   "($$State)=SMX_SWITCH_TrigScan($$ResourceNumber,$$Points);"
  ],
  "description": "\n\nThis function requires SMX4032 drivers to be installed on the system.\n\nSet scanner for trigger driven step scanning.\n\n\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a SMX4032 device.\n\n\u00b7 When there occurs an error during the execution of the low level SMX-Switch functions, Jabil Test while fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\n($State) = SMX_SWITCH_TrigScan($ResourceNumber,$Points);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ResourceNumber\n\nInteger\n\nThe number of the SMX4032 device to be used. (i.e. Device 0, 1, etc.)\n\n\n\n$Points\n\nInteger\n\nThe number of points in the scan.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$State\n\nInteger\n\nWhether or not the operation was successful. Negative value indicates failure. A zero value indicates success.\n\n\n\n\n\nExample:\n\n($State) = SMX_SWITCH_TrigScan($ResourceNumber,$Points);\n\n\n\n\n\nSMX_SWITCH_TriggerInState\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SMX_SWITCH_TriggerInState": {
  "prefix": "SMX_SWITCH_TriggerInState",
  "body": [
   "($$State)=SMX_SWITCH_TriggerInState($$ResourceNumber,$$State,$$Edge);"
  ],
  "description": "\n\nThis function requires SMX4032 drivers to be installed on the system.\n\nSet trigger input state.\n\n\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a SMX4032 device.\n\n\u00b7 When there occurs an error during the execution of the low level SMX-Switch functions, Jabil Test while fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\n($State) = SMX_SWITCH_TriggerInState($ResourceNumber,$State,$Edge);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ResourceNumber\n\nInteger\n\nThe number of the SMX4032 device to be used. (i.e. Device 0, 1, etc.)\n\n\n\n$State\n\nString\n\n\"Enabled\" or \"Disabled\" are the valid states.\n\n\n\n$Edge\n\nString\n\n\"Positive\" or \"Negative\" are the valid states.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$State\n\nInteger\n\nWhether or not the operation was successful. Negative value indicates failure. A zero value indicates success.\n\n\n\n\n\nExample:\n\n($State) = SMX_SWITCH_TriggerInState($ResourceNumber,$State,$Edge);\n\n\n\n\n\nSMX_SWITCH_TriggerOutState\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SMX_SWITCH_TriggerOutState": {
  "prefix": "SMX_SWITCH_TriggerOutState",
  "body": [
   "($$State)=SMX_SWITCH_TriggerOutState($$ResourceNumber,$$State,$$Edge);"
  ],
  "description": "\n\nThis function requires SMX4032 drivers to be installed on the system.\n\nSet trigger output state.\n\n\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a SMX4032 device.\n\n\u00b7 When there occurs an error during the execution of the low level SMX-Switch functions, Jabil Test while fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\n\nResult:\n\n($State) = SMX_SWITCH_TriggerOutState($ResourceNumber,$State,$Edge);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ResourceNumber\n\nInteger\n\nThe number of the SMX4032 device to be used. (i.e. Device 0, 1, etc.)\n\n\n\n$State\n\nString\n\n\"Enabled\" or \"Disabled\" are the valid states.\n\n\n\n$Edge\n\nString\n\n\"Positive\" or \"Negative\" are the valid states.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$State\n\nInteger\n\nWhether or not the operation was successful. Negative value indicates failure. A zero value indicates success.\n\n\n\n\n\nExample:\n\n($State) = SMX_SWITCH_TriggerOutState($ResourceNumber,$State,$Edge);\n\n\n\n\n\nSmartSetTouchControl_SendTouch\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SmartSetTouchControl_SendTouch": {
  "prefix": "SmartSetTouchControl_SendTouch",
  "body": [
   "SmartSetTouchControl_SendTouch($$comPort,$$horizPosition,$$vertPosition,$$touchType);"
  ],
  "description": "\n\nThis function sends a touch command to a controller that uses the SmartSet 10 byte command set.\n\n\n\n\n\nRemarks:\n\nIt takes two calls to this function to perform a single \"touch\" on the screen. One call with touch type of \"INITIAL\" followed by a call with touch type \"UNTOUCH\".\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$comPort\n\nString\n\nThe name of the Com port that the instrument is connected to.\n\n\n\n$horizPosition\n\nInteger\n\nThe horizontal position in pixels of where to touch the screen.\n\n\n\n$vertPosition\n\nInteger\n\nThe vertical position in pixels of where to touch the screen.\n\n\n\n$touchType\n\nString\n\nThe type of touch command to send.\n\nValues:\n\n\u00b7 \"INITIAL\"\n\n\u00b7 \"UNTOUCH\"\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n--\n\n--\n\n\n\n\n\nExample:\n\n// Set up the parameters to touch at location 50, 120.\n\n$comPort = \"COM3\";\n\n$horizPosition = 50;\n\n$vertPosition = 120;\n\nSmartSetTouchControl_SendTouch($comPort, $horizPosition, $vertPosition, \"INITIAL\");\n\nSmartSetTouchControl_SendTouch($comPort, $horizPosition, $vertPosition, \"UNTOUCH\");\n\n\n\n\n\nDekTec_DTA112_ChangeOutputChannel\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS DekTec_DTA112_ChangeOutputChannel": {
  "prefix": "DekTec_DTA112_ChangeOutputChannel",
  "body": [
   "DekTec_DTA112_ChangeOutputChannel($$OutputHandle,$$ChannelFreq);"
  ],
  "description": "\n\nThis function changes the channel frequency for the device's active output channel.\n\n\n\n\n\nNote: Please refer to the channel table below for corresponding channel frequencies.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$OutputHandle\n\nObject\n\nThe handle of the output channel returned from the DekTeck_DTA112_OutputFileStream function\n\n\n\n$ChannelFreq\n\nInteger\n\nChannel Frequency MHz.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\nDekTec_DTA112_ChangeOutputChannel($handle, 67);\n\nU.S. Broadcast Channels\n\n6MHz\n\n\n\nChannel\n\nFrequency MHz\n\n\n\n2\n\n57\n\n\n\n3\n\n63\n\n\n\n4\n\n69\n\n\n\n5\n\n79\n\n\n\n6\n\n85\n\n\n\n7\n\n177\n\n\n\n8\n\n183\n\n\n\n9\n\n189\n\n\n\n10\n\n195\n\n\n\n11\n\n201\n\n\n\n12\n\n207\n\n\n\n13\n\n213\n\n\n\n14\n\n473\n\n\n\n15\n\n479\n\n\n\n16\n\n485\n\n\n\n17\n\n491\n\n\n\n18\n\n497\n\n\n\n19\n\n503\n\n\n\n20\n\n509\n\n\n\n21\n\n515\n\n\n\n22\n\n521\n\n\n\n23\n\n527\n\n\n\n24\n\n533\n\n\n\n25\n\n539\n\n\n\n26\n\n545\n\n\n\n27\n\n551\n\n\n\n28\n\n557\n\n\n\n29\n\n563\n\n\n\n30\n\n569\n\n\n\n31\n\n575\n\n\n\n32\n\n581\n\n\n\n33\n\n587\n\n\n\n34\n\n593\n\n\n\n35\n\n599\n\n\n\n36\n\n605\n\n\n\n37\n\n611\n\n\n\n38\n\n617\n\n\n\n39\n\n623\n\n\n\n40\n\n629\n\n\n\n41\n\n635\n\n\n\n42\n\n641\n\n\n\n43\n\n647\n\n\n\n44\n\n653\n\n\n\n45\n\n659\n\n\n\n46\n\n665\n\n\n\n47\n\n671\n\n\n\n48\n\n677\n\n\n\n49\n\n683\n\n\n\n50\n\n689\n\n\n\n51\n\n695\n\n\n\n52\n\n701\n\n\n\n53\n\n707\n\n\n\n54\n\n713\n\n\n\n55\n\n719\n\n\n\n56\n\n725\n\n\n\n57\n\n731\n\n\n\n58\n\n737\n\n\n\n59\n\n743\n\n\n\n60\n\n749\n\n\n\n61\n\n755\n\n\n\n62\n\n761\n\n\n\n63\n\n767\n\n\n\n64\n\n773\n\n\n\n65\n\n779\n\n\n\n66\n\n785\n\n\n\n67\n\n791\n\n\n\n68\n\n797\n\n\n\n69\n\n803\n\n\n\n\n\nDekTec_DTA112_Close\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS DekTec_DTA112_Close": {
  "prefix": "DekTec_DTA112_Close",
  "body": [
   "DekTec_DTA112_Close($$DeviceHandle);"
  ],
  "description": "\n\nThe close function terminates the software connection to the DekTec DTA 112 PCI card and de-allocates system resources. It detaches the device object from the device hardware.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$DeviceHandle\n\nObject\n\nThe handle of the device returned from the DekTeck_DTA112_Init function\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\nDekTec_DTA112_Close($handle);\n\n\n\n\n\nDekTec_DTA112_Init\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS DekTec_DTA112_Init": {
  "prefix": "DekTec_DTA112_Init",
  "body": [
   "$$DeviceHandle=DekTec_DTA112_Init($$DeviceIndex);"
  ],
  "description": "\n\nThis function establishes a connection to the DekTec DTA 112 PCI card and attaches the device object to the device hardware.\n\n\n\n\n\nNote: It is generally a good programming habit to close the instrument handle when the program is done using the instrument. This can be done with the DekTec_DTA112_Close function.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$DeviceIndex\n\nInteger\n\nIf the system contains multiple devices, this number distinguishes between the various devices. Number of the first device is 0, the next device 1, and so on.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$DeviceHandle\n\nObject\n\nThe handle of the device\n\n\n\n\n\nExamples:\n\n$DeviceHandle = DekTec_DTA112_Init(0);\n\n\n\n\n\nDekTec_DTA112_OutputFileStream\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS DekTec_DTA112_OutputFileStream": {
  "prefix": "DekTec_DTA112_OutputFileStream",
  "body": [
   "$$OutputHandle=DekTec_DTA112_OutputFileStream($$DeviceHandle,$$FilePath,$$Bps,$$Port,$$Channel);"
  ],
  "description": "\n\nThis function outputs a Transport-Stream file (.ts) to the specified port with the desired bps and channel frequency and returns a the handle of the output channel. The file will continuously loop so it is essential to close the output channel with DekTec_DTA112_StopFileStream\n\n\n\n\n\nNote: Please refer to the channel table below for corresponding channel frequencies.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$DeviceHandle\n\nObject\n\nThe handle of the device returned from the DekTeck_DTA112_Init function\n\n\n\n$FilePath\n\nString\n\nThe location of theTransport-Stream file to be output\n\n\n\n$Bps\n\nInteger\n\nTransport-Stream rate specified in bits per second.\n\n\n\n$Port\n\nInteger\n\nThe output port number\n\n\n\n$Channel\n\nInteger\n\nThe frequency of the US Broadcast Channel in MHxz\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$OutputHandle\n\nObject\n\nThe handle of the output channel.\n\n\n\n\n\nExamples:\n\n$file = \"C:\\\\stream.ts\";\n\n$outHandle = DekTec_DTA112_OutputFileStream($devHandle,$file,27000000,2,57);\n\nU.S. Broadcast Channels\n\n6MHz\n\n\n\nChannel\n\nFrequency MHz\n\n\n\n2\n\n57\n\n\n\n3\n\n63\n\n\n\n4\n\n69\n\n\n\n5\n\n79\n\n\n\n6\n\n85\n\n\n\n7\n\n177\n\n\n\n8\n\n183\n\n\n\n9\n\n189\n\n\n\n10\n\n195\n\n\n\n11\n\n201\n\n\n\n12\n\n207\n\n\n\n13\n\n213\n\n\n\n14\n\n473\n\n\n\n15\n\n479\n\n\n\n16\n\n485\n\n\n\n17\n\n491\n\n\n\n18\n\n497\n\n\n\n19\n\n503\n\n\n\n20\n\n509\n\n\n\n21\n\n515\n\n\n\n22\n\n521\n\n\n\n23\n\n527\n\n\n\n24\n\n533\n\n\n\n25\n\n539\n\n\n\n26\n\n545\n\n\n\n27\n\n551\n\n\n\n28\n\n557\n\n\n\n29\n\n563\n\n\n\n30\n\n569\n\n\n\n31\n\n575\n\n\n\n32\n\n581\n\n\n\n33\n\n587\n\n\n\n34\n\n593\n\n\n\n35\n\n599\n\n\n\n36\n\n605\n\n\n\n37\n\n611\n\n\n\n38\n\n617\n\n\n\n39\n\n623\n\n\n\n40\n\n629\n\n\n\n41\n\n635\n\n\n\n42\n\n641\n\n\n\n43\n\n647\n\n\n\n44\n\n653\n\n\n\n45\n\n659\n\n\n\n46\n\n665\n\n\n\n47\n\n671\n\n\n\n48\n\n677\n\n\n\n49\n\n683\n\n\n\n50\n\n689\n\n\n\n51\n\n695\n\n\n\n52\n\n701\n\n\n\n53\n\n707\n\n\n\n54\n\n713\n\n\n\n55\n\n719\n\n\n\n56\n\n725\n\n\n\n57\n\n731\n\n\n\n58\n\n737\n\n\n\n59\n\n743\n\n\n\n60\n\n749\n\n\n\n61\n\n755\n\n\n\n62\n\n761\n\n\n\n63\n\n767\n\n\n\n64\n\n773\n\n\n\n65\n\n779\n\n\n\n66\n\n785\n\n\n\n67\n\n791\n\n\n\n68\n\n797\n\n\n\n69\n\n803\n\n\n\n\n\nDekTec_DTA112_SetOutputLevel\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS DekTec_DTA112_SetOutputLevel": {
  "prefix": "DekTec_DTA112_SetOutputLevel",
  "body": [
   "DekTec_DTA112_SetOutputLevel($$OutputHandle,$$PowerLevel);"
  ],
  "description": "\n\nThis function sets the current level (in dB) for the output channel.\n\n\n\n\n\nNote: The actual output level will be set to 10% of the passed value and negative.\n\nFor example, if you set DekTec_DTA_SetOutputLevel($handle, 100);, internally the card will set the output level to -10db\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$OutputHandle\n\nObject\n\nThe handle of the output channel returned from the DekTeck_DTA112_OutputFileStream function\n\n\n\n$PowerLevel\n\nInteger\n\nOutput level in units of dB. (see note above)\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\nDekTec_DTA112_SetOutputLevel($handle, 25); // actually sets the level to -2.5db\n\n\n\n\n\nDekTec_DTA112_StopFileStream\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS DekTec_DTA112_StopFileStream": {
  "prefix": "DekTec_DTA112_StopFileStream",
  "body": [
   "DekTec_DTA112_StopFileStream($$OutputHandle);"
  ],
  "description": "\n\nThis function detaches the output channel from the hardware and frees resources allocated for the output channel, such as DMA buffers.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$OuputHandle\n\nObject\n\nThe handle of the output channel returned from the DekTeck_DTA112_OutputFileStream function\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\n$file = \"C:\\\\stream.ts\";\n\n$outHandle = DekTec_DTA112_OutputFileStream($devHandle,$file,27000000,2,57);\n\nDekTec_DTA112_StopFileStream($OutputHandle);\n\n\n\n\n\nAeroflexGSMAnalyzer_AbortMeasurement\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AeroFlexGSMAnalyzer_AbortMeasurement": {
  "prefix": "AeroFlexGSMAnalyzer_AbortMeasurement",
  "body": [
   "AeroFlexGSMAnalyzer_AbortMeasurement($$GSM);"
  ],
  "description": "\n\n\n\nAborts all enabled measurements.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$GSM\n\nObject\n\nGSM Analysis Object\n\n\n\n\n\nReturn Values\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n\n\n\n\nAeroFlexGSMAnalyzer_AbortMeasurement($GSM);\n\n\n\n\n\nAeroflexGSMAnalyzer_AssignDigitizerByInstance\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AeroflexGSMAnalyzer_AssignDigitizerByInstance": {
  "prefix": "AeroflexGSMAnalyzer_AssignDigitizerByInstance",
  "body": [
   "AeroflexGSMAnalyzer_AssignDigitizerByInstance($$GSM,$$DigitizerInstance);"
  ],
  "description": "\n\nThis function assigns a digitizer to be used by the GSM measurement system as a measurement resource. The Digitizer instance is created by using the AeroFlexDigitizer_Open function.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$GSM\n\nObject\n\nGSM Analysis Object\n\n\n\n$DigitizerInstance\n\nObject\n\nThe Digitizer instance created by the AeroFlexDigitizer_Open function.\n\n\n\n\n\nReturn Values\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n\n\n\n\n$Digitizer = AeroFlexDigitizer_Open(\"PXI4::14::INSTR\",\"PXI4::15::INSTR\", FALSE);\n\nAeroflexGSMAnalyzer_AssignDigitizerByInstance($GSM,$Digitizer);\n\n\n\n\n\nAeroflexGSMAnalyzer_AssignDigitizerByResource\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AeroFlexGSMAnalyzer_AssignDigitizerByResource": {
  "prefix": "AeroFlexGSMAnalyzer_AssignDigitizerByResource",
  "body": [
   "AeroFlexGSMAnalyzer_AssignDigitizerByResource($$GSM,$$DigitizerResourceString,$$OscillatorResourceString,$$LOisLocal);"
  ],
  "description": "\n\n\n\nThis function assigns the digitizer hardware resources to a GSM measurement system by the PXI Resource string. The hardware will be booted automatically as soon as it's assigned to the GSM Measurement system.\n\n\n\n\n\nNote:\n\nIf you have used the AeroflexGSMAnalyzer_Open function as opposed to the AeroflexGSMAnalyzer_Init function, then these extra steps are unnecessary.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$GSM\n\nObject\n\nThe GSM Object created with the AeroflexGSMAnalyzer_Init function.\n\n\n\n$DigitizerResourceString\n\nString\n\nDigitizer Resource String for the RF resource (301x module) that is to be created and used by the GSM measurement library\n\n\n\n$OscillatorResourceString\n\nString\n\nOscillator Resource String for the LO (303x module) that is to be created and used by the GSM measurement library.\n\n\n\n$LOisLocal\n\nBoolean\n\nIf set to false, an external standard is used, otherwise an internal standard is used. This parameter refers to the oscillator reference for the digitizer.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample: AeroflexGSMAnalyzer_AssignDigitizerByResource($GSM,\"PXI4::14::INSTR\",\"PXI4::15\",true);\n\n\n\n\n\nAeroflexGSMAnalyzer_AssignSignalGeneratorByInstance\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AeroflexGSMAnalyzer_AssignSignalGeneratorByInstance": {
  "prefix": "AeroflexGSMAnalyzer_AssignSignalGeneratorByInstance",
  "body": [
   "AeroflexGSMAnalyzer_AssignSignalGeneratorByInstance($$GSM,$$SigGenInstance);"
  ],
  "description": "\n\nThis function assigns a signal generator to be used by the GSM measurement system as a measurement resource. The Signal Generator instance is created by using the AeroFlexSigGen_Open function.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$GSM\n\nObject\n\nGSM Analysis Object\n\n\n\n$SigGenInstance\n\nObject\n\nThe Signal Generator instance created by the AeroFlexDigitizer_Open function.\n\n\n\n\n\nReturn Values\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n\n\n\n\n$SigGen = AeroFlexSigGen_Open(\"PXI2::15::INSTR\", \"PXI2::14::INSTR\", FALSE);\n\nAeroflexGSMAnalyzer_AssignSignalGeneratorByInstance($GSM,$SigGen);\n\n\n\n\n\nAeroflexGSMAnalyzer_AssignSignalGeneratorByResource\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AeroFlexGSMAnalyzer_AssignSignalGeneratorByResource": {
  "prefix": "AeroFlexGSMAnalyzer_AssignSignalGeneratorByResource",
  "body": [
   "AeroFlexGSMAnalyzer_AssignSignalGeneratorByResource($$GSM,$$SigGenResourceString,$$OscillatorResourceString,$$LOisLocal);"
  ],
  "description": "\n\n\n\nThis function assigns the signal generator resources to a GSM measurement system by the PXI Resource string. The hardware will be booted automatically as soon as it's assigned to the GSM Measurement system.\n\n\n\n\n\nNote:\n\nIf you have used the AeroflexGSMAnalyzer_Open function as opposed to the AeroflexGSMAnalyzer_Init function, then these extra steps are unnecessary.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$GSM\n\nObject\n\nThe GSM Object created with the AeroflexGSMAnalyzer_Init function.\n\n\n\n$SigGenResourceString\n\nString\n\nThe resource name of the signal generator.\n\n\n\n$OscillatorResourceString\n\nString\n\nThe resource name for the LO (303x module) to be used for the signal generator.\n\n\n\n$LOisLocal\n\nBoolean\n\nIf set to false, an external standard is used, otherwise an internal standard is used. This parameter refers to the oscillator reference for the digitizer.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample: AeroflexGSMAnalyzer_AssignSignalGeneratorByResource($GSM,\"PXI4::14::INSTR\",\"PXI4::15\",true);\n\n\n\n\n\nAeroflexGSMAnalyzer_Close\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AeroFlexGSMAnalyzer_Close": {
  "prefix": "AeroFlexGSMAnalyzer_Close",
  "body": [
   "AeroFlexGSMAnalyzer_Close($$GSM);"
  ],
  "description": "\n\nThis function closes the AeroFlex GSM Analysis System, aborts any running measurements, and frees the assigned instrument resources.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$GSM\n\nObject\n\nGSM Analyzer Object\n\n\n\n\n\nExample:\n\n\n\n\n\n$GSM = AeroflexGSMAnalyzer_Open(\"PXI4::14::INSTR\",\"PXI4::15\",true,\"PXI4::10::INSTR\",\"PXI4::11::INSTR\",true);\n\nAeroflexGSMAnalyzer_Reset($GSM);\n\nSetFinalizeFunction(\"CloseGSM\");\n\n\n\n\n\nfunction CloseGSM()\n\n{\n\nAeroflexGSMAnalyzer_Close($GSM);\n\nEnd;\n\n}\n\n\n\n\n\nAeroflexGSMAnalyzer_GetMeasurementTrace\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AeroFlexGSMAnalyzer_GetMeasurementTrace": {
  "prefix": "AeroFlexGSMAnalyzer_GetMeasurementTrace",
  "body": [
   "$$Trace=AeroFlexGSMAnalyzer_GetMeasurementTrace($$GSM,$$MeasurementType);"
  ],
  "description": "\n\n\n\nThis function returns the requested measurement value from the GSM analyzer. In order to retrieve a measurement value, the measurement must be configured as active, and the measurement must have been started before calling this function.\n\n\n\n\n\nIn order to validate that the returned measurement is reliable, the user may call the AeroflexGSMAnalyzer_GetMeasurementValidity function which will verify that the measurement has been configured properly, and that it has been acquired.\n\n\n\n\n\nThis function returns an object containing a plot of X/Y values which can be passed to the Jabil Test graphing function to display the data to the user.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$GSM\n\nObject\n\nGSM Analysis Object\n\n\n\n$MeasurementType\n\nString\n\nThe measurement type to check for valid configuration parameters. Valid values are:\n\n\u00b7 \"CAPTUREPOWERVSTIME\"\n\n\u00b7 \"MODACCEVMVSTIMEAVG\"\n\n\u00b7 \"MODACCEVMVSTIMEMAX\"\n\n\u00b7 \"MODACCEVMVSTIMEMIN\"\n\n\u00b7 \"MODACCEVMVSTIME\"\n\n\u00b7 \"MODACCPHASEERRORVSTIMEAVG\"\n\n\u00b7 \"MODACCPHASEERRORVSTIMEMAX\"\n\n\u00b7 \"MODACCPHASEERRORVSTIMEMIN\"\n\n\u00b7 \"ORFSMODULATIONPOWERVSFREQAVG\"\n\n\u00b7 \"ORFSMODULATIONPOWERVSFREQMAX\"\n\n\u00b7 \"ORFSMODULATIONPOWERVSFREQMIN\"\n\n\u00b7 \"ORFSSWITCHINGPOWERVSFREQ\"\n\n\u00b7 \"POWERFALLINGVSTIMEAVG\"\n\n\u00b7 \"POWERFALLINGVSTIMEMASKLOWERLIMIT\"\n\n\u00b7 \"POWERFALLINGVSTIMEMASKUPPERLIMIT\"\n\n\u00b7 \"POWERFALLINGVSTIMEMAX\"\n\n\u00b7 \"POWERFALLINGVSTIMEMIN\"\n\n\u00b7 \"POWERFALLINGVSTIME\"\n\n\u00b7 \"POWERRISINGVSTIMEAVG\"\n\n\u00b7 \"POWERRISINGVSTIMEMASKLOWERLIMIT\"\n\n\u00b7 \"POWERRISINGVSTIMEMASKUPPERLIMIT\"\n\n\u00b7 \"POWERRISINGVSTIMEMAX\"\n\n\u00b7 \"POWERRISINGVSTIMEMIN\"\n\n\u00b7 \"POWERRISINGVSTIMEAVG\"\n\n\u00b7 \"POWERUSEFULVSTIMEAVG\"\n\n\u00b7 \"POWERUSEFULVSTIMEMASKLOWERLIMIT\"\n\n\u00b7 \"POWERUSEFULVSTIMEMASKUPPERLIMIT\"\n\n\u00b7 \"POWERUSEFULVSTIMEMAX\"\n\n\u00b7 \"POWERUSEFULVSTIMEMIN\"\n\n\u00b7 \"POWERUSEFULVSTIME\"\n\n\u00b7 \"POWERVSFREQAVG\"\n\n\u00b7 \"POWERVSFREQMAX\"\n\n\u00b7 \"POWERVSFREQMIN\"\n\n\u00b7 \"POWERVSFREQ\"\n\n\u00b7 \"POWERVSTIMEAVG\"\n\n\u00b7 \"POWERVSTIMEMASKLOWERLIMIT\"\n\n\u00b7 \"POWERVSTIMEMASKUPPERLIMIT\"\n\n\u00b7 \"POWERVSTIMEMAX\"\n\n\u00b7 \"POWERVSTIMEMIN\"\n\n\u00b7 \"POWERVSTIME\"\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$MeasurementTrace\n\nObject (PlotTrace2D)\n\nA measurement object containing a trace of the X,Y coordinates of the captured data for graphing.\n\n\n\n\n\nExample:\n\n$Trace = AeroFlexGSMAnalyzer_GetMeasurementTrace($GSM,\"POWERVSTIME\");\n\n\n\n\n\nAeroflexGSMAnalyzer_GetMeasurementValidity\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AeroFlexGSMAnalyzer_GetMeasurementValidity": {
  "prefix": "AeroFlexGSMAnalyzer_GetMeasurementValidity",
  "body": [
   "$$isvalid=AeroFlexGSMAnalyzer_GetMeasurementValidity($$GSM,$$MeasurementType);"
  ],
  "description": "\n\nThis function returns a boolean value indicating whether or not the configuration parameters for the specified measurement type are currently valid. If the measurement has a valid configuration a value of 'TRUE' is returned, otherwise a value of 'FALSE' is returned.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$GSM\n\nObject\n\nGSM Analysis Object\n\n\n\n$MeasurementType\n\nString\n\nThe measurement type to check for valid configuration parameters. Valid values are:\n\n\u00b7 \"ALL\"\n\n\u00b7 \"BER\"\n\n\u00b7 \"BURSTPOWER\"\n\n\u00b7 \"BURSTPOWERAVG\"\n\n\u00b7 \"BURSTPOWERMAX\"\n\n\u00b7 \"BURSTPOWERMIN\"\n\n\u00b7 \"BURSTTIMINGERROR\"\n\n\u00b7 \"BURSTTIMINGERRORAVG\"\n\n\u00b7 \"BURSTTIMINGERRORMAX\"\n\n\u00b7 \"BURSTTIMINGERRORMIN\"\n\n\u00b7 \"BURSTTYPE\"\n\n\u00b7 \"CAPTUREPOWERVSTIME\"\n\n\u00b7 \"EDGEDROOP\"\n\n\u00b7 \"EDGEDROOPAVG\"\n\n\u00b7 \"EDGEDROOPMAX\"\n\n\u00b7 \"EDGEDROOPMIN\"\n\n\u00b7 \"EDGEOOSSUPPRESSION\"\n\n\u00b7 \"EDGEOOSSUPPRESSIONAVG\"\n\n\u00b7 \"EDGEOOSSUPPRESIONMIN\"\n\n\u00b7 \"EDGEOOSSUPPRESIONMAX\"\n\n\u00b7 \"EDGEPERCENTILE\"\n\n\u00b7 \"FASTBURSTPOWER\"\n\n\u00b7 \"FASTBURSTPOWERAVG\"\n\n\u00b7 \"FASTBURSTPOWERMAX\"\n\n\u00b7 \"FASTBURSTPOWERMIN\"\n\n\u00b7 \"MODACCEVMMAX\"\n\n\u00b7 \"MODACCEVMMAXMAX\"\n\n\u00b7 \"MODACCEVMMIN\"\n\n\u00b7 \"MODACCEVMMINMIN\"\n\n\u00b7 \"MODACCEVMPEAK\"\n\n\u00b7 \"MODACCEVMPEAKAVG\"\n\n\u00b7 \"MODACCEVMPEAKMAX\"\n\n\u00b7 \"MODACCEVMPEAKMIN\"\n\n\u00b7 \"MODACCEVMRMS\"\n\n\u00b7 \"MODACCEVMRMSAVG\"\n\n\u00b7 \"MODACCEVMRMSMAX\"\n\n\u00b7 \"MODACCEVMRMSMIN\"\n\n\u00b7 \"MODACCEVMVSTIME\"\n\n\u00b7 \"MODACCEVMVSTIMEAVG\"\n\n\u00b7 \"MODACCEVMVSTIMEMAX\"\n\n\u00b7 \"MODACCEVMVSTIMEMIN\"\n\n\u00b7 \"MODACCFREQERROR\"\n\n\u00b7 \"MODACCFREQERRORAVG\"\n\n\u00b7 \"MODACCFREQERRORMAX\"\n\n\u00b7 \"MODACCFREQERRORMIN\"\n\n\u00b7 \"MODACCPHASEERRORMAX\"\n\n\u00b7 \"MODACCPHASEERRORMIN\"\n\n\u00b7 \"MODACCPHASEERRORMINMIN\"\n\n\u00b7 \"MODACCPHASEERRORPEAK\"\n\n\u00b7 \"MODACCPHASEERRORPEAKAVG\"\n\n\u00b7 \"MODACCPHASEERRORPEAKMAX\"\n\n\u00b7 \"MODACCPHASEERRORPEAKMIN\"\n\n\u00b7 \"MODACCPHASEERRORRMS\"\n\n\u00b7 \"MODACCPHASEERRORRMSAVG\"\n\n\u00b7 \"MODACCPHASEERRORRMSMAX\"\n\n\u00b7 \"MODACCPHASEERRORRMSMIN\"\n\n\u00b7 \"MODACCPHASEERRORVSTIME\"\n\n\u00b7 \"MODACCPHASEERRORVSTIMEAVG\"\n\n\u00b7 \"MODACCPHASEERRORVSTIMEMAX\"\n\n\u00b7 \"MODACCPHASEERRORVSTIMEMIN\"\n\n\u00b7 \"ORFSMODULATIONPOWERVSFREQ\"\n\n\u00b7 \"ORFSMODULATIONPOWERVSFREQAVG\"\n\n\u00b7 \"ORFSMODULATIONPOWERVSFREQMAX\"\n\n\u00b7 \"ORFSMODULATIONPOWERVSFREQMIN\"\n\n\u00b7 \"POWERFALLINGVSTIME\"\n\n\u00b7 \"POWERFALLINGVSTIMEAVG\"\n\n\u00b7 \"POWERFALLINGVSTIMEMASKLOWERLIMIT\"\n\n\u00b7 \"POWERFALLINGVSTIMEMASKUPPERLIMIT\"\n\n\u00b7 \"POWERFALLINGVSTIMEMAX\"\n\n\u00b7 \"POWERFALLINGVSTIMEMIN\"\n\n\u00b7 \"POWERFALLINGVSTIMEPASSFAIL\"\n\n\u00b7 \"POWERRISINGINGVSTIME\"\n\n\u00b7 \"POWERRISINGINGVSTIMEAVG\"\n\n\u00b7 \"POWERRISINGINGVSTIMEMASKLOWERLIMIT\"\n\n\u00b7 \"POWERRISINGINGVSTIMEMASKUPPERLIMIT\"\n\n\u00b7 \"POWERRISINGINGVSTIMEMAX\"\n\n\u00b7 \"POWERRISINGINGVSTIMEMIN\"\n\n\u00b7 \"POWERRISINGINGVSTIMEPASSFAIL\"\n\n\u00b7 \"POWERUSEFULVSTIME\"\n\n\u00b7 \"POWERUSEFULVSTIMEAVG\"\n\n\u00b7 \"POWERUSEFULVSTIMEMASKLOWERLIMIT\"\n\n\u00b7 \"POWERUSEFULVSTIMEMASKUPPERLIMIT\"\n\n\u00b7 \"POWERUSEFULVSTIMEMAX\"\n\n\u00b7 \"POWERUSEFULVSTIMEMIN\"\n\n\u00b7 \"POWERUSEFULVSTIMEPASSFAIL\"\n\n\u00b7 \"POWERVSFREQ\"\n\n\u00b7 \"POWERVSFREQAVG\"\n\n\u00b7 \"POWERVSFREQMAX\"\n\n\u00b7 \"POWERVSFREQMIN\"\n\n\u00b7 \"POWERVSTIME\"\n\n\u00b7 \"POWERVSTIMEAVG\"\n\n\u00b7 \"POWERVSTIMEMASKLOWERLIMIT\"\n\n\u00b7 \"POWERVSTIMEMASKUPPERLIMIT\"\n\n\u00b7 \"POWERVSTIMEMAX\"\n\n\u00b7 \"POWERVSTIMEMIN\"\n\n\u00b7 \"POWERVSTIMEPASSFAIL\"\n\n\u00b7 \"TSC\"\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$IsValid\n\nBoolean\n\n\u00b7 Returns 'TRUE' or 'FALSE' depending on whether or not the measurement is configured properly.\n\n\n\n\n\nExample:\n\nAeroFlexGSMAnalyzer_GetMeasurementValidity($GSM,\"EDGEDROOPMAX\");\n\n\n\n\n\nAeroflexGSMAnalyzer_GetMeasurementValue\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AeroFlexGSMAnalyzer_GetMeasurementValue": {
  "prefix": "AeroFlexGSMAnalyzer_GetMeasurementValue",
  "body": [
   "$$isvalid=AeroFlexGSMAnalyzer_GetMeasurementValue($$GSM,$$MeasurementType);"
  ],
  "description": "\n\n\n\nThis function returns the requested measurement value from the GSM analyzer. In order to retrieve a measurement value, the measurement must be configured as active, and the measurement must have been started before calling this function.\n\n\n\n\n\nIn order to validate that the returned measurement is reliable, the user may call the AeroflexGSMAnalyzer_GetMeasurementValidity function which will verify that the measurement has been configured properly, and that it has been acquired.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$GSM\n\nObject\n\nGSM Analysis Object\n\n\n\n$MeasurementType\n\nString\n\nThe measurement type to check for valid configuration parameters. Valid values are:\n\n\u00b7 \"BERBITSINERROR\"\n\n\u00b7 \"BERERRORRATE\"\n\n\u00b7 \"BERSPEECHERASEDFRAMES\"\n\n\u00b7 \"BERSPEECHFRAMEERASURERATE\"\n\n\u00b7 \"BERTOTALBITS\"\n\n\u00b7 \"BERTOTALFRAMES\"\n\n\u00b7 \"BURSTPOWER\"\n\n\u00b7 \"BURSTPOWERAVG\"\n\n\u00b7 \"BURSTPOWERMAX\"\n\n\u00b7 \"BURSTPOWERMIN\"\n\n\u00b7 \"BURSTTIMINGERROR\"\n\n\u00b7 \"BURSTTIMINGERRORAVG\"\n\n\u00b7 \"BURSTTIMINGERRORMAX\"\n\n\u00b7 \"BURSTTIMINGERRORMIN\"\n\n\u00b7 \"CARRIERFREQUENCY\"\n\n\u00b7 \"EDGEDROOP\"\n\n\u00b7 \"EDGEDROOPAVG\"\n\n\u00b7 \"EDGEDROOPMAX\"\n\n\u00b7 \"EDGEDROOPMIN\"\n\n\u00b7 \"EDGEOOSUPPRESSION\"\n\n\u00b7 \"EDGEOOSUPPRESSIONAVG\"\n\n\u00b7 \"EDGEOOSUPPRESSIONMAX\"\n\n\u00b7 \"EDGEOOSUPPRESSIONMIN\"\n\n\u00b7 \"EDGEPERCENTILE\"\n\n\u00b7 \"EDGEPERCENTILEBURSTS\"\n\n\u00b7 \"FASTBURSTPOWER\"\n\n\u00b7 \"FASTBURSTPOWERAVG\"\n\n\u00b7 \"FASTBURSTPOWERMAX\"\n\n\u00b7 \"FASTBURSTPOWERMIN\"\n\n\u00b7 \"MODACCEVMMAX\"\n\n\u00b7 \"MODACCEVMMAXMAX\"\n\n\u00b7 \"MODACCEVMMIN\"\n\n\u00b7 \"MODACCEVMMINMIN\"\n\n\u00b7 \"MODACCEVMPEAK\"\n\n\u00b7 \"MODACCEVMPEAKAVG\"\n\n\u00b7 \"MODACCEVMPEAKMAX\"\n\n\u00b7 \"MODACCEVMPEAKMIN\"\n\n\u00b7 \"MODACCEVMRMS\"\n\n\u00b7 \"MODACCEVMRMSAVG\"\n\n\u00b7 \"MODACCEVMRMSMAX\"\n\n\u00b7 \"MODACCEVMRMSMIN\"\n\n\u00b7 \"MODACCFREQERROR\"\n\n\u00b7 \"MODACCFREQERRORAVG\"\n\n\u00b7 \"MODACCFREQERRORMAX\"\n\n\u00b7 \"MODACCFREQERRORMIN\"\n\n\u00b7 \"MODACCPHASEERRORMAX\"\n\n\u00b7 \"MODACCPHASEERRORMIN\"\n\n\u00b7 \"MODACCPHASEERRORMINMIN\"\n\n\u00b7 \"MODACCPHASEERRORPEAK\"\n\n\u00b7 \"MODACCPHASEERRORPEAKAVG\"\n\n\u00b7 \"MODACCPHASEERRORPEAKMAX\"\n\n\u00b7 \"MODACCPHASEERRORPEAKMIN\"\n\n\u00b7 \"MODACCPHASEERRORRMS\"\n\n\u00b7 \"MODACCPHASEERRORRMSAVG\"\n\n\u00b7 \"MODACCPHASEERRORRMSMAX\"\n\n\u00b7 \"MODACCPHASEERRORRMSMIN\"\n\n\u00b7 \"POWERFALLINGVSTIMEFAILLEVEL\"\n\n\u00b7 \"POWERFALLINGVSTIMEFAILTIME\"\n\n\u00b7 \"POWERFALLINGVSTIMEPASSFAIL\"\n\n\u00b7 \"POWERRISINGVSTIMEFAILLEVEL\"\n\n\u00b7 \"POWERRISINGVSTIMEFAILTIME\"\n\n\u00b7 \"POWERRISINGVSTIMEPASSFAIL\"\n\n\u00b7 \"POWERUSEFULVSTIMEFAILLEVEL\"\n\n\u00b7 \"POWERUSEFULVSTIMEFAILTIME\"\n\n\u00b7 \"POWERUSEFULVSTIMEPASSFAIL\"\n\n\u00b7 \"POWERVSTIMEFAILLEVEL\"\n\n\u00b7 \"POWERVSTIMEFAILTIME\"\n\n\u00b7 \"POWERVSTIMEPASSFAIL\"\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$MeasurementValue\n\nBoolean, Integer, Float\n\nReturns a boolean, integer, or floating point value depending on the measurement type requested.\n\n\n\n\n\nExample:\n\nAeroFlexGSMAnalyzer_GetMeasurementValue($GSM,\"BERBITSINERROR\");\n\n\n\n\n\nAeroflexGSMAnalyzer_GetVersion\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AeroFlexGSMAnalyzer_GetVersion": {
  "prefix": "AeroFlexGSMAnalyzer_GetVersion",
  "body": [
   "$$Version=AeroFlexGSMAnalyzer_GetVersion($$GSM);"
  ],
  "description": "\n\nThis function returns the version number of the underlying measurement library DLL as a single string.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$GSM\n\nObject\n\nGSM Analysis Object\n\n\n\n\n\nReturn Values\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Version\n\nString\n\nA string containing the version information of the underlying measurement library.\n\n\n\n\n\nExample:\n\n\n\n\n\n$Version = AeroFlexGSMAnalyzer_GetVersion($GSM);\n\n\n\n\n\nAeroflexGSMAnalyzer_Init\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AeroFlexGSMAnalyzer_Init": {
  "prefix": "AeroFlexGSMAnalyzer_Init",
  "body": [
   "$$Handle=AeroFlexGSMAnalyzer_Init();"
  ],
  "description": "\n\n\n\nThis function creates a handle to a GSM analyzer object, which is a composite, user-friendly interface to using the Aeroflex PXI Signal Generator and Digitizer for making common GSM physical layer measurements.\n\n\n\n\n\nNote:\n\n\n\n\n\nThis function does not assign any hardware to the GSM Analysis object and this must be done in separate test commands before using the GSM Analysis System.\n\n\n\n\n\nIf you would like to create and assign all the instruments to the GSM Analysis system in a single step, please see the AeroflexGSMAnalyzer_Open function which performs all these operations in a single step.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nReturns the handle to the GSM analysis object used to pass to subsequent measurement functions.\n\n\n\n\n\nExample:\n\n$GSM = AeroflexGSMAnalyzer_Init();\n\nAeroflexGSMAnalyzer_Reset($GSM);\n\nSetFinalizeFunction(\"CloseGSM\");\n\n\n\n\n\nfunction CloseGSM()\n\n{\n\nAeroflexGSMAnalyzer_Close($GSM);\n\nEnd;\n\n}\n\n\n\n\n\nAeroflexGSMAnalyzer_Open\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AeroFlexGSMAnalyzer_Open": {
  "prefix": "AeroFlexGSMAnalyzer_Open",
  "body": [
   "$$Handle=AeroFlexGSMAnalyzer_Open($$DigitizerResourceString,$$OscillatorResourceString,$$LOisLocal,$$SigGenResourceString,$$SigGenOscillatorResourceString,$$SigGenLOIsLocal);"
  ],
  "description": "\n\n\n\nThis function creates a handle to a GSM analyzer object, which is a composite, user-friendly interface to using the Aeroflex PXI Signal Generator and Digitizer for making common GSM physical layer measurements.\n\n\n\n\n\nAfter calling the AeroFlexGSMAnalyzer_Open function, you must close the instrument using the AeroFlexGSMAnalyzer_Close function to release the instrument resources.\n\n\n\n\n\nNote:\n\nThis function allocates the necessary digitizer, oscillators, and signal generators to the GSM analysis system. While these resources have been assigned to the GSM analysis system, they may not be used simultaneously with other operations, such as the Aeroflex Spectrum Analyzer interface.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$DigitizerResourceString\n\nString\n\nDigitizer Resource String for the RF resource (301x module) that is to be created and used by the GSM measurement library\n\n\n\n$OscillatorResourceString\n\nString\n\nOscillator Resource String for the LO (303x module) that is to be created and used by the GSM measurement library.\n\n\n\n$LOisLocal\n\nBoolean\n\nIf set to false, an external standard is used, otherwise an internal standard is used. This parameter refers to the oscillator reference for the digitizer.\n\n\n\n$SigGenResourceString\n\nString\n\nThe resource name of the signal generator.\n\n\n\n$SigGenOscillatorResourceString\n\nString\n\nThe resource name for the LO (303x module) to be used for the signal generator\n\n\n\n$SigGenLOIsLocal\n\nBoolean\n\nIf set to false, and external standard is used, otherwise an internal standard is used. This parameter refers to the oscillator reference for the signal generator.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nReturns the handle to the GSM analysis object used to pass to subsequent measurement functions.\n\n\n\n\n\nExample:\n\n$GSM = AeroflexGSMAnalyzer_Open(\"PXI4::14::INSTR\",\"PXI4::15\",true,\"PXI4::10::INSTR\",\"PXI4::11::INSTR\",true);\n\nAeroflexGSMAnalyzer_Reset($GSM);\n\nSetFinalizeFunction(\"CloseGSM\");\n\n\n\n\n\nfunction CloseGSM()\n\n{\n\nAeroflexGSMAnalyzer_Close($GSM);\n\nEnd;\n\n}\n\n\n\n\n\nAeroflexGSMAnalyzer_Reset\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AeroFlexGSMAnalyzer_Reset": {
  "prefix": "AeroFlexGSMAnalyzer_Reset",
  "body": [
   "AeroFlexGSMAnalyzer_Reset($$GSM);"
  ],
  "description": "\n\nThis function is to reset the AeroFlex GSM Analysis stack and all allocated hardware resources to their initial \"power-on\" defaults.\n\nImportant Note:\n\nThis function will not reset the default state of any RF combiners in the system as they are not used as part of the GSM analysis system, but must be controlled externally.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$GSM\n\nObject\n\nGSM Analysis Object\n\n\n\n\n\nExample:\n\n\n\n\n\nAeroFlexGSMAnalyzer_Reset($GSM);\n\n\n\n\n\nAeroflexGSMAnalyzer_SetARFChannelNumber\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AeroFlexGSMAnalyzer_SetARFChannelNumber": {
  "prefix": "AeroFlexGSMAnalyzer_SetARFChannelNumber",
  "body": [
   "AeroFlexGSMAnalyzer_SetARFChannelNumber($$GSM,$$ARFCN);"
  ],
  "description": "\n\n\n\nSets/gets the absolute radio frequency (ARF) channel number. Specifying a channel number will set a specific digitizer frequency, and where acquired a particular signal generator frequency. The frequencies that the channel number relates to are dependent upon the current system band.\n\nThe following table provides a summary of the relationship between system band, power control level, absolute radio frequency channel number (ARFCN) and uplink frequency ranges. System Band\n\nPower\n\nControl\n\nLevel\n\nOutput Power (dBm)\n\nARFCN\n\nUplink Frequency (MHz)\n\n\n\nGSM400\n\n0-31\n\n39 - 5\n\n259 - 293\n\n306 - 340\n\n450.6 - 457.4\n\n479.0 - 485.8\n\n\n\nGSM700\n\n0-31\n\n39 - 5\n\n438 - 511\n\n747.2 - 761.8\n\n\n\nGSM850\n\n0-31\n\n39 - 5\n\n128 - 251\n\n824.2 - 848.8\n\n\n\nGSM900\n\n0-31\n\n39 - 5\n\n0 - 124\n\n975 - 1023\n\n890.0 - 914.8\n\n880.2 - 889.8\n\n\n\nDCS1800\n\n0-31\n\n36 - 0\n\n512 - 885\n\n1710.2 - 1784.8\n\n\n\nPCS1900 "
 }
,
 "JTS AeroFlexGSMAnalyzer_SetAttenuatorLevel": {
  "prefix": "AeroFlexGSMAnalyzer_SetAttenuatorLevel",
  "body": [
   "AeroFlexGSMAnalyzer_SetAttenuatorLevel($$GSM,$$AttenuatorLevel);"
  ],
  "description": "\n\nSets the digitizer's RF attenuation level specified in dB. The attenuation is specified as a positive integer.\n\n\n\nNote:\n\n\n\nThis function only has an effect in the event that the attenuator mode is set to 'MANUAL'.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$GSM\n\nObject\n\nGSM Analysis Object\n\n\n\n$AttenuatorLevel\n\nInteger\n\nThe level of the attenuator specified in dB.\n\n\n\n\n\nReturn Values\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\nAeroFlexGSMAnalyzer_SetAttenuatorLevel($GSM,6); // Sets attenuator to -6 dB\n\n\n\n\n\nAeroflexGSMAnalyzer_SetAttenuatorMode\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AeroFlexGSMAnalyzer_SetAttenuatorMode": {
  "prefix": "AeroFlexGSMAnalyzer_SetAttenuatorMode",
  "body": [
   "AeroFlexGSMAnalyzer_SetAttenuatorMode($$GSM,$$AttenuatorMode);"
  ],
  "description": "\n\nThis function is used to toggle the attenuator mode between a manual mode setting and an automatic setting in which the attenuation is automatically calculated by the user setting the reference level. The attenuation is coupled with the reference level, so there is no direct control of the attenuation in auto mode.\n\n\n\nWith the Attenuator mode set to Manual, direct control is provided for both the reference level and the attenuation level.\n\n\n\n\n\nImportant Note:\n\n\n\nPlease be aware that when using the attenuator in a manual mode it may be possible to damage the test equipment if the reference level and the attenuator mode are not properly set in the correct order with a high input power applied to the RF digitizer input.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$GSM\n\nObject\n\nGSM Analysis Object\n\n\n\n$AttenuatorMode\n\nString\n\nThe desired attenuator mode of operation. Supported values are:\n\n\u00b7 \"AUTO\"\n\n\u00b7 \"MANUAL\"\n\n\n\n\n\nReturn Values\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\nAeroFlexGSMAnalyzer_SetAttenuatorMode($GSM,\"AUTO\");\n\n\n\n\n\nAeroflexGSMAnalyzer_SetAutoAnalysisTSC\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AeroflexGSMAnalyzer_SetAutoAnalysisTSC": {
  "prefix": "AeroflexGSMAnalyzer_SetAutoAnalysisTSC",
  "body": [
   "AeroflexGSMAnalyzer_SetAutoAnalysisTSC($$GSM,$$DUT,$$AutoTSCMode);"
  ],
  "description": "\n\nThis function sets the automatic burst type detection mode for the specified device under test (DUT). When automatic mode is enabled, the burst type is detected from the burst analysis;\n\nThe GSM measurement library currently supports a single DUT. The DUT index is zero-based (i.e. 0 signifies DUT1). If support for multiple DUTs is added in the future, then an index of 1 would apply for DUT2, 2 for DUT3, and so on.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$GSM\n\nObject\n\nGSM Analysis Object\n\n\n\n$DUT\n\nInteger\n\nThe DUT Number for configuration of the TSC Mode. (Current API only supports 0)\n\n\n\n$AutoTSCMode\n\nBoolean\n\nThe desired auto type of the GSM measurement. Supported auto burst types are:\n\n\u00b7 true = Automatic TSC type detection is enabled for the specified DUT.\n\n\u00b7 false = Automatic TSC type detection is disabled for the specified DUT.\n\n\n\n\n\nReturn Values\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n\n\n\n\nAeroflexGSMAnalyzer_SetAutoAnalysisTSC($GSM,0,$TRUE); /// Configures to enable Auto burst detection;\n\n\n\n\n\nAeroflexGSMAnalyzer_SetAutoBurstTypeDetection\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AeroflexGSMAnalyzer_SetAutoBurstTypeDetection": {
  "prefix": "AeroflexGSMAnalyzer_SetAutoBurstTypeDetection",
  "body": [
   "AeroflexGSMAnalyzer_SetAutoBurstTypeDetection($$GSM,$$DUT,$$AutoBurstMode);"
  ],
  "description": "\n\nThis function sets the automatic burst type detection mode for the specified device under test (DUT). When automatic mode is enabled, the burst type is detected from the burst analysis.\n\nThe GSM measurement library currently supports a single DUT. The DUT index is zero-based (i.e. 0 signifies DUT1). If support for multiple DUTs is added in the future, then an index of 1 would apply for DUT2, 2 for DUT3, and so on.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$GSM\n\nObject\n\nGSM Analysis Object\n\n\n\n$AutoBurstMode\n\nBoolean\n\nThe desired auto burst type detection of the GSM measurement. Supported auto burst detection types are:\n\n\u00b7 true = Automatic burst type detection is enabled for the specified DUT.\n\n\u00b7 false = Automatic burst type detection is disabled for the specified DUT.\n\n\n\n\n\nReturn Values\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n\n\n\n\nAeroflexGSMAnalyzer_SetAutoBurstTypeDetection($GSM,0,$TRUE); /// Configures to enable Auto burst detection;\n\n\n\n\n\nAeroflexGSMAnalyzer_SetAveraging\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AeroFlexGSMAnalyzer_SetAveraging": {
  "prefix": "AeroFlexGSMAnalyzer_SetAveraging",
  "body": [
   "AeroFlexGSMAnalyzer_SetAveraging($$GSM,$$AverageCount);"
  ],
  "description": "\n\nThis function sets the number of averages taken by the digitizer and affects all measurement types that support averaging.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$GSM\n\nObject\n\nGSM Analysis Object\n\n\n\n$AverageCount\n\nInteger\n\nThe number of averages\n\n\n\n\n\nReturn Values\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\nAeroFlexGSMAnalyzer_SetAveraging($GSM,20);\n\n\n\n\n\nAeroflexGSMAnalyzer_SetBERBurstFrameToTest\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AeroflexGSMAnalyzer_SetBERBurstFrameToTest": {
  "prefix": "AeroflexGSMAnalyzer_SetBERBurstFrameToTest",
  "body": [
   "AeroflexGSMAnalyzer_SetBERBurstFrameToTest($$GSM,$$BERBurstFrames);"
  ],
  "description": "\n\n\n\n\n\nSets the BER burst frames to test.\n\nThe minimum is 1, the maximum is 1000 frames and default is 100 frames ;\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$GSM\n\nObject\n\nGSM Analysis Object\n\n\n\n$BERBurstFrames\n\nInteger\n\nNumber of BER burst frames to test\n\n\n\n\n\nReturn Values\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\nAeroflexGSMAnalyzer_SetBERBurstFrameToTest($GSM,200); // Sets BER burst frames to test to 200;\n\n\n\n\n\nAeroflexGSMAnalyzer_SetBERSpeechFramesToTest\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AeroflexGSMAnalyzer_SetBERSpeechFramesToTest": {
  "prefix": "AeroflexGSMAnalyzer_SetBERSpeechFramesToTest",
  "body": [
   "AeroflexGSMAnalyzer_SetBERSpeechFramesToTest($$GSM,$$BERSpeechFrames);"
  ],
  "description": "\n\n\n\n\n\nSets the BER speech frames to test.\n\nThe minimum is 1, the maximum is 250frames and default is 25 frames ;\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$GSM\n\nObject\n\nGSM Analysis Object\n\n\n\n$BERSpeechFrames\n\nInteger\n\nNumber of BER speech frames to test\n\n\n\n\n\nReturn Values\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\nAeroflexGSMAnalyzer_SetBERSpeechFramesToTest($GSM,50); // Sets BER speech frames to test to 50;\n\n\n\n\n\nAeroflexGSMAnalyzer_SetBand\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AeroFlexGSMAnalyzer_SetBand": {
  "prefix": "AeroFlexGSMAnalyzer_SetBand",
  "body": [
   "AeroFlexGSMAnalyzer_SetBand($$GSM,$$Band);"
  ],
  "description": "\n\nThis function sets the system band used by the measurement object. The following table provides a summary of the relationship between system band, power control level, and ARFCN channels frequencies:\n\n\n\nSystem Band\n\nPower\n\nControl\n\nLevel\n\nOutput Power (dBm)\n\nARFCN\n\nUplink Frequency (MHz)\n\n\n\nGSM400\n\n0-31\n\n39 - 5\n\n259 - 293\n\n306 - 340\n\n450.6 - 457.4\n\n479.0 - 485.8\n\n\n\nGSM700\n\n0-31\n\n39 - 5\n\n438 - 511\n\n747.2 - 761.8\n\n\n\nGSM850\n\n0-31\n\n39 - 5\n\n128 - 251\n\n824.2 - 848.8\n\n\n\nGSM900\n\n0-31\n\n39 - 5\n\n0 - 124\n\n975 - 1023\n\n890.0 - 914.8\n\n880.2 - 889.8\n\n\n\nDCS1800\n\n0-31\n\n36 - 0\n\n512 - 885\n\n1710.2 - 1784.8\n\n\n\nPCS1900 "
 }
,
 "JTS AeroflexGSMAnalyzer_SetBurstType": {
  "prefix": "AeroflexGSMAnalyzer_SetBurstType",
  "body": [
   "AeroflexGSMAnalyzer_SetBurstType($$GSM,$$DUT,$$BurstType);"
  ],
  "description": "\n\n\n\n\n\nSet the burst type for the specified device under test (DUT).\n\nThe allowed burst types are EDGE, NORNAL and ACCESS;\n\nThe GSM measurement library currently supports a single DUT. The DUT index is zero-based (i.e. 0 signifies DUT1). If support for multiple DUTs is added in the future, then an index of 1 would apply for DUT2, 2 for DUT3, and so on.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$GSM\n\nObject\n\nGSM Analysis Object\n\n\n\n$DUT\n\nInteger\n\nThe DUT number for configuring the anticipated burst type.\n\n\n\n$BurstType\n\nString\n\nThe desired burst type of the GSM measurement system. Supported burst types are:\n\n\u00b7 \"EDGE\"\n\n\u00b7 \"NORMAL\"\n\n\u00b7 \"ACCESS\"\n\n\n\n\n\nReturn Values\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n\n\n\n\nAeroflexGSMAnalyzer_SetBurstType($GSM,0,$EDGE); /// Configures EDGE burst type\n\n\n\n\n\nAeroflexGSMAnalyzer_SetDUTTimeSlot\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AeroflexGSMAnalyzer_SetDUTTimeslot": {
  "prefix": "AeroflexGSMAnalyzer_SetDUTTimeslot",
  "body": [
   "AeroflexGSMAnalyzer_SetDUTTimeslot($$GSM,$$DUT,$$Timeslot);"
  ],
  "description": "\n\nSets/gets the time slot to be tested for the specified device under test (DUT). Setting the time slot to -1 signifies any time slot.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$GSM\n\nObject\n\nGSM Analysis Object\n\n\n\n$DUT\n\nInteger\n\nThe DUT index for configuring the timeslot. (Note: Aeroflex API only supports 0 at the moment)\n\n\n\n$Timeslot\n\nInteger\n\nThe time slot to be tested\n\n\n\n\n\nReturn Values\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n\n\n\n\nAeroflexGSMAnalyzer_SetDUTTimeslot($GSM,0,0); // Sets DUT to 0 and Timeslot to 0\n\n\n\n\n\nAeroflexGSMAnalyzer_SetDigitizerFrequency\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AeroFlexGSMAnalyzer_SetDigitizerFrequency": {
  "prefix": "AeroFlexGSMAnalyzer_SetDigitizerFrequency",
  "body": [
   "AeroFlexGSMAnalyzer_SetDigitizerFrequency($$GSM,$$Frequency);"
  ],
  "description": "\n\n\n\nThis function sets the digitizer frequency in (hertz).\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$GSM\n\nObject\n\nGSM Analysis Object\n\n\n\n$Frequency\n\nFloat\n\nThe desired frequency of the digitizer\n\n\n\n\n\nReturn Values\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\nAeroFlexGSMAnalyzer_SetDigitizerFrequency($GSM,1555000);\n\n\n\n\n\nAeroflexGSMAnalyzer_SetDownlinkTSC\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AeroflexGSMAnalyzer_SetDownlinkTSC": {
  "prefix": "AeroflexGSMAnalyzer_SetDownlinkTSC",
  "body": [
   "AeroflexGSMAnalyzer_SetDownlinkTSC($$GSM,,$$DownlinkTSC);"
  ],
  "description": "\n\nSets downlink training sequence code code to be used for GSM measurements.\n\n\n\n\n\n(Not to be confused with the DUT TSC code... see the AeroflexGSMAnalyzer_SetTSC function for details)\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$GSM\n\nObject\n\nGSM Analysis Object\n\n\n\n$DownlinkTSC\n\nInteger\n\nThe timeslot to be generated for the downlink TSC.\n\n\n\n\n\nReturn Values\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n\n\n\n\nAeroflexGSMAnalyzer_SetDownlinkTSC($GSM,0); // Sets the TSC to Time Slot 0;\n\n\n\n\n\nAeroflexGSMAnalyzer_SetEnabledMeasurements\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AeroFlexGSMAnalyzer_SetEnabledMeasurement": {
  "prefix": "AeroFlexGSMAnalyzer_SetEnabledMeasurement",
  "body": [
   "AeroFlexGSMAnalyzer_SetEnabledMeasurement($$GSMAnalyzer,$$MeasurementType,$$Enabled);"
  ],
  "description": "\n\n\n\nThis function sets the given measurement type to enabled or disabled depending on the value supplied for the $Enabled parameter.\n\n\n\n\n\nWithin the GSM measurement library, there are a range of available measurements that may be performed. One or more of these measurements may therefore be enabled, however, the more measurements that are enabled will increase the duration required to complete the measurement due to the additional analysis time required.\n\n\n\nThe default setting is that all measurements are disabled, and the order in which specific measurements are enabled or disabled is immaterial and has no effect.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$GSMAnalyzer\n\nObject\n\nGSM Analysis Object\n\n\n\n$MeasurementType\n\nString\n\nThe desired measurement type. Valid values are:\n\n\u00b7 \"ALL\"\n\n\u00b7 \"BER\"\n\n\u00b7 \"BURSTPOWER\"\n\n\u00b7 \"BURSTPOWERAVG\"\n\n\u00b7 \"BURSTPOWERMAX\"\n\n\u00b7 \"BURSTPOWERMIN\"\n\n\u00b7 \"BURSTTIMINGERROR\"\n\n\u00b7 \"BURSTTIMINGERRORAVG\"\n\n\u00b7 \"BURSTTIMINGERRORMAX\"\n\n\u00b7 \"BURSTTIMINGERRORMIN\"\n\n\u00b7 \"BURSTTYPE\"\n\n\u00b7 \"CAPTUREPOWERVSTIME\"\n\n\u00b7 \"EDGEDROOP\"\n\n\u00b7 \"EDGEDROOPAVG\"\n\n\u00b7 \"EDGEDROOPMAX\"\n\n\u00b7 \"EDGEDROOPMIN\"\n\n\u00b7 \"EDGEOOSSUPPRESSION\"\n\n\u00b7 \"EDGEOOSSUPPRESSIONAVG\"\n\n\u00b7 \"EDGEOOSSUPPRESSIONMIN\"\n\n\u00b7 \"EDGEOOSSUPPRESSIONMAX\"\n\n\u00b7 \"EDGEPERCENTILE\"\n\n\u00b7 \"FASTBURSTPOWER\"\n\n\u00b7 \"FASTBURSTPOWERAVG\"\n\n\u00b7 \"FASTBURSTPOWERMAX\"\n\n\u00b7 \"FASTBURSTPOWERMIN\"\n\n\u00b7 \"MODACCEVMMAX\"\n\n\u00b7 \"MODACCEVMMAXMAX\"\n\n\u00b7 \"MODACCEVMMIN\"\n\n\u00b7 \"MODACCEVMMINMIN\"\n\n\u00b7 \"MODACCEVMPEAK\"\n\n\u00b7 \"MODACCEVMPEAKAVG\"\n\n\u00b7 \"MODACCEVMPEAKMAX\"\n\n\u00b7 \"MODACCEVMPEAKMIN\"\n\n\u00b7 \"MODACCEVMRMS\"\n\n\u00b7 \"MODACCEVMRMSAVG\"\n\n\u00b7 \"MODACCEVMRMSMAX\"\n\n\u00b7 \"MODACCEVMRMSMIN\"\n\n\u00b7 \"MODACCEVMVSTIME\"\n\n\u00b7 \"MODACCEVMVSTIMEAVG\"\n\n\u00b7 \"MODACCEVMVSTIMEMAX\"\n\n\u00b7 \"MODACCEVMVSTIMEMIN\"\n\n\u00b7 \"MODACCFREQERROR\"\n\n\u00b7 \"MODACCFREQERRORAVG\"\n\n\u00b7 \"MODACCFREQERRORMAX\"\n\n\u00b7 \"MODACCFREQERRORMIN\"\n\n\u00b7 \"MODACCPHASEERRORMAX\"\n\n\u00b7 \"MODACCPHASEERRORMIN\"\n\n\u00b7 \"MODACCPHASEERRORMINMIN\"\n\n\u00b7 \"MODACCPHASEERRORPEAK\"\n\n\u00b7 \"MODACCPHASEERRORPEAKAVG\"\n\n\u00b7 \"MODACCPHASEERRORPEAKMAX\"\n\n\u00b7 \"MODACCPHASEERRORPEAKMIN\"\n\n\u00b7 \"MODACCPHASEERRORRMS\"\n\n\u00b7 \"MODACCPHASEERRORRMSAVG\"\n\n\u00b7 \"MODACCPHASEERRORRMSMAX\"\n\n\u00b7 \"MODACCPHASEERRORRMSMIN\"\n\n\u00b7 \"MODACCPHASEERRORRVSTIME\"\n\n\u00b7 \"MODACCPHASEERRORRVSTIMEAVG\"\n\n\u00b7 \"MODACCPHASEERRORRVSTIMEMAX\"\n\n\u00b7 \"MODACCPHASEERRORRVSTIMEMIN\"\n\n\u00b7 \"ORFSMODULATIONPOWERVSFREQ\"\n\n\u00b7 \"ORFSMODULATIONPOWERVSFREQAVG\"\n\n\u00b7 \"ORFSMODULATIONPOWERVSFREQMAX\"\n\n\u00b7 \"ORFSMODULATIONPOWERVSFREQMIN\"\n\n\u00b7 \"POWERFALLINGVSTIME\"\n\n\u00b7 \"POWERFALLINGVSTIMEAVG\"\n\n\u00b7 \"POWERFALLINGVSTIMEMASKLOWERLIMIT\"\n\n\u00b7 \"POWERFALLINGVSTIMEMASKUPPERLIMIT\"\n\n\u00b7 \"POWERFALLINGVSTIMEMAX\"\n\n\u00b7 \"POWERFALLINGVSTIMEMIN\"\n\n\u00b7 \"POWERFALLINGVSTIMEPASSFAIL\"\n\n\u00b7 \"POWERRISINGINGVSTIME\"\n\n\u00b7 \"POWERRISINGINGVSTIMEAVG\"\n\n\u00b7 \"POWERRISINGINGVSTIMEMASKLOWERLIMIT\"\n\n\u00b7 \"POWERRISINGINGVSTIMEMASKUPPERLIMIT\"\n\n\u00b7 \"POWERRISINGINGVSTIMEMAX\"\n\n\u00b7 \"POWERRISINGINGVSTIMEMIN\"\n\n\u00b7 \"POWERRISINGINGVSTIMEPASSFAIL\"\n\n\u00b7 \"POWERUSEFULVSTIME\"\n\n\u00b7 \"POWERUSEFULVSTIMEAVG\"\n\n\u00b7 \"POWERUSEFULVSTIMEMASKLOWERLIMIT\"\n\n\u00b7 \"POWERUSEFULVSTIMEMASKUPPERLIMIT\"\n\n\u00b7 \"POWERUSEFULVSTIMEMAX\"\n\n\u00b7 \"POWERUSEFULVSTIMEMIN\"\n\n\u00b7 \"POWERUSEFULVSTIMEPASSFAIL\"\n\n\u00b7 \"POWERVSFREQ\"\n\n\u00b7 \"POWERVSFREQAVG\"\n\n\u00b7 \"POWERVSFREQMAX\"\n\n\u00b7 \"POWERVSFREQMIN\"\n\n\u00b7 \"POWERVSTIME\"\n\n\u00b7 \"POWERVSTIMEAVG\"\n\n\u00b7 \"POWERVSTIMEMASKLOWERLIMIT\"\n\n\u00b7 \"POWERVSTIMEMASKUPPERLIMIT\"\n\n\u00b7 \"POWERVSTIMEMAX\"\n\n\u00b7 \"POWERVSTIMEMIN\"\n\n\u00b7 \"POWERVSTIMEPASSFAIL\"\n\n\u00b7 \"TSC\"\n\n\n\n$Enabled\n\nBoolean\n\nA true/false value indicating whether or not the measurement should be enabled.\n\n\n\n\n\nExample:\n\n\n\n\n\nAeroFlexGSMAnalyzer_SetEnabledMeasurement($GSMAnalyzer,\"BURSTPOWER\",true);\n\n\n\n\n\nAeroflexGSMAnalyzer_SetHeadroomLevel\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AeroFlexGSMAnalyzer_SetHeadroomLevel": {
  "prefix": "AeroFlexGSMAnalyzer_SetHeadroomLevel",
  "body": [
   "AeroFlexGSMAnalyzer_SetHeadroomLevel($$GSM,$$HeadroomLevel);"
  ],
  "description": "\n\n\n\nThis function sets the headroom level specified in dB.\n\nWhen a measurement is performed, the signal's peak power may tend to be higher than the RMS power level as specified for the device under test (specified by the reference level). Therefore, upon performing the measurement, an ADC overload may occur. To help ensure that the ADC does not overload, this difference between peak power and RMS power level may be accommodated by specifying the headroom level.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$GSM\n\nObject\n\nGSM Analysis Object\n\n\n\n$HeadroomLevel\n\nFloat\n\nThe headroom level specified in dB\n\n\n\n\n\nReturn Values\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\nAeroFlexGSMAnalyzer_SetHeadroomLevel($GSM,2); // Sets Headroom level to 2dB\n\n\n\n\n\nAeroflexGSMAnalyzer_SetHighPowerCCH\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AeroflexGSMAnalyzer_SetHighPowerCCH": {
  "prefix": "AeroflexGSMAnalyzer_SetHighPowerCCH",
  "body": [
   "AeroflexGSMAnalyzer_SetHighPowerCCH($$GSM,$$Highpower);"
  ],
  "description": "\n\nThis function sets the High Power CCH mode. This ensures the first timeslot is transmitted at 20dB higher than the other timeslots in the frame. This helps with synchronization.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$GSM\n\nObject\n\nGSM Analysis Object\n\n\n\n$Highpower\n\nBoolean\n\nSets High Power CCH mode.\n\n\u00b7 True = High power CCH mode is enabled.\n\n\u00b7 False = High power CCH mode is disabled.\n\n\n\n\n\nReturn Values\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n\n\n\n\nAeroflexGSMAnalyzer_SetHighPowerCCH($GSM,$TRUE); /// Configures to enable High power CCH mode;\n\n\n\n\n\nAeroflexGSMAnalyzer_SetInputOffset\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AeroFlexGSMAnalyzer_SetInputOffset": {
  "prefix": "AeroFlexGSMAnalyzer_SetInputOffset",
  "body": [
   "AeroFlexGSMAnalyzer_SetInputOffset($$GSM,$$InputOffset);"
  ],
  "description": "\n\n\n\nSets the input offset in dB that will be applied to the measurement library to accommodate a simple loss model between the DUT and the digitizer input.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$GSM\n\nObject\n\nGSM Analysis Object\n\n\n\n$InputOffset\n\nFloat\n\nThe input offset specified in dB.\n\n\n\n\n\nReturn Values\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n\n\n\n\nAeroFlexGSMAnalyzer_SetInputOffset($GSM,18); // Sets the input offset to the Digitizer\n\n\n\n\n\nAeroflexGSMAnalyzer_SetLoopbackMode\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AeroflexGSMAnalyzer_SetLoopbackMode": {
  "prefix": "AeroflexGSMAnalyzer_SetLoopbackMode",
  "body": [
   "AeroflexGSMAnalyzer_SetLoopbackMode($$GSM,$$LoopbackMode);"
  ],
  "description": "\n\nThis function sets the loopback mode to either A/B or C.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$GSM\n\nObject\n\nGSM Analysis Object\n\n\n\n$LoopbackMode\n\nString\n\nThe desired loopback mode of operation. Supported values are:\n\n\u00b7 \"SPEECH \" for mode A/B.\n\n\u00b7 \"BURST\" for Mode C.\n\n\n\n\n\nReturn Values\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\nAeroFlexGSMAnalyzer_SetAttenuatorMode($GSM,\"BURST\"); // Configures loop back mode C.\n\n\n\n\n\nAeroflexGSMAnalyzer_SetMeasurementRunMode\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AeroflexGSMAnalyzer_SetMeasurementRunMode": {
  "prefix": "AeroflexGSMAnalyzer_SetMeasurementRunMode",
  "body": [
   "AeroflexGSMAnalyzer_SetMeasurementRunMode($$GSM,$$RunMode);"
  ],
  "description": "\n\nSets the measurement run mode.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$GSM\n\nObject\n\nGSM Analysis Object\n\n\n\n$RunMode\n\nString\n\nThe desired auto burst type detection of the GSM measurement. Supported run modes are:\n\n\u00b7 \"SINGLE\" Takes one measurement.\n\n\u00b7 \"CONTINUOUS\" Repeats measurement.\n\n\n\n\n\nReturn Values\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n\n\n\n\nAeroflexGSMAnalyzer_SetMeasurementRunMode($GSM,\"CONTINUOUS\"); // Configures repeat measurement.\n\n\n\n\n\nAeroflexGSMAnalyzer_SetMinCaptureTime\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AeroFlexGSMAnalyzer_SetMinCaptureTime": {
  "prefix": "AeroFlexGSMAnalyzer_SetMinCaptureTime",
  "body": [
   "AeroFlexGSMAnalyzer_SetMinCaptureTime($$GSM,$$MinCaptureTime);"
  ],
  "description": "\n\n\n\nThis function sets the minimum capture time in seconds. This value should be set long enough to guarantee finding a complete RF burst to analyze. This property is referred to as 'Search Length' in certain portions of the Aeroflex documentation, as well as PXI Studio.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$GSM\n\nObject\n\nGSM Analysis Object\n\n\n\n$MinCaptureTime\n\nFloat\n\nThe minimum capture time after a trigger event occurs.\n\nMinimum Value = 0.0 s\n\nMaximum Value = 1.0s\n\nDefault Value = 0.0053s (capture 1 frame+1 slot)\n\n\n\n\n\nReturn Values\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n\n\n\n\nAeroFlexGSMAnalyzer_SetMinCaptureTime($GSM,0.500); // sets minimum capture time to 500 milliseconds.\n\n\n\n\n\nAeroflexGSMAnalyzer_SetORFSSpectrumFrequency\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AeroFlexGSMAnalyzer_SetORFSSpectrumFrequency": {
  "prefix": "AeroFlexGSMAnalyzer_SetORFSSpectrumFrequency",
  "body": [
   "AeroFlexGSMAnalyzer_SetORFSSpectrumFrequency($$GSM,$$FrequencyArray);"
  ],
  "description": "\n\nThis function sets the analysis frequencies used for the ORFS readings. The $FrequencyArray argument is a 1D array containing the spectrum frequencies to be measured expressed in Hertz.\n\nNote: The frequency array must begin at 0 Hertz.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$GSM\n\nObject\n\nGSM Analysis Object\n\n\n\n$FrequencyArray\n\nArray\n\nThe desired ORFS spectrum frequencies for measurement.\n\n\n\n\n\nReturn Values\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n\n\n\n\n$Array = Array_Create(\"Integer\",5,1);\n\nArray_SetValue($Array,1,0,0);\n\nArray_SetValue($Array,1,1,-200000);\n\nArray_SetValue($Array,1,2,200000);\n\nArray_SetValue($Array,1,3,-400000);\n\nArray_SetValue($Array,1,4,400000);\n\n\n\n\n\nAeroFlexGSMAnalyzer_SetORFSSpectrumFrequency($GSM,$Array);\n\n// Sets the ORFS frequencies to 0,-200K,200K,-400K,400K\n\n\n\n\n\nAeroflexGSMAnalyzer_SetOutputOffset\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AeroFlexGSMAnalyzer_SetOutputOffset": {
  "prefix": "AeroFlexGSMAnalyzer_SetOutputOffset",
  "body": [
   "AeroFlexGSMAnalyzer_SetOutputOffset($$GSM,$$OutputOffset);"
  ],
  "description": "\n\n\n\nSets the output offset in dB that will be applied to the measurement library to accommodate a simple loss model between the DUT and the signal generator output.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$GSM\n\nObject\n\nGSM Analysis Object\n\n\n\n$OutputOffset\n\nFloat\n\nThe output offset specified in dB.\n\n\n\n\n\nReturn Values\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n\n\n\n\nAeroFlexGSMAnalyzer_SetOutputOffset($GSM,6); // Sets the output offset to the Signal Generator\n\n\n\n\n\nAeroflexGSMAnalyzer_SetPCLLevel\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AeroFlexGSMAnalyzer_SetPCLLevel": {
  "prefix": "AeroFlexGSMAnalyzer_SetPCLLevel",
  "body": [
   "AeroFlexGSMAnalyzer_SetPCLLevel($$GSM,$$PCLLevel);"
  ],
  "description": "\n\n\n\nThis function sets the power control level.\n\nThis property defines the nominal power control level setting of the mobile being analysed. When used in conjunction with the system band setting, it defines the power profile template mask that is used when burst modulation analysis is performed. The power control level can be set within the range 0 to 31, according to the following table.\n\nThe table provides a summary of the relationship between system band, power control level, absolute radio frequency channel number (ARFCN) and uplink frequency ranges.\n\nNote: This function needs to be used in conjunction with the 'SetBand' function in order to properly apply the power level. The AeroflexGSMAnalyzer_SetBand command should be run before setting the PCL level.\n\nSystem Band\n\nPower\n\nControl\n\nLevel\n\nOutput Power (dBm)\n\nARFCN\n\nUplink Frequency (MHz)\n\n\n\nGSM400\n\n0-31\n\n39 - 5\n\n259 - 293\n\n306 - 340\n\n450.6 - 457.4\n\n479.0 - 485.8\n\n\n\nGSM700\n\n0-31\n\n39 - 5\n\n438 - 511\n\n747.2 - 761.8\n\n\n\nGSM850\n\n0-31\n\n39 - 5\n\n128 - 251\n\n824.2 - 848.8\n\n\n\nGSM900\n\n0-31\n\n39 - 5\n\n0 - 124\n\n975 - 1023\n\n890.0 - 914.8\n\n880.2 - 889.8\n\n\n\nDCS1800\n\n0-31\n\n36 - 0\n\n512 - 885\n\n1710.2 - 1784.8\n\n\n\nPCS1900 "
 }
,
 "JTS AeroFlexGSMAnalyzer_SetPowerVsFreqRBW": {
  "prefix": "AeroFlexGSMAnalyzer_SetPowerVsFreqRBW",
  "body": [
   "AeroFlexGSMAnalyzer_SetPowerVsFreqRBW($$GSM,$$ResolutionBandwidth);"
  ],
  "description": "\n\nThis function sets the resolution bandwidth for the power vs. frequency measurement.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$GSM\n\nObject\n\nGSM Analysis Object\n\n\n\n$ResolutionBandwidth\n\nInteger\n\nThe resolution bandwidth. Allowable values are 10kHz, 30kHz, and 100 kHz.\n\n\n\n\n\nReturn Values\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n\n\n\n\nAeroFlexGSMAnalyzer_SetPowerVsFreqRBW($GSM,30000); // Sets RBW to 30kHz.\n\n\n\n\n\nAeroflexGSMAnalyzer_SetPowerVsFreqSpan\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AeroFlexGSMAnalyzer_SetPowerVsFreqSpan": {
  "prefix": "AeroFlexGSMAnalyzer_SetPowerVsFreqSpan",
  "body": [
   "AeroFlexGSMAnalyzer_SetPowerVsFreqSpan($$GSM,$$Span);"
  ],
  "description": "\n\nThis function sets the span for the power vs. frequency measurement.\n\nThe minimum possible value is 500kHz and the maximum value is 10.0MHz\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$GSM\n\nObject\n\nGSM Analysis Object\n\n\n\n$Span\n\nFloat\n\nThe desired span for the Power vs. Frequency Measurement.\n\n\n\n\n\nReturn Values\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n\n\n\n\nAeroFlexGSMAnalyzer_SetPowerVsFreqSpan($GSM,500000); // Sets span to 500kHz.\n\n\n\n\n\nAeroflexGSMAnalyzer_SetReferenceLevel\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AeroFlexGSMAnalyzer_SetReferenceLevel": {
  "prefix": "AeroFlexGSMAnalyzer_SetReferenceLevel",
  "body": [
   "AeroFlexGSMAnalyzer_SetReferenceLevel($$GSM,$$ReferenceLevel);"
  ],
  "description": "\n\n\n\nThis command sets the reference level of the digitizer. Note that the attenuator has two modes of control, both an automatic and manual mode. In automatic mode, setting the reference level automatically sets an appropriate value for the attenuator. In manual mode, the user must set both the reference level and the attenuation level.\n\nThe reference level is specified in dBm.\n\n\n\n\n\nImportant Note:\n\n\n\nPlease be aware that when using the attenuator in a manual mode it may be possible to damage the test equipment if the reference level and the attenuator mode are not properly set in the correct order with a high input power applied to the RF digitizer input.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$GSM\n\nObject\n\nGSM Analysis Object\n\n\n\n$ReferenceLevel\n\nFloat\n\nThe reference level specified in dBm.\n\n\n\n\n\nReturn Values\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n\n\n\n\nAeroFlexGSMAnalyzer_SetReferenceLevel($GSM,15); // Sets Reference level to 15dBm.\n\n\n\n\n\nAeroflexGSMAnalyzer_SetReferenceLevelMode\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AeroFlexGSMAnalyzer_SetReferenceLevelMode": {
  "prefix": "AeroFlexGSMAnalyzer_SetReferenceLevelMode",
  "body": [
   "AeroFlexGSMAnalyzer_SetReferenceLevelMode($$GSM,$$Mode);"
  ],
  "description": "\n\n\n\nThis command sets the mode of controlling the reference level between manual mode and PCL mode.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$GSM\n\nObject\n\nGSM Analysis Object\n\n\n\n$Mode\n\nString\n\nThe desired mode of reference level operation:\n\n\u00b7 \"MANUAL\"\n\n\u00b7 \"PCL\"\n\n\n\n\n\nReturn Values\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n\n\n\n\nAeroFlexGSMAnalyzer_SetReferenceLevelMode($GSM,\"MANUAL\"); // Sets Reference level mode to manual\n\n\n\n\n\nAeroflexGSMAnalyzer_SetSignalGeneratorARBFile\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AeroflexGSMAnalyzer_SetSignalGeneratorARBFile": {
  "prefix": "AeroflexGSMAnalyzer_SetSignalGeneratorARBFile",
  "body": [
   "AeroflexGSMAnalyzer_SetSignalGeneratorARBFile($$GSM,$$AIQFilePath);"
  ],
  "description": "\n\n\n\nThis sets the filename and path for the AIQ file to be played back by the signal generator for BER testing.\n\n\n\n\n\nIf the file is not found, or is an invalid format, the function will generate a failing test result.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$GSM\n\nObject\n\nGSM Analysis Object\n\n\n\n$AIQFilePath\n\nString\n\nThe filename and path to the AIQ File\n\n\n\n\n\nReturn Values\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n\n\n\n\nAeroflexGSMAnalyzer_SetSignalGeneratorARBFile($GSM,\"c:\\\\testfiles\\\\berfile.aiq\");\n\n\n\n\n\nAeroflexGSMAnalyzer_SetSignalGeneratorFrequency\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AeroflexGSMAnalyzer_SetSignalGeneratorFrequency": {
  "prefix": "AeroflexGSMAnalyzer_SetSignalGeneratorFrequency",
  "body": [
   "AeroflexGSMAnalyzer_SetSignalGeneratorFrequency($$GSM,$$Frequency);"
  ],
  "description": "\n\n\n\n\n\nThis function sets the signal generator frequency in (hertz).\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$GSM\n\nObject\n\nGSM Analysis Object\n\n\n\n$Frequency\n\nFloat\n\nThe desired frequency of the signal generator.\n\n\n\n\n\nReturn Values\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\nAeroflexGSMAnalyzer_SetSignalGeneratorFrequency($GSM,836600000); // set signal generator to 836.6MHz.\n\n\n\n\n\nAeroflexGSMAnalyzer_SetSignalGeneratorLevel\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AeroflexGSMAnalyzer_SetSignalGeneratorLevel": {
  "prefix": "AeroflexGSMAnalyzer_SetSignalGeneratorLevel",
  "body": [
   "AeroflexGSMAnalyzer_SetSignalGeneratorLevel($$GSM,$$Level);"
  ],
  "description": "\n\n\n\nThis function sets the signal generator in (dBm).\n\n\n\n\n\nNotes:\n\nMinimum and maximum is depended on the model.\n\n\n\n< 3GHz\n\n> 3GHz\n\n\n\nMin\n\n-120.0dBm\n\n3020A: N/A\n\n3020C: N/A\n\n3025: -120.0dBm\n\n43025C: -120.0dBm\n\n\n\nMax\n\n3020A: +5.0dBm\n\n3020C: +6.0dBm\n\n3025: +5.0dBm\n\n3025C: +6.0dBm.\n\n3020A: N/A\n\n3020C: N/A\n\n3025: 0dBm\n\n3025C: +1dBm\n\n\n\nDefault\n\n0.0 dBm\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$GSM\n\nObject\n\nGSM Analysis Object\n\n\n\n$Level\n\nFloat\n\nThe desired level dBm of the signal generator.\n\n\n\n\n\nReturn Values\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\nAeroflexGSMAnalyzer_SetSignalGeneratorLevel($GSM,-15); // set signal generator to-15dBm.\n\n\n\n\n\nAeroflexGSMAnalyzer_SetTSC\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AeroflexGSMAnalyzer_SetTSC": {
  "prefix": "AeroflexGSMAnalyzer_SetTSC",
  "body": [
   "AeroflexGSMAnalyzer_SetTSC($$GSM,$$DUT,$$TSC);"
  ],
  "description": "\n\nThis function sets the training sequence code (TSC) of the specified device under test (DUT). Analysis of GSM and EDGE bursts requires the TSC to be set.\n\nFor GSM bursts, the range of values that TSC may be set to is 0 to 7. Access bursts are represented by 8. EDGE bursts allow a range from 0 to 7.\n\nThe GSM measurement library currently supports a single DUT. The DUT index is zero-based (i.e. 0 signifies DUT1). If support for multiple DUTs is added in the future, then an index of 1 would apply for DUT2, 2 for DUT3, and so on.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$GSM\n\nObject\n\nGSM Analysis Object\n\n\n\n$DUT\n\nInteger\n\nThe DUT index for configuring the training sequence code (Note: Aeroflex API only supports 0 at the moment)\n\n\n\n$Timeslot\n\nInteger\n\nThe anticipated time slot for the DUT.\n\n\n\n\n\nReturn Values\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n\n\n\n\nAeroflexGSMAnalyzer_SetTSC($GSM,0,0); // Sets DUT to 0 and TSC to 0\n\n\n\n\n\nAeroflexGSMAnalyzer_SetTriggerDelay\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AeroFlexGSMAnalyzer_SetTriggerDelay": {
  "prefix": "AeroFlexGSMAnalyzer_SetTriggerDelay",
  "body": [
   "AeroFlexGSMAnalyzer_SetTriggerDelay($$GSM,$$TriggerDelay);"
  ],
  "description": "\n\n\n\nSets the trigger delay in seconds.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$GSM\n\nObject\n\nGSM Analysis Object\n\n\n\n$TriggerDelay\n\nFloat\n\nThe trigger delay specified in seconds. Allowable values range from 0 to 10000.\n\n\n\n\n\nReturn Values\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n\n\n\n\nAeroFlexGSMAnalyzer_SetTriggerDelay($GSM,0.0500); // Sets trigger delay to 50 Milliseconds.\n\n\n\n\n\nAeroflexGSMAnalyzer_SetTriggerLevel\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AeroFlexGSMAnalyzer_SetTriggerLevel": {
  "prefix": "AeroFlexGSMAnalyzer_SetTriggerLevel",
  "body": [
   "AeroFlexGSMAnalyzer_SetTriggerLevel($$GSM,$$TriggerLevel);"
  ],
  "description": "\n\n\n\nSets the burst trigger level threshold specified in dBm.\n\nImportant Notes:\n\nNotes: \u00b7\n\nThe Burst trigger source corresponds to the 303x Internal trigger source.\n\n\n\n\n\n\u00b7\n\nThe measurement starts in synchronization with the rising edge of the signal when it exceeds the trigger threshold level.\n\n\n\n\n\n\u00b7\n\nBurst trigger is not available when the measurement span exceeds two-thirds of the IF bandwidth. The conflict handling mechanism will therefore report appropriately if this situation applies.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$GSM\n\nObject\n\nGSM Analysis Object\n\n\n\n$TriggerLevel\n\nFloat\n\nThe trigger level specified in dBm\n\n\n\n\n\nReturn Values\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n\n\n\n\nAeroFlexGSMAnalyzer_SetTriggerLevel($GSM,10); // Sets trigger level to 10 dBm\n\n\n\n\n\nAeroflexGSMAnalyzer_SetTriggerPolarity\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AeroFlexGSMAnalyzer_SetTriggerPolarity": {
  "prefix": "AeroFlexGSMAnalyzer_SetTriggerPolarity",
  "body": [
   "AeroFlexGSMAnalyzer_SetTriggerPolarity($$GSM,$$TriggerPolarity);"
  ],
  "description": "\n\n\n\nSets the trigger polarity to control whether the instrument is triggered on the rising or falling edge of the signal.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$GSM\n\nObject\n\nGSM Analysis Object\n\n\n\n$TriggerPolarity\n\nString\n\nThe desired trigger polarity. Supported values are:\n\n\u00b7 \"POSITIVE\"\n\n\u00b7 \"NEGATIVE\"\n\n\n\n\n\nReturn Values\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n\n\n\n\nAeroFlexGSMAnalyzer_SetTriggerPolarity($GSM,\"POSITIVE\"); // Sets trigger to rising edge triggering.\n\n\n\n\n\nAeroflexGSMAnalyzer_SetTriggerSource\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AeroFlexGSMAnalyzer_SetTriggerSource": {
  "prefix": "AeroFlexGSMAnalyzer_SetTriggerSource",
  "body": [
   "AeroFlexGSMAnalyzer_SetTriggerSource($$GSM,$$TriggerSource);"
  ],
  "description": "\n\n\n\nThis function sets the trigger source of the GSM Measurement system.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$GSM\n\nObject\n\nGSM Analysis Object\n\n\n\n$TriggerSource\n\nString\n\nThe desired triggering source of the GSM measurement system. Supported Values are:\n\n\u00b7 \"BURST\"\n\n\u00b7 \"IMMEDIATE\"\n\n\u00b7 \"EXTERNAL\"\n\n\n\n\n\nReturn Values\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n\n\n\n\nAeroFlexGSMAnalyzer_SetTriggerSource($GSM,\"BURST\"); // Configures Burst Triggering.\n\n\n\n\n\nAeroflexGSMAnalyzer_StartMeasurement\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AeroFlexGSMAnalyzer_StartMeasurement": {
  "prefix": "AeroFlexGSMAnalyzer_StartMeasurement",
  "body": [
   "AeroFlexGSMAnalyzer_StartMeasurement($$GSM);"
  ],
  "description": "\n\n\n\nThis functions starts all the current measurement types that have been enabled using the AeroflexGSMAnalyzer_SetEnabledMeasurements command.\n\n\n\n\n\nIf the trigger source is IMMEDIATE, then this starts the measurement immediately.\n\n\n\n\n\nIf the trigger source is EXTERNAL or BURST, then this arms the trigger ready for the measurement to begin.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$GSM\n\nObject\n\nGSM Analysis Object\n\n\n\n\n\nReturn Values\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n\n\n\n\nAeroFlexGSMAnalyzer_StartMeasurement($GSM); // Starts all enabled measurements\n\n\n\n\n\nAeroflexGSMAnalyzer_UnAssignSignalGeneratorByInstance\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AeroflexGSMAnalyzer_UnAssignSignalGeneratorByInstance": {
  "prefix": "AeroflexGSMAnalyzer_UnAssignSignalGeneratorByInstance",
  "body": [
   "AeroflexGSMAnalyzer_UnAssignSignalGeneratorByInstance($$GSM);"
  ],
  "description": "\n\nThis function releases any signal generator from the GSM Measurement system that has been previously assigned using the AeroflexGSMAnalyzer_AssignSignalGeneratorByInstance function.\n\nIn the event that no signal generator has been assigned to the GSM Measurement system, this function will generate a failing test result.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$GSM\n\nObject\n\nGSM Analysis Object\n\n\n\n\n\nReturn Values\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n\n\n\n\nAeroflexGSMAnalyzer_UnAssignSignalGeneratorByInstance($GSM);\n\n\n\n\n\nAeroflexGSMAnalyzer_WaitForMeasurementComplete\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AeroFlexGSMAnalyzer_WaitForMeasurementComplete": {
  "prefix": "AeroFlexGSMAnalyzer_WaitForMeasurementComplete",
  "body": [
   "AeroFlexGSMAnalyzer_WaitForMeasurementComplete($$GSM,$$Timeout,$$PollFrequency);"
  ],
  "description": "\n\n\n\nThis is a convenience function to simplify scripting which waits for the measurement to be completed by the GSM Analysis system before continuing with the test script.\n\n\n\n\n\nIf the measurement does not complete within the time allotted, the function generates a failing test result.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$GSM\n\nObject\n\nGSM Analysis Object\n\n\n\n$Timeout\n\nInteger\n\nThe timeout value specified in seconds.\n\n\n\n$PollFrequency\n\nInteger\n\nThe polling interval specified in milliseconds. A more frequent polling places a higher load on the CPU and PXI bus. but will result in a faster acquisition time.\n\n\n\n\n\nReturn Values\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n\n\n\n\nAeroFlexGSMAnalyzer_WaitForMeasurementComplete($GSM,20,100); // waits a maximum of 20 seconds for the measurement to complete, polls every 100 milliseconds\n\n\n\n\n\nAeroflexGSMAnalyzer_WaitForTSCDetect\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AeroFlexGSMAnalyzer_WaitForTSCDetect": {
  "prefix": "AeroFlexGSMAnalyzer_WaitForTSCDetect",
  "body": [
   "$$TSCDetected=AeroFlexGSMAnalyzer_WaitForTSCDetect($$GSM,$$Timeout,$$PollFrequency);"
  ],
  "description": "\n\n\n\nThis is a convenience function to simplify scripting which waits for the TSC (Training Sequence Code) to be detected by the GSM Analysis system before continuing with the test script. If the TSC is detected in the sample, a value of TRUE is returned, otherwise false. The $Timeout parameter specifies the maximum amount of time that the function will wait looking for the TSC before returning with a value of false. The $PollFrequency parameter sets the delay time between one poll for the TSC to the next attempt at locating the TSC.\n\n\n\n\n\nNote: This function returns a value of True as soon as TSC is detected, regardless of the timeout or polling frequency.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$GSM\n\nObject\n\nGSM Analysis Object\n\n\n\n$Timeout\n\nInteger\n\nThe timeout value specified in seconds.\n\n\n\n$PollFrequency\n\nInteger\n\nThe polling interval specified in milliseconds. A more frequent polling places a higher load on the CPU and PXI bus. but will result in a faster acquisition time.\n\n\n\n\n\nReturn Values\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$TSCDetected\n\nBoolean\n\nReturns True if the TSC is found in the signal, otherwise returns False if no TSC is detected in the allotted timeout period.\n\n\n\n\n\nExample:\n\n\n\n\n\nAeroFlexGSMAnalyzer_WaitForTSCDetect($GSM,20,100); // waits a maximum of 20 seconds to locate TSC, polls every 100 milliseconds\n\n\n\n\n\nArray1DContains\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Array1DContains": {
  "prefix": "Array1DContains",
  "body": [
   "($$found,$$index)=Array1DContains($$array,$$element);"
  ],
  "description": "\n\nThis function will search the supplied array for the specified element and return whether the element was found and the index of the element, if it was found.\n\n\n\n\n\nRemarks:\n\nThe array can be any type of array usable by Jabil Test.\n\nThe array and the element being searched for must be of the same type.\n\nIf the element is not found, the index will be -1.\n\nIf the element appears in more than one location in the array, only the first (lowest) index will be returned.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$array\n\nArray\n\nA 1 dimensional array.\n\n\n\n$element\n\nVaries\n\nThe element to search for in the array. Must be the same type as the array.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$found\n\nBoolean\n\nTrue if the element was found in the array, False otherwise.\n\n\n\n$index\n\nInteger\n\nThe first index in the array where the value was found. If the element is not found, this will be -1.\n\n\n\n\n\nExample:\n\n// Create an Integer array and find a value.\n\n$intArr = Array1DCreate(\"INTEGER\", 7);\n\nArray1DSetValue($intArr, 0, 9);\n\nArray1DSetValue($intArr, 1, 7);\n\nArray1DSetValue($intArr, 2, 8);\n\nArray1DSetValue($intArr, 3, 12);\n\nArray1DSetValue($intArr, 4, 5);\n\nArray1DSetValue($intArr, 5, 2);\n\nArray1DSetValue($intArr, 6, 6);\n\n\n\n\n\n($found, $index) = Array1DContains($intArr, 5);\n\n\n\n\n\n// This value should be found at Index 4.\n\n$outStr = \"Element not found\";\n\n\n\n\n\nif ($found)\n\n{\n\n$outStr = \"\\nElement found at index:\\t \" + $index;\n\n}\n\nUpdateStatus($outStr);\n\n\n\n\n\nArray1DConvert\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Array1DConvert": {
  "prefix": "Array1DConvert",
  "body": [
   "$$outArray=Array1DConvert($$inArray,$$convertTo);"
  ],
  "description": "\n\nThis function will convert the array to the type specified and return it as a new array.\n\n\n\nRemarks:\n\nThe original array is unchanged.\n\n\n\nConverting from a floating point number to an integer will truncate any digits after the decimal point (no rounding).\n\n\n\nWhen converting a number to a Boolean, any positive number = true. 0 and negative numbers = false.\n\n\n\nWhen converting a Boolean to a number, true = 1, false = 0.\n\n\n\nWhen converting a string to a Boolean, \"TRUE\", \"1\", \"YES\", or \"ON\" = true. Anything else = false.\n\n\n\n\n\nNote: This function can also be used to copy an array to a new array by converting it to an array of the same type.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$inArray\n\nArray\n\nA 1 dimensional array of booleans, floats, integers or strings.\n\n\n\n$convertTo\n\nString\n\nThe type of variable to convert the array to. Must be one of: BOOLEAN\n\nFLOAT\n\nINTEGER\n\nSTRING\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$outArray\n\nArray\n\nThe converted array.\n\n\n\n\n\nExample:\n\n\n\n\n\n// Create a Float array to be converted.\n\n$fltArr = Array1DCreate(\"FLOAT\", 7);\n\nArray1DSetValue($fltArr, 0, 9.2);\n\nArray1DSetValue($fltArr, 1, 7.7);\n\nArray1DSetValue($fltArr, 2, 8.1);\n\nArray1DSetValue($fltArr, 3, 12.0);\n\nArray1DSetValue($fltArr, 4, 5.9);\n\nArray1DSetValue($fltArr, 5, 2.6);\n\nArray1DSetValue($fltArr, 6, 6.3);\n\n\n\n// Convert to Integer.\n\n$intArr = Array1DConvert($fltArr, \"INTEGER\");\n\n// The converted array will contain: { 9, 7, 8, 12, 5, 2, 6 }.\n\n\n\n\n\nArray1DCreate\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Array1DCreate": {
  "prefix": "Array1DCreate",
  "body": [
   "$$Array=Array1DCreate($$ArrayType,$$Length);"
  ],
  "description": "\n\nCreates a one dimensional array of the Jabil Test supported type and length specified.\n\n\n\n\n\nNote:\n\nArray indices are zero-based; e.g., a 10 element array contains elements 0-9.\n\nALL elements of the created array will be set to the default value for that variable type. For example, an array of BOOLEAN has every element set to false. An array of INTEGER has every element set to 0.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ArrayType\n\nString\n\nThe type of the array elements. Variable types supported:\n\n\u00b7 BOOLEAN\n\n\u00b7 INTEGER\n\n\u00b7 FLOAT\n\n\u00b7 STRING\n\n\u00b7 OBJECT"
 }
,
 "JTS Array1DGetColFrom2D": {
  "prefix": "Array1DGetColFrom2D",
  "body": [
   "$$colArray=Array1DGetColFrom2D($$array2D,$$columnNum);"
  ],
  "description": "\n\nThis function returns one column of data from a 2D array.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$array2D\n\nArray\n\nA 2 dimensional array.\n\n\n\n$columnNum\n\nInteger\n\nThe number of the column to return from the 2 dimensional array.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$colArray\n\nArray\n\nA 1 dimensional array of the data from the specified column of the 2 dimensional array. The type of the data will match the data type of the 2 dimensional array.\n\n\n\n\n\nExample:\n\n// Get column 2 from a 2 dimensional array.\n\n$colNum = 2;\n\n$colArray = Array1DGetColFrom2D($inputArray, $colNum);\n\n\n\n\n\nArray1DGetRowFrom2D\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Array1DGetRowFrom2D": {
  "prefix": "Array1DGetRowFrom2D",
  "body": [
   "$$rowArray=Array1DGetRowFrom2D($$array2D,$$rowNum);"
  ],
  "description": "\n\nThis function returns one row of data from a 2D array.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$array2D\n\nArray\n\nA 2 dimensional array.\n\n\n\n$rowNum\n\nInteger\n\nThe number of the row to return from the 2 dimensional array.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$rowArray\n\nArray\n\nA 1 dimensional array of the data from the specified row of the 2 dimensional array. The type of the data will match the data type of the 2 dimensional array.\n\n\n\n\n\nExample:\n\n// Get row 1 from a 2 dimensional array.\n\n$rowNum = 1;\n\n$rowArray = Array1DGetRowFrom2D($inputArray, $rowNum);\n\n\n\n\n\nArray1DGetValue\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Array1DGetValue": {
  "prefix": "Array1DGetValue",
  "body": [
   "$$ReturnValue=Array1DGetValue($$Array,$$Index);"
  ],
  "description": "\n\nReturns the element located at the specified index of the array.\n\n\n\n\n\nNote:\n\nArray indices are zero-based; e.g., a 10 element array contains elements 0-9.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Array\n\nObject\n\nThe reference to the array to get a value from.\n\n\n\n$Index\n\nInteger\n\nZero-based index of the element to return.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ReturnValue\n\nVaries\n\nValue of the element returned. The type of the element will match the type of the input array.\n\nNOTE: If the array is an array of bytes, the returned value will be an INTEGER.\n\n\n\n\n\nExample:\n\n$Value = Array1DGetValue($Array, 0); //returns the first element of the array\n\n\n\n\n\nArray1DMaxMin\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Array1DMaxMin": {
  "prefix": "Array1DMaxMin",
  "body": [
   "($$arrayMax,$$maxIndex,$$arrayMin,$$minIndex)=Array1DMaxMin($$numArray);"
  ],
  "description": "\n\nThis function will find the maximum and minimum values in the array and return those values along with the indices where they were found.\n\n\n\n\n\nRemarks:\n\nIf the array is an array of integers, the Max and Min returned will be integers.\n\nIf the array is an array of floats, the Max and Min returned will be floats.\n\nThe indices are always integers.\n\nIf the maximum or minimum value appear in more than one location in the array, only the first (lowest) index will be returned.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$numArray\n\nArray\n\nA 1 dimensional array of integers or floats.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$arrayMax\n\nInteger, Float\n\nThe maximum value found within the array.\n\n\n\n$maxIndex\n\nInteger\n\nThe first index in the array where the maximum value was found.\n\n\n\n$arrayMin\n\nInteger, Float\n\nThe minimum value found in the array.\n\n\n\n$minIndex\n\nInteger\n\nThe first index in the array where the minimum value was found.\n\n\n\n\n\nExample:\n\n// Create an Integer array and find the maximum and minimum values.\n\n$intArr = Array1DCreate(\"INTEGER\", 7);\n\nArray1DSetValue($intArr, 0, 9);\n\nArray1DSetValue($intArr, 1, 7);\n\nArray1DSetValue($intArr, 2, 8);\n\nArray1DSetValue($intArr, 3, 12);\n\nArray1DSetValue($intArr, 4, 5);\n\nArray1DSetValue($intArr, 5, 2);\n\nArray1DSetValue($intArr, 6, 6);\n\n\n\n\n\n($intMax, $MaxIndex, $intMin, $MinIndex) = Array1DMaxMin($intArr);\n\n\n\n\n\n// Max is 12 in index 3. Min is 2 in index 5.\n\n$outStr = \"\\nInteger Max = \" + $intMax + \"\\t Index = \" + $MaxIndex + \"\\nIntegerMin = \" + $intMin + \"\\t Index = \" + $MinIndex;\n\nUpdateStatus($outStr);\n\n\n\n\n\nArray1DSetValue\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Array1DSetValue": {
  "prefix": "Array1DSetValue",
  "body": [
   "Array1DSetValue($$Array,$$Index,$$InputValue);"
  ],
  "description": "\n\nSets the specified element in the given array to the supplied value. If the array does not support the given input value type, an error will be generated.\n\n\n\n\n\nNote:\n\nArray indices are zero-based; e.g., a 10 element array contains elements 0-9.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Array\n\nObject\n\nThe reference to the array to set the value in.\n\n\n\n$Index\n\nInteger\n\nZero-based index of the element to set.\n\n\n\n$InputValue\n\nVaries\n\nThe value to enter into the array. The type of the element must match the type of the array.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\nArray1DSetValue($Array, 0, 1.5); //sets the first element of the array to the value 1.5\n\n\n\n\n\nArray1DSort\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Array1DSort": {
  "prefix": "Array1DSort",
  "body": [
   "Array1DSort($$array,$$reverse);"
  ],
  "description": "\n\nThis function will sort the one dimensional array.\n\n\n\n\n\nRemarks:\n\nThe array can be numeric or string.\n\nThe array is sorted in-place. The original array is modified.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$array\n\nArray\n\nA 1 dimensional array of strings, integers or floats.\n\n\n\n$reverse\n\nBoolean\n\nIf FALSE, the array will be sorted into ascending order.\n\nIf TRUE, the array will be sorted into descending order.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n// Create an Integer array to be sorted.\n\n$intArr = Array1DCreate(\"INTEGER\", 7);\n\nArray1DSetValue($intArr, 0, 9);\n\nArray1DSetValue($intArr, 1, 7);\n\nArray1DSetValue($intArr, 2, 8);\n\nArray1DSetValue($intArr, 3, 12);\n\nArray1DSetValue($intArr, 4, 5);\n\nArray1DSetValue($intArr, 5, 2);\n\nArray1DSetValue($intArr, 6, 6);\n\n\n\n\n\n// Sort ascending.\n\nArray1DSort($intArr, false);\n\n\n\n\n\nArray1DSubArray\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Array1DSubArray": {
  "prefix": "Array1DSubArray",
  "body": [
   "$$subArray=Array1DSubArray($$inArray,$$start,$$length);"
  ],
  "description": "\n\nThis function will return a sub-array of the same type as the input array, with the elements from $start and going for $length elements.\n\n\n\n\n\nRemarks:\n\nThe array can be numeric or string.\n\nThe original array is unchanged.\n\nThe sub-array will be of the same type as the original array.\n\nThe $start + $length must not go beyond the last element of the original array.\n\nRow and column numbers are 0 based (ie. the first row or column is number 0).\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$inArray\n\nArray\n\nA 1 dimensional array of strings, integers or floats.\n\n\n\n$start\n\nInteger\n\nThe first element of the original array to include in the sub-array.\n\n\n\n$length\n\nInteger\n\nThe number of elements from the original array to include in the sub-array.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$subArray\n\nArray\n\nThe sub-Array of the original array.\n\n\n\n\n\nExample:\n\n// Create a Float array to start with..\n\n$fltArr = Array1DCreate(\"FLOAT\", 7);\n\nArray1DSetValue($fltArr, 0, 9.2);\n\nArray1DSetValue($fltArr, 1, 7.7);\n\nArray1DSetValue($fltArr, 2, 8.1);\n\nArray1DSetValue($fltArr, 3, 12.0);\n\nArray1DSetValue($fltArr, 4, 5.9);\n\nArray1DSetValue($fltArr, 5, 2.6);\n\nArray1DSetValue($fltArr, 6, 6.3);\n\n\n\n\n\n// Get the elements from element 2 for 4 elements.\n\n$subArr = Array1DSubArray($fltArr, 2, 4);\n\n// The returned array will contain: { 8.1, 12, 5.9, 2.6 }.\n\n\n\n\n\nArray2DColumnContains\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Array2DColumnContains": {
  "prefix": "Array2DColumnContains",
  "body": [
   "($$found,$$index)=Array2DColumnContains($$array,$$column,$$element);"
  ],
  "description": "\n\nThis function will search the supplied array in the specified column for the element and return whether the element was found and the row index of the element, if it was found.\n\n\n\n\n\nRemarks:\n\nThe array can be any type of array usable by Jabil Test.\n\nThe array and the element being searched for must be of the same type.\n\nIf the element is not found, the index will be -1.\n\nIf the element appears in more than one location in the array, only the first (lowest) index will be returned.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$array\n\nArray\n\nA 2 dimensional array.\n\n\n\n$column\n\nInteger\n\nThe column to search for the element.\n\n\n\n$element\n\nVaries\n\nThe element to search for in the column. Must be the same type as the array.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$found\n\nBoolean\n\nTrue if the element was found in the column, False otherwise.\n\n\n\n$index\n\nInteger\n\nThe first index in the column where the value was found. If the element is not found, this will be -1.\n\n\n\n\n\nExample:\n\n// Create an Integer array and fill with random values.\n\n$numRows = 7;\n\n$numCols = 8;\n\n$intArr = Array2DCreate(\"INTEGER\", $numRows, $numCols);\n\n\n\n\n\n$lc = 0;\n\nwhile ($lc < $numCols)\n\n{\n\n$lr = 0;\n\nwhile ($lr < $numRows)\n\n{\n\nSleepMilliseconds(15); // Required wait between random number picks.\n\n$newNum = GetRandomInteger(1, 1000);\n\nArray2DSetValue($intArr, $lr, $lc, $newNum);\n\n$lr = $lr + 1;\n\n}\n\n$lc = $lc + 1;\n\n}\n\n\n\n\n\n// Check to see if column 5 contains the number 500.\n\n($found, $index) = Array2DColumnContains($intArr, 5, 500);\n\n\n\n\n\n// Print out where the element was found (or not).\n\n$outStr = \"Element not found\";\n\n\n\n\n\nif ($found)\n\n{\n\n$outStr = \"\\nElement found at index:\\t \" + $index;\n\n}\n\nUpdateStatus($outStr);\n\n\n\n\n\nArray2DCreate\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Array2DCreate": {
  "prefix": "Array2DCreate",
  "body": [
   "$$Array=Array2DCreate($$ArrayType,$$Rows,$$Columns);"
  ],
  "description": "\n\nCreates a two dimensional array of the Jabil Test supported type and dimensions specified. Array indexes are zero-based; e.g., a 10x10 array contains elements 0-9x0-9.\n\n\n\n\n\nNote:\n\nArray indices are zero-based; e.g., a 10 element array contains elements 0-9.\n\n\n\n\n\nElements are laid out in the array object in row-major order, per the CLI spec (section 8.9.1). E.g., a 3x4 array would be laid out like so in memory:\n\n\n\n\n\n[A11 A12 A13 A14]\n\n[A21 A22 A23 A24] = [A11 A12 A13 A14 A21 A22 A23 A24 A31 A32 A33 A34]\n\n[A31 A32 A33 A34]\n\n\n\n\n\nALL elements of the created array will be set to the default value for that variable type. For example, an array of BOOLEAN has every element set to false. An array of INTEGER has every element set to 0.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ArrayType\n\nString\n\nThe type of the array elements. Variable types supported:\n\n\u00b7 BOOLEAN\n\n\u00b7 INTEGER\n\n\u00b7 FLOAT\n\n\u00b7 STRING\n\n\u00b7 OBJECT"
 }
,
 "JTS Array2DGetValue": {
  "prefix": "Array2DGetValue",
  "body": [
   "$$ReturnValue=Array2DGetValue($$Array,$$Row,$$Column);"
  ],
  "description": "\n\nReturns the element located at the specified location of the array.\n\n\n\n\n\nNote:\n\nArray indices are zero-based; e.g., a 10 element array contains elements 0-9.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Array\n\nObject\n\nReference to the array to get a value from.\n\n\n\n$Row\n\nInteger\n\nZero-based row index of the element to return.\n\n\n\n$Columns\n\nInteger\n\nZero-based column index of the element to return.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ReturnValue\n\nObject\n\nValue of the element returned. The type of the element will match the type of the input array.\n\nNOTE: If the array is an array of bytes, the returned value will be an INTEGER.\n\n\n\n\n\nExample:\n\n$Value = Array2DGetValue($Array, 0, 0); //returns the top-left element of the array\n\n\n\n\n\nArray2DMaxMinColumn\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Array2DMaxMinColumn": {
  "prefix": "Array2DMaxMinColumn",
  "body": [
   "($$maxValue,$$maxPosition,$$minValue,$$minPosition)=Array2DMaxMinColumn($$inArray,$$rcolumnNum);"
  ],
  "description": "\n\nThis function will return the maximum and minimum values (and their row numbers) from the specified column of the input array.\n\n\n\n\n\nRemarks:\n\nThe array must be numeric.\n\nThe maximum and minimum values returned will be the same numeric type as the array.\n\nRow and column numbers are 0 based (ie. the first row or column is number 0).\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$inArray\n\nArray\n\nA 2 dimensional array of integers or floats.\n\n\n\n$columnNum\n\nInteger\n\nThe column number to get the maximum and minimum values from.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$maxValue\n\nVaries\n\nThe maximum value found in the specified column.\n\n\n\n$maxPosition\n\nInteger\n\nThe row number that the maximum value was found in.\n\n\n\n$minValue\n\nVaries\n\nThe minimum value found in the specified column.\n\n\n\n$minPosition\n\nInteger\n\nThe row number that the minimum value was found in.\n\n\n\n\n\nExample:\n\n// Check column 3 for the max and min values.\n\n($maxValue, $maxPosiiton, $minValue, $minPosition) = Array2DMaxMinColumn($fltArr, 3);\n\n\n\n\n\nArray2DMaxMinRow\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Array2DMaxMinRow": {
  "prefix": "Array2DMaxMinRow",
  "body": [
   "($$maxValue,$$maxPosition,$$minValue,$$minPosition)=Array2DMaxMinRow($$inArray,$$rowNum);"
  ],
  "description": "\n\nThis function will return the maximum and minimum values (and their column numbers) from the specified row of the input array.\n\n\n\n\n\nRemarks:\n\nThe array must be numeric.\n\nThe maximum and minimum values returned will be the same numeric type as the array.\n\nRow and column numbers are 0 based (ie. the first row or column is number 0).\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$inArray\n\nArray\n\nA 2 dimensional array of integers or floats.\n\n\n\n$rowNum\n\nInteger\n\nThe row number to get the maximum and minimum values from.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$maxValue\n\nVaries\n\nThe maximum value found on the specified row.\n\n\n\n$maxPosition\n\nInteger\n\nThe column number that the maximum value was found in.\n\n\n\n$minValue\n\nVaries\n\nThe minimum value found on the specified row.\n\n\n\n$minPosition\n\nInteger\n\nThe column number that the minimum value was found in.\n\n\n\n\n\nExample:\n\n// Check row 3 for the max and min values.\n\n($maxValue, $maxPosiiton, $minValue, $minPosition) = Array2DMaxMinRow($fltArr, 3);\n\n\n\n\n\nArray2DReplaceColumn\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Array2DReplaceColumn": {
  "prefix": "Array2DReplaceColumn",
  "body": [
   "Array2DReplaceColumn($$dataArray,$$column,$$newColumn);"
  ],
  "description": "\n\nThis function will replace the contents of one column in a 2D array with the contents of a 1D array.\n\n\n\n\n\nRemarks:\n\nThe arrays can be of any type, but the type of the 2D array and the 1D array must be the same (ie. both INTEGER or both STRING).\n\nThe replacement data for the column must be the same size as the column.\n\nArray indices are zero-based; e.g., a 10 element array contains elements 0-9.\n\nArray changes are made in-place. Ie. the original $dataArray is modified.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$dataArray\n\nArray\n\nA 2 dimensional array of any data type.\n\n\n\n$column\n\nInteger\n\nThe number of the column to replace (the first column is number 0).\n\n\n\n$newColumn\n\nArray\n\nA 1 dimensional array of the same data type as the $dataArray and having as many elements as $dataArray has rows.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n// Replace column 7 of an array.\n\nArray2DReplaceColumn($dataArray, 7, $newColumn);\n\n\n\n\n\nArray2DReplaceRow\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Array2DReplaceRow": {
  "prefix": "Array2DReplaceRow",
  "body": [
   "Array2DReplaceRow($$dataArray,$$row,$$newRow);"
  ],
  "description": "\n\nThis function will replace the contents of one row in a 2D array with the contents of a 1D array.\n\n\n\n\n\nRemarks:\n\nThe arrays can be of any type, but the type of the 2D array and the 1D array must be the same (ie. both INTEGER or both STRING).\n\nThe replacement data for the row must be the same size as the row.\n\nArray indices are zero-based; e.g., a 10 element array contains elements 0-9.\n\nArray changes are made in-place. Ie. the original $dataArray is modified.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$dataArray\n\nArray\n\nA 2 dimensional array of any data type.\n\n\n\n$row\n\nInteger\n\nThe number of the row to replace (the first row is number 0).\n\n\n\n$newRow\n\nArray\n\nA 1 dimensional array of the same data type as the $dataArray and having as many elements as $dataArray has columns.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n// Replace row 7 of an array.\n\nArray2DReplaceRow($dataArray, 7, $newRow);\n\n\n\n\n\nArray2DRowContains\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Array2DRowContains": {
  "prefix": "Array2DRowContains",
  "body": [
   "($$found,$$index)=Array2DRowContains($$array,$$row,$$element);"
  ],
  "description": "\n\nThis function will search the supplied array in the specified row for the element and return whether the element was found and the column index of the element, if it was found.\n\n\n\n\n\nRemarks:\n\nThe array can be any type of array usable by Jabil Test.\n\nThe array and the element being searched for must be of the same type.\n\nIf the element is not found, the index will be -1.\n\nIf the element appears in more than one location in the array, only the first (lowest) index will be returned.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$array\n\nArray\n\nA 2 dimensional array.\n\n\n\n$row\n\nInteger\n\nThe row to search for the element.\n\n\n\n$element\n\nVaries\n\nThe element to search for in the row. Must be the same type as the array.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$found\n\nBoolean\n\nTrue if the element was found in the row, False otherwise.\n\n\n\n$index\n\nInteger\n\nThe first index in the row where the value was found. If the element is not found, this will be -1.\n\n\n\n\n\nExample:\n\n// Create an Integer array and fill with random values.\n\n$numRows = 7;\n\n$numCols = 8;\n\n$intArr = Array2DCreate(\"INTEGER\", $numRows, $numCols);\n\n\n\n\n\n$lc = 0;\n\nwhile ($lc < $numCols)\n\n{\n\n$lr = 0;\n\nwhile ($lr < $numRows)\n\n{\n\nSleepMilliseconds(15); // Required wait between random number picks.\n\n$newNum = GetRandomInteger(1, 1000);\n\nArray2DSetValue($intArr, $lr, $lc, $newNum);\n\n$lr = $lr + 1;\n\n}\n\n$lc = $lc + 1;\n\n}\n\n\n\n\n\n// Check to see if row 5 contains the number 500.\n\n($found, $index) = Array2DRowContains($intArr, 5, 500);\n\n\n\n\n\n// Print out where the element was found (or not).\n\n$outStr = \"Element not found\";\n\n\n\n\n\nif ($found)\n\n{\n\n$outStr = \"\\nElement found at index:\\t \" + $index;\n\n}\n\nUpdateStatus($outStr);\n\n\n\n\n\nArray2DSetValue\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Array2DSetValue": {
  "prefix": "Array2DSetValue",
  "body": [
   "Array2DSetValue($$Array,$$Row,$$Column,$$InputValue);"
  ],
  "description": "\n\nSets the specified element in the given array to the supplied value. If the array does not support the given input value type, an error will be generated.\n\n\n\n\n\nNote:\n\nArray indices are zero-based; e.g., a 10 element array contains elements 0-9.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Array\n\nObject\n\nThe reference to the array to set the value in.\n\n\n\n$Row\n\nInteger\n\nZero-based row index of the element to set.\n\n\n\n$Column\n\nInteger\n\nZero-based column index of the element to set.\n\n\n\n$InputValue\n\nVaries\n\nThe value to enter into the array. The type of the element must match the type of the array.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\nArray2DSetValue($Array, 0, 0, 1.5); //sets the top-left element of the array to the value 1.5\n\n\n\n\n\nArray2DSortColumn\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Array2DSortColumn": {
  "prefix": "Array2DSortColumn",
  "body": [
   "Array2DSortColumn($$array,$$columnNumber,$$reverse);"
  ],
  "description": "\n\nThis function will sort the two dimensional array using the specified column number as the key for sorting.\n\n\n\nRemarks:\n\nThe array can be numeric or string.\n\nThe array is sorted in-place. The original array is modified.\n\nAll data in a row is kept together. For example, if sorting on column 2: and column 2, row 3 is to move to row 1 - ALL of row 3 will move to row 1 (every column changes the same).\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$array\n\nArray\n\nA 2 dimensional array of strings, integers or floats.\n\n\n\n$columnNumber\n\nInteger\n\nThe column to use as a key for sorting the entire array.\n\n\n\n$reverse\n\nBoolean\n\nIf FALSE, the array will be sorted into ascending order.\n\nIf TRUE, the array will be sorted into descending order.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n\n\n\n\n// Create an Integer array to be sorted.\n\n$intArr = Array2DCreate(\"INTEGER\", 7, 5);\n\n\n\n// Fill the array with random integers.\n\n$rCount = 0;\n\nwhile ($rCount < 7)\n\n{\n\n$cCount = 0;\n\nwhile ($cCount < 5)\n\n{\n\n\n\n$tempNum = GetRandomInteger(0, 50);\n\nArray2DSetValue($intArr, $rCount, $cCount, $tempNum);\n\n$cCount = $cCount + 1;\n\n\n\n}\n\n$rCount = $rCount + 1;\n\n\n\n}\n\n\n\n// Sort ascending on column 2.\n\nArray2DSortColumn($intArr, 2, false);\n\n\n\n\n\nArray2DSortRow\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Array2DSortRow": {
  "prefix": "Array2DSortRow",
  "body": [
   "Array2DSortRow($$array,$$rowNumber,$$reverse);"
  ],
  "description": "\n\nThis function will sort the two dimensional array using the specified row number as the key for sorting.\n\n\n\n\n\nRemarks:\n\nThe array can be numeric or string.\n\nThe array is sorted in-place. The original array is modified.\n\nAll data in a column is kept together. For example, if sorting on row 2: and row 2, column 3 is to move to column 1 - ALL of column 3 will move to column 1 (every row changes the same).\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$array\n\nArray\n\nA 2 dimensional array of strings, integers or floats.\n\n\n\n$rowNumber\n\nInteger\n\nThe row to use as a key for sorting the entire array.\n\n\n\n$reverse\n\nBoolean\n\nIf FALSE, the array will be sorted into ascending order.\n\nIf TRUE, the array will be sorted into descending order.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n// Create an Integer array to be sorted.\n\n$intArr = Array2DCreate(\"INTEGER\", 7, 5);\n\n\n\n\n\n// Fill the array with random integers.\n\n$rCount = 0;\n\nwhile ($rCount < 7)\n\n{\n\n$cCount = 0;\n\nwhile ($cCount < 5)\n\n{\n\n$tempNum = GetRandomInteger(0, 50);\n\nArray2DSetValue($intArr, $rCount, $cCount, $tempNum);\n\n$cCount = $cCount + 1;\n\n}\n\n$rCount = $rCount + 1;\n\n}\n\n\n\n\n\n// Sort ascending on row 2.\n\nArray2DSortRow($intArr, 2, false);\n\n\n\n\n\nArray2DSubColumn\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Array2DSubColumn": {
  "prefix": "Array2DSubColumn",
  "body": [
   "$$subArray=Array2DSubColumn($$inArray,$$columnNum,$$start,$$length);"
  ],
  "description": "\n\nThis function will return a 1D sub-array of the same type as the input array, with the elements from $start and going for $length elements from the specified column.\n\n\n\n\n\nRemarks:\n\nThe array can be numeric or string.\n\nThe original array is unchanged.\n\nThe sub-array will be of the same type as the original array.\n\nThe $start + $length must not go beyond the last element of the original array.\n\nRow and column numbers are 0 based (ie. the first row or column is number 0).\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$inArray\n\nArray\n\nA 2 dimensional array of strings, integers or floats.\n\n\n\n$columnNum\n\nInteger\n\nThe column number to get the sub-array from.\n\n\n\n$start\n\nInteger\n\nThe first row of the original array to include in the sub-array.\n\n\n\n$length\n\nInteger\n\nThe number of elements from the original array to include in the sub-array.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$subArray\n\nArray\n\nThe sub-Array of the original array.\n\n\n\n\n\nExample:\n\n// Get the elements from column 3, row 2 for 4 elements.\n\n$subArr = Array2DSubColumn($fltArr, 3, 2, 4);\n\n\n\n\n\nArray2DSubRow\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Array2DSubRow": {
  "prefix": "Array2DSubRow",
  "body": [
   "$$subArray=Array2DSubRow($$inArray,$$rowNum,$$start,$$length);"
  ],
  "description": "\n\nThis function will return a 1D sub-array of the same type as the input array, with the elements from $start and going for $length elements from the specified row.\n\n\n\n\n\nRemarks:\n\nThe array can be numeric or string.\n\nThe original array is unchanged.\n\nThe sub-array will be of the same type as the original array.\n\nThe $start + $length must not go beyond the last element of the original array.\n\nRow and column numbers are 0 based (ie. the first row or column is number 0).\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$inArray\n\nArray\n\nA 2 dimensional array of strings, integers or floats.\n\n\n\n$rowNum\n\nInteger\n\nThe row number to get the sub-array from.\n\n\n\n$start\n\nInteger\n\nThe first column of the original array to include in the sub-array.\n\n\n\n$length\n\nInteger\n\nThe number of elements from the original array to include in the sub-array.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$subArray\n\nArray\n\nThe sub-Array of the original array.\n\n\n\n\n\nExample:\n\n// Get the elements from row 3, column 2 for 4 elements.\n\n$subArr = Array2DSubRow($fltArr, 3, 2, 4);\n\n\n\n\n\nArray2DToPlot2DTrace\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Array2DToPlot2DTrace": {
  "prefix": "Array2DToPlot2DTrace",
  "body": [
   "$$Trace=Array2DToPlot2DTrace($$Array);"
  ],
  "description": "\n\nConverts the 2D input array to a JabilTestCoreLibs.PlotWindow.PlotTrace2D type used by the charting functions.\n\n\n\n\n\nThe input array must have two rows of numeric data (valid numeric strings or numeric data types). The first row will be the x-values of the PlotTrace2D object, the second row will be the corresponding y-values. Invalid array sizes or types will generate an error.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Array\n\nObject\n\nThe reference to the array to the array to convert.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Trace\n\nObject\n\nPlotTrace2D object containing the data from the input array.\n\n\n\n\n\nExample:\n\n$array2D = Array2DCreate(\"FLOAT\", 2, 3);\n\nArray2DSetValue($array2D, 0, 0, 100);\n\nArray2DSetValue($array2D, 0, 1, 200);\n\nArray2DSetValue($array2D, 0, 2, 300);\n\nArray2DSetValue($array2D, 1, 0, -2.5);\n\nArray2DSetValue($array2D, 1, 1, 3.2);\n\nArray2DSetValue($array2D, 1, 2, 8.8);\n\n\n\n\n\n$Trace1 = Array2DToPlot2DTrace($array2D);\n\n\n\n\n\nSetExtendedPanelMode(\"CHARTING\");\n\nChartPanel_Plot2DTrace(0, \"TEST PLOT 1\", $Trace1, 0, 0, 255);\n\n\n\n\n\nArrayCreate\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ArrayCreate": {
  "prefix": "ArrayCreate",
  "body": [
   "$$Array=ArrayCreate($$ArrayType,$$ArrayDimension1,$$ArrayDimension2);"
  ],
  "description": "\n\nThis function creates a new variable containing an array created according to the parameters supplied to the function. If $ArrayDimension1 is defined as 1 and $ArrayDimension2 is defined as 10, then for the other operating Array functions Dimension1 will be 0 and Dimension2 will be 0-9.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ArrayType\n\nString\n\nThe type of array to create. Valid types are:\n\n\u00b7 \"STRING\"\n\n\u00b7 \"FLOAT\"\n\n\u00b7 \"INTEGER\"\n\n\u00b7 \"BOOLEAN\"\n\n\n\n$ArrayDimension1\n\nInteger\n\nThe first dimension of the array.\n\n\n\n$ArrayDimension2\n\nInteger\n\nThe second dimension of the array.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Array\n\nArray\n\nThe newly created array of the specified type and dimensions.\n\n\n\n\n\nExample:\n\n$Array = ArrayCreate(\"INTEGER\", 1, 100); // Create an array with 1 row and 100 columns.\n\n// NOTE: every element will contain 0 for a value.\n\n\n\n\n\nArrayGetDimensionSize\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ArrayGetDimensionSize": {
  "prefix": "ArrayGetDimensionSize",
  "body": [
   "$$Length=ArrayGetDimensionSize($$Array,$$Dimension);"
  ],
  "description": "\n\nReturns the size of the specified dimension of the input array. Dimension indexes are zero-based; e.g., for 2D arrays dimension 0 is the number of rows, and dimension 1 is the number of columns.\n\n\n\n\n\nSpecifying an invalid dimension size will generate an error.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Array\n\nObject\n\nVariable containing reference to the input array.\n\n\n\n$Dimension\n\nInteger\n\nDimension to get the length of.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Length\n\nInteger\n\nNumber of elements in the specified dimension.\n\n\n\n\n\nExample:\n\n$Length = ArrayGetDimensionSize($Array, 0); //# of elements in the 1st dimension of the array\n\n\n\n\n\nArrayGetLength\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ArrayGetLength": {
  "prefix": "ArrayGetLength",
  "body": [
   "$$Length=ArrayGetLength($$Array);"
  ],
  "description": "\n\nThis function returns the total number of elements in an array for all dimensions.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Array\n\nObject\n\nThe input array.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Length\n\nInteger\n\nThe total number of elements in the array.\n\n\n\n\n\nExample:\n\n\n\n\n\n$Length = ArrayGetLength($Array);\n\n\n\n\n\nArrayGetP2P\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ArrayGetP2P": {
  "prefix": "ArrayGetP2P",
  "body": [
   "$$Value=ArrayGetP2P($$Array,$$Start,$$Length);"
  ],
  "description": "\n\nThis function returns the peak to peak value of the waveform stored in the specified portion of the array. This function requires the \"ArrayCreate\" function to define the Array type as \"Integer\" or \"Float\".\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Array\n\nObject\n\nThe input array.\n\n\n\n$Start\n\nInteger\n\nThe starting element of the array to analyze.\n\n\n\n$Length\n\nInteger\n\nThe number of array elements to analyze.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Value\n\nFloat\n\nThe peak to peak value of the analyzed elements.\n\n\n\n\n\nExample:\n\n\n\n\n\n// Process the entire array to find the peak to peak value.\n\n$length = ArrayGetLength($array);\n\n$p2pValue = ArrayGetP2P($array, 0, $length);\n\n\n\n\n\nArrayGetRank\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ArrayGetRank": {
  "prefix": "ArrayGetRank",
  "body": [
   "$$Rank=ArrayGetRank($$Array);"
  ],
  "description": "\n\nReturns the rank (number of dimensions) of the input array.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Array\n\nObject\n\nVariable containing reference to the input array.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Rank\n\nInteger\n\nThe rank of the input array (number of dimensions).\n\n\n\n\n\nExample:\n\n$Rank = ArrayGetRank($Array); //returns the # of dimensions of the array.\n\n\n\n\n\nArrayGetValue\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ArrayGetValue": {
  "prefix": "ArrayGetValue",
  "body": [
   "$$Value=ArrayGetValue($$Array,$$Dimension1,$$Dimension2);"
  ],
  "description": "\n\nThis function returns the value from the specified location in the array. If the requested value is beyond the range of the array, a failure is returned by the function.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Array\n\nObject\n\nThe input array.\n\n\n\n$Dimension1\n\nInteger\n\nThe first dimension of the array.\n\n\n\n$Dimension2\n\nInteger\n\nThe second dimension of the array.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Value\n\nVarious\n\nThe returned value. This can be string, integer, float or boolean depending on the type of the array.\n\nNOTE: If the array is an array of bytes, the returned value will be an Integer.\n\n\n\n\n\nExample:\n\n// Get the value from location (0,4).\n\n$Value = ArrayGetValue($array, 0, 4);\n\n\n\n\n\nArraySetValue\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ArraySetValue": {
  "prefix": "ArraySetValue",
  "body": [
   "ArraySetValue($$Array,$$Dimension1,$$Dimension2,$$Value);"
  ],
  "description": "\n\nThis function sets the specified element of the array to the supplied value. If an invalid value type is passed to an array of a differing type, an error will be returned.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Array\n\nObject\n\nThe input array.\n\n\n\n$Dimension1\n\nInteger\n\nThe first dimension of the array.\n\n\n\n$Dimension2\n\nInteger\n\nThe second dimension of the array.\n\n\n\n$Value\n\nVarious\n\nThe value to set the specified element to.\n\nNOTE: The type of this element must match the type of the array.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone.\n\n\n\n\n\nExample:\n\n// Create an array of string that is 3 x 12.\n\n$array = ArrayCreate(\"STRING\", 3, 12);\n\n// Put the word \"Dog\" in location (2, 6).\n\nArraySetValue($array, 2, 6, \"Dog\");\n\n\n\n\n\nArrayAnalyzeAmplitudeAtFrequency\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ArrayAnalyzeAmplitudeAtFrequency": {
  "prefix": "ArrayAnalyzeAmplitudeAtFrequency",
  "body": [
   "$$amplitude=ArrayAnalyzeAmplitudeAtFrequency($$array,$$samplesPerSecond,$$desiredFrequency);"
  ],
  "description": "\n\nThis function takes the values in an array, and performs an fast-fourier transform on the array to obtain the frequency domain. The $desiredFrequency is then read and the amplitude returned.\n\nRemarks:\n\nThe $SamplesPerSecond parameter must contain the rate at which the data was sampled in order to return an accurate measurement of the frequency.\n\nThe sample rate should be at least 3 times the frequency rate for an accurate result from this function.\n\nA minimum array length of 512 elements is required for the function.\n\nIf the requested frequency is outside of the waveform's frequency spectrum, the function will fail the test.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$array\n\nArray\n\nThe input array.\n\n\n\n$samplesPerSecond\n\nInteger\n\nThe number of samples per second.\n\n\n\n$desiredFrequency\n\nFloat\n\nThe frequency to return the amplitude of.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$amplitude\n\nFloat\n\nThe calculated amplitude at the requested frequency.\n\n\n\n\n\nExample:\n\n\n\n\n\n$samplesPerSecond = 1000;\n\n$frequency = 5000.0;\n\n$amplitude = ArrayAnalyzeAmplitudeAtFrequency($array, $samplesPerSecond, $frequency);\n\n\n\n\n\nArrayAnalyzeFrequency\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ArrayAnalyzeFrequency": {
  "prefix": "ArrayAnalyzeFrequency",
  "body": [
   "$$Frequency=ArrayAnalyzeFrequency($$Array,$$SamplesPerSecond);"
  ],
  "description": "\n\nThis function takes the values in an array, and performs an fast-fourier transform on the array to obtain the principle harmonic of the input frequency. The $SamplesPerSecond parameter must contain the rate at which the data was sampled in order to return an accurate measurement of the frequency. The sample rate should be at least 3 times the frequency rate for an accurate result from this function. A minimum array length of 512 elements is required for the function.\n\nExample Application:\n\nAs an example application let's assume that a number of samples were taken using the multi-sample function while measuring a voltage on a DAQ card. The resulting array that was returned from the function could be passed into this function along with the sampling rate at which the data was captured to compute the signal frequency of the captured data.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Array\n\nArray\n\nThe input array\n\n\n\n$SamplesPerSecond\n\nInteger\n\nThe number of samples per second.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Frequency\n\nFloat\n\nThe calculated frequency in Hertz.\n\n\n\n\n\nExample:\n\n\n\n\n\n$samplesPerSecond = 1000;\n\n$frequency = ArrayAnalyzeFrequency($array, $samplesPerSecond);\n\n\n\n\n\nArrayAnalyzeFrequencyRange\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ArrayAnalyzeFrequencyRange": {
  "prefix": "ArrayAnalyzeFrequencyRange",
  "body": [
   "$$Frequency=ArrayAnalyzeFrequencyRange($$Array,$$SamplesPerSecond,$$minFrequency,$$maxFrequency);"
  ],
  "description": "\n\nThis function takes the values in an array, and performs an fast-fourier transform on the array to obtain the highest amplitude frequency within the specified range. The $SamplesPerSecond parameter must contain the rate at which the data was sampled in order to return an accurate measurement of the frequency. The sample rate should be at least 3 times the frequency rate for an accurate result from this function. A minimum array length of 512 elements is required for the function.\n\nExample Application:\n\nPlay an audio tone through a sound system and analyze a recording of the sound produced to ensure the tone was reproduced at the correct frequency while ignoring harmonics.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Array\n\nArray\n\nThe input array\n\n\n\n$SamplesPerSecond\n\nInteger\n\nThe number of samples per second.\n\n\n\n$minFrequency\n\nFloat\n\nThe lowest frequency to check to see if it is the highest amplitude.\n\n\n\n$maxFrequency\n\nFloat\n\nThe highest frequency to check to see if it is the highest amplitude.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Frequency\n\nFloat\n\nThe calculated frequency in Hertz.\n\n\n\n\n\nExample:\n\n\n\n\n\n// The wave file to load and analyze.\n\n$fName = \"C:\\\\SoundTest\\\\RecordedSound.wav\";\n\n\n\n\n\n// Set up the frequencies to check.\n\n$minF = 100;\n\n$maxF = 2750;\n\n\n\n\n\n// Read the wave file and get the left channel (in row 0).\n\n($sampRate, $dArray, $len, $numC) = Audio_ReadWaveFile($fName);\n\n$oneChan = Array1DGetRowFrom2D($dArray, 0);\n\n\n\n\n\n// Let's find the frequency.\n\n$freq = ArrayAnalyzeFrequencyRange($oneChan, $sampRate, $minF, $maxF);\n\n\n\n\n\n$outStr = \"Frequency:\\t\" + $freq;\n\nUpdateStatus($outStr);\n\n\n\n\n\nArrayComputeTHD\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ArrayComputeTHD": {
  "prefix": "ArrayComputeTHD",
  "body": [
   "($$THD,$$FundamentalFrequency)=ArrayComputeTHD($$Array,$$SampleRate,$$NumberofHarmonics);"
  ],
  "description": "\n\nThis function computes the THD for an array of measurements that were captured in the time domain.\n\nRemarks:\n\nThe calculations will attempt to find all of the harmonics even if they are beyond the frequency spectrum of the waveform. All harmonics that are beyond the frequency spectrum will be calculated as having a 0 amplitude.\n\nTotal harmonic distortion is calculated as:\n\nSQRT(sum of squares of harmonic amplitudes) / amplitude of fundamental "
 }
,
 "JTS ArraySimulateWaveFormData": {
  "prefix": "ArraySimulateWaveFormData",
  "body": [
   "$$Array=ArraySimulateWaveFormData($$Frequency,$$OffSetValue,$$Amplitude,$$NumberOfSamples,$$SampleRate,$$PercentNoise);"
  ],
  "description": "\n\nThis function generates a simulation of sample data acquired from sampling a sine wave with the supplied parameters.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Frequency\n\nFloat\n\nThe desired since wave frequency in Hertz.\n\n\n\n$OffsetValue\n\nFloat\n\nThe DC Offset fo the simulated since wave data.\n\n\n\n$Amplitude\n\nFloat\n\nThe Peak-to-Peak value of the simulated sine wave data.\n\n\n\n$NumberOfSamples\n\nInteger\n\nThe total number of simulated samples to take from the sinewave data.\n\n\n\n$SampleRate\n\nInteger\n\nThe simulated sample rate.\n\n\n\n$PercentNoise\n\nFloat\n\nThe percent noise (as compared to the total amplitude) to insert into the sine wave data. The generated noise is based on a random number generator.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Array\n\nArray\n\nThe newly created array containing the simulated, sampled waveform data.\n\n\n\n\n\nExample:\n\n\n\n$Array = ArraySimulateWaveFormData(11000, 0, 10, 50000, 25000, 0);\n\n\n\n\n\nArrayWindowAnalyzeFrequency\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ArrayWindowAnalyzeFrequency": {
  "prefix": "ArrayWindowAnalyzeFrequency",
  "body": [
   "$$Value=ArrayWindowAnalyzeFrequency($$Array,$$Start,$$Length,$$SampleRate);"
  ],
  "description": "\n\nThis function returns the frequency of the waveform stored in the specified portion of the array.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Array\n\nObject\n\nThe input array.\n\n\n\n$Start\n\nInteger\n\nThe starting element of the array to analyze.\n\n\n\n$Length\n\nInteger\n\nThe number of array elements to analyze.\n\n\n\n$SampleRate\n\nInteger\n\nSample rate of the waveform stored in the array.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Value\n\nFloat\n\nThe frequency.\n\n\n\n\n\nExample:\n\n// Find the frequency in an array.\n\n$start = 0;\n\n$length = ArrayGetLength($array);\n\n$value = ArrayWindowAnalyzeFrequency($array, $start, $length, $sampleRate);\n\n\n\n\n\nGetTestCellCount\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS GetTestCellCount": {
  "prefix": "GetTestCellCount",
  "body": [
   "$$TotalCells=GetTestCellCount();"
  ],
  "description": "\n\nThis function returns the number of Jabil Test cells which are currently configured in the Global Options dialog.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$TotalCells\n\nInteger\n\nThe number of test cells currently configured.\n\n\n\n\n\nGetTestCellStatus\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS GetTestCellStatus": {
  "prefix": "GetTestCellStatus",
  "body": [
   "$$Status=GetTestCellStatus($$CellNumber);"
  ],
  "description": "\n\nThis function returns a text string with the current status of the test cell.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$CellNumber\n\nInteger\n\nThe test cell number to poll for status\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Status\n\nString\n\nA text string indicating the present status of the test cell. Possible values are:\n\n\u00b7 \"READY\"\n\n\u00b7 \"RUNNING\"\n\n\u00b7 \"PASS\"\n\n\u00b7 \"FAIL\"\n\n\u00b7 \"ABORT\"\n\n\u00b7 \"WAITING\"\n\n\n\n\n\nSetAutomationCell\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SetAutomationCell": {
  "prefix": "SetAutomationCell",
  "body": [
   "$$success=SetAutomationCell($$cellNumber,$$cellStatus);"
  ],
  "description": "\n\nThis function sets or ends automation mode for the specified cell. When a cell is in Automation Mode, the Serial Number text box and Start buttons are disabled. Setting the serial number and starting the cell is controlled from another cell using StartTestCell, SetTestCellDefaultStartupScript and StartTestCellWithSerialNumber.\n\n\n\n\n\nRemarks:\n\nThe test cell can only be placed into or taken out of Automation Mode if there is no script running in that cell.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$cellNumber\n\nInteger\n\nThe cell number to set the Automation Mode status of.\n\n\n\n$cellStatus\n\nBoolen\n\ntrue = turn on Automation Mode\n\nfalse = turn off Automation Mode.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$success\n\nBoolean\n\nReturns true or false depending on whether the test cell Automation Mode was updated successfully.\n\n\n\n\n\nExample:\n\n\n\n\n\n// Turn on Automation Mode in cell 2.\n\n$cellNumber = 2;\n\n$automMode = true;\n\n$success = SetAutomationCell($cellNumber, $automMode);\n\n\n\n\n\nSetTestCellDefaultStartupScript\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SetTestCellDefaultStartupScript": {
  "prefix": "SetTestCellDefaultStartupScript",
  "body": [
   "$$Success=SetTestCellDefaultStartupScript($$CellNumber,$$TestScript,$$ValidateFileExists);"
  ],
  "description": "\n\nThis function sets the default test script for a test cell that will load automatically when Jabil Test is started. This function is different from 'SetTestCellTestScript' since this function actually modifies the Jabil Test configuration database and stores the script as the configured default test script for the test cell. If the test script is already configured for the test cell, it will simply be set as the default script. If the test cell previously wasn't configured to run the script, the new script will be added and set as default.\n\n\n\n\n\nNote: The test cell number does not need to be currently configured as a running cell for this function to work properly. (In other words, if Jabil Test is currently configured to run 3 cells, and you set the default test script for the 4th cell, it will work normally, and the default test script for cell 4 will be set properly).\n\n\n\n\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$CellNumber\n\nInteger\n\nThe test cell number to poll for status\n\n\n\n$TestScript\n\nString\n\nThe file path and name of the desired test script\n\n\n\n$ValidateFileExists\n\nBoolean\n\nIf this variable is set to 'True', then the function will validate that the requested script currently exists on the file system. If the file can not be found, the function returns a failing test result. If this parameter is set to false, than the database will be updated with the new script, even if it can't be found on the file system.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Success\n\nBoolean\n\nReturns a value of true if the test script was configured successfully, otherwise returns false.\n\n\n\n\n\nSetTestCellTestScript\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SetTestCellTestScript": {
  "prefix": "SetTestCellTestScript",
  "body": [
   "$$Successful=SetTestCellTestScript($$CellNumber,$$CellScript);"
  ],
  "description": "\n\nThis function sets the current test script of a test cell to the supplied value. If the test cell is currently running, or if the test script doesn't exist, the function will return a false result, otherwise true is returned if the test script could be set successfully.\n\n\n\nNote: The test script can only be set to a specific test script that has already been configured for the test cell.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$CellNumber\n\nInteger\n\nThe cell number to set the test script.\n\n\n\n$CellScript\n\nString\n\nA text string indicating the test script to set.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Successful\n\nBoolean\n\nReturns true or false depending on whether the test script for the specified cell could be set successfully.\n\n\n\n\n\nSetTestCellToReadyStatus\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SetTestCellToReadyStatus": {
  "prefix": "SetTestCellToReadyStatus",
  "body": [
   "$$Successful=SetTestCellToReadyStatus($$CellNumber,$$resetBrowser,$$resetTestDisplay);"
  ],
  "description": "\n\nThis function sets Ready Status for the specified cell. When a cell is in Ready Status the Serial Number text box and Start buttons are enabled.\n\n\n\nNote: The test cell can only be placed into Ready Status if there is no script running in that cell and the cell is not set as an Automation Cell.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$CellNumber\n\nInteger\n\nThe cell number to set Ready Status of.\n\n\n\n$resetBrowser\n\nBoolean\n\nWhether to reset the browser window as well as the test cell status.\n\n\n\n$resetTestDisplay\n\nBoolean\n\nWhether to reset the Test Display Box as well as the test cell status.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Successful\n\nBoolean\n\nReturns true or false depending on whether the test cell Ready Status was updated successfully.\n\n\n\n\n\nExample:\n\n\n\n\n\n// turn on Ready Status in cell 2.\n\n// Also reset the Browser Window and the Test Display Box.\n\n$CellNumber = 2;\n\n$Successful = SetTestCellToReadyStatus($CellNumber, true, true);\n\n\n\n\n\nSetTestCellViewTab\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SetTestCellViewTab": {
  "prefix": "SetTestCellViewTab",
  "body": [
   "$$Successful=SetTestCellViewTab($$CellNumber,$$viewTab);"
  ],
  "description": "\n\nThis function sets the viewing tab on the specified test cell.\n\n\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$CellNumber\n\nInteger\n\nThe cell number to set the tab of.\n\n\n\n$viewTab\n\nString\n\nThe name of the tab to swithc the view to.\n\nValues:\n\n\u00b7 BROWSER\n\n\u00b7 STATUS\n\n\u00b7 DEBUG\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Successful\n\nBoolean\n\nReturns true or false depending on whether the test cell view tab was updated successfully.\n\n\n\n\n\nExample:\n\n\n\n\n\n// Change cell 2 to the Browser tab.\n\n$CellNumber = 2;\n\n$tab = \"BROWSER\";\n\n$Successful = SetTestCellViewTab($CellNumber, $tab);\n\n\n\n\n\nStartTestCell\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS StartTestCell": {
  "prefix": "StartTestCell",
  "body": [
   "StartTestCell($$CellNumber);"
  ],
  "description": "\n\n\n\nThis function sends a start request to the specified test cell. If the function is already running, the request is ignored.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$CellNumber\n\nInteger\n\nThe cell number to start.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nStartTestCellWithSerialNumber\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS StartTestCellWithSerialNumber": {
  "prefix": "StartTestCellWithSerialNumber",
  "body": [
   "StartTestCellWithSerialNumber($$CellNumber,$$SerialNumber);"
  ],
  "description": "\n\n\n\nThis function sends a start request to the specified test cell, and also supplies the serial number of the product under test. If the function is already running, the request is ignored.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$CellNumber\n\nInteger\n\nThe cell number to start.\n\n\n\n$SerialNumber\n\nString\n\nThe serial number of the product currently to load into the test cell before sending the start request.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nStopTestCell\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS StopTestCell": {
  "prefix": "StopTestCell",
  "body": [
   "StopTestCell($$CellNumber);"
  ],
  "description": "\n\n\n\nThis function sends an \"Abort\" request to the test cell. If the test cell is currently idle, the request is ignored.\n\n\n\n\n\nNote: This function has the exact same effect as the operator clicking the abort button on the test cell. The current test function will run to completion, and the script will abort and run the cleanup function.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$CellNumber\n\nInteger\n\nThe cell number to stop.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nAutomation_CheckElementExistsByAutomationId\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Automation_CheckElementExistsByAutomationId": {
  "prefix": "Automation_CheckElementExistsByAutomationId",
  "body": [
   "$$found=Automation_CheckElementExistsByAutomationId($$RootElement,$$AutomationId);"
  ],
  "description": "\n\nThis function checks for the existence of an automation element within the root element that matches the specified Automation Id.\n\n\n\n\n\nRequirements:\n\nThis function implements the UI Automation Framework which allows you to automate Win32, Windows Forms and WPF applications. Every part of a UI (window, button, menu, \u2026) is represented as an AutomationElement. An AutomationElement is an object that represents the accessible properties of a control.\n\n\n\n\n\nYou can use the Microsoft Program: UI Spy to view and interact with the user interface (UI) elements of an application.\n\n\n\n\n\nNote: UI Spy is installed with the Microsoft Windows SDK. It is located in the \\bin folder of the SDK installation path (uispy.exe) or can be accessed from the Start menu (Start\\All Programs\\Microsoft Windows SDK\\Tools\\UISpy).\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$RootElement\n\nObject\n\nThe root automation element which contains the element you'd like to check for.\n\n\n\n$AutomationId\n\nString\n\nThe Automation ID for the element.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$found\n\nBoolean\n\nTrue if any automation element matching the search parameter was found, otherwise false.\n\n\n\n\n\nUsage Example:\n\n$Window = Automation_GetRootAutomationElement(\"SciCalc\");\n\n$elementFound = Automation_CheckElementExistsByAutomationId($Window,\"131\");\n\nif($elementFound)\n\n{\n\n$Button7 = Automation_GetElementByAutomationId($Window,\"131\");\n\n}\n\n\n\n\n\nAutomation_CheckElementExistsByAutomationIdAndName\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Automation_CheckElementExistsByAutomationIdAndName": {
  "prefix": "Automation_CheckElementExistsByAutomationIdAndName",
  "body": [
   "$$found=Automation_CheckElementExistsByAutomationIdAndName($$RootElement,$$AutomationId,$$Name);"
  ],
  "description": "\n\nThis function checks for the existence of an automation element within the root element that matches the specified Automation Id AND name.\n\n\n\n\n\nRequirements:\n\nThis function implements the UI Automation Framework which allows you to automate Win32, Windows Forms and WPF applications. Every part of a UI (window, button, menu, \u2026) is represented as an AutomationElement. An AutomationElement is an object that represents the accessible properties of a control.\n\n\n\n\n\nYou can use the Microsoft Program: UI Spy to view and interact with the user interface (UI) elements of an application.\n\n\n\n\n\nNote: UI Spy is installed with the Microsoft Windows SDK. It is located in the \\bin folder of the SDK installation path (uispy.exe) or can be accessed from the Start menu (Start\\All Programs\\Microsoft Windows SDK\\Tools\\UISpy).\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$RootElement\n\nObject\n\nThe root automation element which contains the element you'd like to check for.\n\n\n\n$AutomationId\n\nString\n\nThe Automation ID for the element.\n\n\n\n$Name\n\nString\n\nThe Name of the element.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$found\n\nBoolean\n\nTrue if any automation element matching the search parameter was found, otherwise false.\n\n\n\n\n\nUsage Example:\n\n$Window = Automation_GetRootAutomationElement(\"SciCalc\");\n\n$elementFound = Automation_CheckElementExistsByAutomationIdAndName ($Window,\"131\", \"7\");\n\nif($elementFound)\n\n{\n\n$Button7 = Automation_GetElementByAutomationIdAndName($Window, \"131\", \"7\");\n\n}\n\n\n\n\n\nAutomation_CheckElementExistsByName\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Automation_CheckElementExistsByName": {
  "prefix": "Automation_CheckElementExistsByName",
  "body": [
   "$$found=Automation_CheckElementExistsByName($$RootElement,$$Name);"
  ],
  "description": "\n\nThis function checks for the existence of an automation element within the root element that matches the specified name.\n\n\n\n\n\nRequirements:\n\nThis function implements the UI Automation Framework which allows you to automate Win32, Windows Forms and WPF applications. Every part of a UI (window, button, menu, \u2026) is represented as an AutomationElement. An AutomationElement is an object that represents the accessible properties of a control.\n\n\n\n\n\nYou can use the Microsoft Program: UI Spy to view and interact with the user interface (UI) elements of an application.\n\n\n\n\n\nNote: UI Spy is installed with the Microsoft Windows SDK. It is located in the \\bin folder of the SDK installation path (uispy.exe) or can be accessed from the Start menu (Start\\All Programs\\Microsoft Windows SDK\\Tools\\UISpy).\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$RootElement\n\nObject\n\nThe root automation element which contains the element you'd like to check for.\n\n\n\n$Name\n\nString\n\nThe Name of the element.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$found\n\nBoolean\n\nTrue if any automation element matching the search parameter was found, otherwise false.\n\n\n\n\n\nUsage Example:\n\n$Window = Automation_GetRootAutomationElement(\"SciCalc\");\n\n$elementFound = Automation_CheckElementExistsByName ($Window, \"7\");\n\nif($elementFound)\n\n{\n\n$Button7 = Automation_GetElementByName($Window, \"7\");\n\n}\n\n\n\n\n\nAutomation_CheckRootAutomationElementExistsByAutomationId\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Automation_CheckRootAutomationElementExistsByAutomationId": {
  "prefix": "Automation_CheckRootAutomationElementExistsByAutomationId",
  "body": [
   "$$found=Automation_CheckRootAutomationElementExistsByAutomationId($$AutomationId);"
  ],
  "description": "\n\nThis function checks for the existence of an automation element within the current desktop root that matches the specified AutomationId.\n\n\n\n\n\nRequirements:\n\nThis function implements the UI Automation Framework which allows you to automate Win32, Windows Forms and WPF applications. Every part of a UI (window, button, menu, \u2026) is represented as an AutomationElement. An AutomationElement is an object that represents the accessible properties of a control.\n\n\n\n\n\nYou can use the Microsoft Program: UI Spy to view and interact with the user interface (UI) elements of an application. By viewing the application's UI hierarchical structure, property values, and raised events, developers and testers can verify that the UI they are creating is programmatically accessible to assistive technology devices such as screen readers.\n\n\n\n\n\nNote: UI Spy is installed with the Microsoft Windows SDK. It is located in the \\bin folder of the SDK installation path (uispy.exe) or can be accessed from the Start menu (Start\\All Programs\\Microsoft Windows SDK\\Tools\\UISpy).\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AutomationId\n\nString\n\nThe AutomationId of the root automation element to be checked for.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$found\n\nObject\n\nTrue if any automation element matching the search parameter was found, otherwise false.\n\n\n\n\n\nUsage Example:\n\n$elementFound = Automation_CheckRootAutomationElementExistsByAutomationId (\"JabilMainForm\");\n\nif($elementFound)\n\n{\n\n$Window = Automation_GetRootAutomationElementByAutomationId(\"JabilMainForm\");\n\n}\n\nif(!$elementFound)\n\n{\n\nUpdateStatus(\"JabilMainForm not found! \");\n\n}\n\n\n\n\n\nAutomation_CheckRootAutomationElementExistsByName\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Automation_CheckRootAutomationElementExistsByName": {
  "prefix": "Automation_CheckRootAutomationElementExistsByName",
  "body": [
   "$$found=Automation_CheckRootAutomationElementExistsByName($$Name);"
  ],
  "description": "\n\nThis function checks for the existence of an automation element within the current desktop root that matches the specified name.\n\n\n\n\n\nRequirements:\n\nThis function implements the UI Automation Framework which allows you to automate Win32, Windows Forms and WPF applications. Every part of a UI (window, button, menu, \u2026) is represented as an AutomationElement. An AutomationElement is an object that represents the accessible properties of a control.\n\n\n\n\n\nYou can use the Microsoft Program: UI Spy to view and interact with the user interface (UI) elements of an application. By viewing the application's UI hierarchical structure, property values, and raised events, developers and testers can verify that the UI they are creating is programmatically accessible to assistive technology devices such as screen readers.\n\n\n\n\n\nNote: UI Spy is installed with the Microsoft Windows SDK. It is located in the \\bin folder of the SDK installation path (uispy.exe) or can be accessed from the Start menu (Start\\All Programs\\Microsoft Windows SDK\\Tools\\UISpy).\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Name\n\nString\n\nThe Name of the root automation element to be checked for.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$found\n\nObject\n\nTrue if any automation element matching the search parameter was found, otherwise false.\n\n\n\n\n\nUsage Example:\n\n$elementFound = Automation_CheckRootAutomationElementExistsByName(\"Calculator\");\n\nif($elementFound)\n\n{\n\n$Window = Automation_GetRootAutomationElementByName(\"Calculator\");\n\n}\n\nif(!$elementFound)\n\n{\n\nUpdateStatus(\"Calculator not found!\");\n\n}\n\n\n\n\n\nAutomation_ElementCollapse\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Automation_ElementCollapse": {
  "prefix": "Automation_ElementCollapse",
  "body": [
   "Automation_ElementCollapse($$Element);"
  ],
  "description": "\n\nThis function sends a request to the automation element to visually collapse the element and hide content.\n\nNote:\n\n\u00b7 The element must support the ExpandCollapsePattern control pattern\n\n\u00b7 The element can not be a leaf node.\n\n\u00b7 The only the parent element must support the ExpandCollapsePattern.\n\n\u00b7 A menu control, even though an aggregate of individual menu items, is an exception to the above rule. The menu items support the ExpandCollapsePattern control pattern, but the parent menu control does not. A similar exception applies to the tree and tree item controls.\n\n\n\n\n\nRequirements:\n\nThis function implements the UI Automation Framework which allows you to automate Win32, Windows Forms and WPF applications. Every part of a UI (window, button, menu, \u2026) is represented as an AutomationElement. An AutomationElement is an object that represents the accessible properties of a control.\n\n\n\n\n\nYou can use the Microsoft Program: UI Spy to view and interact with the user interface (UI) elements of an application.\n\n\n\n\n\nNote: UI Spy is installed with the Microsoft Windows SDK. It is located in the \\bin folder of the SDK installation path (uispy.exe) or can be accessed from the Start menu (Start\\All Programs\\Microsoft Windows SDK\\Tools\\UISpy).\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Element\n\nObject\n\nThe automation element to collapse\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nUsage Example:\n\n$comboBox = Automation_GetElementByAutomationId($Window,\"131\");\n\nAutomation_ElementCollapse($comboBox);\n\n\n\n\n\nAutomation_ElementExpand\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Automation_ElementExpand": {
  "prefix": "Automation_ElementExpand",
  "body": [
   "Automation_ElementExpand($$Element);"
  ],
  "description": "\n\nThis function sends a request to the automation element to visually expand and display additional content.\n\n\n\n\n\nNote:\n\n\u00b7 The element must support the ExpandCollapsePattern control pattern\n\n\u00b7 The element can not be a leaf node.\n\n\u00b7 The only the parent element must support the ExpandCollapsePattern.\n\n\u00b7 A menu control, even though an aggregate of individual menu items, is an exception to the above rule. The menu items support the ExpandCollapsePattern control pattern, but the parent menu control does not. A similar exception applies to the tree and tree item controls.\n\n\n\n\n\nRequirements:\n\nThis function implements the UI Automation Framework which allows you to automate Win32, Windows Forms and WPF applications. Every part of a UI (window, button, menu, \u2026) is represented as an AutomationElement. An AutomationElement is an object that represents the accessible properties of a control.\n\n\n\n\n\nYou can use the Microsoft Program: UI Spy to view and interact with the user interface (UI) elements of an application.\n\n\n\n\n\nNote: UI Spy is installed with the Microsoft Windows SDK. It is located in the \\bin folder of the SDK installation path (uispy.exe) or can be accessed from the Start menu (Start\\All Programs\\Microsoft Windows SDK\\Tools\\UISpy).\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Element\n\nObject\n\nThe automation element to expand\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nUsage Example:\n\n$comboBox = Automation_GetElementByAutomationId($Window,\"131\");\n\nAutomation_ElementExpand($comboBox);\n\n\n\n\n\nAutomation_ElementGetDocumentText\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Automation_ElementGetDocumentText": {
  "prefix": "Automation_ElementGetDocumentText",
  "body": [
   "$$Text=Automation_ElementGetDocumentText($$Element,$$maxLength);"
  ],
  "description": "\n\nThis function returns the plain text of the element. The text may possibly be truncated at the specified $maxLength. This function respects both hidden and visible text.\n\nIf $maxLength is greater than the length of the text span, the string returned will be the plain text of the text range.\n\n\n\n\n\nNote:\n\n\u00b7 The element must support the TextPattern control pattern.\n\n\n\n\n\nRequirements:\n\nThis function implements the UI Automation Framework which allows you to automate Win32, Windows Forms and WPF applications. Every part of a UI (window, button, menu, \u2026) is represented as an AutomationElement. An AutomationElement is an object that represents the accessible properties of a control.\n\n\n\n\n\nYou can use the Microsoft Program: UI Spy to view and interact with the user interface (UI) elements of an application.\n\n\n\n\n\nNote: UI Spy is installed with the Microsoft Windows SDK. It is located in the \\bin folder of the SDK installation path (uispy.exe) or can be accessed from the Start menu (Start\\All Programs\\Microsoft Windows SDK\\Tools\\UISpy).\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Element\n\nObject\n\nThe automation element to get text from\n\n\n\n$maxLength\n\nInteger\n\nThe maximum length of the string to return. Use -1 if no limit is required\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Text\n\nString\n\nThe plain text of the element, possibly truncated at the specified $maxLength.\n\n\n\n\n\nUsage Example:\n\n$Document = Automation_GetElementByAutomationId($Window,\"15\");\n\n$Text = Automation_ElementGetDocumentText($Document, 100);\n\n\n\n\n\nAutomation_ElementGetToggleValue\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Automation_ElementGetToggleValue": {
  "prefix": "Automation_ElementGetToggleValue",
  "body": [
   "$$Value=Automation_ElementGetToggleValue($$Element);"
  ],
  "description": "\n\nThis function gets the current Automation property value for the toggle element (Example: a checkbox) as a string.\n\n\n\n\n\nNote:\n\n\u00b7 The element must support the TogglePattern control pattern.\n\n\n\n\n\nRequirements:\n\nThis function implements the UI Automation Framework which allows you to automate Win32, Windows Forms and WPF applications. Every part of a UI (window, button, menu, \u2026) is represented as an AutomationElement. An AutomationElement is an object that represents the accessible properties of a control.\n\n\n\n\n\nYou can use the Microsoft Program: UI Spy to view and interact with the user interface (UI) elements of an application.\n\n\n\n\n\nNote: UI Spy is installed with the Microsoft Windows SDK. It can also be downloaded from the Jabil Test Wiki.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Element\n\nObject\n\nThe automation element to get value from\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Value\n\nString\n\nThe value of the Automation element as a string. The default is an empty string. For a checkbox, this will be \"On\" or \"Off\".\n\n\n\n\n\nUsage Example:\n\n$checkBox = Automation_GetElementByAutomationId($Window, \"m_cbUseFile\");\n\n$value = Automation_ElementGetToggleValue($checkBox);\n\n\n\n\n\nAutomation_ElementGetValue\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Automation_ElementGetValue": {
  "prefix": "Automation_ElementGetValue",
  "body": [
   "$$Value=Automation_ElementGetValue($$Element);"
  ],
  "description": "\n\nThis function gets the current Automation property value for the element as a string.\n\n\n\n\n\nNote:\n\n\u00b7 The element must support the ValuePattern control pattern.\n\n\u00b7 This function does not support multi-line edit controls. To retrieve the textual contents of multi-line edit controls use the Automation_GetElementDocumentText function.\n\n\n\n\n\nRequirements:\n\nThis function implements the UI Automation Framework which allows you to automate Win32, Windows Forms and WPF applications. Every part of a UI (window, button, menu, \u2026) is represented as an AutomationElement. An AutomationElement is an object that represents the accessible properties of a control.\n\n\n\n\n\nYou can use the Microsoft Program: UI Spy to view and interact with the user interface (UI) elements of an application.\n\n\n\n\n\nNote: UI Spy is installed with the Microsoft Windows SDK. It is located in the \\bin folder of the SDK installation path (uispy.exe) or can be accessed from the Start menu (Start\\All Programs\\Microsoft Windows SDK\\Tools\\UISpy).\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Element\n\nObject\n\nThe automation element to get value from\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Value\n\nString\n\nThe value of the Automation element as a string. The default is an empty string.\n\n\n\n\n\nUsage Example:\n\n$Button7 = Automation_GetElementByAutomationId($Window,\"131\");\n\nAutomation_ElementGetValue($Button7);\n\n\n\n\n\nAutomation_ElementInvoke\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Automation_ElementInvoke": {
  "prefix": "Automation_ElementInvoke",
  "body": [
   "Automation_ElementInvoke($$Element);"
  ],
  "description": "\n\nThis function sends a request to activate a control and initiate its single, unambiguous action.\n\n\n\n\n\nNote:\n\n\u00b7 The element must support the InvokePattern control pattern and can not be hidden or blocked.\n\n\u00b7 The element must be enabled.\n\n\n\n\n\nRequirements:\n\nThis function implements the UI Automation Framework which allows you to automate Win32, Windows Forms and WPF applications. Every part of a UI (window, button, menu, \u2026) is represented as an AutomationElement. An AutomationElement is an object that represents the accessible properties of a control.\n\n\n\n\n\nYou can use the Microsoft Program: UI Spy to view and interact with the user interface (UI) elements of an application.\n\n\n\n\n\nNote: UI Spy is installed with the Microsoft Windows SDK. It is located in the \\bin folder of the SDK installation path (uispy.exe) or can be accessed from the Start menu (Start\\All Programs\\Microsoft Windows SDK\\Tools\\UISpy).\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Element\n\nObject\n\nThe automation element to invoke\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nUsage Example:\n\n$Button7 = Automation_GetElementByAutomationId($Window,\"131\");\n\nAutomation_ElementInvoke($Button7);\n\n\n\n\n\nAutomation_ElementListSupportedPatterns\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Automation_ElementListSupportedPatterns": {
  "prefix": "Automation_ElementListSupportedPatterns",
  "body": [
   "$$PatternList=Automation_ElementListSupportedPatterns($$Element);"
  ],
  "description": "\n\nThis function retrieves the control patterns that the passed Automation Element supports. The patterns are returned as semicolon ; delimited string.\n\n\n\n\n\nRequirements:\n\nThis function implements the UI Automation Framework which allows you to automate Win32, Windows Forms and WPF applications. Every part of a UI (window, button, menu, \u2026) is represented as an AutomationElement. An AutomationElement is an object that represents the accessible properties of a control.\n\n\n\n\n\nYou can use the Microsoft Program: UI Spy to view and interact with the user interface (UI) elements of an application.\n\n\n\n\n\nNote: UI Spy is installed with the Microsoft Windows SDK. It is located in the \\bin folder of the SDK installation path (uispy.exe) or can be accessed from the Start menu (Start\\All Programs\\Microsoft Windows SDK\\Tools\\UISpy).\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Element\n\nObject\n\nThe automation element to retrieve supported patterns.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$PatternList\n\nString\n\nSemicolon ; delimited string of patterns supported by the passed element.\n\n\n\n\n\nUsage Example:\n\n$Button7 = Automation_GetElementByAutomationId($Window,\"131\");\n\n$PatternList = Automation_ElementListSupportedPatterns($Button7);\n\n\n\n\n\nAutomation_ElementSelectAllDocumentText\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Automation_ElementSelectAllDocumentText": {
  "prefix": "Automation_ElementSelectAllDocumentText",
  "body": [
   "Automation_ElementSelectAllDocumentText($$Element);"
  ],
  "description": "\n\nThis function selects the entire text range that encloses the main text of a document.\n\n\n\n\n\nNote:\n\n\u00b7 The element must support the TextPattern control pattern.\n\n\u00b7 Some auxiliary text such as headers, footnotes, or annotations might not be included.\n\n\n\n\n\nRequirements:\n\nThis function implements the UI Automation Framework which allows you to automate Win32, Windows Forms and WPF applications. Every part of a UI (window, button, menu, \u2026) is represented as an AutomationElement. An AutomationElement is an object that represents the accessible properties of a control.\n\n\n\n\n\nYou can use the Microsoft Program: UI Spy to view and interact with the user interface (UI) elements of an application.\n\n\n\n\n\nNote: UI Spy is installed with the Microsoft Windows SDK. It is located in the \\bin folder of the SDK installation path (uispy.exe) or can be accessed from the Start menu (Start\\All Programs\\Microsoft Windows SDK\\Tools\\UISpy).\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Element\n\nObject\n\nThe automation element to select text from\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nUsage Example:\n\n$Document = Automation_GetElementByAutomationId($Window,\"15\");\n\nAutomation_ElementSelectAllDocumentText($Document);\n\n\n\n\n\nAutomation_ElementSetFocus\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Automation_ElementSetFocus": {
  "prefix": "Automation_ElementSetFocus",
  "body": [
   "Automation_ElementSetFocus($$Element);"
  ],
  "description": "\n\nThis function sets focus on the automation element.The behavior of this method depends on the implementation by the UI Automation provider for the element. Setting focus does not necessarily bring the element to the foreground or make it visible.\n\n\n\n\n\nRequirements:\n\nThis function implements the UI Automation Framework which allows you to automate Win32, Windows Forms and WPF applications. Every part of a UI (window, button, menu, \u2026) is represented as an AutomationElement. An AutomationElement is an object that represents the accessible properties of a control.\n\n\n\n\n\nYou can use the Microsoft Program: UI Spy to view and interact with the user interface (UI) elements of an application.\n\n\n\n\n\nNote: UI Spy is installed with the Microsoft Windows SDK. It is located in the \\bin folder of the SDK installation path (uispy.exe) or can be accessed from the Start menu (Start\\All Programs\\Microsoft Windows SDK\\Tools\\UISpy).\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Element\n\nObject\n\nThe automation element to focus on\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nUsage Example:\n\n$Button7 = Automation_GetElementByAutomationId($Window,\"131\");\n\nAutomation_ElementSetFocus($Button7);\n\n\n\n\n\nAutomation_ElementSetValue\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Automation_ElementSetValue": {
  "prefix": "Automation_ElementSetValue",
  "body": [
   "Automation_ElementSetValue($$Element,$$Value);"
  ],
  "description": "\n\nThis function sets the current Automation property value for the element.\n\n\n\n\n\nNote:\n\n\u00b7 The element must support the ValuePattern control pattern.\n\n\u00b7 This function does not support multi-line edit controls.\n\n\u00b7 The control can not be read-only\n\n\u00b7 The control must be enabled\n\n\n\n\n\nRequirements:\n\nThis function implements the UI Automation Framework which allows you to automate Win32, Windows Forms and WPF applications. Every part of a UI (window, button, menu, \u2026) is represented as an AutomationElement. An AutomationElement is an object that represents the accessible properties of a control.\n\n\n\n\n\nYou can use the Microsoft Program: UI Spy to view and interact with the user interface (UI) elements of an application.\n\n\n\n\n\nNote: UI Spy is installed with the Microsoft Windows SDK. It is located in the \\bin folder of the SDK installation path (uispy.exe) or can be accessed from the Start menu (Start\\All Programs\\Microsoft Windows SDK\\Tools\\UISpy).\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Element\n\nObject\n\nThe automation element to set the value of\n\n\n\n$Value\n\nString\n\nThe value the control will be set to\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nUsage Example:\n\n$Document= Automation_GetElementByAutomationId($Window,\"15\");\n\nAutomation_ElementSetValue($Document, \"Hello World\");\n\n\n\n\n\nAutomation_GetDialogElementByName\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Automation_GetDialogElementByName": {
  "prefix": "Automation_GetDialogElementByName",
  "body": [
   "$$Element=Automation_GetDialogElementByName($$RootElement,$$Name);"
  ],
  "description": "\n\nThis function returns the first dialog element that matches the specified Name within the root element.\n\n\n\n\n\nRequirements:\n\nThis function implements the UI Automation Framework which allows you to automate Win32, Windows Forms and WPF applications. Every part of a UI (window, button, menu, \u2026) is represented as an AutomationElement. An AutomationElement is an object that represents the accessible properties of a control.\n\nYou can use the Microsoft Program: UI Spy to view and interact with the user interface (UI) elements of an application.\n\n\n\n\n\nNotes: UI Spy is installed with the Microsoft Windows SDK. It is located in the \\bin folder of the SDK installation path (uispy.exe) or can be accessed from the Start menu (Start\\All Programs\\Microsoft Windows SDK\\Tools\\UISpy).\n\nThe dialog window must already be open for the element to be found. You may have to delay after opening the dialog before the element ID can be returned.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$RootElement\n\nObject\n\nThe root automation element which contains the dialog you'd like to retrieve.\n\n\n\n$Name\n\nString\n\nThe Name of the dialog.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Element\n\nObject\n\nThe Dialog Element with the matching name within the specified root element. Note: Dialog elements can be used as root elements to access the controls in the dialog.\n\n\n\n\n\nUsage Example:\n\n// Get a handle to the program.\n\n$Window = Automation_GetRootAutomationElement(\"Notepad\");\n\n// Ensure the new program has focus.\n\nAutomation_ElementSetFocus($Window);\n\n// Open the \"Save\" dialog by sending <ctrl-s>.\n\nAutomation_SendKeysWait(\"^s\");\n\n// Get a link to the dialog that opened.\n\n$saveHandle = Automation_GetDialogElementByName($Window, \"Save\");\n\n\n\n\n\nAutomation_GetElementByAutomationId\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Automation_GetElementByAutomationId": {
  "prefix": "Automation_GetElementByAutomationId",
  "body": [
   "$$Element=Automation_GetElementByAutomationId($$RootElement,$$AutomationId);"
  ],
  "description": "\n\nThis function returns the first element that matches the specified Automation Id within the root element.\n\n\n\n\n\nRequirements:\n\nThis function implements the UI Automation Framework which allows you to automate Win32, Windows Forms and WPF applications. Every part of a UI (window, button, menu, \u2026) is represented as an AutomationElement. An AutomationElement is an object that represents the accessible properties of a control.\n\n\n\n\n\nYou can use the Microsoft Program: UI Spy to view and interact with the user interface (UI) elements of an application.\n\n\n\n\n\nNote: UI Spy is installed with the Microsoft Windows SDK. It is located in the \\bin folder of the SDK installation path (uispy.exe) or can be accessed from the Start menu (Start\\All Programs\\Microsoft Windows SDK\\Tools\\UISpy).\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$RootElement\n\nObject\n\nThe root automation element which contains the element you'd like to retrieve.\n\n\n\n$AutomationId\n\nString\n\nThe Automation ID for the element.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Element\n\nObject\n\nThe Automation Element with the matching automation ID within the specified root element.\n\n\n\n\n\nUsage Example:\n\n$Window = Automation_GetRootAutomationElement(\"SciCalc\");\n\n$Button7 = Automation_GetElementByAutomationId($Window,\"131\");\n\n\n\n\n\nAutomation_GetElementByAutomationIdAndClassName\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Automation_GetElementByAutomationIdAndClassName": {
  "prefix": "Automation_GetElementByAutomationIdAndClassName",
  "body": [
   "$$Element=Automation_GetElementByAutomationIdAndClassName($$RootElement,$$AutomationId,$$ClassName);"
  ],
  "description": "\n\nThis function returns the first element that matches both the specified Automation Id AND Class Name within the root element.\n\n\n\n\n\nRequirements:\n\nThis function implements the UI Automation Framework which allows you to automate Win32, Windows Forms and WPF applications. Every part of a UI (window, button, menu, \u2026) is represented as an AutomationElement. An AutomationElement is an object that represents the accessible properties of a control.\n\n\n\n\n\nYou can use the Microsoft Program: UI Spy to view and interact with the user interface (UI) elements of an application.\n\n\n\n\n\nNote: UI Spy is installed with the Microsoft Windows SDK. It is located in the \\bin folder of the SDK installation path (uispy.exe) or can be accessed from the Start menu (Start\\All Programs\\Microsoft Windows SDK\\Tools\\UISpy).\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$RootElement\n\nObject\n\nThe root automation element which contains the element you'd like to retrieve.\n\n\n\n$AutomationId\n\nString\n\nThe AutomationId of the element\n\n\n\n$Class Name\n\nString\n\nThe Class Name of the element.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Element\n\nObject\n\nThe Automation Element with the matching automation ID within the specified root element.\n\n\n\n\n\nUsage Example:\n\n$Window = Automation_GetRootAutomationElement(\"SciCalc\");\n\n$Button = Automation_GetElementByAutomationIdAndClassName($Window,\"314\",\"Button\");\n\n\n\n\n\nAutomation_GetElementByAutomationIdAndName\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Automation_GetElementByAutomationIdAndName": {
  "prefix": "Automation_GetElementByAutomationIdAndName",
  "body": [
   "$$Element=Automation_GetElementByAutomationIdAndName($$RootElement,$$AutomationId,$$Name);"
  ],
  "description": "\n\nThis function returns the first element that matches both the specified Automation Id AND Name within the root element.\n\n\n\n\n\nRequirements:\n\nThis function implements the UI Automation Framework which allows you to automate Win32, Windows Forms and WPF applications. Every part of a UI (window, button, menu, \u2026) is represented as an AutomationElement. An AutomationElement is an object that represents the accessible properties of a control.\n\n\n\n\n\nYou can use the Microsoft Program: UI Spy to view and interact with the user interface (UI) elements of an application.\n\n\n\n\n\nNote: UI Spy is installed with the Microsoft Windows SDK. It is located in the \\bin folder of the SDK installation path (uispy.exe) or can be accessed from the Start menu (Start\\All Programs\\Microsoft Windows SDK\\Tools\\UISpy).\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$RootElement\n\nObject\n\nThe root automation element which contains the element you'd like to retrieve.\n\n\n\n$AutomationId\n\nString\n\nThe AutomationId of the element\n\n\n\n$Name\n\nString\n\nThe Name of the element.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Element\n\nObject\n\nThe Automation Element with the matching automation ID within the specified root element.\n\n\n\n\n\nUsage Example:\n\n$Window = Automation_GetRootAutomationElement(\"SciCalc\");\n\n$Button = Automation_GetElementByAutomationIdAndName($Window,\"314\",\"Degrees\");\n\n\n\n\n\nAutomation_GetElementByClassName\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Automation_GetElementByClassName": {
  "prefix": "Automation_GetElementByClassName",
  "body": [
   "$$Element=Automation_GetElementByClassName($$RootElement,$$ClassName);"
  ],
  "description": "\n\nThis function returns the first element that matches the specified Class Name within the root element.\n\n\n\n\n\nRequirements:\n\nThis function implements the UI Automation Framework which allows you to automate Win32, Windows Forms and WPF applications. Every part of a UI (window, button, menu, \u2026) is represented as an AutomationElement. An AutomationElement is an object that represents the accessible properties of a control.\n\n\n\n\n\nYou can use the Microsoft Program: UI Spy to view and interact with the user interface (UI) elements of an application.\n\n\n\n\n\nNote: UI Spy is installed with the Microsoft Windows SDK. It is located in the \\bin folder of the SDK installation path (uispy.exe) or can be accessed from the Start menu (Start\\All Programs\\Microsoft Windows SDK\\Tools\\UISpy).\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$RootElement\n\nObject\n\nThe root automation element which contains the element you'd like to retrieve.\n\n\n\n$ClassName\n\nString\n\nThe Class Name of the element.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Element\n\nObject\n\nThe Automation Element with the matching automation ID within the specified root element.\n\n\n\n\n\nUsage Example:\n\n$Window = Automation_GetRootAutomationElement(\"SciCalc\");\n\n$Button = Automation_GetElementByClassName($Window,\"Edit\");\n\n\n\n\n\nAutomation_GetElementByName\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Automation_GetElementByName": {
  "prefix": "Automation_GetElementByName",
  "body": [
   "$$Element=Automation_GetElementByName($$RootElement,$$Name);"
  ],
  "description": "\n\nThis function returns the first element that matches the specified Name within the root element.\n\n\n\n\n\nRequirements:\n\nThis function implements the UI Automation Framework which allows you to automate Win32, Windows Forms and WPF applications. Every part of a UI (window, button, menu, \u2026) is represented as an AutomationElement. An AutomationElement is an object that represents the accessible properties of a control.\n\n\n\n\n\nYou can use the Microsoft Program: UI Spy to view and interact with the user interface (UI) elements of an application.\n\n\n\n\n\nNote: UI Spy is installed with the Microsoft Windows SDK. It is located in the \\bin folder of the SDK installation path (uispy.exe) or can be accessed from the Start menu (Start\\All Programs\\Microsoft Windows SDK\\Tools\\UISpy).\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$RootElement\n\nObject\n\nThe root automation element which contains the element you'd like to retrieve.\n\n\n\n$Name\n\nString\n\nThe Name of the element.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Element\n\nObject\n\nThe Automation Element with the matching automation ID within the specified root element.\n\n\n\n\n\nUsage Example:\n\n$Window = Automation_GetRootAutomationElement(\"Notepad\");\n\n$Button = Automation_GetElementByName($Window,\"Save\");\n\n\n\n\n\nAutomation_GetElementByNameAndClassName\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Automation_GetElementByNameAndClassName": {
  "prefix": "Automation_GetElementByNameAndClassName",
  "body": [
   "$$Element=Automation_GetElementByNameAndClassName($$RootElement,$$Name,$$ClassName);"
  ],
  "description": "\n\nThis function returns the first element that matches both the specified Name AND Class Name within the root element.\n\n\n\n\n\nRequirements:\n\nThis function implements the UI Automation Framework which allows you to automate Win32, Windows Forms and WPF applications. Every part of a UI (window, button, menu, \u2026) is represented as an AutomationElement. An AutomationElement is an object that represents the accessible properties of a control.\n\n\n\n\n\nYou can use the Microsoft Program: UI Spy to view and interact with the user interface (UI) elements of an application.\n\n\n\n\n\nNote: UI Spy is installed with the Microsoft Windows SDK. It is located in the \\bin folder of the SDK installation path (uispy.exe) or can be accessed from the Start menu (Start\\All Programs\\Microsoft Windows SDK\\Tools\\UISpy).\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$RootElement\n\nObject\n\nThe root automation element which contains the element you'd like to retrieve.\n\n\n\n$Name\n\nString\n\nThe Name of the element\n\n\n\n$ClassName\n\nString\n\nThe Class Name of the element\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Element\n\nObject\n\nThe Automation Element with the matching automation ID within the specified root element.\n\n\n\n\n\nUsage Example:\n\n$Window = Automation_GetRootAutomationElement(\"SciCalc\");\n\n$Button = Automation_GetElementByNameAndClassName($Window,\"Degrees\",\"Button\");\n\n\n\n\n\nAutomation_GetElementByNameSubstring\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Automation_GetElementByNameSubstring": {
  "prefix": "Automation_GetElementByNameSubstring",
  "body": [
   "$$Element=Automation_GetElementByNameSubstring($$RootElement,$$NameSubstring);"
  ],
  "description": "\n\nThis function returns the first element whose name contains the specified substring within the specified root element.\n\n\n\n\n\nRequirements:\n\nThis function implements the UI Automation Framework which allows you to automate Win32, Windows Forms and WPF applications. Every part of a UI (window, button, menu, \u2026) is represented as an AutomationElement. An AutomationElement is an object that represents the accessible properties of a control.\n\n\n\n\n\nYou can use the Microsoft Program: UI Spy to view and interact with the user interface (UI) elements of an application.\n\n\n\n\n\nNote: UI Spy is installed with the Microsoft Windows SDK. It is located in the \\bin folder of the SDK installation path (uispy.exe) or can be accessed from the Start menu (Start\\All Programs\\Microsoft Windows SDK\\Tools\\UISpy).\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$RootElement\n\nObject\n\nThe root automation element which contains the element you'd like to retrieve.\n\n\n\n$NameSubstring\n\nString\n\nThe substring to search for in the name of the element.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Element\n\nObject\n\nThe Automation Element with the matching automation ID within the specified root element.\n\n\n\n\n\nUsage Example:\n\n$child = Automation_GetElementByNameSubstring($root, \"App\");\n\n\n\n\n\nAutomation_GetElementByPropertyIndex\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Automation_GetElementByPropertyIndex": {
  "prefix": "Automation_GetElementByPropertyIndex",
  "body": [
   "$$Count=Automation_GetElementByPropertyIndex($$Root,$$PropertyValue,$$PropertyType,$$Index);"
  ],
  "description": "\n\nThis function returns the automation element within the root element at the required index that matches the specified property value for the specified property type. The index is zero based.\n\n\n\n\n\nProperty Type Values:\n\n\u00b7 CLASS = Element Class Name\n\n\u00b7 AUTOID = Element Automation Id\n\n\u00b7 NAME = Element Name\n\n\u00b7 CTRL = Element Control Type\n\n\n\n\n\nRequirements:\n\nThis function implements the UI Automation Framework which allows you to automate Win32, Windows Forms and WPF applications. Every part of a UI (window, button, menu, \u2026) is represented as an AutomationElement. An AutomationElement is an object that represents the accessible properties of a control.\n\n\n\n\n\nYou can use the Microsoft Program: UI Spy to view and interact with the user interface (UI) elements of an application.\n\n\n\n\n\nNote: UI Spy is installed with the Microsoft Windows SDK. It is located in the \\bin folder of the SDK installation path (uispy.exe) or can be accessed from the Start menu (Start\\All Programs\\Microsoft Windows SDK\\Tools\\UISpy).\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Root\n\nObject\n\nThe root automation element which contains the elements you'd like to count.\n\n\n\n$PropertyValue\n\nString\n\nThe property value that you'd like to match\n\n\n\n$PropertyType\n\nString\n\nThe property type you'd like to compare the value against. [CLASS,AUTOID,NAME,CTRL]\n\n\n\n$Index\n\nInteger\n\nThe zero based index of the matching elements\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Count\n\nInteger\n\nThe number of matching elements\n\n\n\n\n\nUsage Example:\n\n$Window = Automation_GetRootAutomationElement(\"SciCalc\");\n\n$element = Automation_GetElementByPropertyIndex($Window,\"ControlType.RadioButton\",\"CTRL\",0);\n\n\n\n\n\nAutomation_GetElementCountByProperty\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Automation_GetElementCountByProperty": {
  "prefix": "Automation_GetElementCountByProperty",
  "body": [
   "$$Count=Automation_GetElementCountByProperty($$Root,$$PropertyValue,$$PropertyType);"
  ],
  "description": "\n\nThis function returns the number of elements within the root element that match the specified property value for the specified property type.\n\n\n\n\n\nProperty Type Values:\n\n\u00b7 CLASS = Element Class Name\n\n\u00b7 AUTOID = Element Automation Id\n\n\u00b7 NAME = Element Name\n\n\u00b7 CTRL = Element Control Type\n\n\n\n\n\nRequirements:\n\nThis function implements the UI Automation Framework which allows you to automate Win32, Windows Forms and WPF applications. Every part of a UI (window, button, menu, \u2026) is represented as an AutomationElement. An AutomationElement is an object that represents the accessible properties of a control.\n\n\n\n\n\nYou can use the Microsoft Program: UI Spy to view and interact with the user interface (UI) elements of an application.\n\n\n\n\n\nNote: UI Spy is installed with the Microsoft Windows SDK. It is located in the \\bin folder of the SDK installation path (uispy.exe) or can be accessed from the Start menu (Start\\All Programs\\Microsoft Windows SDK\\Tools\\UISpy).\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Root\n\nObject\n\nThe root automation element which contains the elements you'd like to count.\n\n\n\n$PropertyValue\n\nString\n\nThe property value that you'd like to match\n\n\n\n$PropertyType\n\nString\n\nThe property type you'd like to compare the value against. [CLASS,AUTOID,NAME,CTRL]\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Count\n\nInteger\n\nThe number of matching elements\n\n\n\n\n\nUsage Example:\n\n$Window = Automation_GetRootAutomationElement(\"SciCalc\");\n\n$c = Automation_GetElementCountByProperty($Window,\"ControlType.RadioButton\",\"CTRL\");\n\n\n\n\n\nAutomation_GetElementDescript\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Automation_GetElementDescript": {
  "prefix": "Automation_GetElementDescript",
  "body": [
   "($$className,$$controlType,$$automationId,$$elementName,$$processId)=Automation_GetElementDescript($$elementHandle);"
  ],
  "description": "\n\nThis function returns information about an automation element.\n\n\n\nNote:\n\n\u00b7 Not all data will be populated by all elements. This is a function for how the software being automated was created.\n\n\u00b7 Some automation elements will not support returning the process ID. For these, the returned value will be \"Not Supported\".\n\n\u00b7 The process ID is the Windows process ID.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$elementHandle\n\nObject\n\nThe handle to the element that you wish to get information about. This will have been created with any of the Automation_GetElement"
 }
,
 "JTS Automation_GetRootAutomationElement": {
  "prefix": "Automation_GetRootAutomationElement",
  "body": [
   "$$RootElement=Automation_GetRootAutomationElement($$ClassName);"
  ],
  "description": "\n\nThis function returns the first automation element within the current desktop root that matches the specified ClassName of that element.\n\n\n\n\n\nRequirements:\n\nThis function implements the UI Automation Framework which allows you to automate Win32, Windows Forms and WPF applications. Every part of a UI (window, button, menu, \u2026) is represented as an AutomationElement. An AutomationElement is an object that represents the accessible properties of a control.\n\n\n\n\n\nYou can use the Microsoft Program: UI Spy to view and interact with the user interface (UI) elements of an application. By viewing the application's UI hierarchical structure, property values, and raised events, developers and testers can verify that the UI they are creating is programmatically accessible to assistive technology devices such as screen readers.\n\n\n\n\n\nNote: UI Spy is installed with the Microsoft Windows SDK. It is located in the \\bin folder of the SDK installation path (uispy.exe) or can be accessed from the Start menu (Start\\All Programs\\Microsoft Windows SDK\\Tools\\UISpy).\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ClassName\n\nString\n\nThe ClassName of the root automation element to be returned.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$RootElement\n\nObject\n\nThe root automation element which contains the element you'd like to retrieve.\n\n\n\n\n\nUsage Example:\n\n$Window = Automation_GetRootAutomationElement(\"SciCalc\");\n\n\n\n\n\nAutomation_GetRootAutomationElementByAutomationId\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Automation_GetRootAutomationElementByAutomationId": {
  "prefix": "Automation_GetRootAutomationElementByAutomationId",
  "body": [
   "$$RootElement=Automation_GetRootAutomationElementByAutomationId($$AutomationId);"
  ],
  "description": "\n\nThis function returns the first automation element within the current desktop root that matches the specified AutomationId of that element.\n\n\n\n\n\nRequirements:\n\nThis function implements the UI Automation Framework which allows you to automate Win32, Windows Forms and WPF applications. Every part of a UI (window, button, menu, \u2026) is represented as an AutomationElement. An AutomationElement is an object that represents the accessible properties of a control.\n\n\n\n\n\nYou can use the Microsoft Program: UI Spy to view and interact with the user interface (UI) elements of an application. By viewing the application's UI hierarchical structure, property values, and raised events, developers and testers can verify that the UI they are creating is programmatically accessible to assistive technology devices such as screen readers.\n\n\n\n\n\nNote: UI Spy is installed with the Microsoft Windows SDK. It is located in the \\bin folder of the SDK installation path (uispy.exe) or can be accessed from the Start menu (Start\\All Programs\\Microsoft Windows SDK\\Tools\\UISpy).\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AutomationId\n\nString\n\nThe AutomationId of the root automation element to be returned.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$RootElement\n\nObject\n\nThe root automation element which contains the element you'd like to retrieve.\n\n\n\n\n\nUsage Example:\n\n$Window = Automation_GetRootAutomationElementByAutomationId(\"JabilMainForm\");\n\n\n\n\n\nAutomation_GetRootAutomationElementByName\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Automation_GetRootAutomationElementByName": {
  "prefix": "Automation_GetRootAutomationElementByName",
  "body": [
   "$$RootElement=Automation_GetRootAutomationElementByName($$Name);"
  ],
  "description": "\n\nThis function returns the first automation element within the current desktop root that matches the specified Name of that element.\n\n\n\n\n\nRequirements:\n\nThis function implements the UI Automation Framework which allows you to automate Win32, Windows Forms and WPF applications. Every part of a UI (window, button, menu, \u2026) is represented as an AutomationElement. An AutomationElement is an object that represents the accessible properties of a control.\n\n\n\n\n\nYou can use the Microsoft Program: UI Spy to view and interact with the user interface (UI) elements of an application. By viewing the application's UI hierarchical structure, property values, and raised events, developers and testers can verify that the UI they are creating is programmatically accessible to assistive technology devices such as screen readers.\n\n\n\n\n\nNote: UI Spy is installed with the Microsoft Windows SDK. It is located in the \\bin folder of the SDK installation path (uispy.exe) or can be accessed from the Start menu (Start\\All Programs\\Microsoft Windows SDK\\Tools\\UISpy).\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Name\n\nString\n\nThe Name of the root automation element to be returned.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$RootElement\n\nObject\n\nThe root automation element which contains the element you'd like to retrieve.\n\n\n\n\n\nUsage Example:\n\n$Window = Automation_GetRootAutomationElementByName(\"Untitled - Notepad\");\n\n\n\n\n\nAutomation_GetRootAutomationElementByNameSubstring\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Automation_GetRootAutomationElementByNameSubstring": {
  "prefix": "Automation_GetRootAutomationElementByNameSubstring",
  "body": [
   "$$RootElement=Automation_GetRootAutomationElementByNameSubstring($$NameSubstring);"
  ],
  "description": "\n\nThis function returns the first automation element within the current desktop root whose name contains the specified substring.\n\n\n\n\n\nRequirements:\n\nThis function implements the UI Automation Framework which allows you to automate Win32, Windows Forms and WPF applications. Every part of a UI (window, button, menu, \u2026) is represented as an AutomationElement. An AutomationElement is an object that represents the accessible properties of a control.\n\n\n\n\n\nYou can use the Microsoft Program: UI Spy to view and interact with the user interface (UI) elements of an application. By viewing the application's UI hierarchical structure, property values, and raised events, developers and testers can verify that the UI they are creating is programmatically accessible to assistive technology devices such as screen readers.\n\n\n\n\n\nNote: UI Spy is installed with the Microsoft Windows SDK. It is located in the \\bin folder of the SDK installation path (uispy.exe) or can be accessed from the Start menu (Start\\All Programs\\Microsoft Windows SDK\\Tools\\UISpy).\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NameSubstring\n\nString\n\nThe substring of the root automation element's name.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$RootElement\n\nObject\n\nThe root automation element which contains the element you'd like to retrieve.\n\n\n\n\n\nUsage Example:\n\n$root = Automation_GetRootAutomationElementByNameSubstring(\"Not\");\n\n\n\n\n\nAutomation_GridGetItem\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Automation_GridGetItem": {
  "prefix": "Automation_GridGetItem",
  "body": [
   "$$GridItem=Automation_GridGetItem($$ParentElement,$$Row,$$Column);"
  ],
  "description": "\n\nThis function retrieves an Automation Element that represents the specified cell within the specified source element containing the grid.\n\n\n\n\n\nNote:\n\n\u00b7 The element must support the GridPattern control pattern.\n\n\u00b7 Grid coordinates are zero-based with the upper left (or upper right cell depending on locale) having coordinates (0,0).\n\n\u00b7 If a cell is empty, a UI Automation element is still returned in order to support retrieval of the ContainingGrid property for that cell. This is possible when the layout of child elements in the grid are staggered.\n\n\n\n\n\nRequirements:\n\nThis function implements the UI Automation Framework which allows you to automate Win32, Windows Forms and WPF applications. Every part of a UI (window, button, menu, \u2026) is represented as an AutomationElement. An AutomationElement is an object that represents the accessible properties of a control.\n\n\n\n\n\nYou can use the Microsoft Program: UI Spy to view and interact with the user interface (UI) elements of an application.\n\n\n\n\n\nNote: UI Spy is installed with the Microsoft Windows SDK. It is located in the \\bin folder of the SDK installation path (uispy.exe) or can be accessed from the Start menu (Start\\All Programs\\Microsoft Windows SDK\\Tools\\UISpy).\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$SourceElement\n\nObject\n\nThe automation element containing the grid.\n\n\n\n$Row\n\nInteger\n\nThe row of the grid item to retrieve\n\n\n\n$Column\n\nInteger\n\nThe column of the grid item to retrieve.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$GridItem\n\nObject\n\nThe automation element retrieved from the specified grid cell.\n\n\n\n\n\nUsage Example:\n\n$Container = Automation_GetElementByAutomationId($Window,\"1\");\n\n$Element = Automation_GridGetItem($Container, 0, 0);\n\n$value = Automation_ElementGetValue($Element);\n\n\n\n\n\nAutomation_SendKeys\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Automation_SendKeys": {
  "prefix": "Automation_SendKeys",
  "body": [
   "Automation_SendKeys($$KeyStrokes);"
  ],
  "description": "\n\n\n\n\n\nUse the SendKeys method to send keystrokes to applications that have no automation interface. Most keyboard characters are represented by a single keystroke. Some keyboard characters are made up of combinations of keystrokes (CTRL+SHIFT+HOME, for example). To send a single keyboard character, send the character itself as the string argument. For example, to send the letter x, send the string argument \"x\".\n\n\n\n\n\nYou can use SendKeys to send more than one keystroke at a time. To do this, create a compound string argument that represents a sequence of keystrokes by appending each keystroke in the sequence to the one before it. For example, to send the keystrokes a, b, and c, you would send the string argument \"abc\". The SendKeys method uses some characters as modifiers of characters (instead of using their face-values). This set of special characters consists of parentheses, brackets, braces, and the:\n\n\n\n\n\n\u00b7 "
 }
,
 "JTS Automation_SendKeysWait": {
  "prefix": "Automation_SendKeysWait",
  "body": [
   "Automation_SendKeysWait($$KeyStrokes);"
  ],
  "description": "\n\n\n\n\n\nUse the SendKeys method to send keystrokes to applications that have no automation interface. Most keyboard characters are represented by a single keystroke. Some keyboard characters are made up of combinations of keystrokes (CTRL+SHIFT+HOME, for example). To send a single keyboard character, send the character itself as the string argument. For example, to send the letter x, send the string argument \"x\".\n\n\n\n\n\nNote: This function differs from the SendKeys function since it waits for the window to process all events before continuing to the next script command. If you aren't sure which function to use, try 'SendKeysWait' first.\n\n\n\n\n\nYou can use SendKeys to send more than one keystroke at a time. To do this, create a compound string argument that represents a sequence of keystrokes by appending each keystroke in the sequence to the one before it. For example, to send the keystrokes a, b, and c, you would send the string argument \"abc\". The SendKeys method uses some characters as modifiers of characters (instead of using their face-values). This set of special characters consists of parentheses, brackets, braces, and the:\n\n\n\n\n\n\u00b7 "
 }
,
 "JTS Automation_SendMouseClick": {
  "prefix": "Automation_SendMouseClick",
  "body": [
   "Automation_SendMouseClick($$Xposition,$$Yposition,$$button);"
  ],
  "description": "\n\n\n\nThis function will move the cursor to the specified coordinates on screen and perform a mouse click at that location.\n\nThe location is in pixels from the top left of the screen.\n\nA button down followed by a button up event is simulated.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Xposition\n\nInteger\n\nThe horizontal position to move the cursor to. Counted in pixels from the left edge of the screen.\n\n\n\n$Yposition\n\nInteger\n\nThe vertical position to move the cursor to. Counted in pixels from the top edge of the screen.\n\n\n\n$button\n\nString\n\nThe mouse button to simulate the click of.\n\nValue:\n\n\u00b7 \"Left\"\n\n\u00b7 \"Middle\"\n\n\u00b7 \"Right\"\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n\n\n\n\n// Click the left mouse button at location 100,200.\n\n$Xposition = 100;\n\n$Yposition = 200;\n\n$button = \"Left\";\n\nAutomation_SendMouseClick($Xposition, $Yposition, $button);\n\n\n\n\n\nInvokeViewWindowScript\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS BrowserInvoke": {
  "prefix": "BrowserInvoke",
  "body": [
   "$$ReturnVariable=BrowserInvoke($$FunctionName$$Argument1,..,$$ArgumentN]);"
  ],
  "description": "\n\nThis function invokes a Javascript function within the current view window's document.\n\n\n\n\n\nNote:\n\nThe Javascript function arguments are optional and this function can accept as many as needed.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$FunctionName\n\nString\n\nThe name of the Javascript Function to invoke.\n\n\n\n$Arguments\n\nObject\n\n[optional] A variable number of Javascript function arguments can be passed as needed to invoke.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ReturnVariable\n\nObject\n\nThe return variable from the Javascript function if one exists.\n\n\n\n\n\nExample:\n\n$str = BrowserInvokeScript(\"TestReturn\");\n\nBrowserInvokeScript(\"PopItUp\", $str);\n\n\n\n\n\n"
 }
,
 "JTS BrowserRefresh": {
  "prefix": "BrowserRefresh",
  "body": [
   "BrowserRefresh();"
  ],
  "description": "\n\nThis function refreshes the view window and reloads the current document and/or text.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\nBrowserRefresh();\n\n\n\n\n\nUpdateViewWindowDocument\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS BrowserSetDocument": {
  "prefix": "BrowserSetDocument",
  "body": [
   "BrowserSetDocument($$Path);"
  ],
  "description": "\n\nThis function sets the browser document to the html file at the specified path.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Path\n\nString\n\nPath to the HTML file to set in the browser.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\nBrowserSetDocument(\"C:\\\\html\\\\window.html\");\n\n\n\n\n\nUpdateViewWindowText\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS BrowserSetText": {
  "prefix": "BrowserSetText",
  "body": [
   "BrowserSetText($$Text);"
  ],
  "description": "\n\nThis function sets the browser text to the specified string.\n\n\n\n\n\nNote: The string can contain HTML syntax to be rendered in the browser.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Text\n\nString\n\nText to display in the browser.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\nBrowserSetText(\"<b>Display this test string</b>\");\n\n\n\n\n\nBrowserUpdateTag\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS BrowserUpdateTag": {
  "prefix": "BrowserUpdateTag",
  "body": [
   "BrowserUpdateTag($$TagId,$$Contents$$Action]);"
  ],
  "description": "\n\nThis function finds the HTML Element within the current browser document with a matching tag id and either replaces or appends the content of the element with the specified text.\n\n\n\n\n\nNotes:\n\n\u00b7 The contents string can contain HTML syntax to be rendered in the browser.\n\n\u00b7 The element to be replaced is found by the Id, not the tag. For example, the line <span id=\"changetag\"> Change this text. </span> would be located by the Id \"changetag\" and not by the tag name \"span\".\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$TagId\n\nString\n\nThe Id of the HTML element to update.\n\n\n\n$Contents\n\nString\n\nThe text to display within the element.\n\n\n\n$Action\n\nString\n\n[OPTIONAL] Specifies whether the content should replace the existing element content or append to it. This argument is optional and set to REPLACE by default. Acceptable inputs are REPLACE or APPEND.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone.\n\n\n\n\n\nExample:\n\nBrowserSetDocument(\"C:\\\\JabilTest\\\\Resources\\\\BrowserTemplate.html\");\n\nSleep(1);\n\nBrowserUpdateTag(\"header\", \"this is a header\");\n\nBrowserUpdateTag(\"body\", \"put this in the body\");\n\nBrowserUpdateTag(\"optional1\", \"bold italics\");\n\nBrowserUpdateTag(\"optional1\", \"<br />append this\", \"APPEND\");\n\nBrowserUpdateTag(\"optional2\", \"italics\");\n\nBrowserUpdateTag(\"optional3\", \"small\");\n\nBrowserUpdateTag(\"test\", \"test\");\n\nSleep(5);\n\nEnd;\n\n\n\n\n\nRequestCableLabsCertificate\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS RequestCableLabsCertificate": {
  "prefix": "RequestCableLabsCertificate",
  "body": [
   "($$RequestedKey,$$KeyStatus)=RequestCableLabsCertificate($$ServerURL,$$CustomerName,$$ProductType,$$TestOperator,$$SerialNumber);"
  ],
  "description": "\n\nThis function will request a Cable Labs end entity certificate for the supplied customer, product type, and serial number. In order to use this function, the Cable Labs certificate server administration utility must be used to authorize the given client to request certificates for a customer.Example:\n\n($Key,$KeyStatus) = RequestCableLabsCertificate(\"http://gtsstgsvr/datamanagerservice/service.asmx\",\"MyCompany\",\"MyProduct\",$TestOperator,$SerialNumber);\n\n\n\n\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ServerURL\n\nString\n\nThis is the URL of the server which is hosting the web service used to request certificates from the cable labs management server\n\n\n\n$CustomerName\n\nString\n\nThe name of the customer for whom you are requesting a certificate\n\n\n\n$ProductType\n\nString\n\nThe product type for which you are requesting a certificate\n\n\n\n$TestOperator\n\nString\n\nThe test operator whom you would like recorded as being the requestor of the certificate\n\n\n\n$SerialNumber\n\nString\n\nThe serial number of the product to assign to the requested certificate. Note: Once a certificate has been requested for a given customer, product style, and serial number, the same certificate will always be returned by the function.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$key\n\nString\n\nThe cable labs certificate requested. This certificate will be returned completely unencrypted in clear text\n\n\n\n$keyStatus\n\nString\n\nThe status string indicating if this key was newly assigned by this request, or if the key was previously assigned to the product in a past test run.\n\n\n\n\n\nChartPanel_AddNewPane\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ChartPanel_AddNewPane": {
  "prefix": "ChartPanel_AddNewPane",
  "body": [
   "ChartPanel_AddNewPane();"
  ],
  "description": "\n\n\n\n\n\nThis function adds a new pane to the existing chart panel. Each pane is identified by a zero based index. Each pane can contain a single chart or plot of any type. The pane is automatically scaled and placed within the window based on the current size of the control.\n\n\n\n\n\nImportant Note: In order to use the Jabil Test Chart Panel Functionality, make sure that the current test cell extended panel mode is set to Charting Mode.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nUsage Example:\n\nChartPanel_AddNewPane();\n\n\n\n\n\nChartPanel_ClearAllPanes\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ChartPanel_ClearAllPanes": {
  "prefix": "ChartPanel_ClearAllPanes",
  "body": [
   "ChartPanel_ClearAllPanes();"
  ],
  "description": "\n\n\n\n\n\nThis function removes all existing panes from the chart panel window.\n\n\n\n\n\nImportant Note: In order to use the Jabil Test Chart Panel Functionality, make sure that the current test cell extended panel mode is set to Charting Mode.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nUsage Example:\n\nChartPanel_AddNewPane();\n\n\n\n\n\nChartPanel_ClearAllSeriesOnPane\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ChartPanel_ClearAllSeriesOnPane": {
  "prefix": "ChartPanel_ClearAllSeriesOnPane",
  "body": [
   "ChartPanel_ClearAllSeriesOnPane($$PaneIndex);"
  ],
  "description": "\n\n\n\n\n\nThis function removes all plotted series on a given pane on the graphing panel. If the current pane does not exist, the function will generate a failing test result.\n\n\n\n\n\nImportant Note: In order to use the Jabil Test Chart Panel Functionality, make sure that the current test cell extended panel mode is set to Charting Mode.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$PaneIndex\n\nInteger\n\nThe zero based index of the pane for which to remove all trace and plot information.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nUsage Example:\n\nChartPanel_ClearAllSeriesOnPane(0); // Clears all graph data on the first pane.\n\n\n\n\n\nChartPanel_Plot1DArray\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ChartPanel_Plot1DArray": {
  "prefix": "ChartPanel_Plot1DArray",
  "body": [
   "ChartPanel_Plot1DArray($$PaneIndex,$$SeriesLabel,$$Array,$$Red,$$Green,$$Blue);"
  ],
  "description": "\n\n\n\n\n\nThis function plots a 1 dimensional array on the specified graph pane. The series added to the graph is identified via the $SeriesLabel parameter. The user may also specify the color of the series drawn on the graph by specifying it's Red, Green, and Blue color components.\n\n\n\n\n\nImportant Note: In order to use the Jabil Test Chart Panel Functionality, make sure that the current test cell extended panel mode is set to Charting Mode.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$PaneIndex\n\nInteger\n\nThe index of the pane on which to graph the array data.\n\n\n\n$SeriesLabel\n\nString\n\nThe series label which will be displayed in the legend of the graph pane\n\n\n\n$Array\n\nArray\n\nThe 1 dimensional array to plot on the graph object. Note this array must be an array of numerics such as integers, doubles, floats, etc.\n\n\n\n$Red\n\nInteger\n\nThe value of the red component for the plotted data. Valid values are 0 to 255.\n\n\n\n$Green\n\nInteger\n\nThe value of the green component for the plotted data. Valid values are 0 to 255.\n\n\n\n$Blue\n\nInteger\n\nThe value of the blue component for the plotted data. Valid values are 0 to 255.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nUsage Example:\n\nChartPanel_Plot1DArray(0,\"Power\",$Array,255,0,0);\n\n\n\n\n\nChartPanel_Plot2DArray\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ChartPanel_Plot2DArray": {
  "prefix": "ChartPanel_Plot2DArray",
  "body": [
   "ChartPanel_Plot2DArray($$PaneIndex,$$SeriesLabel,$$Array,$$Red,$$Green,$$Blue);"
  ],
  "description": "\n\nThis function plots a 2 dimensional array on the specified graph pane. The series added to the graph is identified via the $SeriesLabel parameter. The user may also specify the color of the series drawn on the graph by specifying it's Red, Green, and Blue color components.\n\n\n\n\n\nThe first dimension of the 2 dimensional array is plotted as X values, and the second dimension will be plotted as the corresponding Y values.\n\n\n\n\n\nImportant Note: In order to use the Jabil Test Chart Panel Functionality, make sure that the current test cell extended panel mode is set to Charting Mode.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$PaneIndex\n\nInteger\n\nThe index of the pane on which to graph the array data.\n\n\n\n$SeriesLabel\n\nString\n\nThe series label which will be displayed in the legend of the graph pane\n\n\n\n\n$Array\n\n\nArray\n\nThe 2 dimensional array to plot on the graph object. Note this array must be an array of numerics such as integers, doubles, floats, etc. The first dimension of the 2 dimensional array is plotted as X values, and the second dimension will be plotted as the corresponding Y values.\n\n\n\n$Red\n\nInteger\n\nThe value of the red component for the plotted data. Valid values are 0 to 255.\n\n\n\n$Green\n\nInteger\n\nThe value of the green component for the plotted data. Valid values are 0 to 255.\n\n\n\n$Blue\n\nInteger\n\nThe value of the blue component for the plotted data. Valid values are 0 to 255.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nUsage Example:\n\nChartPanel_Plot2DArray(0, \"Power\", $Array, 255, 0, 0);\n\n\n\n\n\nChartPanel_Plot2DBarGraphFromTrace\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ChartPanel_Plot2DBarGraphTrace": {
  "prefix": "ChartPanel_Plot2DBarGraphTrace",
  "body": [
   "ChartPanel_Plot2DBarGraphTrace($$PaneIndex,$$SeriesLabel,$$Trace,$$Red,$$Green,$$Blue);"
  ],
  "description": "\n\n\n\n\n\nThis function plots a 2 dimensional bargraph on the specified graph pane. The series added to the graph is identified via the $SeriesLabel parameter. The user may also specify the color of the series drawn on the graph by specifying it's Red, Green, and Blue color components.\n\nThis function differs from the ChartPanel_Plot2DTrace function as each X/Y value in the Trace2D object is represented as a vertical bar at the X position specified, and the height is specified by the Y value.\n\n\n\n\n\nNote: This function uses the new native Trace2D data type which has recently been added to the Jabil Test Core Library. Most older instrument libraries actually return their non-scalar measurement data as array data types, so you should use the corresponding ChartPanel_Plot1DArray or ChartPanel_Plot2DArray functions for these types of data objects.\n\nThe Trace2D data type is a convenience feature to simplify Jabil Test scripting since all necessary data regarding how the data should be plotted is contained in the data structure returned from the instrument library.\n\n\n\n\n\nGoing forward, all instrument driver functions which return an array of data that is intended for graphing such as spectrum analyzers, oscilloscopes, vector signal analyzers, etc should return the new Trace2D data type which is contained in the Jabil Test Core Library.\n\n\n\n\n\nImportant Note: In order to use the Jabil Test Chart Panel Functionality, make sure that the current test cell extended panel mode is set to Charting Mode.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$PaneIndex\n\nInteger\n\nThe index of the pane on which to graph the array data.\n\n\n\n$SeriesLabel\n\nString\n\nThe series label which will be displayed in the legend of the graph pane\n\n\n\n$Trace\n\nObject (JabilTestCoreLibs.PlotWindow.PlotTrace2D)\n\nThe data in a trace object to be plotted on the graph. New instrument functions added to Jabil Test will return their data in a trace object which specifies the type of data that is contained within the trace, and how it should be formatted on the graph.\n\n\n\n$Red\n\nInteger\n\nThe value of the red component for the plotted data. Valid values are 0 to 255.\n\n\n\n$Green\n\nInteger\n\nThe value of the green component for the plotted data. Valid values are 0 to 255.\n\n\n\n$Blue\n\nInteger\n\nThe value of the blue component for the plotted data. Valid values are 0 to 255.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nUsage Example:\n\nChartPanel_Plot2DBarGraphTrace(0,\"Power\",$Trace,255,0,0);\n\n\n\n\n\nChartPanel_PlotTrace\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ChartPanel_Plot2DTrace": {
  "prefix": "ChartPanel_Plot2DTrace",
  "body": [
   "ChartPanel_Plot2DTrace($$PaneIndex,$$SeriesLabel,$$Trace,$$Red,$$Green,$$Blue);"
  ],
  "description": "\n\n\n\n\n\nThis function plots a 2 dimensional trace on the specified graph pane. The series added to the graph is identified via the $SeriesLabel parameter. The user may also specify the color of the series drawn on the graph by specifying it's Red, Green, and Blue color components.\n\n\n\n\n\nNote: This function uses the new native Trace2D data type which has recently been added to the Jabil Test Core Library. Most older instrument libraries actually return their non-scalar measurement data as array data types, so you should use the corresponding ChartPanel_Plot1DArray or ChartPanel_Plot2DArray functions for these types of data objects.\n\nThe Trace2D data type is a convenience feature to simplify Jabil Test scripting since all necessary data regarding how the data should be plotted is contained in the data structure returned from the instrument library.\n\n\n\n\n\nGoing forward, all instrument driver functions which return an array of data that is intended for graphing such as spectrum analyzers, oscilloscopes, vector signal analyzers, etc should return the new Trace2D data type which is contained in the Jabil Test Core Library.\n\n\n\n\n\nImportant Note: In order to use the Jabil Test Chart Panel Functionality, make sure that the current test cell extended panel mode is set to Charting Mode.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$PaneIndex\n\nInteger\n\nThe index of the pane on which to graph the array data.\n\n\n\n$SeriesLabel\n\nString\n\nThe series label which will be displayed in the legend of the graph pane\n\n\n\n$Trace\n\nObject (JabilTestCoreLibs.PlotWindow.PlotTrace2D)\n\nThe data in a trace object to be plotted on the graph. New instrument functions added to Jabil Test will return their data in a trace object which specifies the type of data that is contained within the trace, and how it should be formatted on the graph.\n\n\n\n$Red\n\nInteger\n\nThe value of the red component for the plotted data. Valid values are 0 to 255.\n\n\n\n$Green\n\nInteger\n\nThe value of the green component for the plotted data. Valid values are 0 to 255.\n\n\n\n$Blue\n\nInteger\n\nThe value of the blue component for the plotted data. Valid values are 0 to 255.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nUsage Example:\n\nChartPanel_Plot2DTrace(0,\"Power\",$Trace,255,0,0);\n\n\n\n\n\nChartPanel_PlotXYArrays\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ChartPanel_PlotXYArrays": {
  "prefix": "ChartPanel_PlotXYArrays",
  "body": [
   "ChartPanel_PlotXYArrays($$PaneIndex,$$SeriesLabel,$$XArray,$$YArray,$$Red,$$Green,$$Blue);"
  ],
  "description": "\n\n\n\n\n\nThis function plots an array on the specified graph panel. The function takes one dimensional arrays of X coordinates and Y coordinates of the same length and plots the values together as points on the graph. The series added to the graph is identified via the $SeriesLabel parameter. The user may also specify the color of the series drawn on the graph by specifying it's Red, Green, and Blue color components.\n\n\n\n\n\nThe first one dimensional array is plotted as X values, and the second one dimensional array will be plotted as the corresponding Y values.\n\n\n\n\n\nImportant Note: In order to use the Jabil Test Chart Panel Functionality, make sure that the current test cell extended panel mode is set to Charting Mode.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$PaneIndex\n\nInteger\n\nThe index of the pane on which to graph the array data.\n\n\n\n$SeriesLabel\n\nString\n\nThe series label which will be displayed in the legend of the graph pane\n\n\n\n$XArray\n\nArray\n\nThe one dimensional array to plot as X values on the graph object. Note this array must be an array of numerics such as integers, doubles, floats, etc.\n\n\n\n$YArray\n\nArray\n\nThe one dimensional array to plot as Y values on the graph object. Note this array must be an array of numerics such as integers, doubles, floats, etc.\n\n\n\n$Red\n\nInteger\n\nThe value of the red component for the plotted data. Valid values are 0 to 255.\n\n\n\n$Green\n\nInteger\n\nThe value of the green component for the plotted data. Valid values are 0 to 255.\n\n\n\n$Blue\n\nInteger\n\nThe value of the blue component for the plotted data. Valid values are 0 to 255.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nUsage Example:\n\nChartPanel_PlotXYArrays(0,\"Power\",$XArray,$YArray,255,0,0);\n\n\n\n\n\nChartPanel_RefreshPanel\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ChartPanel_RefreshPanel": {
  "prefix": "ChartPanel_RefreshPanel",
  "body": [
   "ChartPanel_RefreshPanel();"
  ],
  "description": "\n\n\n\n\n\nThis function causes all panes on the current graphing window to be refreshed and redrawn. In the event that the data on a particular chart is outside of the current scale, the scale of each pane will also be recalculated.\n\n\n\n\n\nImportant Note: In order to use the Jabil Test Chart Panel Functionality, make sure that the current test cell extended panel mode is set to Charting Mode.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nUsage Example:\n\nChartPanel_RefreshPanel();\n\n\n\n\n\nChartPanel_RemovePane\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ChartPanel_RemovePane": {
  "prefix": "ChartPanel_RemovePane",
  "body": [
   "ChartPanel_RemovePane($$PaneIndex);"
  ],
  "description": "\n\n\n\n\n\nThis function removes the specified pane from the current charting window. Each pane is identified by a zero based index. Each pane can contain a single chart or plot of any type. The remaining panes on the charting window (if any) will automatically be rescaled and resized to fill the available area.\n\n\n\n\n\nImportant Note: In order to use the Jabil Test Chart Panel Functionality, make sure that the current test cell extended panel mode is set to Charting Mode.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$PaneIndex\n\nInteger\n\nThe index for the pane to be removed from the window.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nUsage Example:\n\nChartPanel_RemovePane($PaneIndex);\n\n\n\n\n\nChartPanel_SetAxisLabels\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ChartPanel_SetAxisLabels": {
  "prefix": "ChartPanel_SetAxisLabels",
  "body": [
   "ChartPanel_SetAxisLabels($$PaneIndex,$$XAxisLabel,$$YAxisLabel);"
  ],
  "description": "\n\n\n\n\n\nThis function sets the label of the X and Y axis on the graphing pane specified by the supplied index parameter. If the pane specified does not exist in the graphing window, then a failing test result will be returned.\n\n\n\n\n\nIf no data exists on the graph, the axis labels will not be displayed.\n\n\n\n\n\nImportant Note: In order to use the Jabil Test Chart Panel Functionality, make sure that the current test cell extended panel mode is set to Charting Mode.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$PaneIndex\n\nInteger\n\nThe index for the pane to set the desired axis labels\n\n\n\n$XAxisLabel\n\nString\n\nThe label for the X Axis\n\n\n\n$YAxisLabel\n\nString\n\nThe label for the Y Axis\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nUsage Example:\n\nChartPanel_SetAxisLabels(0,\"Time in seconds\",\"Power in dBm\");\n\n\n\n\n\nChartPanel_SetTitle\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ChartPanel_SetTitle": {
  "prefix": "ChartPanel_SetTitle",
  "body": [
   "ChartPanel_SetTitle($$PaneIndex,$$Title);"
  ],
  "description": "\n\n\n\n\n\nThis function sets the titled to be displayed for a given graph pane. If the graph pane does not exist, the function will generate a failing test result.\n\n\n\n\n\nImportant Note: In order to use the Jabil Test Chart Panel Functionality, make sure that the current test cell extended panel mode is set to Charting Mode.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$PaneIndex\n\nInteger\n\nThe zero based index of the graph pane to be titled.\n\n\n\n$Title\n\nString\n\nThe desired title for the given graph pane.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nUsage Example:\n\nChartPanel_SetTitle(0,\"Power Vs. Time\");\n\n\n\n\n\nChartPanel_SetXAxisRange\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ChartPanel_SetXAxisRange": {
  "prefix": "ChartPanel_SetXAxisRange",
  "body": [
   "ChartPanel_SetXAxisRange($$PaneIndex,$$XAxisMin,$$XAxisMax);"
  ],
  "description": "\n\n\n\n\n\nThis function sets the range of the X-Axis to the minimum and maximum specified.\n\n\n\n\n\nImportant Note: In order to use the Jabil Test Chart Panel Functionality, make sure that the current test cell extended panel mode is set to Charting Mode.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$PaneIndex\n\nInteger\n\nThe index for the pane to set the desired axis labels\n\n\n\n$XAxisMin\n\nFloat\n\nThe minimum value for the X Axis.\n\n\n\n$XAxisMax\n\nFloat\n\nThe maximum value for the X Axis.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nUsage Example:\n\nChartPanel_SetXAxisRange(0, -10, 110);\n\n\n\n\n\nChartPanel_SetYAxisRange\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ChartPanel_SetYAxisRange": {
  "prefix": "ChartPanel_SetYAxisRange",
  "body": [
   "ChartPanel_SetYAxisRange($$PaneIndex,$$YAxisMin,$$YAxisMax);"
  ],
  "description": "\n\n\n\n\n\nThis function sets the range of the Y-Axis to the minimum and maximum specified.\n\n\n\n\n\nImportant Note: In order to use the Jabil Test Chart Panel Functionality, make sure that the current test cell extended panel mode is set to Charting Mode.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$PaneIndex\n\nInteger\n\nThe index for the pane to set the desired axis labels\n\n\n\n$YAxisMin\n\nFloat\n\nThe minimum value for the Y Axis.\n\n\n\n$YAxisMax\n\nFloat\n\nThe maximum value for the Y Axis.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nUsage Example:\n\nChartPanel_SetYAxisRange(0, -10, 110);\n\n\n\n\n\nIntroduction To Charting Function Library\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Plot2DTrace_GetLength": {
  "prefix": "Plot2DTrace_GetLength",
  "body": [
   "($$XLength,$$YLength)=Plot2DTrace_GetLength($$Trace);"
  ],
  "description": "\n\n\n\n\n\nThis function takes a Jabil Test Plot2DTrace variable and returns the number elements stored in the X and Y value arrays of the 2D Plot Object.\n\nThis function is usually used for index limit testing, and in nearly all situations the number of X and Y values will be equal.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Trace\n\nObject (Plot2DTrace)\n\nThe Plot2DTrace returned from an instrument function.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$XLength\n\nInteger\n\nThe number of X values contained in the array inside the Plot2DTrace object.\n\n\n\n$YLength\n\nInteger\n\nThe number of Y values contained in the array inside the Plot2DTrace object\n\n\n\n\n\nUsage Example:\n\n($XLength,$YLength) = Plot2DTrace_GetLength($Trace)\n\n\n\n\n\nPlot2DTrace_GetValuesByIndex\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Plot2DTrace_GetValuesByIndex": {
  "prefix": "Plot2DTrace_GetValuesByIndex",
  "body": [
   "($$XValue,$$YValue)=Plot2DTrace_GetValuesByIndex($$Trace,$$Index);"
  ],
  "description": "\n\n\n\n\n\nThis function returns the X and Y values from the 2D Trace object at the specified index position. The total length of the 2D Trace can be determined by using the Plot2DTrace_GetLength function.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Trace\n\nObject (Plot2DTrace)\n\nThe Plot2DTrace returned from an instrument function.\n\n\n\n$Index\n\nInteger\n\nThe index of the trace to retrieve the X and Y values from...\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$XValue\n\nFloat\n\nThe value of the X element array inside the plot at the specified index.\n\n\n\n$YValue\n\nFloat\n\nThe value of the Y element array inside the plot at the specified index\n\n\n\n\n\nUsage Example:\n\n($XValue,$YValue) = Plot2DTrace_GetValue($Trace,150);\n\n// Get the values at the 150th index of the plot array\n\n\n\n\n\nBluetooth_CloseSerialConnection\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Bluetooth_CloseSerialConnection": {
  "prefix": "Bluetooth_CloseSerialConnection",
  "body": [
   "Bluetooth_CloseSerialConnection($$Connection);"
  ],
  "description": "\n\nThis function closes a bluetooth serial connection that was previously created using the Bluetooth_CreateSerialConnection function.\n\n\n\nNotes:\n\n\n\n\n\nThis function requires the ThirtyTwoFeet .NET libraries (created by In The Hand Ltd.) to be installed on the system.\n\n\n\n\n\nThis collection of bluetooth functions are compatible with any bluetooth device which uses the Microsoft Bluetooth stack. This library is not compatible with functions using the WIDCOMM Bluetooth stack.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Connection\n\nObject\n\nA bluetooth serial connection which was previously created using the Bluetooth_CreateSerialConnection function.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\nBluetooth_CloseSerialConnection($Connection);\n\n\n\n\n\nBluetooth_CreateSerialConnection\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Bluetooth_CreateSerialConnection": {
  "prefix": "Bluetooth_CreateSerialConnection",
  "body": [
   "$$BTConnection=Bluetooth_CreateSerialConnection($$BluetoothAddress);"
  ],
  "description": "\n\nThis function creates a new bluetooth serial connection. In order to create a new serial connection with the bluetooth device, it must be in a discoverable state, or have previously been paired with the computer. If the device requires a secure bluetooth connection with a PIN, it first must be paired before creating a serial connection.\n\n\n\nNotes:\n\n\n\n\n\nThis function requires the ThirtyTwoFeet .NET libraries (created by In The Hand Ltd.) to be installed on the system.\n\n\n\n\n\nThis collection of bluetooth functions are compatible with any bluetooth device which uses the Microsoft Bluetooth stack. This library is not compatible with functions using the WIDCOMM Bluetooth stack.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$BluetoothAddress\n\nString\n\nThe bluetooth address of the discoverable device with which you would like to establish a connection. The address format is \"aa:bb:cc:dd:ee:ff\" or \"aabbccddeeff\".\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nBTConnection\n\nObject\n\nThe bluetooth serial connection.\n\n\n\n\n\nExample:\n\n$BTConnection = Bluetooth_CreateSerialConnection(\"00:11:22:33:44:55:66\");\n\n\n\n\n\nBluetooth_GetDiscoverableCount\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Bluetooth_GetDiscoverableCount": {
  "prefix": "Bluetooth_GetDiscoverableCount",
  "body": [
   "$$DeviceCount=Bluetooth_GetDiscoverableCount();"
  ],
  "description": "\n\n\u00b7 This function checks the list of bluetooth discoverable devices and returns the number of devices in the list.\n\n\n\nNotes:\n\n\n\n\n\nThis function requires the ThirtyTwoFeet .NET libraries (created by In The Hand Ltd.) to be installed on the system.\n\n\n\n\n\nThis collection of bluetooth functions are compatible with any bluetooth device which uses the Microsoft Bluetooth stack. This library is not compatible with functions using the WIDCOMM Bluetooth stack.\n\n\n\n\n\nChecking for discoverable devices will take a few seconds.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$DeviceCount\n\nInteger\n\nThe number of discoverable bluetooth devices in the range of the computer.\n\n\n\n\n\nExample:\n\n$DeviceCount = Bluetooth_GetDiscoverableCount();\n\n\n\n\n\nBluetooth_GetDiscoverableDevices\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Bluetooth_GetDiscoverableDevices": {
  "prefix": "Bluetooth_GetDiscoverableDevices",
  "body": [
   "$$DeviceNames,$$DeviceAddresses=Bluetooth_GetDiscoverableDevices();"
  ],
  "description": "\n\n\u00b7 This function returns the names and addresses of the bluetooth discoverable devices within range of the computer.\n\n\n\nNotes:\n\n\n\n\n\nThis function requires the ThirtyTwoFeet .NET libraries (created by In The Hand Ltd.) to be installed on the system.\n\n\n\n\n\nThis collection of bluetooth functions are compatible with any bluetooth device which uses the Microsoft Bluetooth stack. This library is not compatible with functions using the WIDCOMM Bluetooth stack.\n\n\n\n\n\nChecking for discoverable devices will take a few seconds.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$DeviceNames\n\nArray\n\nThe list of Bluetooth discoverable device names.\n\n\n\n$DeviceAddresses\n\nArray\n\nThe list of Bluetooth discoverable device addresses.\n\n\n\n\n\nExample:\n\n$DeviceNames, $DeviceAddresses = Bluetooth_GetDiscoverableDevices();\n\n\n\n\n\nBluetooth_GetRadioCount\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Bluetooth_GetRadioCount": {
  "prefix": "Bluetooth_GetRadioCount",
  "body": [
   "$$RadioCount=Bluetooth_GetRadioCount($$BluetoothAddress);"
  ],
  "description": "\n\nThis function iterates through all the supported bluetooth radios which are present on the host computer, and returns the number of available radios found. In the debug text, the details of each radio are listed, including:\n\n\u00b7 Radio ID\n\n\u00b7 Device Name\n\n\u00b7 Manufacturer\n\n\u00b7 Local Address\n\n\u00b7 Device Class\n\n\u00b7 Software Manufacturer\n\n\n\nNotes:\n\n\n\n\n\nThis function requires the ThirtyTwoFeet .NET libraries (created by In The Hand Ltd.) to be installed on the system.\n\n\n\n\n\nThis collection of bluetooth functions are compatible with any bluetooth device which uses the Microsoft Bluetooth stack. This library is not compatible with functions using the WIDCOMM Bluetooth stack.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$RadioCount\n\nInteger\n\nThe number of bluetooth radios installed on the local computer.\n\n\n\n\n\nExample:\n\n$RadioCount = Bluetooth_GetRadioCount();\n\n\n\n\n\nBluetooth_ListDiscoverableDevices\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Bluetooth_ListDiscoverableDevices": {
  "prefix": "Bluetooth_ListDiscoverableDevices",
  "body": [
   "$$DeviceCount=Bluetooth_ListDiscoverableDevices();"
  ],
  "description": "\n\nThis function iterates through all the discoverable bluetooth devices in the range of the local test computer. In the debug text, the details of each discoverable device is listed, including:\n\n\u00b7 Device Name\n\n\u00b7 Device Address\n\n\u00b7 Boolean Value indicating if the device is authenticated\n\n\n\nNotes:\n\n\n\n\n\nThis function requires the ThirtyTwoFeet .NET libraries (created by In The Hand Ltd.) to be installed on the system.\n\n\n\n\n\nThis collection of bluetooth functions are compatible with any bluetooth device which uses the Microsoft Bluetooth stack. This library is not compatible with functions using the WIDCOMM Bluetooth stack.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$DeviceCount\n\nInteger\n\nThe number of discoverable bluetooth devices in the range of the computer.\n\n\n\n\n\nExample:\n\n$DeviceCount = Bluetooth_ListDiscoverableDevices();\n\n\n\n\n\nBluetooth_PairWithDevice\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Bluetooth_PairWithDevice": {
  "prefix": "Bluetooth_PairWithDevice",
  "body": [
   "$$Success=Bluetooth_PairWithDevice($$BluetoothAddress,$$SecurityPIN,$$FailOnPairingFailure);"
  ],
  "description": "\n\nThis function attempts to pair with a device using the bluetooth address and security pin supplied to the function. If the device doesn't require a PIN, you can specify a blank string. If the $FailOnPairingFailure is set to 'TRUE', it will automatically generate a test failure on pairing failure. Otherwise, the function returns a pass, but will set the return variable to 'FALSE' so that it can be ignored, or retried.\n\n\n\nTip: Some devices require a null character at the end of the security pin such as \"1234\\0\".\n\n\n\n\n\nNotes:\n\n\n\n\n\nThis function requires the ThirtyTwoFeet .NET libraries (created by In The Hand Ltd.) to be installed on the system.\n\n\n\n\n\nThis collection of bluetooth functions are compatible with any bluetooth device which uses the Microsoft Bluetooth stack. This library is not compatible with functions using the WIDCOMM Bluetooth stack.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$BluetoothAddress\n\nString\n\nThe bluetooth address of the device with which to pair. The address should be supplied as a string in this format '00:11:22:33:44:55' or \"001122334455\".\n\n\n\n$SecurityPIN\n\nString\n\nThe security pin of the device, for example '7517'.\n\n\n\n$FailOnPairingFailure\n\nBoolean\n\nIf this parameter is set to 'TRUE', the function will return a test failure if the device doesn't pair successfully.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Success\n\nBoolean\n\nReturns 'TRUE' if the device pairs successfully, otherwise returns 'FALSE'.\n\n\n\n\n\nExample:\n\n$Success = Bluetooth_PairWithDevice(\"00:11:22:aa:bb:cc\", \"1123\", true);\n\n\n\n\n\nBluetooth_SerialReadHexString\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Bluetooth_SerialReadHexString": {
  "prefix": "Bluetooth_SerialReadHexString",
  "body": [
   "$$hexString=Bluetooth_SerialReadHexString($$btSerialHandle,$$numBytes,$$timeout);"
  ],
  "description": "\n\nThis function reads a series of bytes from a Bluetooth device that has been connected to using Bluetooth_CreateSerialConnection and returns those bytes as a hex string.\n\nIf the number of bytes is not specified, the serial stream will be read to its end or until the timeout has elapsed.\n\nIf the timeout value is not specified, the serial stream will be read to its end or until the specified number of bytes has been read.\n\n\n\n\n\nNotes:\n\n\n\n\n\nThis function requires the ThirtyTwoFeet .NET libraries (created by In The Hand Ltd.) to be installed on the system.\n\n\n\n\n\nIf both number of bytes and timeout are zero, it is possible to have an infinite wait time.\n\n\n\n\n\nThis collection of bluetooth functions are compatible with any bluetooth device which uses the Microsoft Bluetooth stack. This library is not compatible with functions using the WIDCOMM Bluetooth stack.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$btHandle\n\nObject\n\nThe serial Bluetooth connection created with Bluetooth_CreateSerialConnection.\n\n\n\n$numBytes\n\nInteger\n\nThe number of bytes to read from the serial Bluetooth stream. Once the specified number of bytes has been read, the result will be returned. If set to 0, the stream will be read to its end or until the timeout is reached.\n\n\n\n$timeout\n\nInteger\n\nThe number of milliseconds to wait before returning any bytes that were read. If set to 0, the stream will be read to its end or until the specified number of bytes are received.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$hexString\n\nString\n\nA hexadecimal encoded string containing all of the bytes read.\n\n\n\n\n\nExample:\n\n\n\n\n\n// Connect to device at address aa:bb:cc:dd:ee:ff.\n\n$btAddress = \"aabbccddeeff\";\n\n$btHandle = Bluetooth_CreateSerialConnection($btAddress);\n\n// Read serial bytes for 5 seconds.\n\n$timeout = 5000;\n\n$hexString = Bluetooth_SerialReadHexString($btHandle, 0, $timeout);\n\n\n\n\n\nBluetooth_SerialSendHexString\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Bluetooth_SerialSendHexString": {
  "prefix": "Bluetooth_SerialSendHexString",
  "body": [
   "Bluetooth_SerialSendHexString($$btSerialHandle,$$hexString,$$timeout);"
  ],
  "description": "\n\nThis function sends a series of bytes to a Bluetooth device that has been connected to using Bluetooth_CreateSerialConnection.\n\nIf the timeout value is not specified, the function will wait until all bytes have been sent.\n\n\n\n\n\nNotes:\n\n\n\n\n\nThis function requires the ThirtyTwoFeet .NET libraries (created by In The Hand Ltd.) to be installed on the system.\n\n\n\n\n\nIf the timeout is zero, it is possible to have an infinite wait time.\n\n\n\n\n\nThis collection of bluetooth functions are compatible with any bluetooth device which uses the Microsoft Bluetooth stack. This library is not compatible with functions using the WIDCOMM Bluetooth stack.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$btHandle\n\nObject\n\nThe serial Bluetooth connection created with Bluetooth_CreateSerialConnection.\n\n\n\n$hexString\n\nString\n\nThe bytes to send to the Bluetooth device represented as a hex string. (eg. aa bb 11 66)\n\n\n\n$timeout\n\nInteger\n\nThe number of milliseconds to wait for th Bluetooth device to receive all the bytes. If set to 0, the function will wait until all bytes are sent.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone.\n\n\n\n\n\nExample:\n\n\n\n\n\n// Connect to device at address aa:bb:cc:dd:ee:ff.\n\n$btAddress = \"aabbccddeeff\";\n\n$btHandle = Bluetooth_CreateSerialConnection($btAddress);\n\n// Send \"Hello\" as ASCII and wait a maximum of 5 seconds.\n\n$hexString = \"48 65 6C 6C 6F\";\n\n$timeout = 5000;\n\n$hexString = Bluetooth_SerialSendHexString($btHandle, $hexString, $timeout);\n\n\n\n\n\nExxoTest_CANActivate\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ExxoTest_CANActivate": {
  "prefix": "ExxoTest_CANActivate",
  "body": [
   "ExxoTest_CANActivate($$CardId,$$BusId);"
  ],
  "description": "\n\n\n\nThis function activates the specific CAN Bus on the ExxoTest USB Mux and prepares it for communication. This function must be run after the CAN operation and bus have been properly configured. Please see the Usage Example below for complete details.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$CardId\n\nInteger\n\nThe ID of the ExxoTest device\n\n\n\n$BusId\n\nInteger\n\nThe Can Bus to be configured.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\nExxoTest_Init(0);\n\nExxoTest_ConfigureCANOperation(0,0,\"FIFO\",256);\n\nExxoTest_ConfigureCANBus(0,0,2,12,3,1,1);\n\nExxoTest_CANActivate(0,0);\n\nExxoTest_CANDeactivate(0,0);\n\n\n\n\n\nSupported Instruments\n\nAll ExxoTest USB Communication Devices\n\n\n\n\n\nExxoTest_CANCreateMessage\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ExxoTest_CANCreateMessage": {
  "prefix": "ExxoTest_CANCreateMessage",
  "body": [
   "$$CanMessage=ExxoTest_CANCreateMessage($$MessageId,$$MessageType,$$ServiceType,$$MessageData);"
  ],
  "description": "\n\n\n\nThis function creates a new CAN message to prepare to send. This function only builds the message, and does not send it. For complete details on the CAN message structure and the definition of the message fields, please consult the CAN-BUS specification.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$MessageId\n\nString\n\nA hexadecimal string indicating the Message ID\n\n\n\n$MessageType\n\nString\n\nThe type of the message, allowable values are:\n\n\u00b7 \"STANDARD\"\n\n\u00b7 \"EXTENDED\"\n\n\n\n$ServiceType\n\nString\n\nSpecifies the service type of the message. The allowable values are:\n\n\u00b7 \"TRANSMIT_DATA\"\n\n\u00b7 \"RECEIVE_DATA\"\n\n\u00b7 \"TRANSMIT_REMOTE\"\n\n\u00b7 \"RECEIVE_REMOTE\"\n\n\n\n\n\n$MessageData\n\nString\n\nA comma separated byte string containing the bytes to send in the CAN Message.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$CanMessage\n\nObject\n\nThe newly constructed CAN Message which can be passed to the other ExxoTest CAN functions.\n\n\n\n\n\nExamples:\n\n$MyMessage = ExxoTest_CANCreateMessage(\"01\",\"STANDARD\",\"TRANSMIT_DATA\",\"11,22,33,AA,BB,CC\");\n\n\n\n\n\nSupported Instruments\n\nAll ExxoTest USB Communication Devices\n\n\n\n\n\nExxoTest_CANDeactivate\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ExxoTest_CANDeactivate": {
  "prefix": "ExxoTest_CANDeactivate",
  "body": [
   "ExxoTest_CANDeactivate($$CardId,$$BusId);"
  ],
  "description": "\n\n\n\nThis function deactivates the specified CAN bus on the specified device. If the CAN bus was not previously activated, this function will return without failure. If the CAN bus is busy, this function will block until the CAN bus can be deactivated.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$CardId\n\nInteger\n\nThe ID of the ExxoTest device\n\n\n\n$BusId\n\nInteger\n\nThe Can Bus to be configured.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\nExxoTest_CANDeactivate(0,0);\n\n\n\n\n\nSupported Instruments\n\nAll ExxoTest USB Communication Devices\n\n\n\n\n\nExxoTest_CanGetNextMessage\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ExxoTest_CANGetNextMessage": {
  "prefix": "ExxoTest_CANGetNextMessage",
  "body": [
   "($$MesageFound,$$QueueDepth,$$MessageId,$$MessageLength,$$MessageData)=ExxoTest_CANGetNextMessage($$CardId,$$BusId);"
  ],
  "description": "\n\n\n\nThis function will search the FIFO stack for the next available received CAN message, and return it to the scripting environment. If no CAN messages have been received, the $MessageFound parameter is set to false. Otherwise, the $MessageFound parameter is set to TRUE and the respective fields pertaining to the message are returned. The $QueueDepth return value specifies the number of CAN events that remain in the FIFO queue.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$CardId\n\nInteger\n\nThe identifier for the CAN device.\n\n\n\n$BusId\n\nInteger\n\nThe identifier for the BUS that should be checked for received CAN messages.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$MessageFound\n\nBoolean\n\nSpecifies whether or not a received message was found in the FIFO queue.\n\n\n\n$QueueDepth\n\nInteger\n\nThe number of CAN events that remain in the FIFO queue.\n\n\n\n$MessageId\n\nInteger\n\nThe message identifier for the CAN message\n\n\n\n$MessageLength\n\nInteger\n\nThe number of bytes in the CAN message.\n\n\n\n$MessageData\n\nString\n\nThe hexadecimal string representing the contents of the CAN message.\n\n\n\n\n\nExamples:\n\n($MessageFound,$QueueDepth,$MessageId,$MessageLength,$MessageData) = ExxoTest_CANGetNextMessage(0,2);\n\nUpdateStatus($MessageFound);\n\nUpdateStatus($QueueDepth);\n\nUpdateStatus($MessageId);\n\nUpdateStatus($MessageLength);\n\nUpdateStatus($MessageData);\n\n\n\n\n\nSupported Instruments\n\nAll ExxoTest USB Communication Devices\n\n\n\n\n\nExxoTest_CANSelectTransceiverHS\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ExxoTest_CANSelectTransceiverHS": {
  "prefix": "ExxoTest_CANSelectTransceiverHS",
  "body": [
   "ExxoTest_CANSelectTransceiverHS($$CardId,$$BusId,$$HighSpeed);"
  ],
  "description": "\n\nThis function selects the appropriate CAN transceiver type to use on a CAN bus that supports both High Speed and Low Speed CAN.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$CardId\n\nInteger\n\nThe identifier of the device to be configured.\n\n\n\n$BusId\n\nInteger\n\nThe identifier of the CAN bus to be configured.\n\n\n\n$HighSpeed\n\nBoolean\n\nSpecifies whether or not the BUS should use the high speed CAN transceiver:\n\n\u00b7 \"FALSE\" = Low Speed CAN\n\n\u00b7 \"TRUE\" = High Speed CAN\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\nExxoTest_CANSelectTransceiverHS(0,0,\"FALSE\"));\n\n\n\n\n\nSupported Instruments\n\nAll ExxoTest USB Communication Devices\n\n\n\n\n\nExxoTest_CANSendMessage\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ExxoTest_CANSendMessage": {
  "prefix": "ExxoTest_CANSendMessage",
  "body": [
   "ExxoTest_CANSendMessage($$CardId,$$BusID,$$CanMessage);"
  ],
  "description": "\n\n\n\nThis function sends a message created with the ExxoTest_CANCreateMessage function on the specified card and bus. If the message can't be sent successfully on the bus, the function generates a failure.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$CardId\n\nInteger\n\nThe ID of the ExxoTest device\n\n\n\n$BusId\n\nInteger\n\nThe Can Bus on which to send the message.\n\n\n\n$CanMessage\n\nObject\n\nA Can Message object created using the ExxoTest_CANSendMessage command.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\n$CanMessage = ExxoTest_CANCreateMessage(\"01\",\"STANDARD\",\"TRANSMIT_DATA\",\"11,22,33,AA,BB,CC\");\n\nExxoTest_CANSendMessage(0,0,$CanMessage);\n\n\n\n\n\nSupported Instruments\n\nAll ExxoTest USB Communication Devices\n\n\n\n\n\nBelow is a complete script demonstrating how to send and receive messages on a looped back CAN port:\n\n\n\n\n\nUpdateStatus(\"ExxoTest\");\n\ncall Init();\n\nSetFinalizeFunction(\"Cleanup\");\n\n\n\n\n\n// CAN BUS 0\n\nExxoTest_ConfigureCANOperation(0,0,\"FIFO\",2047);\n\nExxoTest_ConfigureCANParameters(0,0,\"STANDARD\",\"0\",\"0\",\"TRUE\",\"TRUE\");\n\nExxoTest_ConfigureCANBus(0,0,64,16,8,1,1);\n\nExxoTest_CANSelectTransceiverHS(0,0,\"FALSE\");\n\nExxoTest_CANActivate(0,0);\n\n\n\n\n\n// CAN BUS 2\n\nExxoTest_ConfigureCANOperation(0,2,\"FIFO\",2047);\n\nExxoTest_ConfigureCANParameters(0,2,\"STANDARD\",\"0\",\"0\",\"TRUE\",\"TRUE\");\n\nExxoTest_ConfigureCANBus(0,2,64,16,8,1,1);\n\nExxoTest_CANActivate(0,2);\n\n\n\n\n\n$CanMessage = ExxoTest_CANCreateMessage(\"01\",\"STANDARD\",\"TRANSMIT_DATA\",\"AA,BB,CC,DD,EE,FF,00,11\");\n\n\n\n\n\nExxoTest_CANSendMessage(0,0,$CanMessage);\n\nExxoTest_CANSendMessage(0,0,$CanMessage);\n\nExxoTest_CANSendMessage(0,0,$CanMessage);\n\nSleep(1);\n\n($MessageFound,$QueueDepth,$MessageId,$MessageLength,$MessageData) = ExxoTest_CANGetNextMessage(0,2);\n\nUpdateStatus($MessageFound);\n\nUpdateStatus($QueueDepth);\n\nUpdateStatus($MessageId);\n\nUpdateStatus($MessageLength);\n\nUpdateStatus($MessageData);\n\n\n\n\n\nExxoTest_CANDeactivate(0,0);\n\nExxoTest_CANDeactivate(0,2);\n\nEnd;\n\n\n\n\n\nfunction Init()\n\n{\n\nExxoTest_Init(0);\n\nreturn;\n\n}\n\n\n\n\n\nfunction Cleanup()\n\n{\n\nExxoTest_Close(0);\n\nEnd;\n\n}\n\n\n\n\n\nExxoTest_Close\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ExxoTest_Close": {
  "prefix": "ExxoTest_Close",
  "body": [
   "ExxoTest_Close($$CardId);"
  ],
  "description": "\n\n\n\nThis function closes the communcation with the ExxoTest communication MUX. This should be the final function called when the test script has finished using the device. This function should always be called anytime that the ExxoTest_Open function has been used to initiate communication with the instrument.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$CardId\n\nInteger\n\nThe ID of the ExxoTest device\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\nExxoTest_Close(0);\n\n\n\n\n\nSupported Instruments\n\nAll ExxoTest USB Communication Devices\n\n\n\n\n\nExxoTest_ConfigureCANBus\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ExxoTest_ConfigureCANBus": {
  "prefix": "ExxoTest_ConfigureCANBus",
  "body": [
   "ExxoTest_ConfigureCANBus($$CardId,$$BusId,$$BRP,$$TSEG1,TSEG2,$$SJF,$$SPL);"
  ],
  "description": "\n\nThis function configures the CAN bus for communication. Please see the ExxoTest Manual for complete details over all the configuration parameters used to initialize the CAN communication bus.\n\n\n\n\n\nHere are a few examples:\n\n\n\n\n\nThe baudrate is calculated as follows:\n\nBaud rate = (8Mhz/(1+TSEG1+TSEG2)"
 }
,
 "JTS ExxoTest_ConfigureCANOperation": {
  "prefix": "ExxoTest_ConfigureCANOperation",
  "body": [
   "ExxoTest_ConfigureCANOperation($$CardId,$$BusId,$$OperationMode,$$FifoSize);"
  ],
  "description": "\n\n\n\n\n\nThis function determines the interface mode between the application and the card. It supports buffer and FIFO modes.\n\n\n\n\n\n\u00b7 FIFO Storage: In this mode, the events to be transferred to the application are stocked in a waiting list. These events are of the following types: end of transmition, reception, errors... When the application calls the GetEvent function, the first event (the oldest in time) is popped from the list. If the waiting list is full and an event takes place, then a bit indicating loss of event is placed on the last event.\n\n\u00b7 BUFFER Storage: In this mode, the events to be transferred to the application are in a unique buffer allocated during message configuration (regardless of its service). These events are either end of transmission or reception (not errors). When the application calls the CanGetEvent function, the message's communication handle allows the user to find the buffer to be read. This buffer contains the last event that has been received (the most recent in time). THe buffer is reset with each reading. If no event takes place btween two readings, the summary (EVENT_EMPTY) tells the application.\n\n\n\n\n\nAdditional Notes:\n\nThis function must be called in the correct sequence in order for it to function correctly. Please see the usage example below for details of the correct calling order and an example of using the function.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$CardId\n\nInteger\n\nThe identifier of the device to be configured.\n\n\n\n$BusId\n\nInteger\n\nThe identifier of the CAN bus to be configured.\n\n\n\n$OperationMode\n\nString\n\nThe desired operation mode of the CAN interface. The allowable values are:\n\n\u00b7 \"BUFFER\"\n\n\u00b7 \"FIFO\"\n\n\n\n$FifoSize\n\nInteger\n\nThe desired size of the FIFO buffer.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\nExxoTest_Init(0);\n\nExxoTest_ConfigureCANOperation(0,0,\"FIFO\",256);\n\nExxoTest_ConfigureCANBus(0,0,2,12,3,1,1);\n\nExxoTest_CANActivate(0,0);\n\nExxoTest_CANDeactivate(0,0);\n\n\n\n\n\nSupported Instruments\n\nAll ExxoTest USB Communication Devices\n\n\n\n\n\nExxoTest_ConfigureCANParameters\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ExxoTest_ConfigureCANParameters": {
  "prefix": "ExxoTest_ConfigureCANParameters",
  "body": [
   "ExxoTest_ConfigureCANParameters($$CardId,$$BusId,$$CanType,$$IdentityMask,$$FilterMask,$$EnableAcknowledge,$$ReceiveAll);"
  ],
  "description": "\n\n\n\n\n\nThis function allows configuration of additional operational parameters for the CAN bus.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$CardId\n\nInteger\n\nThe identifier of the device to be configured.\n\n\n\n$BusId\n\nInteger\n\nThe identifier of the CAN bus to be configured.\n\n\n\n$CanType\n\nString\n\nSpecifies the CAN messaging mode. Allowable values are:\n\n\u00b7 \"STANDARD\" = Standard 11 Bit CAN Messaging\n\n\u00b7 \"EXTENDED\" = Extended 29 Bit CAN Messaging\n\n\n\n$IdentityMask\n\nString\n\nIdentifier of acceptance filter (0x000 by default) THe acceptance filter is situated in the reception buffer.\n\n[0-0x7FF] = Standard Identifier\n\n[0x1FFFFFFFF] = Extended Identifier\n\n\n\n$FilterMask\n\nString\n\nThe Hexidecimal string representing the mask acceptance filter. (0x000 is default).\n\n[0-0x7FF] = Standard Identifier\n\n[0x1FFFFFFF] = Extended Identifier\n\n\n\n$EnableAcknowledgement\n\nBoolean\n\nSpecifies whether or not the CAN receiver will send acknowledgement of received messages. The default setting is \"TRUE\". If this parameter is set to false, the CAN adapter is in \"SPY\" mode meaning it will only monitor, but not interact on the CAN Bus. In order to send messages, this parameter must be set to TRUE.\n\n\n\n$ReceiveAll\n\nBoolean\n\nIf this parameter is set to true, all messages received apart from those programmed are transferred to the application through the reception FIFO. If this parameter is set to FALSE, only those messages received which were programmed at reception are transferred to the application.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\nExxoTest_ConfigureCANParameters(0,2,\"STANDARD\",\"0\",\"0\",\"TRUE\",\"TRUE\");\n\n\n\n\n\nExxoTest_ConfigureLINBus\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ExxoTest_ConfigureLINBus": {
  "prefix": "ExxoTest_ConfigureLINBus",
  "body": [
   "ExxoTest_ConfigureLINBus($$CardId,$$BusId,$$BaudRate);"
  ],
  "description": "\n\nThis function configures the LIN bus for communication. Please see the ExxoTest Manual for complete details over all the configuration parameters used to initialize the CAN communication bus.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$CardId\n\nInteger\n\nThe identifier of the device to be configured.\n\n\n\n$BusId\n\nInteger\n\nThe identifier of the CAN bus to be configured.\n\n\n\n$BaudRate\n\nInteger\n\nThe selected Baud Rate. Allowable Values are:\n\n\u00b7 2400\n\n\u00b7 9600\n\n\u00b7 19200\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\nExxoTest_ConfigureLINBus(0,0,9600);\n\n\n\n\n\nSupported Instruments\n\nAll ExxoTest USB Communication Devices\n\n\n\n\n\nExxoTest_ConfigureLINOperation\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ExxoTest_ConfigureLINOperation": {
  "prefix": "ExxoTest_ConfigureLINOperation",
  "body": [
   "ExxoTest_ConfigureLINOperation($$CardId,$$BusId,$$OperationMode,$$FifoSize);"
  ],
  "description": "\n\n\n\n\n\nThis function determines the interface mode between the application and the card. It supports only FIFO mode.\n\n\n\n\n\n\u00b7 FIFO Storage: In this mode, the events to be transferred to the application are stocked in a waiting list. These events are of the following types: end of transmition, reception, errors... When the application calls the GetEvent function, the first event (the oldest in time) is popped from the list. If the waiting list is full and an event takes place, then a bit indicating loss of event is placed on the last event.\n\nAdditional Notes:\n\nThis function must be called in the correct sequence in order for it to function correctly. Please see the usage example below for details of the correct calling order and an example of using the function.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$CardId\n\nInteger\n\nThe identifier of the device to be configured.\n\n\n\n$BusId\n\nInteger\n\nThe identifier of the LIN bus to be configured.\n\n\n\n$OperationMode\n\nString\n\nThe desired operation mode of the LIN interface. The allowable values are:\n\n\u00b7 \"FIFO\"\n\n\n\n$FifoSize\n\nInteger\n\nThe desired size of the FIFO buffer.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\nExxoTest_ConfigureLINOperation(0,0,\"FIFO\",2047);\n\nExxoTest_ConfigureLINBus(0,0,9600);\n\nExxoTest_LINActivate(0,0);\n\nExxoTest_LINDeactivate(0,0);\n\n\n\n\n\nSupported Instruments\n\nAll ExxoTest USB Communication Devices\n\n\n\n\n\nExxoTest_Init\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ExxoTest_Init": {
  "prefix": "ExxoTest_Init",
  "body": [
   "ExxoTest_Init($$CardId);"
  ],
  "description": "\n\n\n\n\n\nThis function opens communcation with the device and prepares it for operation. This is the first function that should be called when using the ExxoTest communcation MUX.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$CardId\n\nInteger\n\nThe identifier of the device to be configured.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\nExxoTest_Init(0);\n\n\n\n\n\nSupported Instruments\n\nAll ExxoTest USB Communication Devices\n\n\n\n\n\nExxoTest_LINActivate\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ExxoTest_LINActivate": {
  "prefix": "ExxoTest_LINActivate",
  "body": [
   "ExxoTest_LINActivate($$CardId,$$BusId);"
  ],
  "description": "\n\n\n\nThis function activates the specific LIN Bus on the ExxoTest USB Mux and prepares it for communication. This function must be run after the LIN operation and bus have been properly configured. Please see the Usage Example below for complete details.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$CardId\n\nInteger\n\nThe ID of the ExxoTest device\n\n\n\n$BusId\n\nInteger\n\nThe LIN Bus to be configured.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\nExxoTest_ConfigureLINOperation(0,0,\"FIFO\",2047);\n\nExxoTest_ConfigureLINBus(0,0,9600);\n\nExxoTest_LINActivate(0,0);\n\nExxoTest_LINDeactivate(0,0);\n\nExxoTest_LINCreateMessage(\"01\",\"TRANSMIT_DATA\",\"GEN_NO_ERROR\",\"AA,BB,CC,DD,EE,FF,00,11\");\n\n\n\n\n\nSupported Instruments\n\nAll ExxoTest USB Communication Devices\n\n\n\n\n\nExxoTest_LINCreateMessage\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ExxoTest_LINCreateMessage": {
  "prefix": "ExxoTest_LINCreateMessage",
  "body": [
   "$$LinMessage=ExxoTest_LINCreateMessage($$MessageId,$$ServiceType,$$GenerateErrorOptions,$$MessageData);"
  ],
  "description": "\n\n\n\nThis function creates a new LIN message to prepare to send. This function only builds the message, and does not send it. For complete details on the LIN message structure and the definition of the message fields, please consult the LIN protocol specification.\n\n\n\n\n\nNote: This function allows introducing errors into the LIN message to simulate bus failures or communication contention. See the parameters below for additional details.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$MessageId\n\nString\n\nA hexadecimal string indicating the Message ID\n\n\n\n$ServiceType\n\nString\n\nThe Type of LIN service. Allowable values are:\n\n\u00b7 \"TRANSMIT_DATA\" = Sends Data\n\n\u00b7 \"REQUEST_IFR\" = Request In-Frame Response\n\n\u00b7 \"UPDATE_IFR\" = Update In-Frame Response\n\n\n\n$ServiceType\n\nString\n\nSpecifies the service type of the message. The allowable values are:\n\n\u00b7 \"TRANSMIT_DATA\"\n\n\u00b7 \"RECEIVE_DATA\"\n\n\u00b7 \"TRANSMIT_REMOTE\"\n\n\u00b7 \"RECEIVE_REMOTE\"\n\n\n\n\n\n$GenerateErrorOptions\n\nString\n\nAllows for creating errors in the LIN message. The allowable options are:\n\n\u00b7 \"GEN_NO_ERROR\" = No Errors\n\n\u00b7 \"GEN_ERR_PO\" = Parity Bit Error on P0 Bit\n\n\u00b7 \"GEN_ERR_P1\" = Parity Bit Error on P1 Bit\n\n\u00b7 \"GEN_ERR_CRC\" = Generate CRC Error\n\n\u00b7 \"GEN_ERR_SYNCH\" = Synchro byte Error (Sends 0xAA instead of 0x55)\n\n\u00b7 \"\"GEN_ERR_DATP1\" = Extra Data Byte (0xFF) is added to the data field\n\n\u00b7 \"GEN_ERR_DATP2\" = Two Extra Data Bytes (OxFF) are added to the data field\n\n\u00b7 \"GEN_ERR_DATL1\" = 1 Data Byte is removed from the Data Field\n\n\u00b7 \"GEN_ER_DATL2\" = 2 Data Bytes are removed from the Data Field\n\n\u00b7 \"GEN_FREE_IDENT\" = Allows sending a message without a data length defined by the identifier. The identifier can take a value between 0 to 63 and data length can take a value between 0 and 8 bytes.\n\n\n\n\n\n$MessageData\n\nString\n\nA comma separated byte string containing the bytes to send in the LIN Message.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$LinMessage\n\nObject\n\nThe newly constructed LIN Message which can be passed to the other ExxoTest CAN functions.\n\n\n\n\n\nExamples:\n\n$MyMessage =ExxoTest_LINCreateMessage(\"01\",\"TRANSMIT_DATA\",\"GEN_NO_ERROR\",\"AA,BB,CC,DD,EE,FF,00,11\");\n\n\n\n\n\nSupported Instruments\n\nAll ExxoTest USB Communication Devices\n\n\n\n\n\nExxoTest_LINDeactivate\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ExxoTest_LINDeactivate": {
  "prefix": "ExxoTest_LINDeactivate",
  "body": [
   "ExxoTest_LINDeactivate($$CardId,$$BusId);"
  ],
  "description": "\n\n\n\nThis function deactivates the specified LIN bus on the specified device. If the LIN bus was not previously activated, this function will return without failure. If the LIN bus is busy, this function will block until the LIN bus can be deactivated.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$CardId\n\nInteger\n\nThe ID of the ExxoTest device\n\n\n\n$BusId\n\nInteger\n\nThe Can Bus to be configured.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\nExxoTest_LINDeactivate(0,0);\n\n\n\n\n\nSupported Instruments\n\nAll ExxoTest USB Communication Devices\n\n\n\n\n\nExxoTest_LINGetNextMessage\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ExxoTest_LINGetNextMessage": {
  "prefix": "ExxoTest_LINGetNextMessage",
  "body": [
   "($$MesageFound,$$QueueDepth,$$MessageId,$$MessageLength,$$MessageData)=ExxoTest_LINGetNextMessage($$CardId,$$BusId);"
  ],
  "description": "\n\n\n\nThis function will search the FIFO stack for the next available received LIN message, and return it to the scripting environment. If no LIN messages have been received, the $MessageFound parameter is set to false. Otherwise, the $MessageFound parameter is set to TRUE and the respective fields pertaining to the message are returned. The $QueueDepth return value specifies the number of LIN events that remain in the FIFO queue.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$CardId\n\nInteger\n\nThe identifier for the LIN device.\n\n\n\n$BusId\n\nInteger\n\nThe identifier for the BUS that should be checked for received LIN messages.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$MessageFound\n\nBoolean\n\nSpecifies whether or not a received message was found in the FIFO queue.\n\n\n\n$QueueDepth\n\nInteger\n\nThe number of LIN events that remain in the FIFO queue.\n\n\n\n$MessageId\n\nInteger\n\nThe message identifier for the LIN message\n\n\n\n$MessageLength\n\nInteger\n\nThe number of bytes in the LIN message.\n\n\n\n$MessageData\n\nString\n\nThe hexadecimal string representing the contents of the LIN message.\n\n\n\n\n\nExamples:\n\n($MessageFound,$QueueDepth,$MessageId,$MessageLength,$MessageData) = ExxoTest_LINGetNextMessage(0,2);\n\nUpdateStatus($MessageFound);\n\nUpdateStatus($QueueDepth);\n\nUpdateStatus($MessageId);\n\nUpdateStatus($MessageLength);\n\nUpdateStatus($MessageData);\n\n\n\n\n\nSupported Instruments\n\nAll ExxoTest USB Communication Devices\n\n\n\n\n\nExxoTest_LINSendMessage\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ExxoTest_LINSendMessage": {
  "prefix": "ExxoTest_LINSendMessage",
  "body": [
   "ExxoTest_LINSendMessage($$CardId,$$BusID,$$LinMessage);"
  ],
  "description": "\n\n\n\nThis function sends a message created with the ExxoTest_LINCreateMessage function on the specified card and bus. If the message can't be sent successfully on the bus, the function generates a failure.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$CardId\n\nInteger\n\nThe ID of the ExxoTest device\n\n\n\n$BusId\n\nInteger\n\nThe LIN Bus to send the message.\n\n\n\n$CanMessage\n\nObject\n\nA LIN Message object created using the ExxoTest_LINSendMessage command.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\nExxoTest_LINSendMessage(0,0,$LinMessage);\n\n\n\n\n\nSupported Instruments\n\nAll ExxoTest USB Communication Devices\n\n\n\n\n\nBelow is a complete script demonstrating how to send and receive messages on a looped back LIN port:\n\n\n\n\n\n// Configue LIN 0\n\nExxoTest_ConfigureLINOperation(0,0,\"FIFO\",2047);\n\nExxoTest_ConfigureLINBus(0,0,9600);\n\nExxoTest_LINActivate(0,0);\n\n\n\n\n\n// Configure LIN 1\n\nExxoTest_ConfigureLINOperation(0,1,\"FIFO\",2047);\n\nExxoTest_ConfigureLINBus(0,1,9600);\n\nExxoTest_LINActivate(0,1);\n\n\n\n\n\n// Send the messages\n\n$LinMessage =ExxoTest_LINCreateMessage(\"02\",\"TRANSMIT_DATA\",\"GEN_NO_ERROR\",\"AA,BB,CC,DD,EE,FF,00,11\");\n\nExxoTest_LINSendMessage(0,0,$LinMessage);\n\nExxoTest_LINSendMessage(0,0,$LinMessage);\n\nSleep(1);\n\n($MessageFound,$QueueDepth,$MessageId,$MessageLength,$MessageData) = ExxoTest_LINGetNextMessage(0,1);\n\n\n\n\n\nExxoTest_LINDeactivate(0,0);\n\nExxoTest_LINDeactivate(0,1);\n\n\n\n\n\nNI_CAN_Close\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_CAN_Close": {
  "prefix": "NI_CAN_Close",
  "body": [
   "NI_CAN_Close($$canHandle);"
  ],
  "description": "\n\nThis function will close communication with a CAN bus.\n\n\n\n\n\nRemarks:\n\nThe bus to close communication with must have been opened using the function NI_CAN_Open.\n\nCommunication actions should be stopped before closing by using the function NI_CAN_Stop.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$canHandle\n\nObject\n\nA handle to a CAN bus interface that was opened using the function NI_CAN_Open.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n// Open communication with CAN bus interface \"CAN0\".\n\n$canName = \"CAN0\";\n\n$baud = 1000000; // 1Mb/s\n\n\n\n\n\n$canHandle = NI_CAN_Open($canName, $baud);\n\n\n\n\n\n// Close communication with the CAN bus.\n\n\n\n\n\nNI_CAN_Close($canHandle);\n\n\n\n\n\nNI_CAN_GetAttributes\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_CAN_GetAttributes": {
  "prefix": "NI_CAN_GetAttributes",
  "body": [
   "($$serialNumber,$$baudRate,$$filterMode,$$filterMask)=NI_CAN_GetAttributes($$canHandle);"
  ],
  "description": "\n\nThis function will return some pertinent attributes (settings) from a CAN bus.\n\n\n\n\n\nRemarks:\n\nThe bus to close communication with must have been opened using the function NI_CAN_Open.\n\nThe communication does not need to be started before reading the attributes.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$canHandle\n\nObject\n\nA handle to a CAN bus interface that was opened using the function NI_CAN_Open.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$serialNumber\n\nString\n\nThe serial number reported by the CAN bus interface (in hexadecimal).\n\n\n\n$baudRate\n\nString\n\nThe baud rate reported by the CAN bus interface.\n\n\n\n$filterMode\n\nString\n\nThe filter mode reported by the CAN bus interface (in hexadecimal).\n\n\n\n$filterMask\n\nString\n\nThe filter mask reported by the CAN bus interface (in hexadecimal).\n\n\n\n\n\nExample:\n\n// Open communication with CAN bus interface \"CAN0\".\n\n$canName = \"CAN0\";\n\n$baud = 1000000; // 1Mb/s\n\n\n\n\n\n$canHandle = NI_CAN_Open($canName, $baud);\n\n\n\n\n\n// Read the attributes.\n\n($serialNumber, $baudRate, $filterMode, $filterMask) = NI_CAN_GetAttributes($canHandle);\n\n\n\n\n\nNI_CAN_GetHWInfo\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_CAN_GetHWInfo": {
  "prefix": "NI_CAN_GetHWInfo",
  "body": [
   "($$serialNumber,$$cardSeries,$$transceiver)=NI_CAN_GetHWInfo($$cardIndex,$$portIndex);"
  ],
  "description": "\n\nThis function will return some hardware information from a CAN bus card.\n\n\n\n\n\nRemarks:\n\nThe hardware to get information from does not need to be opened first.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$cardIndex\n\nInteger\n\nThe index to the card in the system.\n\n\n\n$portIndex\n\nInteger\n\nThe index to the port to get information from in the system.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$serialNumber\n\nString\n\nThe serial number reported by the CAN bus hardware (in hexadecimal).\n\n\n\n$cardSeries\n\nString\n\nThe card series reported by the CAN bus hardware.\n\n\n\n$transciever\n\nString\n\nThe transceiver reported by the CAN bus hardware (in hexadecimal).\n\n\n\n\n\nExample:\n\n// Get hardware information from card 1, port 1.\n\n$card = 1;\n\n$port = 1;\n\n\n\n\n\n// Read the HW information.\n\n($serialNumber, $cardSeries, $transceiver) = NI_CAN_GetHWInfo($card, $port);\n\n\n\n\n\nNI_CAN_GetNumberInReadBuffer\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_CAN_GetNumberInReadBuffer": {
  "prefix": "NI_CAN_GetNumberInReadBuffer",
  "body": [
   "$$numFrames=NI_CAN_GetNumberInReadBuffer($$canHandle);"
  ],
  "description": "\n\nThis function will return the number of unread frames in the incoming buffer.\n\n\n\n\n\nRemarks:\n\nThe bus must have been opened using the function NI_CAN_Open.\n\nThe communication must have been started before reading the number of frames using the function NI_CAN_Start.\n\nThe unread frames can be cleared out of the buffer by reading them or by using the function NI_CAN_Reset.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$canHandle\n\nObject\n\nA handle to a CAN bus interface that was opened using the function NI_CAN_Open.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$numFrames\n\nInteger\n\nThe number of unread frames in the incoming buffer.\n\n\n\n\n\nExample:\n\n// Open communication with CAN bus interface \"CAN0\".\n\n$canName = \"CAN0\";\n\n$baud = 1000000; // 1Mb/s\n\n\n\n\n\n$canHandle = NI_CAN_Open($canName, $baud);\n\n\n\n\n\n// Read the number of waiting frames.\n\n$numFrames = NI_CAN_GetNumberInReadBuffer($canHandle);\n\n\n\n\n\nNI_CAN_Open\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_CAN_Open": {
  "prefix": "NI_CAN_Open",
  "body": [
   "$$canHandle=NI_CAN_Open($$canBusName,$$baudRate);"
  ],
  "description": "\n\nThis function will open communication with a specified CAN bus interface and set the specified baud rate. The interface will also be set to not start automatically on power-up.\n\n\n\n\n\nRemarks:\n\n$canBusName must match the name of the CAN bus interface as listed National Instruments' Measurement and Automation Explorer (MAX).\n\nBefore reading or writing data, the interface must be started using the function NI_CAN_Start.\n\nThe baud rate can be changed later using the function NI_CAN_SetAttribute.\n\nWhen communication is complete, use the function NI_CAN_Close.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$canBusName\n\nString\n\nThe name of the CAN bus as listed in NI MAX.\n\n\n\n$baudRate\n\nInteger\n\nThe baud rate to set the interface to.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$canHandle\n\nObject\n\nA handle to the CAN bus interface for use in other NI-CAN functions.\n\n\n\n\n\nExample:\n\n// Open communication with CAN bus interface \"CAN0\".\n\n$canName = \"CAN0\";\n\n$baud = 1000000; // 1Mb/s\n\n\n\n\n\n$canHandle = NI_CAN_Open($canName, $baud);\n\n\n\n\n\nNI_CAN_ReadMultipleFrames\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_CAN_ReadMultipleFrames": {
  "prefix": "NI_CAN_ReadMultipleFrames",
  "body": [
   "($$framesRead,$$timeStamps,$$arbIDs,$$frameTypes,$$dataLengths,$$data64s)=NI_CAN_ReadMultipleFrames($$canHandle,$$numFrames,$$byteOrder);"
  ],
  "description": "\n\nThis function will return the specified number of frames from the incoming buffer.\n\n\n\n\n\nRemarks:\n\nThe bus must have been opened using the function NI_CAN_Open.\n\nThe communication must have been started before reading the number of frames using the function NI_CAN_Start.\n\nIf the requested number of frames do not exist, the existing frames will be returned and the number of frames read will indicate the number of frames returned.\n\nThe arrays of data returned will all be the same length with the data for the first frame being in the first element of all of the arrays.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$canHandle\n\nObject\n\nA handle to a CAN bus interface that was opened using the function NI_CAN_Open.\n\n\n\n$numFrames\n\nInteger\n\nThe maximum number of frames to read from the incoming buffer.\n\n\n\n$byteOrder\n\nString\n\nThe incoming byte order. This adjusts for different systems sending order; whether it is Little Endian or Big Endian. Valid entries are:\n\n\u00b7 Normal (data returned in the order the bytes are received).\n\n\u00b7 Reversed (byte order reversed before being returned).\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$framesRead\n\nInteger\n\nThe number of frames returned from the incoming buffer.\n\n\n\n$timeStamps\n\nArray\n\nAn array containing all of the timestamps for the frames returned.\n\n\n\n$arbIDs\n\nArray\n\nAn array containing all of the arbitration IDs for the frames returned.\n\n\n\n$frameTypes\n\nArray\n\nAn array containing all of the frame types for the frames returned.\n\n\n\n$dataLengths\n\nArray\n\nAn array containing all of the data lengths for the frames returned.\n\n\n\n$data64s\n\nArray\n\nAn array containing the 64 bit data for the frames returned.\n\n\n\n\n\nExample:\n\n// Open communication with CAN bus interface \"CAN0\".\n\n$canName = \"CAN0\";\n\n$baud = 1000000; // 1Mb/s\n\n\n\n\n\n$canHandle = NI_CAN_Open($canName, $baud);\n\n\n\n\n\n// Start the interface.\n\nNI_CAN_Start($canHandle);\n\n\n\n\n\n// Read the number of waiting frames.\n\n$numFrames = NI_CAN_GetNumberInReadBuffer($canHandle);\n\n\n\n\n\n// Read all of the waiting frames with Little-Endian data.\n\n$order = \"Reversed\";\n\n($framesRead, $timeStamps, $arbIDs, $frameTypes, $dataLengths, $data64s) = NI_CAN_ReadMultipleFrames($canHandle, $numFrames, $order);\n\n\n\n\n\nNI_CAN_ReadSingleFrame\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_CAN_ReadSingleFrame": {
  "prefix": "NI_CAN_ReadSingleFrame",
  "body": [
   "($$timeStamp,$$arbID,$$frameType,$$dataLength,$$data64,$$data7)=NI_CAN_ReadSingleFrame($$canHandle,$$byteOrder);"
  ],
  "description": "\n\nThis function will return a single frame from the incoming buffer.\n\n\n\n\n\nRemarks:\n\nThe bus must have been opened using the function NI_CAN_Open.\n\nThe communication must have been started before reading the number of frames using the function NI_CAN_Start.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$canHandle\n\nObject\n\nA handle to a CAN bus interface that was opened using the function NI_CAN_Open.\n\n\n\n$byteOrder\n\nString\n\nThe incoming byte order. This adjusts for different systems sending order; whether it is Little Endian or Big Endian. Valid entries are:\n\n\u00b7 Normal (data returned in the order the bytes are received).\n\n\u00b7 Reversed (byte order reversed before being returned).\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$timeStamp\n\nString\n\nThe timestamp for the read frame in hexadecimal.\n\n\n\n$arbID\n\nString\n\nThe arbitration ID for the read frame in hexadecimal.\n\n\n\n$frameType\n\nString\n\nThe frame type for the read frame in hexadecimal.\n\n\n\n$dataLength\n\nInteger\n\nThe number of data byte in the read frame.\n\n\n\n$data64\n\nString\n\nThe 64 bit data in the read frame in hexadecimal.\n\n\n\n$data7\n\nString\n\nThe 7 bit data in the read frame in hexadecimal.\n\n\n\n\n\nExample:\n\n// Open communication with CAN bus interface \"CAN0\".\n\n$canName = \"CAN0\";\n\n$baud = 1000000; // 1Mb/s\n\n\n\n\n\n$canHandle = NI_CAN_Open($canName, $baud);\n\n\n\n\n\n// Start the interface.\n\nNI_CAN_Start($canHandle);\n\n\n\n\n\n// Read one frame with Little Endian data.\n\n$order = \"Reversed\";\n\n($timeStamp, $arbID, $frameType, $dataLength, $data64, $data7) = NI_CAN_ReadSingleFrame($canHandle, $order);\n\n\n\n\n\nNI_CAN_Reset\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_CAN_Reset": {
  "prefix": "NI_CAN_Reset",
  "body": [
   "NI_CAN_Reset($$canHandle);"
  ],
  "description": "\n\nThis function will clear the incoming buffer of a CAN bus and reset the current pointer to the start of the buffer.\n\n\n\n\n\nRemarks:\n\nThe bus to reset communication with must have been opened using the function NI_CAN_Open.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$canHandle\n\nObject\n\nA handle to a CAN bus interface that was opened using the function NI_CAN_Open.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n// Open communication with CAN bus interface \"CAN0\".\n\n$canName = \"CAN0\";\n\n$baud = 1000000; // 1Mb/s\n\n\n\n\n\n$canHandle = NI_CAN_Open($canName, $baud);\n\n\n\n\n\n// Reset communication with the CAN bus.\n\n\n\n\n\nNI_CAN_Reset($canHandle);\n\n\n\n\n\nNI_CAN_SetAttribute\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_CAN_Attribute": {
  "prefix": "NI_CAN_Attribute",
  "body": [
   "NI_CAN_Attribute($$canHandle,$$attribName,$$attribValue);"
  ],
  "description": "\n\nThis function will set an attribute on one CAN bus interface.\n\n\n\n\n\nRemarks:\n\nThe bus to set the attribute on must have been opened using the function NI_CAN_Open.\n\nCommunication actions should be stopped before closing by using the function NI_CAN_Stop.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$canHandle\n\nObject\n\nA handle to a CAN bus interface that was opened using the function NI_CAN_Open.\n\n\n\n$attribName\n\nString\n\nThe name of the attribute to change. Must be one of:\n\n\u00b7 Single Shot\n\n\u00b7 Filter Mode\n\n\u00b7 Filter Mask\n\n\u00b7 Baud Rate\n\n\n\n$attribValue\n\nString\n\nThe value to set the attribute to.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n// Open communication with CAN bus interface \"CAN0\".\n\n$canName = \"CAN0\";\n\n$baud = 1000000; // 1Mb/s\n\n\n\n\n\n$canHandle = NI_CAN_Open($canName, $baud);\n\n\n\n\n\n// Set the Filter Mask.\n\n$attrib = \"Filter Mask\";\n\n$value = \"FFFFFFFE\";\n\n\n\n\n\nNI_CAN_SetAttribute($canHandle, $attrib, $value);\n\n\n\n\n\nNI_CAN_Start\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_CAN_Start": {
  "prefix": "NI_CAN_Start",
  "body": [
   "NI_CAN_Start($$canHandle);"
  ],
  "description": "\n\nThis function will start action, including frame acquisition, on a CAN bus.\n\n\n\n\n\nRemarks:\n\nThe bus to close communication with must have been opened using the function NI_CAN_Open.\n\nTo stop the actions use the function NI_CAN_Stop.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$canHandle\n\nObject\n\nA handle to a CAN bus interface that was opened using the function NI_CAN_Open.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n// Open communication with CAN bus interface \"CAN0\".\n\n$canName = \"CAN0\";\n\n$baud = 1000000; // 1Mb/s\n\n\n\n\n\n$canHandle = NI_CAN_Open($canName, $baud);\n\n\n\n\n\n// Start the action on the CAN bus.\n\n\n\n\n\nNI_CAN_Start($canHandle);\n\n\n\n\n\nNI_CAN_Stop\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_CAN_Stop": {
  "prefix": "NI_CAN_Stop",
  "body": [
   "NI_CAN_Stop($$canHandle);"
  ],
  "description": "\n\nThis function will stop action, including frame acquisition, on a CAN bus.\n\n\n\n\n\nRemarks:\n\nThe bus to close communication with must have been opened using the function NI_CAN_Open.\n\nThe CAN bus must already have been started using the function NI_CAN_Start.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$canHandle\n\nObject\n\nA handle to a CAN bus interface that was opened using the function NI_CAN_Open.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n// Open communication with CAN bus interface \"CAN0\".\n\n$canName = \"CAN0\";\n\n$baud = 1000000; // 1Mb/s\n\n\n\n\n\n$canHandle = NI_CAN_Open($canName, $baud);\n\n\n\n\n\n// Start the action on the CAN bus.\n\nNI_CAN_Start($canHandle);\n\n\n\n\n\n// Stop the action on the CAN bus.\n\n\n\n\n\nNI_CAN_Stop($canHandle);\n\n\n\n\n\nNI_CAN_WriteMultipleFrames\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_CAN_WriteMultipleFrames": {
  "prefix": "NI_CAN_WriteMultipleFrames",
  "body": [
   "$$numberWritten=NI_CAN_WriteMultipleFrames($$canHandle,$$destination,$$dataToWrite);"
  ],
  "description": "\n\nThis function will write a number of frames to the CAN bus.\n\n\n\n\n\nRemarks:\n\nThe bus to close communication with must have been opened using the function NI_CAN_Open.\n\nTo CAN bus actions must have been started using the function NI_CAN_Start.\n\nThe data to send must be in a array that is a multiple of 8 in length (each frame sent will contain 8 bytes of data).\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$canHandle\n\nObject\n\nA handle to a CAN bus interface that was opened using the function NI_CAN_Open.\n\n\n\n$destination\n\nInteger\n\nThe ID of the destination node to send the data to.\n\n\n\n$dataToWrite\n\nArray\n\nAn array of bytes containing the data to send to the destination node. This array must be a multiple of 8 bytes long.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$numberWritter\n\nInteger\n\nThe number of frames that were written.\n\n\n\n\n\nExample:\n\n// Open communication with CAN bus interface \"CAN0\".\n\n$canName = \"CAN0\";\n\n$baud = 1000000; // 1Mb/s\n\n\n\n\n\n$canHandle = NI_CAN_Open($canName, $baud);\n\n\n\n\n\n// Start the action on the CAN bus.\n\nNI_CAN_Start($canHandle);\n\n\n\n\n\n// Assuming the data is stored in an array called $data.\n\n// Send to destination node 6.\n\n$dest = 6;\n\n\n\n\n\n$numFrames = NI_CAN_WriteMultipleFrames($canHandle, $dest, $data);\n\n\n\n\n\nNI_CAN_WriteSingleFrame\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_CAN_Frame": {
  "prefix": "NI_CAN_Frame",
  "body": [
   "NI_CAN_Frame($$canHandle,$$destination,$$dataToWrite);"
  ],
  "description": "\n\nThis function will write a single frame to the CAN bus.\n\n\n\n\n\nRemarks:\n\nThe bus to close communication with must have been opened using the function NI_CAN_Open.\n\nTo CAN bus actions must have been started using the function NI_CAN_Start.\n\nThe data to send must be in a array that is 8 bytes in length.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$canHandle\n\nObject\n\nA handle to a CAN bus interface that was opened using the function NI_CAN_Open.\n\n\n\n$destination\n\nInteger\n\nThe ID of the destination node to send the data to.\n\n\n\n$dataToWrite\n\nArray\n\nAn array of bytes containing the data to send to the destination node. This array must be 8 bytes long.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n// Open communication with CAN bus interface \"CAN0\".\n\n$canName = \"CAN0\";\n\n$baud = 1000000; // 1Mb/s\n\n\n\n\n\n$canHandle = NI_CAN_Open($canName, $baud);\n\n\n\n\n\n// Start the action on the CAN bus.\n\nNI_CAN_Start($canHandle);\n\n\n\n\n\n// Assuming the data is stored in an array called $data.\n\n// Send to destination node 6.\n\n$dest = 6;\n\n\n\n\n\n$numFrames = NI_CAN_WriteSingleFrame($canHandle, $dest, $data);\n\n\n\n\n\nCAN_Close\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS CAN_Close": {
  "prefix": "CAN_Close",
  "body": [
   "CAN_Close();"
  ],
  "description": "\n\nThis function will close communication with a Phytec PCAN-USB adapter.\n\n\n\n\n\nRemarks:\n\nThis function will always return a passing result. Even if the PCAN adapter was never opened with the CAN_Init function, or is disconnected from the system.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n// Open communication with CAN bus interface.\n\n$canBaud = \"CAN_BAUD_100K\";\n\n$messType = \"CAN_INIT_TYPE_EX\";\n\n\n\n\n\nCAN_Init($canBaud, $messType);\n\n\n\n\n\n// Close the interface.\n\nCAN_Close();\n\n\n\n\n\nCAN_Init\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS CAN_Init": {
  "prefix": "CAN_Init",
  "body": [
   "CAN_Init($$baudRate,$$messageType);"
  ],
  "description": "\n\nThis function will open communication with a Phytec PCAN-USB adapter.\n\n\n\n\n\nRemarks:\n\nIf the PCAN-USB interface can not be initialized, a Fail result is returned.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$baudRate\n\nString\n\nThe baud rate to initialize the adapter to. Valid values are:\n\n\u00b7 CAN_BAUD_1M\n\n\u00b7 CAN_BAUD_500K\n\n\u00b7 CAN_BAUD_250K\n\n\u00b7 CAN_BAUD_125K\n\n\u00b7 CAN_BAUD_100K\n\n\u00b7 CAN_BAUD_50K\n\n\n\n$messageType\n\nString\n\nThe type of messages to support (either standard or extended frames). Valid values are:\n\n\u00b7 CAN_INIT_TYPE_EX\n\n\u00b7 CAN_INIT_TYPE_ST\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n// Open communication with CAN bus interface.\n\n$canBaud = \"CAN_BAUD_100K\";\n\n$messType = \"CAN_INIT_TYPE_EX\";\n\n\n\n\n\nCAN_Init($canBaud, $messType);\n\n\n\n\n\nCAN_Read\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS CAN_Read": {
  "prefix": "CAN_Read",
  "body": [
   "($$msgId,$$msgType,$$msgLength,$$msgData)=CAN_Read();"
  ],
  "description": "\n\nThis function will return the next available message from the PCAN-USB CAN bus.\n\n\n\n\n\nRemarks:\n\nCommunication must have been opened with the CAN_Init function.\n\nCAN bus messages are stored in a FIFO buffer and accumulate until read.\n\nIf no message exists in the buffer, the function will return \"NO MESSAGE\" in $msgData.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$msgId\n\nString\n\nA hexadecimal string representing the ID of the CAN message sender. Any CAN node which has its filter set up appropriately will receive this message.\n\n\n\n$msgType\n\nInteger\n\nAn integer representing the type of message received. The types of messages that can be received are:\n\n\u00b7 0 = MSGTYPE_STANDARD\n\n\u00b7 1 = MSGTYPE_RTR\n\n\u00b7 2 = MSGTYPE_EXTENDED\n\n\u00b7 128 = MSGTYPE_STATUS\n\n\n\n$msgLength\n\nInteger\n\nThe length of the CAN message in bytes. Valid range is 0 to 8.\n\n\n\n$msgData\n\nString\n\nA hexidecimal string representing the contents of the CAN message. These bytes are transmitted in big endian order, meaning that the most significant byte will be first in the string. In the event that no message exists to be Read, this return value will contain \"No Message\".\n\n\n\n\n\nExample:\n\n// Open communication with CAN bus interface.\n\n$canBaud = \"CAN_BAUD_100K\";\n\n$messType = \"CAN_INIT_TYPE_EX\";\n\n\n\n\n\nCAN_Init($canBaud, $messType);\n\n\n\n\n\n// Wait a second for a messages to come in.\n\nSleep(1);\n\n\n\n\n\n// Read one message from the buffer.\n\n($msgId, $msgType, $msgLength, $msgData) = CAN_Read();\n\n\n\n\n\n// Close the interface.\n\nCAN_Close();\n\n\n\n\n\nCAN_Send\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS CAN_Send": {
  "prefix": "CAN_Send",
  "body": [
   "CAN_Send($$msgId,$$msgType,$$msgLength,$$msgData);"
  ],
  "description": "\n\nThis function sends the CAN message specified in the function arguments out on the CAN Bus.\n\n\n\n\n\nRemarks:\n\nCommunication must have been opened with the CAN_Init function.\n\nThis function returns a PASS result if the message could be placed on the BUS successfully. In the event that a BUSOFF or BUSHEAVY error occurs, the function returns a FAIL result.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$msgId\n\nString\n\nA hexadecimal string representing the ID of the CAN message recipient. Any CAN node which has its filter set up appropriately will receive this message.\n\n\n\n$msgType\n\nInteger\n\nAn integer representing the type of message to send. The types of messages that can be sent are:\n\n\u00b7 0 = MSGTYPE_STANDARD\n\n\u00b7 1 = MSGTYPE_RTR\n\n\u00b7 2 = MSGTYPE_EXTENDED\n\n\u00b7 128 = MSGTYPE_STATUS\n\n\n\n$msgLength\n\nInteger\n\nThe length of the CAN message in bytes. Valid range is 0 to 8.\n\n\n\n$msgData\n\nString\n\nA hexidecimal string representing the contents of the CAN message. These bytes are transmitted in little endian order, meaning that the most signficant byte should be placed last in the string. If the number of bytes in the $msgData parameter is longer than the message length specified in the $msgLength parameter, the extra bytes will be ignored which will cause an error since the most significant byte will be discarded.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n// Open communication with CAN bus interface.\n\n$canBaud = \"CAN_BAUD_100K\";\n\n$messType = \"CAN_INIT_TYPE_EX\";\n\n\n\n\n\nCAN_Init($canBaud, $messType);\n\n\n\n\n\n// Send one message.\n\n$msgId = 31;\n\n$msgType = 2;\n\n$msgData = \"F8E7D6C5B4A39281\";\n\n$messStrLen = StringLength($msgData);\n\n$msgLength = $messStrLen / 2; // 2 characters per byte.\n\nCAN_Send($msgId, $msgType, $msgLength, $msgData);\n\n\n\n\n\n// Close the interface.\n\nCAN_Close();\n\n\n\n\n\nCAN_Status\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS CAN_Status": {
  "prefix": "CAN_Status",
  "body": [
   "$$returnValue=CAN_Status();"
  ],
  "description": "\n\nThis function will query the PCAN-USB interface for its current status.\n\n\n\n\n\nRemarks:\n\nThis function will always return a passing result. Even if the PCAN adapter was never opened with the CAN_Init function, or is disconnected from the system.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$returnValue\n\nInteger\n\nThe numeric value returned from the status function provided in the PCAN_USB API. The definitions of these values (there are several) can be found in the help file that's installed along with the 'PCAN Light' developer kit.\n\n\n\n\n\nExample:\n\n// Open communication with CAN bus interface.\n\n$canBaud = \"CAN_BAUD_100K\";\n\n$messType = \"CAN_INIT_TYPE_EX\";\n\n\n\n\n\nCAN_Init($canBaud, $messType);\n\n\n\n\n\n// Get the CAN but status.\n\n$status = CAN_Status();\n\n\n\n\n\n// Close the interface.\n\nCAN_Close();\n\n\n\n\n\nSoftingCAN_Close\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SoftingCAN_Close": {
  "prefix": "SoftingCAN_Close",
  "body": [
   "SoftingCAN_Close($$canHandle);"
  ],
  "description": "\n\nThis function will close communications on the specified CAN bus.\n\n\n\n\n\nRemarks:\n\nUses the Softing CANbus drivers. Tested using version 5.17.015.\n\nThe CAN bus interface must have been opened using the SoftingCAN_Init function.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$canHandle\n\nObject\n\nThe handle to the CAN bus to close.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n// Open communication with a CANpro USB adapter.\n\n$canName = \"CANpro USB_1\";\n\n$baud = \"1M\";\n\n$canHandle = SoftingCAN_Init($canName, $baud);\n\n\n\n\n\n// Close communication.\n\nSoftingCAN_Close($canHandle);\n\n\n\n\n\nSoftingCAN_GetAllCanChannels\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SoftingCAN_GetAllCanChannels": {
  "prefix": "SoftingCAN_GetAllCanChannels",
  "body": [
   "($$numChans,$$isOpens,$$chanNames,$$devTypes,$$FirmIds,$$chanNums,$$serialNums)=SoftingCAN_GetAllCanChannels($$canHandle);"
  ],
  "description": "\n\nThis function will return a number of arrays with data about all of the CAN channels on the computer system.\n\n\n\n\n\nRemarks:\n\nUses the Softing CANbus drivers. Tested using version 5.17.015.\n\nThe CAN bus interface must have been opened using the SoftingCAN_Init function.\n\nIf multiple CAN but interfaces are open, it does not matter which one is used - they will all return the same data.\n\nEach of the arrays of data will be the same length. That length will be equal to $numChans.\n\nIf one physical device contains multiple CAN channels, the data that refers to the hardware (device type, firmware ID and serial number) will be the same for each channel.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$canHandle\n\nObject\n\nThe handle to one CAN bus.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$numChans\n\nInteger\n\nThe number of CAN bus channels on the system.\n\n\n\n$isOpens\n\nBoolean Array\n\nWhether each of the channels is open.\n\n\n\n$chanNames\n\nString Array\n\nThe name of each of the channels.\n\n\n\n$devTypes\n\nString Array\n\nThe device type for each of the channels.\n\n\n\n$FirmIds\n\nInteger Array\n\nThe Firmware ID for each of the channels.\n\n\n\n$chanNums\n\nInteger Array\n\nThe physical channel number for each of the channels.\n\n\n\n$serialNums\n\nInteger Array\n\nThe serial number of each of the channels.\n\n\n\n\n\nExample:\n\n// Open communication with a CANpro USB adapter.\n\n$canName = \"CANpro USB_1\";\n\n$baud = \"1M\";\n\n$canHandle = SoftingCAN_Init($canName, $baud);\n\n\n\n\n\n// Get information on the channels.\n\n($numChans, $isOpens, $chanNames, $devTypes, $FirmIds, $chanNums, $serialNums) = SoftingCAN_GetAllCanChannels($canHandle);\n\n\n\n\n\n// Print out the channel information.\n\n$outStr = \"Number of CAN channels = \" + $numC;\n\nUpdateStatus($outStr);\n\n$loopCount = 0;\n\nwhile ($loopCount < $numC)\n\n{\n\n$chanNum = $loopCount + 1;\n\n$outStr = \"\\r\\nChannel number:\\t\" + $chanNum;\n\nUpdateStatus($outStr);\n\n$arrVal = Array1DGetValue($ioA, $loopCount);\n\n$outStr = \"\\tChannel Is Open:\\t\" + $arrVal;\n\nUpdateStatus($outStr);\n\n$arrVal = Array1DGetValue($cnA, $loopCount);\n\n$outStr = \"\\tChannel Name:\\t\" + $arrVal;\n\nUpdateStatus($outStr);\n\n$arrVal = Array1DGetValue($dtA, $loopCount);\n\n$outStr = \"\\tDevice Type:\\t\" + $arrVal;\n\nUpdateStatus($outStr);\n\n$arrVal = Array1DGetValue($fiA, $loopCount);\n\n$outStr = \"\\tFirmware ID:\\t\" + $arrVal;\n\nUpdateStatus($outStr);\n\n$arrVal = Array1DGetValue($cNumsA, $loopCount);\n\n$outStr = \"\\tPhysical Channel Number:\\t\" + $arrVal;\n\nUpdateStatus($outStr);\n\n$arrVal = Array1DGetValue($snA, $loopCount);\n\n$outStr = \"\\tSerial Number:\\t\" + $arrVal;\n\nUpdateStatus($outStr);\n\n$loopCount = $loopCount + 1;\n\n}\n\n\n\n\n\n// Close communication.\n\nSoftingCAN_Close($canHandle);\n\n\n\n\n\nSoftingCAN_GetNumberInReadFifo\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SoftingCAN_GetNumberInReadFifo": {
  "prefix": "SoftingCAN_GetNumberInReadFifo",
  "body": [
   "$$number=SoftingCAN_GetNumberInReadFifo($$canHandle);"
  ],
  "description": "\n\nThis function will return the number of unread messages in the incoming message FIFO.\n\n\n\n\n\nRemarks:\n\nUses the Softing CANbus drivers. Tested using version 5.17.015.\n\nThe CAN bus interface must have been opened using the SoftingCAN_Init function.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$canHandle\n\nObject\n\nThe handle to the CAN bus.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$number\n\nInteger\n\nThe number of unread messages in the incoming message FIFO.\n\n\n\n\n\nExample:\n\n// Open communication with a CANpro USB adapter.\n\n$canName = \"CANpro USB_1\";\n\n$baud = \"1M\";\n\n$canHandle = SoftingCAN_Init($canName, $baud);\n\n\n\n\n\n// Get the number of messages and print on the Debug tab.\n\n$numMess = SoftingCAN_GetNumberInReadFifo($canHandle);\n\n\n\n\n\n$outStr = \"Number of unread messages = \" + $numMess;\n\nUpdateStatus($outStr);\n\n\n\n\n\n// Close communication.\n\nSoftingCAN_Close($canHandle);\n\n\n\n\n\nSoftingCAN_Init\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SoftingCAN_Init": {
  "prefix": "SoftingCAN_Init",
  "body": [
   "$$canHandle=SoftingCAN_Init($$canBusName,$$baudRate,$$stdCode,$$stdMask,$$extCode,$$extMask);"
  ],
  "description": "\n\nThis function will open communications on the specified CAN bus, set the baud rate and the acceptance codes and acceptance masks for incoming message IDs. Message acquisition will begin immediately after this function runs.\n\n\n\n\n\nRemarks:\n\nUses the Softing CANbus drivers. Tested using version 5.17.015.\n\nSome CANbus adapters have interfaces to two different CAN buses. Both can be opened using their CAN bus names.\n\nThe CAN bus names can be found (and set) using the Softing CAN Interface Manager (SCIM) program.\n\nAcceptance codes and acceptance masks can be integers or hex strings. Hex strings can include spaces to make them easier to read. For example \"0xFFFFFFFF\" = \"0xFF FF FF FF\" = \"0xFFFF FFFF\".\n\nAcceptance codes and masks work together to determine which message IDs are passed through from the CANbus to the buffer. Bitwise - any 1 in the mask means that the corresponding bit in the message ID must exactly match that bit in the acceptance code. A 0 in the mask means that bit can be any state. See the Softing CAN Layer 2 manual for more information on codes and masks.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$canBusName\n\nString\n\nThe name of the CAN bus to open communications with.\n\n\n\n$baudRate\n\nString\n\nThe baud rate to set the CAN bus adapter to use. Valid entries are:\n\n\u00b7 1M\n\n\u00b7 800k\n\n\u00b7 500k\n\n\u00b7 250k\n\n\u00b7 125k\n\n\u00b7 100k\n\n\u00b7 10k\n\n\n\n$stdCode\n\nString\n\nInteger\n\nThe acceptance code for standard frames.\n\nIf this is a hexadecimal string, it must start with \"0x\" and valid numbers are \"0x0\" to \"0x1FF\". Setting to \"0xFFFFFFFF\" will force the use of the setting from the SCIM program.\n\nIf this is an integer, valid numbers are 0 to 2047. Setting to 4,294,967,295 will force the use of the setting from the SCIM program.\n\n\n\n$stdMask\n\nString\n\nInteger\n\nThe acceptance mask for standard frames.\n\nIf this is a hexadecimal string, it must start with \"0x\" and valid numbers are \"0x0\" to \"0x1FF\". Setting to \"0xFFFFFFFF\" will force the use of the setting from the SCIM program.\n\nIf this is an integer, valid numbers are 0 to 2047. Setting to 4,294,967,295 will force the use of the setting from the SCIM program.\n\n\n\n$extCode\n\nString\n\nInteger\n\nThe acceptance code for extended frames.\n\nIf this is a hexadecimal string, it must start with \"0x\" and valid numbers are \"0x0\" to \"0x1FFFFFFF\". Setting to \"0xFFFFFFFF\" will force the use of the setting from the SCIM program.\n\nIf this is an integer, valid numbers are 0 to 536,870,911. Setting to 4,294,967,295 will force the use of the setting from the SCIM program.\n\n\n\n$extMask\n\nString\n\nInteger\n\nThe acceptance mask for extended frames.\n\nIf this is a hexadecimal string, it must start with \"0x\" and valid numbers are \"0x0\" to \"0x1FFFFFFF\". Setting to \"0xFFFFFFFF\" will force the use of the setting from the SCIM program.\n\nIf this is an integer, valid numbers are 0 to 536,870,911. Setting to 4,294,967,295 will force the use of the setting from the SCIM program.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$canHandle\n\nObject\n\nA handle to the opened CAN bus adapter.\n\n\n\n\n\nExample:\n\n// Open communication with a CANpro USB adapter.\n\n$canName = \"CANpro USB_1\";\n\n$baud = \"1M\";\n\n$stdCode = 0;\n\n$stdMask = 0; // We do not care about the ID in the standard messages - we will see them all.\n\n$extCode = \"0x18EF4041\";\n\n$extMask = \"0x1FFF FFFF\"; // Only IDs equal to 0x18EF4041 will be seen.\n\n$canHandle = SoftingCAN_Init($canName, $baud, $stdCode, $stdMask, $extCode, $extMask);\n\n\n\n\n\nSoftingCAN_ReadData\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SoftingCAN_ReadData": {
  "prefix": "SoftingCAN_ReadData",
  "body": [
   "($$numBytes,$$dataTime,$$data,$$messageType)=SoftingCAN_ReadData($$canHandle);"
  ],
  "description": "\n\nThis function will return the first data in the FIFO and include the number of bytes in the message, the time the message was sent and the type of message.\n\n\n\n\n\nRemarks:\n\nUses the Softing CANbus drivers. Tested using version 5.17.015.\n\nThe CAN bus interface must have been opened using the SoftingCAN_Init function.\n\nThe $dataTime is the number of microseconds since the interface was last reset.\n\nMessage types can include: No new event\n\nExtended data frame received\n\n\n\nStandard data frame received\n\nTransmission of extended data frame confirmed\n\n\n\nStandard remote frame received\n\nTransmission of extended remote frame confirmed\n\n\n\nTransmission of standard data frame confirmed\n\nExtended remote frame received\n\n\n\nOverrun of remote transmit FIFO\n\nError frame detected\n\n\n\nChange of bus status\n\nUnknown function return code: #\n\n\n\nTransmission of standard remote frame confirmed\n\n\n\n\n\nNOTE: Sending data will give you a read packet with one of the Transmission Confirmed messages listed above. For incoming data, call the read function until the $messageType is either \"Standard data frame received\" or \"Extended data frame received\".\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$canHandle\n\nObject\n\nThe handle to the CAN bus.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$numBytes\n\nInteger\n\nThe number of data bytes in the message.\n\n\n\n$dataTime\n\nInteger\n\nThe number of microseconds since the last reset.\n\n\n\n$data\n\nArray\n\nThe data in an array of bytes.\n\n\n\n$messageType\n\nString\n\nThe type of message. See table above for message types.\n\n\n\n\n\nExample:\n\n// Open communication with a CANpro USB adapter.\n\n$canName = \"CANpro USB_1\";\n\n$baud = \"1M\";\n\n$canHandle = SoftingCAN_Init($canName, $baud);\n\n\n\n\n\n// Read one message.\n\n($numBytes, $dataTime, $data, $messageType) = SoftingCAN_ReadData($canHandle);\n\n\n\n\n\n// Close communication.\n\nSoftingCAN_Close($canHandle);\n\n\n\n\n\nSoftingCAN_Reinitialize\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SoftingCAN_Reinitialize": {
  "prefix": "SoftingCAN_Reinitialize",
  "body": [
   "SoftingCAN_Reinitialize($$canHandle);"
  ],
  "description": "\n\nThis function will reinitialize the CAN bus FIFO and stops acquisition. You must run this function in order to change the acceptance codes and masks. To change the acceptance codes and masks, use the SoftingCAN_Init function.\n\n\n\n\n\nRemarks:\n\nUses the Softing CANbus drivers. Tested using version 5.17.015.\n\nThe CAN bus interface must have been opened using the SoftingCAN_Init function.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$canHandle\n\nObject\n\nThe handle to the CAN bus to reinitialize the FIFO of.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n// Open communication with a CANpro USB adapter.\n\n$canName = \"CANpro USB_1\";\n\n$baud = \"1M\";\n\n$canHandle = SoftingCAN_Init($canName, $baud);\n\n\n\n\n\n// Reinitialize the FIFO.\n\nSoftingCAN_Reinitialize($canHandle);\n\n\n\n\n\nSoftingCAN_ResetReceiveFifo\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SoftingCAN_ResetReceiveFifo": {
  "prefix": "SoftingCAN_ResetReceiveFifo",
  "body": [
   "SoftingCAN_ResetReceiveFifo($$canHandle);"
  ],
  "description": "\n\nThis function will reset and clear the incoming FIFO on the specified CAN bus.\n\n\n\n\n\nRemarks:\n\nUses the Softing CANbus drivers. Tested using version 5.17.015.\n\nThe CAN bus interface must have been opened using the SoftingCAN_Init function.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$canHandle\n\nObject\n\nThe handle to the CAN bus to clear the incoming FIFO of.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n// Open communication with a CANpro USB adapter.\n\n$canName = \"CANpro USB_1\";\n\n$baud = \"1M\";\n\n$canHandle = SoftingCAN_Init($canName, $baud);\n\n\n\n\n\n// Clear the incoming FIFO.\n\nSoftingCAN_ResetReceiveFifo($canHandle);\n\n\n\n\n\nSoftingCAN_ResetXmitFifo\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SoftingCAN_ResetXmitFifo": {
  "prefix": "SoftingCAN_ResetXmitFifo",
  "body": [
   "SoftingCAN_ResetXmitFifo($$canHandle);"
  ],
  "description": "\n\nThis function will reset and clear the outgoing FIFO on the specified CAN bus.\n\n\n\n\n\nRemarks:\n\nUses the Softing CANbus drivers. Tested using version 5.17.015.\n\nThe CAN bus interface must have been opened using the SoftingCAN_Init function.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$canHandle\n\nObject\n\nThe handle to the CAN bus to clear the outgoing FIFO of.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n// Open communication with a CANpro USB adapter.\n\n$canName = \"CANpro USB_1\";\n\n$baud = \"1M\";\n\n$canHandle = SoftingCAN_Init($canName, $baud);\n\n\n\n\n\n// Clear the outgoing FIFO.\n\nSoftingCAN_ResetXmitFifo($canHandle);\n\n\n\n\n\nSoftingCAN_WriteData\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SoftingCAN_WriteData": {
  "prefix": "SoftingCAN_WriteData",
  "body": [
   "SoftingCAN_WriteData($$canHandle,$$destID,$$extend,$$messDLC,$$messData);"
  ],
  "description": "\n\nThis function will write one frame of data to one location.\n\n\n\n\n\nRemarks:\n\nUses the Softing CANbus drivers. Tested using version 5.17.015.\n\nThe CAN bus interface must have been opened using the SoftingCAN_Init function.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$canHandle\n\nObject\n\nThe handle to the CAN bus.\n\n\n\n$destID\n\nInteger\n\nThe ID of the destination for the message.\n\n\n\n$extend\n\nString\n\nWhether to use the extended (29 bit) ID or the standard (11 bit) ID.\n\n\n\n$messDLC\n\nInteger\n\nThe DLC for the message.\n\n\n\n$messData\n\nArray\n\nAn array of bytes to send on the CAN bus. Sent in order from lowest element to highest (array element 0 sent first).\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n// Open communication with a CANpro USB adapter.\n\n$canName = \"CANpro USB_1\";\n\n$baud = \"1M\";\n\n$canHandle = SoftingCAN_Init($canName, $baud);\n\n\n\n\n\n// Write one message.\n\n$dest = 123456;\n\n$extend = \"true\";\n\n$messDLC = 123;\n\n$messData = Array1DCreate(\"INTEGER\", 8);\n\nArray1DSetValue($messData, 0, 23);\n\nArray1DSetValue($messData, 1, 253);\n\nArray1DSetValue($messData, 2, 34);\n\nArray1DSetValue($messData, 3, 110);\n\nArray1DSetValue($messData, 4, 56);\n\nArray1DSetValue($messData, 5, 207);\n\nArray1DSetValue($messData, 6, 05);\n\nArray1DSetValue($messData, 7, 32);\n\n\n\n\n\nSoftingCAN_WriteData($canHandle, $dest, $extend, $messDLC, $messData);\n\n\n\n\n\n// Close communication.\n\nSoftingCAN_Close($canHandle);\n\n\n\n\n\nSystec_CAN_CloseCan\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Systec_CAN_CloseCan": {
  "prefix": "Systec_CAN_CloseCan",
  "body": [
   "$$ErrorCode=Systec_CAN_CloseCan($$CanHandle,$$Channel);"
  ],
  "description": "\n\nThis function requires Systec device drivers V3.0 or higher to be installed on the system.\n\nThis function shuts down a selective CAN interface of a USB-CANmodul. This function sets the operating voltage of the CAN controller to 0 V. After calling this function, all CAN messages received from CAN bus are ignored and not transferred to the PC.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a Systec USB-CANmodul GW001/GW002.\n\n\u00b7 This function will fail when you use wrong parameter values.\n\n\u00b7 The corresponding error message is displayed when an error or a warning occurs.\n\n\u00b7 For detailed information, read the Systec manual delivered with the software package.\n\n\n\nResult:\n\n$ErrorCode = Systec_CAN_CloseCan($CanHandle, $Channel);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$CanHandle\n\nObject\n\nThe USB-CANmodul handle returned with the function Systec_CAN_InitHardware.\n\n\n\n$Channel\n\nInteger\n\nCAN-channel, which is to be initialized.\n\nPossible values:\n\n\u00b7 0: channel 0\n\n\u00b7 1: channel 1\n\n\u00b7 255: any available channel\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\nInteger\n\nThe error code of the function.\n\nPossible values:\n\n\u00b7 0 : successful\n\n\u00b7 < 128 : warning\n\n\n\n\n\nFor detailed error codes, see the Systec manual.\n\n\n\n\n\nExample:\n\n$ErrorCode = Systec_CAN_CloseCan($CanHandle, 0);\n\n\n\n\n\nSystec_CAN_CloseHardware\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Systec_CAN_CloseHardware": {
  "prefix": "Systec_CAN_CloseHardware",
  "body": [
   "Systec_CAN_CloseHardware($$CanHandle);"
  ],
  "description": "\n\nThis function requires Systec device drivers V3.0 or higher to be installed on the system.\n\nThis function shuts down an initialized USB-CANmodul that was initialized with Systec_CAN_InitHardware. The software returns to the state DLL_INIT. After the function call, the USB-CAN handle is not valid.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a Systec USB-CANmodul GW001/GW002.\n\n\u00b7 For detailed information, read the Systec manual delivered with the software package.\n\n\n\nResult:\n\nSystec_CAN_CloseHardware($CanHandle);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$CanHandle\n\nObject\n\nThe USB-CANmodul handle returned with the function Systec_CAN_InitHardware.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n\n\nExample:\n\nSystec_CAN_CloseHardware($CanHandle);\n\n\n\n\n\nSystec_CAN_InitCan\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Systec_CAN_InitCan": {
  "prefix": "Systec_CAN_InitCan",
  "body": [
   "$$ErrorCode=Systec_CAN_InitCan($$CanHandle,$$Channel,$$Baudrate,$$BusTimingRegister0,$$BusTimingRegister1,$$TransmissionMode,$$AcceptanceMaskRegister,$$AcceptanceCodeRegister,$$OutputControlRegister,$$Receivebuffer,$$TransmitBuffer);"
  ],
  "description": "\n\nThis function requires Systec device drivers V3.0 or higher to be installed on the system.\n\nThis function initializes the specified CAN-channel of a USB-CANmodul.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a Systec USB-CANmodul GW001/GW002.\n\n\u00b7 This function will fail when you use wrong parameter values.\n\n\u00b7 The corresponding error message is displayed when an error or a warning occurs.\n\n\u00b7 For detailed information, read the Systec manual delivered with the software package.\n\n\n\nResult:\n\n$ErrorCode = Systec_CAN_InitCan($CanHandle, $Channel, $Baudrate, $BusTimingRegister0, $BusTimingRegister1, $TransmissionMode, $AcceptanceMaskRegister, $AcceptanceCodeRegister, $OutputControlRegister, $Receivebuffer, $TransmitBuffer);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$CanHandle\n\nObject\n\nThe USB-CANmodul handle returned with the function Systec_CAN_InitHardware.\n\n\n\n$Channel\n\nInteger\n\nCAN-channel, which is to be initialized.\n\nPossible values:\n\n\u00b7 0: channel 0\n\n\u00b7 1: channel 1\n\n\u00b7 255: any available channel\n\n\n\n$Baudrate\n\nString\n\nThe baudrate register for Multiport, USB-CANmodul1 and USB-CANmodul2.\n\nPossible values:\n\n\u00b7 100K: CAN baud rate 100 kBit/s\n\n\u00b7 10K: CAN baud rate 10 kBit/s\n\n\u00b7 125K: CAN baud rate 125 kBit/s\n\n\u00b7 1M: CAN baud rate 1 MBit/s\n\n\u00b7 20K: CAN baud rate 20 kBit/s\n\n\u00b7 250K: CAN baud rate 250 kBit/s\n\n\u00b7 500K: CAN baud rate 500 kBit/s\n\n\u00b7 50K: CAN baud rate 50 kBit/s\n\n\u00b7 800K: CAN baud rate 800 kBit/s\n\n\u00b7 AUTO: Automatic baudrate detection.\n\n\u00b7 USE BUS TIMING REGISTERS: Uses predefined values of BTR0/BTR1 for GW-001/002\n\n\n\n$BusTimingRegister0\n\nInteger\n\nThe bus timing register 0 of SJA1000.\n\n\n\n$BusTimingRegister1\n\nInteger\n\nThe bus timing register 1 of SJA1000.\n\n\n\n$TransmissionMode\n\nString\n\nThe transmission mode of the CAN-channel.\n\nPossible values:\n\n\u00b7 TX ECHO: return messages as transmit echo.\n\n\u00b7 NORMAL: normal transmit- and receive mode.\n\n\u00b7 LISTEN ONLY: Listen-only mode. Transmitted CAN messages are not sent out via CAN-bus. Received CAN-messages of remote nodes are not acknowledged.\n\n\n\n$AcceptanceMaskRegister\n\nInteger\n\nThe acceptance mask register of SJA1000.\n\n\n\n$AcceptanceCodeRegister\n\nInteger\n\nThe acceptance code register of SJA1000.\n\n\n\n$OutputControlRegister\n\nstring\n\nThe output control register of SJA1000. Should be 0x1A\n\n\n\n$Receivebuffer\n\nInteger\n\nNumber of receive buffer entries\n\n\n\n$TransmitBuffer\n\nInteger\n\nNumber of transmit buffer entries\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\nInteger\n\nThe error code of the function.\n\nPossible values:\n\n\u00b7 0 : successful\n\n\u00b7 < 128 : warning\n\n\n\n\n\nFor detailed error codes, see the Systec manual.\n\n\n\n\n\nExample:\n\n$ErrorCode = Systec_CAN_InitCan($CanHandle, 0, \"125k\", 0, 0, \"normal\", -1, 0, \"0x1A\", 4096, 4096);\n\n\n\n\n\nSystec_CAN_InitHardware\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Systec_CAN_InitHardware": {
  "prefix": "Systec_CAN_InitHardware",
  "body": [
   "$$CanHandle=Systec_CAN_InitHardware($$DeviceNumber);"
  ],
  "description": "\n\nThis function requires Systec device drivers V3.0 or higher to be installed on the system.\n\nThis function initializes an USB-CANmodul using the device number. The software changes into the state HW_INIT. From this point, other functions can be called. If the function was executed successfully, the function transfers a USB-CAN handle to the variable Handle. Other functions have to be called with this handle.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a Systec USB-CANmodul GW001/GW002.\n\n\u00b7 This function will fail if there is an error in the system.\n\n\u00b7 For detailed information, read the Systec manual delivered with the software package.\n\n\n\nResult:\n\n$CanHandle = Systec_CAN_InitHardware($DeviceNumber);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$DeviceNumber\n\nInteger\n\nThe device number of the USB-CANmodul (0 \u2013 254).\n\nThe value 255 makes sure that the first allocated USB-CANmodul is used.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$CanHandle\n\nObject\n\nThe USB-CANmodul handle to use in other functions.\n\n\n\n\n\nExample:\n\n$CanHandle = Systec_CAN_InitHardware(0);\n\n$CanHandle = Systec_CAN_InitHardware(255);\n\n\n\n\n\nSystec_CAN_ReadCanMessage\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Systec_CAN_ReadCanMessage": {
  "prefix": "Systec_CAN_ReadCanMessage",
  "body": [
   "$$ErrorCode=Systec_CAN_ReadCanMessage($$CanHandle,$$Channel,$$Identifier,$$MessageCount,$$Timeout);"
  ],
  "description": "\n\nThis function requires Systec device drivers V3.0 or higher to be installed on the system.\n\nThis function reads a CAN message from the buffer of a specific CAN-channel until the timeout is reached.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a Systec USB-CANmodul GW001/GW002.\n\n\u00b7 This function will fail when you use wrong parameter values.\n\n\u00b7 The corresponding error message is displayed when an error or a warning occurs.\n\n\u00b7 For detailed information, read the Systec manual delivered with the software package.\n\n\n\nResult:\n\n$ErrorCode = Systec_CAN_ReadCanMessage($CanHandle, $Channel, $Identifier, $MessageCount, $Timeout);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$CanHandle\n\nObject\n\nThe USB-CANmodul handle returned with the function Systec_CAN_InitHardware.\n\n\n\n$Channel\n\nInteger\n\nCAN-channel, which is to read data from.\n\nPossible values:\n\n\u00b7 0: channel 0\n\n\u00b7 1: channel 1\n\n\u00b7 255: any available channel\n\n\n\n$Identifier\n\nString\n\nThe CAN identifier.\n\nExample:\n\n\"0x581\"\n\n\n\n$MessageCount\n\nInteger\n\nThe message count is the number of messages the USB-CANmodul reads in one time.\n\n\n\n$Timeout\n\nFloat\n\nThe timeout in seconds.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\nInteger\n\nThe error code of the function.\n\nPossible values:\n\n\u00b7 0 : successful\n\n\u00b7 < 128 : warning\n\n\n\n\n\nFor detailed error codes, see the Systec manual.\n\n\n\n\n\nExample:\n\n($ErrorCode,$ReadData) = Systec_CAN_ReadCanMessage($CanHandle, 0, \"0x581\", 10, 1.0);\n\n\n\n\n\nSystec_CAN_ResetCan\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Systec_CAN_ResetCan": {
  "prefix": "Systec_CAN_ResetCan",
  "body": [
   "$$ErrorCode=Systec_CAN_ResetCan($$CanHandle,$$Channel,$$ResetFlag);"
  ],
  "description": "\n\nThis function requires Systec device drivers V3.0 or higher to be installed on the system.\n\nThis function resets parametered global features of features of a separate CAN channel\n\nof a USB-CANmodul.\n\n\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a Systec USB-CANmodul GW001/GW002.\n\n\u00b7 This function will fail when you use wrong parameter values.\n\n\u00b7 The corresponding error message is displayed when an error or a warning occurs.\n\n\u00b7 For detailed information, read the Systec manual delivered with the software package.\n\n\u00b7 When you use the reset flag \"reset firmware\", you have to execute the Systec_CAN_InitHardware and Systec_CAN_InitCan again since the handle previously created with those functions is also resetted.\n\n\n\nResult:\n\n$ErrorCode = Systec_CAN_ResetCan($CanHandle, $Channel, $ResetFlag);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$CanHandle\n\nObject\n\nThe USB-CANmodul handle returned with the function Systec_CAN_InitHardware.\n\n\n\n$Channel\n\nInteger\n\nCAN-channel, which is to be initialized.\n\nPossible values:\n\n\u00b7 0: channel 0\n\n\u00b7 1: channel 1\n\n\u00b7 255: any available channel\n\n\n\n$ResetFlag\n\nString\n\nThe flag specify what components are to be reset.\n\nPossible values:\n\n\u00b7 RESET ALL: Reset all components. However, the firmware is not reset\n\n\u00b7 completely.\n\n\u00b7 RESET NO STATUS: Skip reset of the CAN error status (not supported for GW-001\n\n\u00b7 and/or GW-002).\n\n\u00b7 RESET NO CAN CONTROLLER: Skip reset of the CAN controller.\n\n\u00b7 RESET NO TX COUNTER: Skip reset of the transmit message counter.\n\n\u00b7 RESET NO RX COUNTER: Skip reset of the receive message counter.\n\n\u00b7 RESET NO TX BUFFER CHANNEL: Skip reset of the transmit buffers of a specific CAN-channel\n\n\u00b7 RESET NO TX BUFFER DLL: Skip reset of the transmit buffer for both CAN-channels within\n\n\u00b7 the DLL.\n\n\u00b7 RESET NO TX BUFFER SYS: Skip reset of the transmit message counter of both CAN-channels\n\n\u00b7 within the Kernel-Mode driver.\n\n\u00b7 RESET NO TX BUFFER FIRMWARE: Skip reset of the transmit buffers of both CAN-channels within\n\n\u00b7 the device\u2019s firmware.\n\n\u00b7 RESET NO RX BUFFER CHANNEL: Skip reset of the receive buffers of a specific CAN-channel\n\n\u00b7 RESET NO RX BUFFER DLL: Skip reset of both receive message counters within the DLL\n\n\u00b7 RESET NO RX BUFFER SYS: Skip reset of the receive message counter of both CAN-channels\n\n\u00b7 within the Kernel-Mode driver.\n\n\u00b7 RESET NO RX BUFFER FIRMWARE: Skip reset of receive message counters of both CAN-channels\n\n\u00b7 within the device\u2019s firmware.\n\n\u00b7 RESET FIRMWARE: Complete reset of the device firmware.\n\n\u00b7 RESET NO COUNTER ALL: Skip reset of the transmit and receive counters in all software parts.\n\n\u00b7 RESET NO TX BUFFER COMM: Skip reset of the firmware transmit buffer, the kernel transmit buffer and the usbcan32.dll transmit buffer.\n\n\u00b7 RESET NO RX BUFFER COM: Skip reset of the firmware receive buffer, the kernel receive buffer and the usbcan32.dll receive buffer.\n\n\u00b7 RESET NO TX BUFFER ALL: Skip reset of the firmware transmit buffer, the kernel transmit buffer,the usbcan32.dll transmit buffer and the usbcan32.dll channel transmit buffer.\n\n\u00b7 RESET NO RX BUFFER ALL: Skip reset of the firmware receive buffer, the kernel receive buffer,the usbcan32.dll receive buffer and the usbcan32.dll channel receive buffer.\n\n\u00b7 RESET NO BUFFER COMM: Skip reset of the transmit and receive buffer in the kernel buffer, firmware buffer and the usbcan32.dll buffer.\n\n\u00b7 RESET NO BUFFER ALL: Skip reset of the transmit and receive buffer in the kernel buffer, firmware buffer, the usbcan32.dll buffer and the usbcan32.dll channel buffer.\n\n\u00b7 RESET ONLY STATUS: Reset of the CAN error status only.\n\n\u00b7 RESET ONLY CAN CONTROLLER: Reset the CAN controller only.\n\n\u00b7 RESET ONLY TX BUFFER FIRMWARE: Skip reset of the transmit buffers of both CAN-channels within the device's firmware.\n\n\u00b7 RESET ONLY RX BUFFER FIRMWARE: Skip reset of the receive message counters of both CAN-channels within the device's firmware.\n\n\u00b7 RESET ONLY RX CHANNEL BUFFER: Reset of the receive buffer of only one CAN-channel.\n\n\u00b7 RESET ONLY TX CHANNEL BUFFER: Reset of the transmit buffer of o nly one CAN-channel.\n\n\u00b7 RESET ONLY RX BUFFER: Reset of the receive buffers in all software parts and reset of the receive message counter.\n\n\u00b7 RESET ONLY RX BUFFER GW002: Reset of the receive buffers in all software parts and reset of the receive message counter for GW002.\n\n\u00b7 RESET ONLY TX BUFFER: Reset of the transmit buffers in all software parts and reset of the\n\n\u00b7 transmit message counter.\n\n\u00b7 RESET ONLY ALL BUFFERS: Reset off all message buffers (receive and transmit buffers) in all\n\n\u00b7 software parts and reset of the receive and transmit message counter.\n\n\u00b7 RESET ONLY ALL COUNTERS: Reset of the receive and transmit counter.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\nInteger\n\nThe error code of the function.\n\nPossible values:\n\n\u00b7 0 : successful\n\n\u00b7 < 128 : warning\n\n\n\n\n\nFor detailed error codes, see the Systec manual.\n\n\n\n\n\nExample:\n\nSystec_CAN_ResetCan($CanHandle1, 0, \"RESET FIRMWARE\");\n\n\n\n\n\nSystec_CAN_WriteCanMessage\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Systec_CAN_WriteCanMessage": {
  "prefix": "Systec_CAN_WriteCanMessage",
  "body": [
   "$$ErrorCode=Systec_CAN_WriteCanMessage($$CanHandle,$$Channel,$$Identifier,$$FrameFormat,$$DataToWrite);"
  ],
  "description": "\n\nThis function requires Systec device drivers V3.0 or higher to be installed on the system.\n\nThis function transmits one CAN messages through the specified CAN-channel\n\nof the USB-CANmodul using a specific frame format and identifier.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a Systec USB-CANmodul GW001/GW002.\n\n\u00b7 This function will fail when you use wrong parameter values.\n\n\u00b7 The corresponding error message is displayed when an error or a warning occurs.\n\n\u00b7 For detailed information, read the Systec manual delivered with the software package.\n\n\n\nResult:\n\n$ErrorCode = Systec_CAN_WriteCanMessage($CanHandle, $Channel, $Identifier, $FrameFormat, $DataToWrite);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$CanHandle\n\nObject\n\nThe USB-CANmodul handle returned with the function Systec_CAN_InitHardware.\n\n\n\n$Channel\n\nInteger\n\nCAN-channel, which is to write data.\n\nPossible values:\n\n\u00b7 0: channel 0\n\n\u00b7 1: channel 1\n\n\u00b7 255: any available channel\n\n\n\n$Identifier\n\nString\n\nThe CAN identifier.\n\nExample:\n\n\"0x601\"\n\n\n\n$FrameFormat\n\nString\n\nThe CAN frame format.\n\nPossible values:\n\n\u00b7 CAN 2.0A MESSAGE: CAN2.0A message with 11-bit CANID\n\n\u00b7 CAN 2.0B MESSAGE: CAN2.0B message with 29-bit CAN-ID\n\n\u00b7 REMOTE FRAME: CAN Remote Frame\n\n\u00b7 TRANSMIT ECHO: transmit echo.\n\n\n\n$DataToWrite\n\nString\n\nHEX data to write to the CAN bus. The data can be seperated with a space, a dash and a comma. The prefix 0x can be used or not.\n\nExample:\n\n\u00b7 \"0x23,0xff - 0x5f , 0x00 0x00 0x00 0x00 0x00\"\n\n\u00b7 \"0x23 0xff 0x5f 0x00 0x00 0x00 0x00 0x00\"\n\n\u00b7 \"23 ff 5f 00 00 00 00 00\"\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ErrorCode\n\nInteger\n\nThe error code of the function.\n\nPossible values:\n\n\u00b7 0 : successful\n\n\u00b7 < 128 : warning\n\n\n\n\n\nFor detailed error codes, see the Systec manual.\n\n\n\n\n\nExample:\n\n$ErrorCode = Systec_CAN_WriteCanMessage($CanHandle, 0, \"0x601\", \"CAN 2.0A MESSAGE\", \"0x23,0xff - 0x5f , 0x00 0x00 0x00 0x00 0x00\");\n\n\n\n\n\nOneWire_Close\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OneWire_Close($OneWireAdapter);TheOneWire_xxxfunctionssupportawidearrayofOneWire\u2122ProtocoladaptersdistributedbyMaxim": {
  "prefix": "OneWire_Close($OneWireAdapter);TheOneWire_xxxfunctionssupportawidearrayofOneWire\u2122ProtocoladaptersdistributedbyMaxim",
  "body": [
   "OneWire_Close($$OneWireAdapter);TheOneWire_xxxfunctionssupportawidearrayofOneWire\u2122ProtocoladaptersdistributedbyMaxim(formallyDallasSemiconductor)FormoreinformationseetheMaximwebsiteathttp://www.maxim-ic.com/.Remarks:\u00b7Inordertousethisfunctionlibrary,youmusthavetheMicrosoft.NetJ#RuntimeinstalledwhichisusedbytheOneWire.Net.API"
  ],
  "description": "\n\nThis function closes the OneWire protocol adapter and releases any used resources.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$OneWireAdapter\n\nObject\n\nThe instance of the initialized OneWire adapter\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nOneWire_ComputeCRC8\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OneWire_ComputeCRC8($ByteString);TheOneWire_xxxfunctionssupportawidearrayofOneWire\u2122ProtocoladaptersdistributedbyMaxim": {
  "prefix": "OneWire_ComputeCRC8($ByteString);TheOneWire_xxxfunctionssupportawidearrayofOneWire\u2122ProtocoladaptersdistributedbyMaxim",
  "body": [
   "$$Checksum=OneWire_ComputeCRC8($$ByteString);TheOneWire_xxxfunctionssupportawidearrayofOneWire\u2122ProtocoladaptersdistributedbyMaxim(formallyDallasSemiconductor)FormoreinformationseetheMaximwebsiteathttp://www.maxim-ic.com/.Remarks:\u00b7Inordertousethisfunctionlibrary,youmusthavetheMicrosoft.NetJ#RuntimeinstalledwhichisusedbytheOneWire.Net.API"
  ],
  "description": "\n\nThis function takes a supplied byte string in \"xx xx xx xx \" format and computes the 1 byte checksum. (Note: The string must end in a whitespace character to signify the end of the string)\n\nExample:.\n\n$Checksum = OneWire_ComputeCRC8(\"A0 DA 0C 00 02 F1\");\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ByteString\n\nString\n\nA string in the format specified above\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Checksum\n\nString\n\nA two digit hexidecimal string indicating the checksum value of the supplied string.\n\n\n\n\n\nOneWire_CreateNewFile\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OneWire_CreateNewFile($Adapter,$Container,$FilePathAndName,$FileMode,$FileData);TheOneWire_xxxfunctionssupportawidearrayofOneWire\u2122ProtocoladaptersdistributedbyMaxim": {
  "prefix": "OneWire_CreateNewFile($Adapter,$Container,$FilePathAndName,$FileMode,$FileData);TheOneWire_xxxfunctionssupportawidearrayofOneWire\u2122ProtocoladaptersdistributedbyMaxim",
  "body": [
   "OneWire_CreateNewFile($$Adapter,$$Container,$$FilePathAndName,$$FileMode,$$FileData);TheOneWire_xxxfunctionssupportawidearrayofOneWire\u2122ProtocoladaptersdistributedbyMaxim(formallyDallasSemiconductor)FormoreinformationseetheMaximwebsiteathttp://www.maxim-ic.com/."
  ],
  "description": "\n\n\n\n\n\nThis function can be used to create a new file on a Dallas Semiconductor One Wire memory device. This function can be used with any One Wire device which supports a psuedo-file system such as EEPROM, EPROM, or any unpaged, or paged memory devices.\n\n\n\n\n\n\u00b7 The filename must be a maximum of 4 characters in length, with a 3 character file extension.\n\n\u00b7 There are two modes for writing data to the file, 'HEX' and 'ASCII'. If the parameter is specified as hex, the $FileData parameter is first passed through a conversion routine to translate the text to an array of bytes before writing it to the device. If the parameter is specified as ASCII, the data is written unchanged to the device.\n\n\n\n\n\nIf the function fails to create the new file on the device for any reason, a test failure is returned back to the test executive.\n\n\n\n\n\nRemarks:\n\n\u00b7 In order to use this function library, you must have the Microsoft .Net J# Runtime installed which is used by the OneWire.Net. API\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Adapter\n\nObject\n\nAn instance of the One-Wire Adapter returned from the OneWire_Init function\n\n\n\n$Container\n\nObject\n\nThe OneWireDeviceContainer returned from the OneWire_GetDeviceContainer function.\n\n\n\n$DirectoryPathAndName\n\nString\n\nThe directory path and file name for the file to be created.\n\n\n\n$FileMode\n\nString\n\nThe filemode to use when writing to the device. The supported options are:\n\n\u00b7 \"HEX\" - The string is converted to an array of bytes before being written to the device. The string must contain only valid hexidecimal characters (0-0, A-F)\n\n\u00b7 \"ASCII\" - The string is written to the device 'As Is' by converting each string character to it's equivalent ascii encoding.\n\n\n\n$FileData\n\nString\n\nA string containing the hex or ASCII data to write to the file\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample Code:\n\n\n\n\n\n$OneWireAdapter = OneWire_Init(\"\",\"\");\n\nSetFinalizeFunction(\"Cleanup\");\n\n($DeviceCount,$Addresses) = OneWire_FindAllDevices($OneWireAdapter);\n\n$Address = StringReplace($Addresses,\";\",\"\");\n\nUpdateStatus($Address);\n\n$Container = OneWire_GetDeviceContainer($OneWireAdapter,$Address);\n\nUpdateStatus($Container);\n\nOneWire_FormatDevice($OneWireAdapter,$Container);\n\n($FileCount,$FileArray) = OneWire_ReadDirectory($OneWireAdapter,$Container,\"\");\n\nUpdateStatus($FileCount);\n\nOneWire_CreateNewFile($OneWireAdapter,$Container,\"0000.000\",\"ASCII\",\"TEST DATA TO WRITE TO CHIP\");\n\n\n\n\n\nEnd;\n\n\n\n\n\nfunction Cleanup()\n\n{\n\nOneWire_Close($OneWireAdapter);\n\nEnd;\n\n}\n\n\n\n\n\nOneWire_FindAllDevices\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OneWire_FindAllDevices($Adapter);TheOneWire_xxxfunctionssupportawidearrayofOneWire\u2122ProtocoladaptersdistributedbyMaxim": {
  "prefix": "OneWire_FindAllDevices($Adapter);TheOneWire_xxxfunctionssupportawidearrayofOneWire\u2122ProtocoladaptersdistributedbyMaxim",
  "body": [
   "($$DeviceCount,$$Addresses)=OneWire_FindAllDevices($$Adapter);TheOneWire_xxxfunctionssupportawidearrayofOneWire\u2122ProtocoladaptersdistributedbyMaxim(formallyDallasSemiconductor)FormoreinformationseetheMaximwebsiteathttp://www.maxim-ic.com/."
  ],
  "description": "\n\n\n\n\n\nThis function queries the OneWire device bus and enumerates all OneWire devices on the network. The function returns the number of devices found, and also a single string containing the address of all the devices on the bus in a semi-colon delimited list.\n\n\n\nRemarks:\n\n\u00b7 In order to use this function library, you must have the Microsoft .Net J# Runtime installed which is used by the OneWire.Net. API\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Adapter\n\nObject\n\nAn instance of the One-Wire Adapter returned from the OneWire_Init function\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$DeviceCount\n\nInteger\n\nThe number of one wire devices found on the network connected to the OneWire communication adapter.\n\n\n\n$Addresses\n\nString\n\nA Semi-colon delimited list of all the addresses of the One-Wire devices found on the current One-Wire bus.\n\n\n\n\n\nOneWire_FormatDevice\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OneWire_FormatDevice($Adapter,$Container);TheOneWire_xxxfunctionssupportawidearrayofOneWire\u2122ProtocoladaptersdistributedbyMaxim": {
  "prefix": "OneWire_FormatDevice($Adapter,$Container);TheOneWire_xxxfunctionssupportawidearrayofOneWire\u2122ProtocoladaptersdistributedbyMaxim",
  "body": [
   "OneWire_FormatDevice($$Adapter,$$Container);TheOneWire_xxxfunctionssupportawidearrayofOneWire\u2122ProtocoladaptersdistributedbyMaxim(formallyDallasSemiconductor)FormoreinformationseetheMaximwebsiteathttp://www.maxim-ic.com/."
  ],
  "description": "\n\n\n\n\n\nThis function formats the file system for a specific device on the Dallas Semiconductor One-Wire Network. This function can be used with any One Wire device which supports a psuedo-file system such as EEPROM, EPROM, or any unpaged, or paged memory devices.\n\nIf the device being used is a 'Write Once' device, it can still be formatted multiple times, however each additional format consumes unused space in the device memory.\n\n\n\nRemarks:\n\n\u00b7 In order to use this function library, you must have the Microsoft .Net J# Runtime installed which is used by the OneWire.Net. API\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Adapter\n\nObject\n\nAn instance of the One-Wire Adapter returned from the OneWire_Init function\n\n\n\n$Container\n\nObject\n\nThe OneWireDeviceContainer returned from the OneWire_GetDeviceContainer function.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample Code:\n\n\n\n\n\n$OneWireAdapter = OneWire_Init(\"\",\"\");\n\nSetFinalizeFunction(\"Cleanup\");\n\n($DeviceCount,$Addresses) = OneWire_FindAllDevices($OneWireAdapter);\n\n$Address = StringReplace($Addresses,\";\",\"\");\n\nUpdateStatus($Address);\n\n$Container = OneWire_GetDeviceContainer($OneWireAdapter,$Address);\n\nUpdateStatus($Container);\n\nOneWire_FormatDevice($OneWireAdapter,$Container);\n\n($FileCount,$FileArray) = OneWire_ReadDirectory($OneWireAdapter,$Container,\"\");\n\nUpdateStatus($FileCount);\n\nOneWire_CreateNewFile($OneWireAdapter,$Container,\"0000.000\",\"ASCII\",\"TEST DATA TO WRITE TO CHIP\");\n\n\n\n\n\nEnd;\n\n\n\n\n\nfunction Cleanup()\n\n{\n\nOneWire_Close($OneWireAdapter);\n\nEnd;\n\n}\n\n\n\n\n\nOneWire_GetDeviceContainer\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OneWire_GetDeviceContainer($Adapter,$DeviceAddress);TheOneWire_xxxfunctionssupportawidearrayofOneWire\u2122ProtocoladaptersdistributedbyMaxim": {
  "prefix": "OneWire_GetDeviceContainer($Adapter,$DeviceAddress);TheOneWire_xxxfunctionssupportawidearrayofOneWire\u2122ProtocoladaptersdistributedbyMaxim",
  "body": [
   "$$Container=OneWire_GetDeviceContainer($$Adapter,$$DeviceAddress);TheOneWire_xxxfunctionssupportawidearrayofOneWire\u2122ProtocoladaptersdistributedbyMaxim(formallyDallasSemiconductor)FormoreinformationseetheMaximwebsiteathttp://www.maxim-ic.com/."
  ],
  "description": "\n\n\n\n\n\nThis function returns a handle for a specific device on the Dallas Semiconductor One-Wire Network that can be passed to other functions for specific actions. The device is specified by it's address which can be obtained by the OneWire_FindAllDevices function. If the device is not found, the function returns a failing test result.\n\n\n\nRemarks:\n\n\u00b7 In order to use this function library, you must have the Microsoft .Net J# Runtime installed which is used by the OneWire.Net. API\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Adapter\n\nObject\n\nAn instance of the One-Wire Adapter returned from the OneWire_Init function\n\n\n\n$DeviceAddress\n\nString\n\nThe address of the OneWire Device\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Container\n\nObject\n\nA handle to the device container specified by the address string.\n\n\n\n\n\nExample Code:\n\n\n\n\n\n$OneWireAdapter = OneWire_Init(\"\",\"\");\n\nSetFinalizeFunction(\"Cleanup\");\n\n($DeviceCount,$Addresses) = OneWire_FindAllDevices($OneWireAdapter);\n\n$Address = StringReplace($Addresses,\";\",\"\");\n\nUpdateStatus($Address);\n\n$Container = OneWire_GetDeviceContainer($OneWireAdapter,$Address);\n\nUpdateStatus($Container);\n\nOneWire_FormatDevice($OneWireAdapter,$Container);\n\n($FileCount,$FileArray) = OneWire_ReadDirectory($OneWireAdapter,$Container,\"\");\n\nUpdateStatus($FileCount);\n\nOneWire_CreateNewFile($OneWireAdapter,$Container,\"0000.000\",\"ASCII\",\"TEST DATA TO WRITE TO CHIP\");\n\n\n\n\n\nEnd;\n\n\n\n\n\nfunction Cleanup()\n\n{\n\nOneWire_Close($OneWireAdapter);\n\nEnd;\n\n}\n\n\n\n\n\nOneWire_GetFreeMemorySpace\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OneWire_GetFreeMemorySpace($Adapter,$Container);TheOneWire_xxxfunctionssupportawidearrayofOneWire\u2122ProtocoladaptersdistributedbyMaxim": {
  "prefix": "OneWire_GetFreeMemorySpace($Adapter,$Container);TheOneWire_xxxfunctionssupportawidearrayofOneWire\u2122ProtocoladaptersdistributedbyMaxim",
  "body": [
   "$$FreeSpace=OneWire_GetFreeMemorySpace($$Adapter,$$Container);TheOneWire_xxxfunctionssupportawidearrayofOneWire\u2122ProtocoladaptersdistributedbyMaxim(formallyDallasSemiconductor)FormoreinformationseetheMaximwebsiteathttp://www.maxim-ic.com/."
  ],
  "description": "\n\n\n\n\n\nThis function returns the number of unused bytes available on the One-Wire Storage device. This function can be used with any One Wire device which supports a psuedo-file system such as EEPROM, EPROM, or any unpaged, or paged memory devices.\n\n\n\n\n\nNote: On any 'Write-Once' device, the available storage is not recovered after the device is formatted, only the inodes on the file system are rewritten to create the appearance of a blank storage device.\n\n\n\n\n\nRemarks:\n\n\u00b7 In order to use this function library, you must have the Microsoft .Net J# Runtime installed which is used by the OneWire.Net. API\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Adapter\n\nObject\n\nAn instance of the One-Wire Adapter returned from the OneWire_Init function\n\n\n\n$Container\n\nObject\n\nThe OneWireDeviceContainer returned from the OneWire_GetDeviceContainer function.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$FreeSpace\n\nInteger\n\nThe number of unused bytes available on the OneWire memory/storage device.\n\n\n\n\n\nExample Code:\n\n$OneWireAdapter = OneWire_Init(\"\",\"\");\n\nSetFinalizeFunction(\"Cleanup\");\n\n($DeviceCount,$Addresses) = OneWire_FindAllDevices($OneWireAdapter);\n\n$Address = StringReplace($Addresses,\";\",\"\");\n\nUpdateStatus($Address);\n\n$Container = OneWire_GetDeviceContainer($OneWireAdapter,$Address);\n\nUpdateStatus($Container);\n\nOneWire_FormatDevice($OneWireAdapter,$Container);\n\n($FileCount,$FileArray) = OneWire_ReadDirectory($OneWireAdapter,$Container,\"\");\n\nUpdateStatus($FileCount);\n\nOneWire_CreateNewFile($OneWireAdapter,$Container,\"0000.000\",\"ASCII\",\"Hello Word!\");\n\n$contents = OneWire_ReadFileAsString($OneWireAdapter,$Container,\"0000.000\");\n\n$FreeSpace = OneWire_GetFreeMemorySpace($OneWireAdapter,$Container);\n\nUpdateStatus($FreeSpace);\n\n\n\n\n\nEnd;\n\n\n\n\n\nfunction Cleanup()\n\n{\n\nOneWire_Close($OneWireAdapter);\n\nEnd;\n\n}\n\n\n\n\n\nOneWireInit\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OneWire_Init($AdapterName,$AdapterPort);TheOneWire_xxxfunctionssupportawidearrayofOneWire\u2122ProtocoladaptersdistributedbyMaxim": {
  "prefix": "OneWire_Init($AdapterName,$AdapterPort);TheOneWire_xxxfunctionssupportawidearrayofOneWire\u2122ProtocoladaptersdistributedbyMaxim",
  "body": [
   "$$OneWireAdapter=OneWire_Init($$AdapterName,$$AdapterPort);TheOneWire_xxxfunctionssupportawidearrayofOneWire\u2122ProtocoladaptersdistributedbyMaxim(formallyDallasSemiconductor)FormoreinformationseetheMaximwebsiteathttp://www.maxim-ic.com/.Remarks:\u00b7Inordertousethisfunctionlibrary,youmusthavetheMicrosoft.NetJ#RuntimeinstalledwhichisusedbytheOneWire.Net.API"
  ],
  "description": "\n\nThis function opens the OneWire protocol adapter according to the supplied AdapterName and AdapterPort. For full documentation concerning these two parameters refer to the OneWire API programmers interface. This function supports all three family of adapters, including Serial, Parallel, and USB protocol adapters.\n\nExamples:\n\n$OneWireAdapter = OneWire_Init(\"{DS9097U}\",\"COM1\");\n\n$OneWireAdapter = OneWire_Init(\"{DS1490}\",\"USB0\");\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AdapterName\n\nString\n\nThe string specifying the adapter to use for communicating with the OneWire network\n\n\n\n$AdapterPort\n\nString\n\nThe string specifying the port on which the adapter is connected. This can be a string identifier for Parrallel (LPTx), Serial (COMx), or USB (USBx).\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$OneWireAdapter\n\nObject\n\nAn instance of the opened OneWire adapter object.\n\n\n\n\n\nOneWireReadBytes\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OneWire_ReadBytes($OneWireAdapter,$NumBytesToRead);TheOneWire_xxxfunctionssupportawidearrayofOneWire\u2122ProtocoladaptersdistributedbyMaxim": {
  "prefix": "OneWire_ReadBytes($OneWireAdapter,$NumBytesToRead);TheOneWire_xxxfunctionssupportawidearrayofOneWire\u2122ProtocoladaptersdistributedbyMaxim",
  "body": [
   "$$Bytes=OneWire_ReadBytes($$OneWireAdapter,$$NumBytesToRead);TheOneWire_xxxfunctionssupportawidearrayofOneWire\u2122ProtocoladaptersdistributedbyMaxim(formallyDallasSemiconductor)FormoreinformationseetheMaximwebsiteathttp://www.maxim-ic.com/.Remarks:\u00b7Inordertousethisfunctionlibrary,youmusthavetheMicrosoft.NetJ#RuntimeinstalledwhichisusedbytheOneWire.Net.API"
  ],
  "description": "\n\nThis function reads the specified number of bytes from the onewire network.\n\nExamples:\n\n$Bytes = OneWire_ReadBytes($OneWireAdapter,10);\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$OneWireAdapter\n\nObject\n\nAn instance of the opened OneWire adapter object.\n\n\n\n$NumBytesToRead\n\nInteger\n\nThe number of bytes to read from the OneWire network.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Bytes\n\nString\n\nThe returned Byte String\n\n\n\n\n\nOneWire_ReadDirectory\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OneWire_ReadDirectory($Adapter,$Container,$DirectoryPath);TheOneWire_xxxfunctionssupportawidearrayofOneWire\u2122ProtocoladaptersdistributedbyMaxim": {
  "prefix": "OneWire_ReadDirectory($Adapter,$Container,$DirectoryPath);TheOneWire_xxxfunctionssupportawidearrayofOneWire\u2122ProtocoladaptersdistributedbyMaxim",
  "body": [
   "($$FileCount,$$FileArray)=OneWire_ReadDirectory($$Adapter,$$Container,$$DirectoryPath);TheOneWire_xxxfunctionssupportawidearrayofOneWire\u2122ProtocoladaptersdistributedbyMaxim(formallyDallasSemiconductor)FormoreinformationseetheMaximwebsiteathttp://www.maxim-ic.com/."
  ],
  "description": "\n\n\n\n\n\nThis function reads the contents of a directory of the file system for a specific device on the Dallas Semiconductor One-Wire Network. This function can be used with any One Wire device which supports a psuedo-file system such as EEPROM, EPROM, or any unpaged, or paged memory devices.\n\n\n\n\n\nYou can read the root node of a device by specifying a blank string for the $DirectoryPath argument.\n\n\n\nRemarks:\n\n\u00b7 In order to use this function library, you must have the Microsoft .Net J# Runtime installed which is used by the OneWire.Net. API\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Adapter\n\nObject\n\nAn instance of the One-Wire Adapter returned from the OneWire_Init function\n\n\n\n$Container\n\nObject\n\nThe OneWireDeviceContainer returned from the OneWire_GetDeviceContainer function.\n\n\n\n$DirectoryPath\n\nString\n\nThe directory path on the device. If the directory is not found, a failure is generated for this test step.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$FileCount\n\nInteger\n\nThe number of files or sub-directories contained in the specified directory\n\n\n\n$FileArray\n\nArray\n\nAn array of the file and directory names contained in the directory.\n\n\n\n\n\nExample Code:\n\n\n\n\n\n$OneWireAdapter = OneWire_Init(\"\",\"\");\n\nSetFinalizeFunction(\"Cleanup\");\n\n($DeviceCount,$Addresses) = OneWire_FindAllDevices($OneWireAdapter);\n\n$Address = StringReplace($Addresses,\";\",\"\");\n\nUpdateStatus($Address);\n\n$Container = OneWire_GetDeviceContainer($OneWireAdapter,$Address);\n\nUpdateStatus($Container);\n\nOneWire_FormatDevice($OneWireAdapter,$Container);\n\n($FileCount,$FileArray) = OneWire_ReadDirectory($OneWireAdapter,$Container,\"\");\n\nUpdateStatus($FileCount);\n\nOneWire_CreateNewFile($OneWireAdapter,$Container,\"0000.000\",\"ASCII\",\"TEST DATA TO WRITE TO CHIP\");\n\n\n\n\n\nEnd;\n\n\n\n\n\nfunction Cleanup()\n\n{\n\nOneWire_Close($OneWireAdapter);\n\nEnd;\n\n}\n\n\n\n\n\nOneWire_ReadFileAsString\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OneWire_ReadFileAsString($Adapter,$Container,$FileName);TheOneWire_xxxfunctionssupportawidearrayofOneWire\u2122ProtocoladaptersdistributedbyMaxim": {
  "prefix": "OneWire_ReadFileAsString($Adapter,$Container,$FileName);TheOneWire_xxxfunctionssupportawidearrayofOneWire\u2122ProtocoladaptersdistributedbyMaxim",
  "body": [
   "$$FileContents=OneWire_ReadFileAsString($$Adapter,$$Container,$$FileName);TheOneWire_xxxfunctionssupportawidearrayofOneWire\u2122ProtocoladaptersdistributedbyMaxim(formallyDallasSemiconductor)FormoreinformationseetheMaximwebsiteathttp://www.maxim-ic.com/."
  ],
  "description": "\n\n\n\n\n\nThis function reads an ASCII file that has been created on the Maxim One-Wire memory storage device. This function can be used with any One Wire device which supports a psuedo-file system such as EEPROM, EPROM, or any unpaged, or paged memory devices.\n\n\n\n\n\n\u00b7 This function should generally be used to only read the contents from ASCII files which are stored on the device.\n\n\u00b7 The entire ASCII contents of the specified file are returned as a single string.\n\n\n\nRemarks:\n\n\u00b7 In order to use this function library, you must have the Microsoft .Net J# Runtime installed which is used by the OneWire.Net. API\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Adapter\n\nObject\n\nAn instance of the One-Wire Adapter returned from the OneWire_Init function\n\n\n\n$Container\n\nObject\n\nThe OneWireDeviceContainer returned from the OneWire_GetDeviceContainer function.\n\n\n\n$FileName\n\nString\n\nThe filename and path of the ASCII text file to be read from the storage device.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$FileContents\n\nString\n\nThe ASCII contents of the file specified by the $FileName parameter\n\n\n\n\n\nExample Code:\n\n$OneWireAdapter = OneWire_Init(\"\",\"\");\n\nSetFinalizeFunction(\"Cleanup\");\n\n($DeviceCount,$Addresses) = OneWire_FindAllDevices($OneWireAdapter);\n\n$Address = StringReplace($Addresses,\";\",\"\");\n\nUpdateStatus($Address);\n\n$Container = OneWire_GetDeviceContainer($OneWireAdapter,$Address);\n\nUpdateStatus($Container);\n\nOneWire_FormatDevice($OneWireAdapter,$Container);\n\n($FileCount,$FileArray) = OneWire_ReadDirectory($OneWireAdapter,$Container,\"\");\n\nUpdateStatus($FileCount);\n\nOneWire_CreateNewFile($OneWireAdapter,$Container,\"0000.000\",\"ASCII\",\"Hello Word!\");\n\n$contents = OneWire_ReadFileAsString($OneWireAdapter,$Container,\"0000.000\");\n\n$FreeSpace = OneWire_GetFreeMemorySpace($OneWireAdapter,$Container);\n\nUpdateStatus($FreeSpace);\n\n\n\n\n\nEnd;\n\n\n\n\n\nfunction Cleanup()\n\n{\n\nOneWire_Close($OneWireAdapter);\n\nEnd;\n\n}\n\n\n\n\n\nOneWire_Reset\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OneWire_Reset($OneWireAdapter);TheOneWire_xxxfunctionssupportawidearrayofOneWire\u2122ProtocoladaptersdistributedbyMaxim": {
  "prefix": "OneWire_Reset($OneWireAdapter);TheOneWire_xxxfunctionssupportawidearrayofOneWire\u2122ProtocoladaptersdistributedbyMaxim",
  "body": [
   "OneWire_Reset($$OneWireAdapter);TheOneWire_xxxfunctionssupportawidearrayofOneWire\u2122ProtocoladaptersdistributedbyMaxim(formallyDallasSemiconductor)FormoreinformationseetheMaximwebsiteathttp://www.maxim-ic.com/.Remarks:\u00b7Inordertousethisfunctionlibrary,youmusthavetheMicrosoft.NetJ#RuntimeinstalledwhichisusedbytheOneWire.Net.API"
  ],
  "description": "\n\nSends a reset on the one-wire network.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$OneWireAdapter\n\nObject\n\nAn instance of the opened OneWire adapter object.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nOneWireSendBytes\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OneWire_SendBytes($OneWireAdapter,$ByteString);TheOneWire_xxxfunctionssupportawidearrayofOneWire\u2122ProtocoladaptersdistributedbyMaxim": {
  "prefix": "OneWire_SendBytes($OneWireAdapter,$ByteString);TheOneWire_xxxfunctionssupportawidearrayofOneWire\u2122ProtocoladaptersdistributedbyMaxim",
  "body": [
   "OneWire_SendBytes($$OneWireAdapter,$$ByteString);TheOneWire_xxxfunctionssupportawidearrayofOneWire\u2122ProtocoladaptersdistributedbyMaxim(formallyDallasSemiconductor)FormoreinformationseetheMaximwebsiteathttp://www.maxim-ic.com/.Remarks:\u00b7Inordertousethisfunctionlibrary,youmusthavetheMicrosoft.NetJ#RuntimeinstalledwhichisusedbytheOneWire.Net.API"
  ],
  "description": "\n\nThis function sends the supplied byte array out to the one wire network.\n\nExamples:\n\nOneWire_SendBytes($OneWireAdapter,\"FF 00 FF 12 AE\");\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$OneWireAdapter\n\nObject\n\nAn instance of the opened OneWire adapter object.\n\n\n\n$ByteString\n\nString\n\nThe string specifying the bytes to send to the network. The bytes should be supplied in hexadecimal format separated by whitespace.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nGPIB_Clear\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS GPIB_Clear": {
  "prefix": "GPIB_Clear",
  "body": [
   "GPIB_Clear($$GPIBInstance);"
  ],
  "description": "\n\nThis function sends either an SDC (Selected Device Clear) or DCL (Device Clear) command to the specified instrument on the GPIB bus. This can be used to clear communication or instrument errors. It may be useful in some circumstances to add this command immediately after opening an instrument.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$GPIBInstance\n\nObject\n\nThe object representing the instance of the GPIB Instrument.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nUsage Example:\n\n\n\n\n\nGPIB_Clear($Handle);\n\n\n\n\n\nGPIB_Close\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS GPIB_Close": {
  "prefix": "GPIB_Close",
  "body": [
   "GPIB_Close($$GPIBInstance);"
  ],
  "description": "\n\nThis function uses the Agilent IO Libraries, in order to use these universal GPIB functions in JabilTest, you need to have the Agilent IO Libraries installed.\n\nThis function closes the GPIB object and attempts to recover used resources. It does not reset the unit or change it's existing settings. This function returns a passing result if the object exists, otherwise a failure is generated by the script function.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$GPIBInstance\n\nObject\n\nThe object representing the instance of the GPIB Instrument.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nGPIB.Open\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS GPIB_Open": {
  "prefix": "GPIB_Open",
  "body": [
   "$$GPIBInstance=GPIB_Open($$ResourceString);"
  ],
  "description": "\n\nThis function uses the Agilent IO Libraries, in order to use these universal GPIB functions in JabilTest, you need to have the Agilent IO Libraries installed.\n\nThis function returns a generic object referencing the GPIB device at the given resource string identifier. Since this command is meant to be universal, no device specific initialization is performed.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ResourceString\n\nString\n\nThe resource string identifying the instrument. For example, \"GPIB0::9::Instr\".\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$GPIBInstance\n\nObject\n\nThe object representing the instance of the GPIB Instrument.\n\n\n\n\n\nGPIB_OpenBool\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS GPIB_OpenBool": {
  "prefix": "GPIB_OpenBool",
  "body": [
   "($$GPIBHandle,$$success)=GPIB_OpenBool($$resourceString);"
  ],
  "description": "\n\nThis function returns a generic object referencing the GPIB device at the given resource string identifier. Since this command is meant to be universal, no device specific initialization is performed. This function also returns a boolean to indicate whether the GPIB device was successfully connected to.\n\n\n\n\n\nNotes:\n\nThis function uses the Agilent IO Libraries, in order to use these universal GPIB functions in Jabil Test, you need to have the Agilent IO Libraries installed.\n\nIf the GPIB device is not successfully connected to, this function will not fail, but will return a FALSE in the success boolean.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$resourceString\n\nString\n\nThe resource string identifying the instrument. For example, \"GPIB0::9::Instr\".\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$GPIBHandle\n\nObject\n\nThe object representing the instance of the GPIB instrument.\n\n\n\n$success\n\nBoolean\n\nTrue if the instrument was successfully connected to, False otherwise.\n\n\n\n\n\nUsage Example:\n\n// Connect to the instrument.\n\nLabel InstrConnect:\n\n\n\n\n\n($GPIBHandle, $success) = GPIB_OpenBool(\"GPIB0::11::Instr\");\n\n\n\n\n\nif (!$success)\n\n{\n\n// Did not connect, wait 1 second and try again.\n\nSleep(1);\n\ngoto InstrConnect;\n\n}\n\n\n\n\n\nGPIB_Read\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS GPIB_Read": {
  "prefix": "GPIB_Read",
  "body": [
   "$$Reading=GPIB_Read($$GPIBInstance);"
  ],
  "description": "\n\nThis function uses the Agilent IO Libraries, in order to use these universal GPIB functions in JabilTest, you need to have the Agilent IO Libraries installed.\n\nThis function returns a string containing the measurement result of a GPIB device. In general, this command will always be proceeded by a GPIB.Write. Reading from a device with an empty buffer will cause unpredictable result depending on the device.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$GPIBInstance\n\nObject\n\nThe object representing the instance of the GPIB Instrument.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Reading\n\nString\n\nThe reading currently waiting in the GPIB buffer.\n\n\n\n\n\nGPIB_Write\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS GPIB_Write": {
  "prefix": "GPIB_Write",
  "body": [
   "GPIB_Write($$GPIBInstance,$$CommandString);"
  ],
  "description": "\n\nThis function uses the Agilent IO Libraries, in order to use these universal GPIB functions in JabilTest, you need to have the Agilent IO Libraries installed.\n\nThis function writes a command string to a given GPIB instrument object. Refer to programming documentation for your device for proper command syntax as this command will not detect the failure of a given GPIB command. A failure will occur if the command cannot be delivered.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$GPIBInstance\n\nObject\n\nThe object representing the instance of the GPIB Instrument.\n\n\n\n$CommandString\n\nString\n\nThe command written to the GPIB device.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nIviGPIB_Clear\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS IviGPIB_Clear": {
  "prefix": "IviGPIB_Clear",
  "body": [
   "IviGPIB_Clear($$GpibHandle);"
  ],
  "description": "\n\nThis function sends a Clear command to the instrument.\n\n\n\nRemarks:\n\n\u00b7 This function requires the IVI Foundation VISA drivers. Both the IVI Shared Components and the VISA Shared Components.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$GpibHandle\n\nObject\n\nThe GPIB resource handle opened with the IviGPIB_Open or IviGPIB_OpenBool function.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n// Connect to the instrument.\n\n$resourceString = \"GPIB::11::INSTR\";\n\n$timeOut = 2000; // Time out = 2 seconds.\n\n$gpib = IviGPIB_Open($resourceString, $timeOut);\n\n\n\n\n\nIviGPIB_Clear($gpib);\n\n\n\n\n\nIviGPIB_Close\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS IviGPIB_Close": {
  "prefix": "IviGPIB_Close",
  "body": [
   "IviGPIB_Close($$GpibHandle);"
  ],
  "description": "\n\nThis function closes communication with the instrument.\n\n\n\nRemarks:\n\n\u00b7 This function requires the IVI Foundation VISA drivers. Both the IVI Shared Components and the VISA Shared Components.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$GpibHandle\n\nObject\n\nThe GPIB resource handle opened with the IviGPIB_Open or IviGPIB_OpenBool function.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n// Connect to the instrument.\n\n$resourceString = \"GPIB::11::INSTR\";\n\n$timeOut = 2000; // Time out = 2 seconds.\n\n$gpib = IviGPIB_Open($resourceString, $timeOut);\n\n\n\n\n\n// Other functions to work with the instrument.\n\n\n\n\n\nIviGPIB_Close($gpib);\n\n\n\n\n\nIviGPIB_Open\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS IviGPIB_Open": {
  "prefix": "IviGPIB_Open",
  "body": [
   "$$GpibHandle=IviGPIB_Open($$resourceString,$$timeOut);"
  ],
  "description": "\n\nThis function creates a connection to the instrument specified in the resource string.\n\n\n\nRemarks:\n\n\u00b7 This function requires the IVI Foundation VISA drivers. Both the IVI Shared Components and the VISA Shared Components.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$resourceString\n\nString\n\nThe GPIB address of the instrument. Prefix with either GPIB:: or GPIB<busNumber> Followed by the address of the instrument and the instrument designation ::INSTR.\n\n\n\n$timeOut\n\nInteger\n\nThe time out value to use for communicating with the instrument in milliseconds.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$GpibHandle\n\nObject\n\nThe reference to the instrument that will be used in other GPIB functions.\n\n\n\n\n\nExample:\n\n// Connect to the instrument.\n\n$resourceString = \"GPIB::11::INSTR\";\n\n$timeOut = 2000; // Time out = 2 seconds.\n\n$gpib = IviGPIB_Open($resourceString, $timeOut);\n\n\n\n\n\nIviGPIB_OpenBool\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS IviGPIB_OpenBool": {
  "prefix": "IviGPIB_OpenBool",
  "body": [
   "($$GpibHandle,$$success)=IviGPIB_OpenBool($$resourceString,$$timeOut);"
  ],
  "description": "\n\nThis function creates a connection to the instrument specified in the resource string and returns the connection reference and a success boolean.\n\n\n\nRemarks:\n\n\u00b7 This function requires the IVI Foundation VISA drivers. Both the IVI Shared Components and the VISA Shared Components.\n\n\u00b7 This function will not Fail a test.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$resourceString\n\nString\n\nThe GPIB address of the instrument. Prefix with either GPIB:: or GPIB<busNumber> Followed by the address of the instrument and the instrument designation ::INSTR.\n\n\n\n$timeOut\n\nInteger\n\nThe time out value to use for communicating with the instrument in milliseconds.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$GpibHandle\n\nObject\n\nThe reference to the instrument that will be used in other GPIB functions.\n\n\n\n$success\n\nBoolean\n\nA status boolean indicating whether the connection succeeded.\n\n\n\n\n\nExample:\n\n// Connect to the instrument.\n\n$resourceString = \"GPIB::11::INSTR\";\n\n$timeOut = 2000; // Time out = 2 seconds.\n\n($gpib, $success) = IviGPIB_OpenBool($resourceString, $timeOut);\n\n\n\n\n\nIviGPIB_Read\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS IviGPIB_Read": {
  "prefix": "IviGPIB_Read",
  "body": [
   "$$inString=IviGPIB_Read($$GpibHandle);"
  ],
  "description": "\n\nThis function reads a string from the instrument up to a termination character.\n\n\n\nRemarks:\n\n\u00b7 This function requires the IVI Foundation VISA drivers. Both the IVI Shared Components and the VISA Shared Components.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$GpibHandle\n\nObject\n\nThe GPIB resource handle opened with the IviGPIB_Open or IviGPIB_OpenBool function.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$inString\n\nString\n\nThe string read back from the instrument.\n\n\n\n\n\nExample:\n\n// Connect to the instrument.\n\n$resourceString = \"GPIB::11::INSTR\";\n\n$timeOut = 2000; // Time out = 2 seconds.\n\n$gpib = IviGPIB_Open($resourceString, $timeOut);\n\n\n\n\n\n$inString = IviGPIB_Read($gpib);\n\n\n\n\n\n$outStr = \"The instrument responded: \" + $inString;\n\nUpdateStatus($outStr);\n\n\n\n\n\nIviGPIB_ReadBool\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS IviGPIB_ReadBool": {
  "prefix": "IviGPIB_ReadBool",
  "body": [
   "($$inString,$$success)=IviGPIB_ReadBool($$GpibHandle);"
  ],
  "description": "\n\nThis function reads a string from the instrument up to a termination character and also returns a boolean indicating whether the read was successful.\n\n\n\nRemarks:\n\n\u00b7 This function requires the IVI Foundation VISA drivers. Both the IVI Shared Components and the VISA Shared Components.\n\n\u00b7 This function will not fail a test.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$GpibHandle\n\nObject\n\nThe GPIB resource handle opened with the IviGPIB_Open or IviGPIB_OpenBool function.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$inString\n\nString\n\nThe string read back from the instrument.\n\n\n\n$success\n\nBoolean\n\nA status boolean indicating whether the read was successful.\n\n\n\n\n\nExample:\n\n// Connect to the instrument.\n\n$resourceString = \"GPIB::11::INSTR\";\n\n$timeOut = 2000; // Time out = 2 seconds.\n\n$gpib = IviGPIB_Open($resourceString, $timeOut);\n\n\n\n\n\n($inString, $success) = IviGPIB_ReadBool($gpib);\n\n\n\n\n\n$outStr = \"The instrument responded: \" + $inString;\n\nUpdateStatus($outStr);\n\n\n\n\n\nIviGPIB_Write\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS IviGPIB_Write": {
  "prefix": "IviGPIB_Write",
  "body": [
   "IviGPIB_Write($$GpibHandle,$$outString);"
  ],
  "description": "\n\nThis function writes a string to the instrument.\n\n\n\n\n\nRemarks:\n\n\u00b7 This function requires the IVI Foundation VISA drivers. Both the IVI Shared Components and the VISA Shared Components.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$GpibHandle\n\nObject\n\nThe GPIB resource handle opened with the IviGPIB_Open or IviGPIB_OpenBool function.\n\n\n\n$outString\n\nString\n\nThe string to send to the instrument.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n// Connect to the instrument.\n\n$resourceString = \"GPIB::11::INSTR\";\n\n$timeOut = 2000; // Time out = 2 seconds.\n\n$gpib = IviGPIB_Open($resourceString, $timeOut);\n\n\n\n\n\n$outString = \""
 }
,
 "JTS IviGPIB_WriteBool": {
  "prefix": "IviGPIB_WriteBool",
  "body": [
   "$$success=IviGPIB_WriteBool($$GpibHandle,$$outString);"
  ],
  "description": "\n\nThis function writes a string to the instrument and returns a boolean indicating whether the write was successful.\n\n\n\n\n\nRemarks:\n\n\u00b7 This function requires the IVI Foundation VISA drivers. Both the IVI Shared Components and the VISA Shared Components.\n\n\u00b7 This function will not fail a test.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$GpibHandle\n\nObject\n\nThe GPIB resource handle opened with the IviGPIB_Open or IviGPIB_OpenBool function.\n\n\n\n$outString\n\nString\n\nThe string to send to the instrument.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$success\n\nBoolean\n\nA status boolean indicating whether the write was successful.\n\n\n\n\n\nExample:\n\n// Connect to the instrument.\n\n$resourceString = \"GPIB::11::INSTR\";\n\n$timeOut = 2000; // Time out = 2 seconds.\n\n$gpib = IviGPIB_Open($resourceString, $timeOut);\n\n\n\n\n\n$outString = \""
 }
,
 "JTS HTTP_Request": {
  "prefix": "HTTP_Request",
  "body": [
   "$$returnVar=HTTP_Request($$url,$$userName,$$password,$$domain,$$returnVarType,$$retryCount);"
  ],
  "description": "\n\nThis function accesses the requested URL destination via HTTP and returns either a WebResponse object or a String containing the contents of the web page. If the web page requires authentification credentials, they can be supplied with the $userName, $password, and $domain arguments. In the event that the authentication arguments are left blank, they are ignored. The $returnVariableType determines whether this function should return a reference to the WebResponse object to the script, or if a string containing the HTML contents of the web-page should be returned to the script interpreter.\n\n\n\n\n\nRemarks:\n\nIf the web-page is not reachable, can't be found, or times out, an error is returned.\n\nIn the event that Access is Denied an error is also returned.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$url\n\nString\n\nThe URL of the website to retrieve data from.\n\n\n\n$userName\n\nString\n\nThe user name to supply for authentification credentials. If authentification is not required, this string should be empty.\n\n\n\n$password\n\nString\n\nThe password to supply for authentification credentials. If authentication is not required, this string should be empty.\n\n\n\n$domain\n\nString\n\nThe domain to supply for authentification credentials. If authentification is not required, this string should be empty.\n\n\n\n$returnVarType\n\nString\n\nThe type of variable that should be returned to the script. Valid entries are: \"String\"\n\n\"WebResponse\"\n\n\"None\"\n\n\n\n\n\n$retryCount\n\nInteger\n\nThe number of attempts to retry before returning a failure.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$returnVar\n\nString or Object\n\nEither a string containing the HTML contents of a web-page are returned, or a WebResponse object which can then be passed to other HTTP functions. If \"None\" is specified as the return type, no variable will be returned to the test script.\n\n\n\n\n\nExample:\n\n\n\n\n\n// Get the data from a web page.\n\n$url = \"http://www.google.com\";\n\n$userName = \"\";\n\n$password = \"\";\n\n$domain = \"\";\n\n$returnType = \"String\";\n\n$retry = 5;\n\n\n\n$webData = HTTP_Request($url, $userName, $password, $domain, $returnType, $retry);\n\n\n\n\n\nHTTP_SubmitForm\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS HTTP_SubmitForm": {
  "prefix": "HTTP_SubmitForm",
  "body": [
   "$$returnVar=HTTP_SubmitForm($$url,$$userName,$$password,$$domain,$$returnVarType,$$formData,$$retryCount);"
  ],
  "description": "\n\nThis function accesses the requested URL destination via HTTP, submits the form data and returns either a WebResponse object or a String containing the contents of the web page. If the web page requires authentification credentials, they can be supplied with the $userName, $password, and $domain arguments. In the event that the authentication arguments are left blank, they are ignored. The $returnVariableType determines whether this function should return a reference to the WebResponse object to the script, or if a string containing the HTML contents of the web-page should be returned to the script interpreter.\n\n\n\n\n\nRemarks:\n\nIf the web-page is not reachable, can't be found, or times out, an error is returned.\n\nIn the event that Access is Denied an error is also returned.\n\nThe form data included must be in standard HTML form encoded format. Example: On a form with inputs for UserName and Password, use: \"UserName\"=\"MyName\"&\"Password\"=\"myPassword\"\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$url\n\nString\n\nThe URL of the website to retrieve data from.\n\n\n\n$userName\n\nString\n\nThe user name to supply for authentification credentials. If authentification is not required, this string should be empty.\n\n\n\n$password\n\nString\n\nThe password to supply for authentification credentials. If authentication is not required, this string should be empty.\n\n\n\n$domain\n\nString\n\nThe domain to supply for authentification credentials. If authentification is not required, this string should be empty.\n\n\n\n$returnVarType\n\nString\n\nThe type of variable that should be returned to the script. Valid entries are: \"String\"\n\n\"WebResponse\"\n\n\"None\"\n\n\n\n\n\n$formData\n\nString\n\nThe data to be submitted to the url before getting the return data.\n\n\n\n$retryCount\n\nInteger\n\nThe number of attempts to retry before returning a failure.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$returnVar\n\nString or Object\n\nEither a string containing the HTML contents of a web-page are returned, or a WebResponse object which can then be passed to other HTTP functions. If \"None\" is specified as the return type, no variable will be returned to the test script.\n\n\n\n\n\nExample:\n\n\n\n\n\n// Get the data from a web page that wants to know your UserName and Password.\n\n$url = \"http://www.google.com\";\n\n$userName = \"\";\n\n$password = \"\";\n\n$domain = \"\";\n\n$returnType = \"String\";\n\n$formData = \"\\\"UserName\\\"=\\\"MyUserName\\\"&\\\"Password\\\"=\\\"MyPassWord\\\"\"; //Escape quote marks within the string.\n\n$retry = 5;\n\n\n\n$webData = HTTP_SubmitForm($url, $userName, $password, $domain, $returnType, $formData, $retry);\n\n\n\n\n\nHTTP_SubmitFormWithContentType\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS HTTP_SubmitFormWithContentType": {
  "prefix": "HTTP_SubmitFormWithContentType",
  "body": [
   "$$returnVar=HTTP_SubmitFormWithContentType($$url,$$userName,$$password,$$domain,$$returnVarType,$$formData,$$contentType,$$retryCount);"
  ],
  "description": "\n\nThis function accesses the requested URL destination via HTTP, submits the form data and returns either a WebResponse object or a String containing the contents of the web page. If the web page requires authentification credentials, they can be supplied with the $userName, $password, and $domain arguments. In the event that the authentication arguments are left blank, they are ignored. The $returnVariableType determines whether this function should return a reference to the WebResponse object to the script, or if a string containing the HTML contents of the web-page should be returned to the script interpreter.\n\n\n\n\n\nRemarks:\n\nIf the web-page is not reachable, can't be found, or times out, an error is returned.\n\nIn the event that Access is Denied an error is also returned.\n\nThe form data included must be in standard HTML form encoded format. Example: On a form with inputs for UserName and Password, use: \"UserName\"=\"MyName\"&\"Password\"=\"myPassword\"\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$url\n\nString\n\nThe URL of the website to retrieve data from.\n\n\n\n$userName\n\nString\n\nThe user name to supply for authentification credentials. If authentification is not required, this string should be empty.\n\n\n\n$password\n\nString\n\nThe password to supply for authentification credentials. If authentication is not required, this string should be empty.\n\n\n\n$domain\n\nString\n\nThe domain to supply for authentification credentials. If authentification is not required, this string should be empty.\n\n\n\n$returnVarType\n\nString\n\nThe type of variable that should be returned to the script. Valid entries are: \"String\"\n\n\"WebResponse\"\n\n\n\n\n\n$formData\n\nString\n\nThe data to be submitted to the url before getting the return data.\n\n\n\n$contentType\n\nString\n\nThe content type to be specified in the send header. Examples: \"application/x-www-form-urlencoded\"\n\n\"application/xml; charset=iso-8859-1\"\n\n\n\n\n\n$retryCount\n\nInteger\n\nThe number of attempts to retry before returning a failure.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$returnVar\n\nString or Object\n\nEither a string containing the HTML contents of a web-page are returned, or a WebResponse object which can then be passed to other HTTP functions.\n\n\n\n\n\nExample:\n\n\n\n\n\n// Get the data from a web page that wants to know your UserName and Password.\n\n$url = \"http://www.google.com\";\n\n$userName = \"\";\n\n$password = \"\";\n\n$domain = \"\";\n\n$returnType = \"String\";\n\n$formData = \"\\\"UserName\\\"=\\\"MyUserName\\\"&\\\"Password\\\"=\\\"MyPassWord\\\"\"; //Escape quote marks within the string.\n\n$contentType = \"application/x-www-form-urlencoded\";\n\n$retry = 5;\n\n\n\n$webData = HTTP_SubmitFormWithContentType($url, $userName, $password, $domain, $returnType, $formData, $contentType, $retry);\n\n\n\n\n\nAA_Adaptor_I2C_BitRate_Set\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AA_Adaptor_I2C_BitRate_Set": {
  "prefix": "AA_Adaptor_I2C_BitRate_Set",
  "body": [
   "$$bitRateCurrent=AA_Adaptor_I2C_BitRate_Set($$adaptorHandle,$$bitRate);"
  ],
  "description": "\n\nThis function will set the adaptor to the specified bit rate.\n\n\n\n\n\nRemarks:\n\n\u00b7 The USB driver \"TotalPhazeUSB-v2.02.exe\" must be installed to use this function.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$adaptorHandle\n\nObject\n\nThe instance of the adaptor that was opened using AA_Adaptor_I2CSPI_Open_With_Config.\n\n\n\n$bitRate\n\nInteger\n\nThe bit rate to set on the adaptor.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$bitRateCurrent\n\nInteger\n\nThe actual bit rate that was set after this function has executed.\n\n\n\n\n\nExample:\n\n$adaptSN = \"2237419378\";\n\n$portID = AA_Adaptor_Get_PortID_By_SN($adaptSN);\n\n\n\n\n\n// Get a handle to the adaptor.\n\n$adaptConfig = \"SPI_I2C\";\n\n$powerConfig = \"POWER_BOTH\";\n\n$adaptorHandle = AA_Adaptor_I2CSPI_Open_With_Config($portID, $adaptConfig, $powerConfig);\n\n\n\n\n\n// Set the bit rate on the adaptor to 400kHz.\n\n$bitRate = 400;\n\n$currentRate = AA_Adaptor_I2C_BitRate_Set($adaptorHandle, $bitRate);\n\n\n\n\n\nAA_Adaptor_Get_PortID_By_SN\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AA_Adaptor_Get_PortID_By_SN": {
  "prefix": "AA_Adaptor_Get_PortID_By_SN",
  "body": [
   "$$PortID=AA_Adaptor_Get_PortID_By_SN($$adaptorSN);"
  ],
  "description": "\n\nThis function gets the I2C adaptor port ID of the adaptor specified by the serial number.\n\n\n\n\n\nRemarks:\n\n\u00b7 The USB driver \"TotalPhazeUSB-v2.02.exe\" must be installed to use this function.\n\n\u00b7 The serial number can be found using the Aardvark GUI.exe program.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$adaptorSN\n\nString\n\nThe serial number of the adaptor.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$PortID\n\nInteger\n\nThe Port ID of the specified adaptor. The test will be Failed if the adaptor is not found.\n\n\n\n\n\nExample:\n\n// Get the port ID for adaptor SN \"2237419378\".\n\n$adaptorSN = \"2237419378\";\n\n$PortID = AA_Adaptor_Get_PortID_By_SN($adaptorSN);\n\n\n\n\n\nAA_Adaptor_I2CSPI_Close\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AA_Adaptor_I2CSPI_Close": {
  "prefix": "AA_Adaptor_I2CSPI_Close",
  "body": [
   "AA_Adaptor_I2CSPI_Close($$adaptorHandle);"
  ],
  "description": "\n\nThis function will close communications with the specified I2C adaptor.\n\n\n\n\n\nRemarks:\n\n\u00b7 The USB driver \"TotalPhazeUSB-v2.02.exe\" must be installed to use this function.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$adaptorHandle\n\nObject\n\nThe instance of the adaptor that was opened using AA_Adaptor_I2CSPI_Open_With_Config\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone.\n\n\n\n\n\nExample:\n\nAA_Adaptor_I2CSPI_Close($adaptorHandle);\n\n\n\n\n\nAA_Adaptor_I2CSPI_Open_With_Config\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AA_Adaptor_I2CSPI_Open_With_Config": {
  "prefix": "AA_Adaptor_I2CSPI_Open_With_Config",
  "body": [
   "$$adaptorHandle=AA_Adaptor_I2CSPI_Open_With_Config($$portID,$$adaptorConfig,$$powerConfig);"
  ],
  "description": "\n\nThis function will open communication through an adaptor using the specified configuration\n\n\n\n\n\nRemarks:\n\n\u00b7 The USB driver \"TotalPhazeUSB-v2.02.exe\" must be installed to use this function.\n\n\u00b7 The Power configuration is only required when opening communications with an I2C adaptor (it is not required for SPI adaptors).\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$portID\n\nInteger\n\nThe adaptor Port ID. This can be found using the function AA_Adaptor_Get_PortID_By_SN.\n\n\n\n$adaptorConfig\n\nString\n\nThe adaptor mode. Valid inputs are:\n\n\u00b7 SPI_I2C\n\n\u00b7 GPIO_I2C\n\n\u00b7 SPI_GPIO\n\n\u00b7 GPIO_ONLY\n\n\u00b7 QUERY\n\n\n\n$powerConfig\n\nString\n\nThe adaptor power option (I2C Only). Valid inputs are:\n\n\u00b7 POWER_NONE\n\n\u00b7 POWER_BOTH\n\n\u00b7 POWER_QUERY\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$adaptorHandle\n\nObject\n\nA pointer to this instance of the adaptor driver.\n\n\n\n\n\nExample:\n\n// Get the portID first.\n\n$adaptSN = \"2237419378\";\n\n$portID = AA_Adaptor_Get_PortID_By_SN($adaptSN);\n\n\n\n\n\n// Get a handle to the adaptor.\n\n$adaptConfig = \"SPI_I2C\";\n\n$powerConfig = \"POWER_BOTH\";\n\n$adaptorHandle = AA_Adaptor_I2CSPI_Open_With_Config($portID, $adaptConfig, $powerConfig);\n\n\n\n\n\nAA_Adaptor_I2C_Host_Read\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AA_Adaptor_I2C_Host_Read": {
  "prefix": "AA_Adaptor_I2C_Host_Read",
  "body": [
   "$$dataRead=AA_Adaptor_I2C_Host_Read($$adaptorHandle,$$slaveAddress,$$expectedLength);"
  ],
  "description": "\n\nThis function will read data from the specified slave address.\n\n\n\n\n\nRemarks:\n\n\u00b7 The USB driver \"TotalPhazeUSB-v2.02.exe\" must be installed to use this function.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$adaptorHandle\n\nObject\n\nThe instance of the adaptor that was opened using AA_Adaptor_I2CSPI_Open_With_Config.\n\n\n\n$slaveAddress\n\nString\n\nThe slave device address in hexadecimal. Example: \"5E\"\n\n\n\n$expectedLength\n\nInteger\n\nThe number of bytes expected to be returned by the slave device.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$dataRead\n\nString\n\nThe data read from the slave device.\n\n\n\n\n\nExample:\n\n$adaptSN = \"2237419378\";\n\n$portID = AA_Adaptor_Get_PortID_By_SN($adaptSN);\n\n\n\n\n\n// Get a handle to the adaptor.\n\n$adaptConfig = \"SPI_I2C\";\n\n$powerConfig = \"POWER_BOTH\";\n\n$adaptorHandle = AA_Adaptor_I2CSPI_Open_With_Config($portID, $adaptConfig, $powerConfig);\n\n\n\n\n\n// Read 10 bytes from slave device at address 5E.\n\n$slaveAdd = \"5E\";\n\n$expect = 10;\n\n$dataRead = AA_Adaptor_I2C_Host_Read($adaptorHandle, $slaveAdd, $expect);\n\n\n\n\n\nAA_Adaptor_I2C_Host_Write\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AA_Adaptor_I2C_Host_Write": {
  "prefix": "AA_Adaptor_I2C_Host_Write",
  "body": [
   "$$wBytes=AA_Adaptor_I2C_Host_Write($$adaptorHandle,$$slaveAddress,$$hexData);"
  ],
  "description": "\n\nThis function will write data to the specified slave address.\n\n\n\n\n\nRemarks:\n\n\u00b7 The USB driver \"TotalPhazeUSB-v2.02.exe\" must be installed to use this function.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$adaptorHandle\n\nObject\n\nThe instance of the adaptor that was opened using AA_Adaptor_I2CSPI_Open_With_Config.\n\n\n\n$slaveAddress\n\nString\n\nThe slave device address in hexadecimal. Example: \"5E\"\n\n\n\n$hexData\n\nString\n\nHexadecimal data in a string.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$wBytes\n\nInteger\n\nThe number of bytes written to the target.\n\n\n\n\n\nExample:\n\n$adaptSN = \"2237419378\";\n\n$portID = AA_Adaptor_Get_PortID_By_SN($adaptSN);\n\n\n\n\n\n// Get a handle to the adaptor.\n\n$adaptConfig = \"SPI_I2C\";\n\n$powerConfig = \"POWER_BOTH\";\n\n$adaptorHandle = AA_Adaptor_I2CSPI_Open_With_Config($portID, $adaptConfig, $powerConfig);\n\n\n\n\n\n// Write \"02 F9 01 FA\" to slave device at address 5E.\n\n$slaveAdd = \"5E\";\n\n$hexData = \"02 F9 01 FA\";\n\n$numBytes = AA_Adaptor_I2C_Host_Write($adaptorHandle, $slaveAdd, $hexData);\n\n\n\n\n\nAA_Adaptor_I2C_TargetPower_Set\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AA_Adaptor_I2C_TargetPower_Set": {
  "prefix": "AA_Adaptor_I2C_TargetPower_Set",
  "body": [
   "AA_Adaptor_I2C_TargetPower_Set($$adaptorHandle,$$powerConfig);"
  ],
  "description": "\n\nThis function will set the adaptor's power mode.\n\n\n\n\n\nRemarks:\n\n\u00b7 The USB driver \"TotalPhazeUSB-v2.02.exe\" must be installed to use this function.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$adaptorHandle\n\nObject\n\nThe instance of the adaptor that was opened using AA_Adaptor_I2CSPI_Open_With_Config.\n\n\n\n$powerConfig\n\nString\n\nThe adaptor power option (I2C Only). Valid inputs are:\n\n\u00b7 POWER_NONE\n\n\u00b7 POWER_BOTH\n\n\u00b7 POWER_QUERY\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone.\n\n\n\n\n\nExample:\n\n$adaptSN = \"2237419378\";\n\n$portID = AA_Adaptor_Get_PortID_By_SN($adaptSN);\n\n\n\n\n\n// Get a handle to the adaptor.\n\n$adaptConfig = \"SPI_I2C\";\n\n$powerConfig = \"POWER_BOTH\";\n\n$adaptorHandle = AA_Adaptor_I2CSPI_Open_With_Config($portID, $adaptConfig, $powerConfig);\n\n\n\n\n\n// Change the Power Config to \"None\".\n\n$newPowConfig = \"POWER_NONE\";\n\nAA_Adaptor_I2C_TargetPower_Set($adaptorHandle, $newPowConfig);\n\n\n\n\n\nUSBI2cIo_Close\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS UsbI2cIo_Close": {
  "prefix": "UsbI2cIo_Close",
  "body": [
   "UsbI2cIo_Close($$USBIO_DeviceHandle);"
  ],
  "description": "\n\nThis function closes the USB session with a DevaSys I2C board specified by the USBIO_DeviceHandle handle variable which was previously opened by the UsbI2cIo_Open function.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$USBIO_DeviceHandle\n\nInteger\n\nThe handle of the device which is to be closed.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n\n\nnone\n\n\n\n\n\nUsbI2cIo Examples\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS UsbI2cIo_I2cRead": {
  "prefix": "UsbI2cIo_I2cRead",
  "body": [
   "($$returnBufferStr,$$returnBufferIntArray,$$returnBufferStrArray)=UsbI2cIo_I2cRead($$USBIO_DeviceHandle,$$USBIO_SlaveDeviceAddres,$$USBIO_MemoryAddress,$$USBIO_WordCount,$$USBIO_TransactionType);"
  ],
  "description": "\n\nThis function assumes that a session with the DevaSys Usb I2C device has already been initiated and that the handle is contained in the USBIO_DeviceHandle argument. This function performs a read operation from a device with the addresses specified in the $USBIO_SlaveDeviceAddres and $USBIO_MemoryAddress arguments.\n\nThe USBIO_TransactionType variable determines the transaction type and weather the USBIO_MemoryAddress variable is used, see the table below for further details.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nUSBIO_DeviceHandle\n\nInteger\n\nThis is the device handle obtained fromt he UsbI2cIo_Open function call.\n\n\n\nUSBIO_SlaveDeviceAddres\n\nInteger\n\nThis is the address of the device with which we want to communicate. The address in the script must match the address setting of the end device with which we want to communicate.\n\n\n\nUSBIO_MemoryAddress\n\nInteger\n\nDepending on the Transaction Type (see below) the MemorryAddress can be used to specify the internal address of the device. See I2C spec for further details.\n\n\n\nUSBIO_WordCount\n\nInteger\n\nThe number of bytes we want to read.\n\n\n\nUSBIO_TransactionType\n\nString\n\nThere are 4 types of Transaction Types supported by the DevaSysDevice and the transaction types determine how the device is addressed internally\n\nI2C_TRANS_NOADR: read or write with no address cycle\n\nI2C_TRANS_8ADR: read or write with 8 bit address cycle\n\nI2C_TRANS_16ADR: read or write with 16 bit address cycle\n\nI2C_TRANS_NOADR_NS: read or write with no address cycle, stop signaling suppressed\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nreturnBufferStr\n\nString\n\nContains the contents of the return buffer as a string each byte being delimited by a space.\n\n\n\nreturnBufferIntArray\n\nIntArray\n\nContains the contents of the return buffer as an Integer array.\n\n\n\nreturnBufferStrArray\n\nStrArray\n\nContains the contents of the return buffer as a string array.\n\n\n\n\n\nUsbI2CIo_Open\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS UsbI2cIo_Open": {
  "prefix": "UsbI2cIo_Open",
  "body": [
   "$$USBIO_DeviceHandle=UsbI2cIo_Open($$USBIO_DeviceNumber);"
  ],
  "description": "\n\nThis function opens a USB session with a DevaSys I2C board specified by the USBIO_DeviceNumber argument. This function checks that there is at least one device connected to the Computer and if none are present it aborts. If at least one device is present the functions attempts to obtain a handle to the device through the dll supplied by DevaSys as part of the driver.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$USBIO_DeviceNumber\n\nInteger\n\nThe DevaSys devices are usually assigned sequential numbers so if only one device is plugged in it will be device 0, if more than one devices are plugged in they will be numbered sequentially.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$USBIO_DeviceHandle\n\nIneger\n\nThe function returns an object of type Ingeger which can be passed to the other UsbI2CIo script commands.\n\n\n\n\n\nUsbI2cIo_Write\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS UsbI2cIo_I2cWrite": {
  "prefix": "UsbI2cIo_I2cWrite",
  "body": [
   "UsbI2cIo_I2cWrite($$USBIO_DeviceHandle,$$USBIO_SlaveDeviceAddres,$$USBIO_MemoryAddress,$$USBIO_WordCount,$$USBIO_TransactionType,$$USBIO_WriteBuffer);"
  ],
  "description": "\n\nThis function assumes that a session with the DevaSys Usb I2C device has already been initiated and that the handle is contained in the USBIO_DeviceHandle argument. This function performs a write operation to the device with the addresses specified in the $USBIO_SlaveDeviceAddres and $USBIO_MemoryAddress arguments.\n\nThe USBIO_TransactionType variable determines the transaction type and weather the USBIO_MemoryAddress variable is used, see the table below for further details.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nUSBIO_DeviceHandle\n\nInteger\n\nThis is the device handle obtained fromt he UsbI2cIo_Open function call.\n\n\n\nUSBIO_SlaveDeviceAddres\n\nInteger\n\nThis is the address of the device with which we want to communicate. The address in the script must match the address setting of the end device with which we want to communicate.\n\n\n\nUSBIO_MemoryAddress\n\nInteger\n\nDepending on the Transaction Type (see below) the MemorryAddress can be used to specify the internal address of the device. See I2C spec for further details.\n\n\n\nUSBIO_WordCount\n\nInteger\n\nThe number of bytes we want to read.\n\n\n\nUSBIO_TransactionType\n\nString\n\nThere are 4 types of Transaction Types supported by the DevaSysDevice and the transaction types determine how the device is addressed internally\n\nI2C_TRANS_NOADR: read or write with no address cycle\n\nI2C_TRANS_8ADR: read or write with 8 bit address cycle\n\nI2C_TRANS_16ADR: read or write with 16 bit address cycle\n\nI2C_TRANS_NOADR_NS: read or write with no address cycle, stop signaling suppressed\n\n\n\nUSBIO_WriteBuffer\n\nString\n\nA space delimited string of bytes to be written to the device, for example \"00 00 1F FF\"\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nTelosMasterReceiver\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS TelosMasterReceiver": {
  "prefix": "TelosMasterReceiver",
  "body": [
   "$$Data=TelosMasterReceiver($$DeviceNumber,$$Address,$$NrOfBytes,$$ClockSpeed);"
  ],
  "description": "\n\nThis function reads data as master transmitter from an I2C device.\n\n\n\nRemarks:\n\n\u00b7 This function requires Telos I2C framework to be installed on the system (I2C studio V4.3.1+). Previous versions will no longer function with this library.\n\n\u00b7 This function is tested with a Connii MM.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$DeviceNumber\n\nInteger\n\nThe number of Telos I2C device you want to use.\n\n\n\n$Address\n\nString\n\nThe 7 bit i2C address\n\nReference the Telos manual and interface\n\n\n\n$Data\n\nString\n\nThe Hex data.\n\nNone Hex characters will be ignored\n\n\n\n$ClockSpeed\n\nInteger\n\nThe speed: 100000 represents 100Khz.\n\nAll other values will use default the highest speed of 400Khz\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Data\n\nString\n\nThe data you requested to read at an address.\n\nEach byte is seperated with a space.\n\n\n\n\n\nExample:\n\n$Data = TelosMasterReceiver(1, \"33\", \"2\", 100000);\n\n\n\n\n\nTelosMasterTransmitter\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS TelosMasterTransmitter": {
  "prefix": "TelosMasterTransmitter",
  "body": [
   "TelosMasterTransmitter($$DeviceNumber,$$Address,$$Data,$$ClockSpeed);"
  ],
  "description": "\n\nThis function sents data as master transmitter to an I2C device.\n\n\n\nRemarks:\n\n\u00b7 This function requires Telos I2C framework to be installed on the system (I2C studio V4.3.1+). Previous versions will no longer function with this library.\n\n\u00b7 This function is tested with a Connii MM.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$DeviceNumber\n\nInteger\n\nThe number of Telos I2C device you want to use.\n\n\n\n$Address\n\nString\n\nThe 7 bit i2C address\n\nReference the Telos manual and interface\n\n\n\n$Data\n\nString\n\nThe Hex data.\n\nNone Hex characters will be ignored\n\n\n\n$ClockSpeed\n\nInteger\n\nThe speed: 100000 represents 100Khz.\n\nAll other values will use default the highest speed of 400Khz\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n\n\nExample:\n\nTelosMasterTransmitter(1, \"33\", \"C3 C3\", 100000);\n\n\n\n\n\nTelos_I2C_Close\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Telos_I2C_Close": {
  "prefix": "Telos_I2C_Close",
  "body": [
   "Telos_I2C_Close($$board);"
  ],
  "description": "\n\nThis function closes a board object to the defined board type and the serial number.\n\n\n\nRemarks:\n\n\u00b7 This function requires Telos I2C framework to be installed on the system (I2C studio V4.3.1+). Previous versions will no longer function with this library.\n\n\u00b7 This function is tested with a Connii MM.\n\n\u00b7 When there occurs an error during the execution of the low level functions, Jabil Test will fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\u00b7 The functions TelosMasterTransmitter and TelosMasterReceiver are opening and closing the interface during every function execution. The open interface is time consuming. With the function Telos_I2C_Initialize, we are able to open the interface and leave it in that state. Now we don't lose time with the Telos_I2C_MasterTransmitter and Telos_I2C_MasterReceiver functions. We use the Telos_I2C_Close function to close the connection once we are done with it.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$board\n\nObject\n\nHandle for the I2C board created with Telos_I2C_Initialize\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n\n\nExample:\n\nTelos_I2C_Close($board);\n\n\n\n\n\nTelos_I2C_Initialize\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Telos_I2C_Initialize": {
  "prefix": "Telos_I2C_Initialize",
  "body": [
   "$$board=Telos_I2C_Initialize($$BoardTypeName,$$SerialNumber);"
  ],
  "description": "\n\nThis function opens a board object to the defined board type and the serial number. When your are finished using the Telos device, execute the Telos_I2C_Close to destroy the $board object.\n\n\n\nRemarks:\n\n\u00b7 This function requires Telos I2C framework to be installed on the system (I2C studio V4.3.1+). Previous versions will no longer function with this library.\n\n\u00b7 This function is tested with a Connii MM.\n\n\u00b7 When there occurs an error during the execution of the low level functions, Jabil Test will fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\u00b7 The functions TelosMasterTransmitter and TelosMasterReceiver are opening and closing the interface during every function execution. The open interface is time consuming. With the function Telos_I2C_Initialize, we are able to open the interface and leave it in that state. Now we don't lose time with the Telos_I2C_MasterTransmitter and Telos_I2C_MasterReceiver functions.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$BoardTypeName\n\nString\n\nBoard type of the board to be opened.\n\nPossible values:\n\n\u00b7 \"DUMMY\" : dummy device.\n\n\u00b7 \"CONNII\" : I2C Fast Mode Interface for USB, Single Master.\n\n\u00b7 \"CONNII_MM\" : I2C Fast Mode Interface for USB, I2C Multimaster\n\n\u00b7 \"TRACII_400\" : Fast Mode I2C Monitor and Interface\n\n\u00b7 \"TRACII_XL\" : I2C High Speed Interface for USB\n\n\u00b7 \"TRACII_XL2\" : I2C High Speed Interface for USB\n\n\n\n$SerialNumber\n\nString\n\nThe serial number of the board to be opened (hexadecimal value). You can find the serial number of the Telos hardware on the box identify sticker or in the I2C studio application in the left bottom corner.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$board\n\nObject\n\nHandle for the I2C board.\n\n\n\n\n\nExample:\n\n$board = Telos_I2C_Initialize(\"CONNII_MM\", \"6489\");\n\n\n\n\n\nTelos_I2C_MasterCombined\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Telos_I2C_MasterCombined": {
  "prefix": "Telos_I2C_MasterCombined",
  "body": [
   "$$Data=Telos_I2C_MasterCombined($$board,$$I2C_Address,$$Data_To_Send,$$Bytes_To_Read,$$Clock_Speed);"
  ],
  "description": "\n\nThis function executes a master combined transfer. The combined mode transfer consists of one master transmitter transfer and one master receiver transfer. On the I2C bus the transfer looks like START, ADDR/W, DATA, START, ADDR/R, DATA, STOP\n\n\n\nRemarks:\n\n\u00b7 This function requires Telos I2C framework to be installed on the system (I2C studio V4.3.1+). Previous versions will no longer function with this library.\n\n\u00b7 This function is tested with a Telos CONNII_MM 2.0 device.\n\n\u00b7 If this function returns an error, it will fail the test, but it will not close the connection. The connection must be closed in the Fail or Finalize functions of the script. Us the function Telos_I2C_Close.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$board\n\nObject\n\nHandle for the I2C board.\n\n\n\n$I2C_Address\n\nString\n\nThe 7 bit i2C address. Reference the Telos manual and interface for more information.\n\n\n\n$Data_To_Send\n\nString\n\nThe Hex data.\n\nNone Hex characters will be ignored\n\n\n\n$Bytes_To_Read\n\nInteger\n\nNumber of bytes to read after transmit of the data to send.\n\n\n\n$Clock_Speed\n\nInteger\n\nThe speed: 100000 represents 100Khz.\n\nAll other values will use default the highest speed of 400Khz\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Data\n\nString\n\nBytes returned by I2C slave.\n\n\n\n\n\nExample:\n\n$ReturnValues = Telos_I2C_MasterCombined($objTelos, \"59\", \"05 04 02 81 8D BD\", 3, 400000);\n\n\n\n\n\nTelos_I2C_MasterCombinedBool\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Telos_I2C_MasterCombinedBool": {
  "prefix": "Telos_I2C_MasterCombinedBool",
  "body": [
   "($$Data,$$Status)=Telos_I2C_MasterCombinedBool($$board,$$I2C_Address,$$Data_To_Send,$$Bytes_To_Read,$$Clock_Speed);"
  ],
  "description": "\n\nThis function executes a master combined transfer. The combined mode transfer consists of one master transmitter transfer and one master receiver transfer. On the I2C bus the transfer looks like START, ADDR/W, DATA, START, ADDR/R, DATA, STOP\n\n\n\nRemarks:\n\n\u00b7 This function requires Telos I2C framework to be installed on the system (I2C studio V4.3.1+). Previous versions will no longer function with this library.\n\n\u00b7 This function is tested with a Telos CONNII_MM 2.0 device.\n\n\u00b7 If this function returns an error, it will fail the test, but it will not close the connection. The connection must be closed in the Fail or Finalize functions of the script. Us the function Telos_I2C_Close.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$board\n\nObject\n\nHandle for the I2C board.\n\n\n\n$I2C_Address\n\nString\n\nThe 7 bit i2C address. Reference the Telos manual and interface for more information.\n\n\n\n$Data_To_Send\n\nString\n\nThe Hex data.\n\nNone Hex characters will be ignored\n\n\n\n$Bytes_To_Read\n\nInteger\n\nNumber of bytes to read after transmit of the data to send.\n\n\n\n$Clock_Speed\n\nInteger\n\nThe speed: 100000 represents 100Khz.\n\nAll other values will use default the highest speed of 400Khz\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Data\n\nString\n\nBytes returned by I2C slave.\n\n\n\n$Status\n\nBoolean\n\nFalse if an error occurred during the master combined transfer. True if no error.\n\n\n\n\n\nExample:\n\n($ReturnValues, $Status) = Telos_I2C_MasterCombinedBool($objTelos, \"59\", \"05 04 02 81 8D BD\", 3, 400000);\n\n\n\n\n\nTelos_I2C_MasterReceiver\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Telos_I2C_MasterReceiver": {
  "prefix": "Telos_I2C_MasterReceiver",
  "body": [
   "$$bytes=Telos_I2C_MasterReceiver($$board,$$I2C_Address,$$Nr_Of_Bytes,$$Clock_Speed);"
  ],
  "description": "\n\nThis function reads data as master transmitter from an I2C device.\n\n\n\nRemarks:\n\n\u00b7 This function requires Telos I2C framework to be installed on the system (I2C studio V4.3.1+). Previous versions will no longer function with this library.\n\n\u00b7 This function is tested with a Connii MM.\n\n\u00b7 When there occurs an error during the execution of the low level functions, Jabil Test will fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\u00b7 The functions TelosMasterTransmitter and TelosMasterReceiver are opening and closing the interface during every function execution. The open interface is time consuming. With the function Telos_I2C_Initialize, we are able to open the interface and leave it in that state. Now we don't lose time with the Telos_I2C_MasterTransmitter and Telos_I2C_MasterReceiver functions.\n\n\u00b7 Be sure to execute first the function Telos_I2C_Initialize to estabilish a connection to the Telos hardware.\n\n\u00b7 If this function returns an error, it will fail the test, but it will not close the connection. The connection must be closed in the Fail or Finalize functions of the script. Us the function Telos_I2C_Close.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$board\n\nObject\n\nHandle for the I2C board.\n\n\n\n$I2C_Address\n\nString\n\nThe 7 bit i2C address. Reference the Telos manual and interface for more information.\n\n\n\n$Nr_Of_Bytes\n\nInteger\n\nThe amount of bytes you want to read.\n\n\n\n$Clock_Speed\n\nInteger\n\nThe speed: 100000 represents 100Khz.\n\nAll other values will use default the highest speed of 400Khz\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$bytes\n\nString\n\nThe data you requested to read at an address.\n\nEach byte is separated with a space.\n\n\n\n\n\nExample:\n\n$I2C_Address = New(\"String\", \"01\");\n\n$Nr_Of_Bytes = New(\"Integer\", 8);\n\n$Clock_Speed = New(\"Integer\", 100000);\n\n$bytes = Telos_I2C_MasterReceiver($board, $I2C_Address, $Nr_Of_Bytes, $Clock_Speed);\n\n\n\n\n\nTelos_I2C_MasterTransmitter\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Telos_I2C_MasterTransmitter": {
  "prefix": "Telos_I2C_MasterTransmitter",
  "body": [
   "Telos_I2C_MasterTransmitter($$board,$$I2C_Address,$$Data_To_Send,$$Clock_Speed);"
  ],
  "description": "\n\nThis function sends data as master transmitter to an I2C device.\n\n\n\nRemarks:\n\n\u00b7 This function requires Telos I2C framework to be installed on the system (I2C studio V4.3.1+). Previous versions will no longer function with this library.\n\n\u00b7 This function is tested with a Connii MM.\n\n\u00b7 When there occurs an error during the execution of the low level functions, Jabil Test will fail and return the error message.\n\n\u00b7 The function will verify if the given parameter exists, otherwise Jabil Test fails and returns the error message.\n\n\u00b7 The functions TelosMasterTransmitter and TelosMasterReceiver are opening and closing the interface during every function execution. The open interface is time consuming. With the function Telos_I2C_Initialize, we are able to open the interface and leave it in that state. Now we don't lose time with the Telos_I2C_MasterTransmitter and Telos_I2C_MasterReceiver functions.\n\n\u00b7 Be sure to execute first the function Telos_I2C_Initialize to estabilish a connection to the Telos hardware.\n\n\u00b7 If this function returns an error, it will fail the test, but it will not close the connection. The connection must be closed in the Fail or Finalize functions of the script. Us the function Telos_I2C_Close.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$board\n\nObject\n\nHandle for the I2C board.\n\n\n\n$I2C_Address\n\nString\n\nThe 7 bit i2C address. Reference the Telos manual and interface for more information.\n\n\n\n$Data_To_Send\n\nString\n\nThe Hex data.\n\nNone Hex characters will be ignored\n\n\n\n$Clock_Speed\n\nInteger\n\nThe speed: 100000 represents 100Khz.\n\nAll other values will use default the highest speed of 400Khz\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n\n\nExample:\n\n$I2C_Address = New(\"String\", \"01\");\n\n$Data_To_Send = New(\"String\", \"53 43 01\");\n\n$Clock_Speed = New(\"Integer\", 100000);\n\nTelos_I2C_MasterTransmitter($board, $I2C_Address, $Data_To_Send, $Clock_Speed);\n\n\n\n\n\nRedRat_irNetBox_Close\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS RedRat_irNetBox_Close": {
  "prefix": "RedRat_irNetBox_Close",
  "body": [
   "RedRat_irNetBox_Close($$RedRatHandle);"
  ],
  "description": "\n\n\u00b7 This function requires the .NET Framework 1.1 and development environment (SDK, VisualStudio .NET or other).\n\n\u00b7 This function requires The RedRat SDK. You can download the RedRat SDK from http://www.redrat.co.uk/SDK\n\n\u00b7 First you have to assign an IP address to the RedRat irNetBox device to be able to use it:\n\n\u00b7 Ensure that your irNetBox is connected to the same network as your computer, start the XPort Installer application (installed by default under Lantronix -> Device Installer), then press Search.\n\n\u00b7 Your NetBox will appear as an XPort in the list, so select it and press Assign IP.\n\n\u00b7 A wizard will start that will allow you to configure the IP settings. Once complete, the device reboots and will then be seen with its new IP address.\n\n\u00b7 If you have given it a fixed IP address, but want to return to using DHCP, then set all fields in the IP settings page to 0.0.0.0.\n\nIMPORTANT: Do not adjust the \"OEM configurable pins\" or the \"Ports\" values as this will stop the XPort communicating with the IR I/O processor.\n\n\n\nThe closing step closes the session and deallocates any resources the session used.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a irNetBox-Pro device.\n\n\n\nResult:\n\nRedRat_irNetBox_Close($RedRatHandle);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$RedRatHandle\n\nObject\n\nThe instrument handle you obtain from RedRat_irNetBox_Init that identifies a particular instrument's session.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n\n\nExample:\n\nRedRat_irNetBox_Close($RedRatHandle);\n\n\n\n\n\nRedRat_irNetBox_Init\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS RedRat_irNetBox_Init": {
  "prefix": "RedRat_irNetBox_Init",
  "body": [
   "$$RedRatHandle=RedRat_irNetBox_Init($$IPAddress,$$MACAddress);"
  ],
  "description": "\n\n\u00b7 This function requires the .NET Framework 1.1 and development environment (SDK, VisualStudio .NET or other).\n\n\u00b7 This function requires The RedRat SDK. You can download the RedRat SDK from http://www.redrat.co.uk/SDK\n\n\u00b7 First you have to assign an IP address to the RedRat irNetBox device to be able to use it:\n\n\u00b7 Ensure that your irNetBox is connected to the same network as your computer, start the XPort Installer application (installed by default under Lantronix -> Device Installer), then press Search.\n\n\u00b7 Your NetBox will appear as an XPort in the list, so select it and press Assign IP.\n\n\u00b7 A wizard will start that will allow you to configure the IP settings. Once complete, the device reboots and will then be seen with its new IP address.\n\n\u00b7 If you have given it a fixed IP address, but want to return to using DHCP, then set all fields in the IP settings page to 0.0.0.0.\n\n\u00b7 IMPORTANT: Do not adjust the \"OEM configurable pins\" or the \"Ports\" values as this will stop the XPort communicating with the IR I/O processor.\n\n\n\nThe user has to provide the MAC address and the IP address of the RedRat device. When the function finds such a device, we create an object that we use to communicate with the RedRat device.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a irNetBox-Pro device.\n\n\n\nResult:\n\n\n\n\n\n$RedRatHandle = RedRat_irNetBox_Init($IPAddress, $MACAddress);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$IPAddress\n\nString\n\nThe IP address that you assigned to the irNetBox device. This IP address is stored in the registry together with the MAC address.\n\n\n\n$MACAddress\n\nString\n\nThe MAC address of the irNetBox device.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$RedRatHandle\n\nObject\n\nThe RedRat irNetBox handle to use in further functions\n\n\n\n\n\nExample:\n\n\n\n\n\n$RedRatHandle = RedRat_irNetBox_Init(\"172.29.6.49\", \"00-20-4A-8B-FA-91\");\n\n\n\n\n\nRedRat_irNetBox_SendFromFile\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS RedRat_irNetBox_SendFromFile": {
  "prefix": "RedRat_irNetBox_SendFromFile",
  "body": [
   "RedRat_irNetBox_SendFromFile($$RedRatHandle,$$XmlFile,$$SignalName,$$Output);"
  ],
  "description": "\n\n\u00b7 This function requires the .NET Framework 1.1 and development environment (SDK, VisualStudio .NET or other).\n\n\u00b7 This function requires The RedRat SDK. You can download the RedRat SDK from http://www.redrat.co.uk/SDK\n\n\u00b7 First you have to assign an IP address to the RedRat irNetBox device to be able to use it:\n\n\u00b7 Ensure that your irNetBox is connected to the same network as your computer, start the XPort Installer application (installed by default under Lantronix -> Device Installer), then press Search.\n\n\u00b7 Your NetBox will appear as an XPort in the list, so select it and press Assign IP.\n\n\u00b7 A wizard will start that will allow you to configure the IP settings. Once complete, the device reboots and will then be seen with its new IP address.\n\n\u00b7 If you have given it a fixed IP address, but want to return to using DHCP, then set all fields in the IP settings page to 0.0.0.0.\n\n\u00b7 IMPORTANT: Do not adjust the \"OEM configurable pins\" or the \"Ports\" values as this will stop the XPort communicating with the IR I/O processor.\n\n\n\nThe user can send IR-signals from a certain database on the specified output channel. That database is build with the RedRat tool \"Signal DB Utility\". You learn the IR signals with that tool and the signals will be saved into a database.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a irNetBox-Pro device.\n\n\n\nResult:\n\n\n\n\n\nRedRat_irNetBox_SendFromFile($RedRatHandle, $XmlFile, $SignalName, $Output);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$RedRatHandle\n\nObject\n\nThe RedRat handle created with the function RedRat_irNetBox_Init.\n\n\n\n$XmlFile\n\nString\n\nThis argument contains the path and the filename of the created database. This database contains all the signals the user wants to send.\n\n\n\n$SignalName\n\nString\n\nThis argument is the signal name in the database that the user wants to send.\n\n\n\n$Output\n\nInteger\n\nThe RedRat output the user wants to use to output the signal of the database.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n\n\nExample:\n\nRedRat_irNetBox_SendFromFile($RedRat4, \"c:\\\\mytv.xml\", \"MyTV\", \"0\", 6);\n\n\n\n\n\nRedRat3USB_CaptureSignal\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS RedRat3USB_CaptureSignal": {
  "prefix": "RedRat3USB_CaptureSignal",
  "body": [
   "RedRat3USB_CaptureSignal($$InstrumentHandle,$$SignalFileNameAndPath);"
  ],
  "description": "\n\nThis function uses the RedRat3 IR device to capture an incoming IR signal and save the data collected to an XML file.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThe handle to the APX525 instrument session.\n\n\n\n$SignalFileNameAndPath\n\nString\n\nPath and filename used for storing the captured IR data.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\nNA\n\nNA\n\n\n\n\n\nExamples:\n\nRedRat3USB_CaptureSignal($InstrumentHandle,$SignalFileNameAndPath);\n\n\n\n\n\nSupported Instruments\n\nRedRat3 USB device\n\n\n\n\n\nRedRat3USB_Close\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS RedRat3USB_Close": {
  "prefix": "RedRat3USB_Close",
  "body": [
   "RedRat3USB_Close($$InstrumentHandle);"
  ],
  "description": "\n\nThe close function terminates the software connection to the instrument and de-allocates system resources. It is generally a good programming habit to close the instrument handle when the program is done using the instrument.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThe handle of the instrument returned from the RedRat3USB_Init function\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\nRedRat3USB_Close($handle);\n\n\n\n\n\nSupported Instruments\n\nRedRat3 USB device\n\n\n\n\n\nRedRat3USB_Init\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS RedRat3USB_Init": {
  "prefix": "RedRat3USB_Init",
  "body": [
   "$$handle=RedRat3USB_Init($$DeviceNo);"
  ],
  "description": "\n\nThis function initializes a session with a RedRateUSB device and returns the handle to the test script.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$DeviceNo\n\nInteger\n\nThe number of the RedRat3 device connected to the system. (i.e. If 2 RedRat3 USB devices are connected you may set $DeviceNo to 1 or 2.)\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$handle\n\nObject\n\nThe handle to the RedRat3 USB instrument session.\n\n\n\n\n\nExamples:\n\n$handle = RedRat3USB_Init($DeviceNo);\n\n\n\n\n\nSupported Instruments\n\nRedRat3 USB device\n\n\n\n\n\nRedRat3USB_OutputSignal\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS RedRat3USB_OutputSignal": {
  "prefix": "RedRat3USB_OutputSignal",
  "body": [
   "RedRat3USB_OutputSignal($$InstrumentHandle,$$SignalFileNameAndPath);"
  ],
  "description": "\n\nThis function uses the RedRat3 IR device to send the IR data contained in a stored XML file.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InstrumentHandle\n\nObject\n\nThe handle to the APX525 instrument session.\n\n\n\n$SignalFileNameAndPath\n\nString\n\nPath and filename of the previously stored IR data to transmit.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\nNA\n\nNA\n\n\n\n\n\nExamples:\n\nRedRat3USB_OutputSignal($InstrumentHandle,$SignalFileNameAndPath);\n\n\n\n\n\nSupported Instruments\n\nRedRat3 USB device\n\n\n\n\n\nTIRA_CaptureToFile\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS TIRA_CaptureToFile": {
  "prefix": "TIRA_CaptureToFile",
  "body": [
   "TIRA_CaptureToFile($$CaptureTime,$$FileName);"
  ],
  "description": "\n\nThe TIRA_xxx functions support the TIRA USB IR Transmitter from Home Electronics.\n\nTIRA Website: http://www.home-electro.com/tira2.php\n\nThis command waits for an IR code to be received by the TIRA device, and saves it to a file in a proprietary binary format. The $CaptureTime argument specifies the maximum amount of time to wait for an IR code to be received. If no IR code is detected the function will exit after the $CaptureTime (in seconds) has expired. In the event that an IR code is received, the function saves it to the specified file and exits immediately.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$RepeatCount\n\nInteger\n\nThe number of times to transmit the IR code\n\n\n\n$FileName\n\nString\n\nThe full path to save the captured transmitted IR code.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nTIRA_Close\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS TIRA_Close": {
  "prefix": "TIRA_Close",
  "body": [
   "TIRA_Close();"
  ],
  "description": "\n\nThe TIRA_xxx functions support the TIRA USB IR Transmitter from Home Electronics.\n\nTIRA Website: http://www.home-electro.com/tira2.php\n\nThis command closes the TIRA device and frees all the consumed resources.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nTIRA_Init\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS TIRA_Init": {
  "prefix": "TIRA_Init",
  "body": [
   "TIRA_Init($$ComPort);"
  ],
  "description": "\n\nThe TIRA_xxx functions support the TIRA USB IR Transmitter from Home Electronics.\n\nTIRA Website: http://www.home-electro.com/tira2.php\n\nThis command initializes the TIRA device and prepares it to either capture IR codes or transmit previously captured IR codes.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ComPort\n\nInteger\n\nThe Virtual USB COM port where the TIRA device is installed.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nTIRA_Receive\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS TIRA_Receive": {
  "prefix": "TIRA_Receive",
  "body": [
   "$$receivedCode=TIRA_Receive();"
  ],
  "description": "\n\nThis command receives IR codes using the tira_get_ir_data function from Tira2.dll, the API dll supplied by vendor.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$receivedCode\n\nString\n\nByte string in Hex format containing the six bytes of most recent received IR code.\n\n\n\n\n\nThe TIRA_xxx functions support the TIRA USB IR Transceiver from Home Electronics.\n\nTIRA Website: http://www.home-electro.com/tira2.php\n\n\n\n\n\nTIRA_SendFromFile\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS TIRA_SendFromFile": {
  "prefix": "TIRA_SendFromFile",
  "body": [
   "TIRA_SendFromFile($$RepeatCount,$$FileName);"
  ],
  "description": "\n\nThe TIRA_xxx functions support the TIRA USB IR Transmitter from Home Electronics.\n\nTIRA Website: http://www.home-electro.com/tira2.php\n\nThis command sends an IR code that has been previously captured to a file using the TIRA_CaptureToFile command. The $RepeatCount argument specifies the number of times that the IR code will be repeated.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$RepeatCount\n\nInteger\n\nThe number of times to transmit the IR code\n\n\n\n$FileName\n\nString\n\nThe full path to the IR code file that has been previously created using the TIRA_CaptureToFile command.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nSerialClose\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SerialClose": {
  "prefix": "SerialClose",
  "body": [
   "SerialClose($$comPort);"
  ],
  "description": "\n\nCloses an open Serial Port. If the port was already closed, no error is returned.\n\n\n\nNOTE:\n\nThis function has been deprecated. Please use the Serial_Open, Serial_Close functions.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$comPort\n\nObject\n\nThe instance of the serial port to close. The $comPort object is created by a call to SerialOpen.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone.\n\n\n\n\n\nExample:\n\n\n\n\n\nSerialClose($comPort);\n\n\n\n\n\nSerialCloseWithLogging\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SerialCloseWithLogging": {
  "prefix": "SerialCloseWithLogging",
  "body": [
   "SerialCloseWithLogging($$comPort);"
  ],
  "description": "\n\nCloses an open Serial Port, and also closes and flushes the associated text log file. If the port was already closed when the function is run, no error is returned.\n\nImportant Note: This function should only be used to close a serial port which has been opened with the SerialOpenWithLogging function. If you are using a serial port that has been opened with the SerialOpen function, use the standard SerialClose function instead.\n\nNOTE:\n\nThis function has been deprecated. Please use the Serial_OpenWithLogging, Serial_CloseWithLogging functions.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$comPort\n\nObject\n\nThe instance of the serial port to close. The $comPort object is created by a call to SerialOpenWithLogging.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone.\n\n\n\n\n\nExample:\n\n\n\n\n\nSerialCloseWithLogging($comPort);\n\n\n\n\n\nSerialGetPortNumber\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SerialGetPortNumber": {
  "prefix": "SerialGetPortNumber",
  "body": [
   "$$comPortNumber=SerialGetPortNumber($$ComObject);"
  ],
  "description": "\n\nThis function retrieves the Com Port number associated with a comport object created using the SerialOpen function.\n\n\n\nNOTE:\n\nThis function has been deprecated. Please use the Serial_GetPortNumber function.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ComObject\n\nObject\n\nThe instance of the serial port object created by a call to SerialOpen.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$comPortNumber\n\nInteger\n\nThe number of the com port associated with the comport scripting object.\n\n\n\n\n\nExample:\n\n\n\n\n\n$comPortNumber = SerialGetPortNumber($ComObject);\n\n\n\n\n\nSerialHandshakingManualRead\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SerialHandshakingManualRead": {
  "prefix": "SerialHandshakingManualRead",
  "body": [
   "$$Status=SerialHandshakingManualRead($$comPort,$$Pin);"
  ],
  "description": "\n\nThis function can read the Handshaking of COM. The pre-condition is the COM initialize should be used SerialOpenWithHandshaking function and setting the Handshaking type as \u201cNone\u201d.\n\n\n\nNOTE:\n\nThis function has been deprecated. Please use the Serial_OpenWithHandshaking, Serial_HandshakingManualRead functions.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$comPort\n\nObject\n\nThe instance of the serial port object created by a call to SerialOpenWithHandshaking.\n\n\n\n\n\n$Pin\n\n\n\n\n\nString\n\nThe Pin for which handshaking will be controlled.\n\nValue:\n\n\u00b7 \u201cCTS\u201d\n\n\u00b7 \u201cDSR\u201d\n\n\u00b7 \u201cRI\u201d\n\n\u00b7 \u201cDCD\u201d\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Status\n\nBoolean\n\nThe status of the Pin.\n\n\n\n\n\nExample:\n\n// Read the \u201cCTS\u201d Pin.\n\n$Status = SerialHandshakingManualRead($comPort,\u201dCTS\u201d);\n\n\n\n\n\nSerialHandshakingManualSet\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SerialHandshakingManualSet": {
  "prefix": "SerialHandshakingManualSet",
  "body": [
   "SerialHandshakingManualSet($$comPort,$$Pin,$$Status);"
  ],
  "description": "\n\nThis function is used to set the Handshaking of COM port. The pre-condition is that the COM port should be initialized using SerialOpenWithHandshaking and the Handshaking type set to \u201cNone\u201d.\n\n\n\nNOTE:\n\nThis function has been deprecated. Please use the Serial_OpenWithHandshaking, Serial_HandshakingManualSet functions.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ComObject\n\nObject\n\nThe instance of the serial port object created by a call to SerialOpenWithHandshaking.\n\n\n\n\n\n$Pin\n\n\n\n\n\nString\n\nThe Pin for which Handshaking will be controlled.\n\nValue:\n\n\u00b7 \"RTS\"\n\n\u00b7 \"DTR\"\n\n\n\n\n\n$Status\n\n\n\n\n\nString\n\nThe Status to set. Use \"TRUE\" to set the pin high and \"FALSE\" to set the pin low.\n\nValue:\n\n\u00b7 \"TRUE\"\n\n\u00b7 \"FALSE\"\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone.\n\n\n\n\n\nExample:\n\n// Set the \u201cRTS\u201d Pin to \u201c1\u201d.\n\nSerialHandshakingManualSet($comPort, \u201dRTS\u201d, \u201dTRUE\u201d);\n\n\n\n\n\nSerialOpen\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SerialOpen": {
  "prefix": "SerialOpen",
  "body": [
   "$$comObject=SerialOpen($$comPort,$$baudRate,$$byteSize,$$parity,$$stopBits);"
  ],
  "description": "\n\nOpens a Serial port object for communication. The resulting object is then used with the other serial functions to support communication. In order to close the serial port after it has been opened, use the SerialClose function. If the specified comPort is in use, this function returns a failure.\n\n\n\nNOTE:\n\nThis function has been deprecated. Please use the Serial_Open, Serial_Close functions.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$comPort\n\nInteger\n\nThe COM port you wish to open.\n\n\n\n\n\n$baudRate\n\n\n\n\n\nInteger\n\nThe baud rate to initialize the COM port at.\n\nValues:\n\n\u00b7 300\n\n\u00b7 1200\n\n\u00b7 2400\n\n\u00b7 4800\n\n\u00b7 9600\n\n\u00b7 14400\n\n\u00b7 19200\n\n\u00b7 38400\n\n\u00b7 115200\n\n\n\n$byteSize\n\nInteger\n\nThe number of data bits in each byte sent or received. Usually set to '7' or '8'.\n\n\n\n\n\n$parity\n\n\n\n\n\nString\n\nThe data parity to use.\n\nValue:\n\n\u00b7 \"E\" = Even\n\n\u00b7 \"N\" = None ("
 }
,
 "JTS SerialOpenBool": {
  "prefix": "SerialOpenBool",
  "body": [
   "($$comObject,$$success)=SerialOpenBool($$comPort,$$baudRate,$$byteSize,$$parity,$$stopBits);"
  ],
  "description": "\n\nOpens a Serial port object for communication. The resulting object is then used with the other serial functions to support communication. In order to close the serial port after it has been opened, use the SerialClose function.\n\n\n\nNOTE:\n\nIf the specified comPort can not be opened, this function will return a false in the $success variable.\n\nThis function has been deprecated. Please use the Serial_Open, Serial_Close functions.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$comPort\n\nInteger\n\nThe COM port you wish to open.\n\n\n\n\n\n$baudRate\n\n\n\n\n\nInteger\n\nThe baud rate to initialize the COM port at.\n\nValues:\n\n\u00b7 300\n\n\u00b7 1200\n\n\u00b7 2400\n\n\u00b7 4800\n\n\u00b7 9600\n\n\u00b7 14400\n\n\u00b7 19200\n\n\u00b7 38400\n\n\u00b7 115200\n\n\n\n$byteSize\n\nInteger\n\nThe number of data bits in each byte sent or received. Usually set to '7' or '8'.\n\n\n\n\n\n$parity\n\n\n\n\n\nString\n\nThe data parity to use.\n\nValue:\n\n\u00b7 \"E\" = Even\n\n\u00b7 \"N\" = None ("
 }
,
 "JTS SerialOpenWithHandshaking": {
  "prefix": "SerialOpenWithHandshaking",
  "body": [
   "$$comObject=SerialOpenWithHandshaking($$comPort,$$baudRate,$$byteSize,$$parity,$$stopBits,$$handShakingMode);"
  ],
  "description": "\n\nCreates an Opens a Serial port object for communication. The resulting object is then used with the other serial functions to support communication. In order to close the serial port after it has been created, use the SerialClose function. If the specified comPort is in use, this function returns a failure.\n\n\n\nNOTE:\n\nThis function has been deprecated. Please use the Serial_OpenWithHandshaking, Serial_Close functions.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$comPort\n\nInteger\n\nThe COM port you wish to open.\n\n\n\n\n\n$baudRate\n\n\n\n\n\nInteger\n\nThe baud rate to initialize the COM port at.\n\nValues:\n\n\u00b7 300\n\n\u00b7 1200\n\n\u00b7 2400\n\n\u00b7 4800\n\n\u00b7 9600\n\n\u00b7 14400\n\n\u00b7 19200\n\n\u00b7 38400\n\n\u00b7 115200\n\n\n\n$byteSize\n\nInteger\n\nThe number of data bits in each byte sent or received. Usually set to '7' or '8'.\n\n\n\n\n\n$parity\n\n\n\n\n\nString\n\nThe data parity to use.\n\nValue:\n\n\u00b7 \"E\" = Even\n\n\u00b7 \"N\" = None ("
 }
,
 "JTS SerialOpenWithHandshakingBool": {
  "prefix": "SerialOpenWithHandshakingBool",
  "body": [
   "($$comObject,$$success)=SerialOpenWithHandshakingBool($$comPort,$$baudRate,$$byteSize,$$parity,$$stopBits,$$handShakingMode);"
  ],
  "description": "\n\nCreates an Opens a Serial port object for communication. The resulting object is then used with the other serial functions to support communication. In order to close the serial port after it has been created, use the SerialClose function.\n\n\n\nNOTE:\n\nIf the specified comPort can not be opened, this function will return a false in the $success variable.\n\nThis function has been deprecated. Please use the Serial_OpenWithHandshaking, Serial_Close functions.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$comPort\n\nInteger\n\nThe COM port you wish to open.\n\n\n\n\n\n$baudRate\n\n\n\n\n\nInteger\n\nThe baud rate to initialize the COM port at.\n\nValues:\n\n\u00b7 300\n\n\u00b7 1200\n\n\u00b7 2400\n\n\u00b7 4800\n\n\u00b7 9600\n\n\u00b7 14400\n\n\u00b7 19200\n\n\u00b7 38400\n\n\u00b7 115200\n\n\n\n$byteSize\n\nInteger\n\nThe number of data bits in each byte sent or received. Usually set to '7' or '8'.\n\n\n\n\n\n$parity\n\n\n\n\n\nString\n\nThe data parity to use.\n\nValue:\n\n\u00b7 \"E\" = Even\n\n\u00b7 \"N\" = None ("
 }
,
 "JTS SerialOpenWithLogging": {
  "prefix": "SerialOpenWithLogging",
  "body": [
   "($$comObject,$$success)=SerialOpenWithLogging($$comPort,$$baudRate,$$byteSize,$$parity,$$stopBits,$$logFilePath);"
  ],
  "description": "\n\nCreates an Opens a Serial port object for communication, and creates a log file that will record all the information sent to/from the serial port. Returns a Boolean for whether opening the comport and the file was successful.\n\nIn order to record data sent to and from the serial port, use the SerialSendWithLogging function. If you do not wish a particular serial action to be recorded to the log, use the standard SerialSend function.\n\nThe resulting object is then used with the other serial functions to support communication. In order to close the serial port after it has been created, use the SerialCloseWithLogging function.\n\nNotes:\n\nIf the specified comPort can not be opened, this function will return a false in the $success variable.\n\nIf you use the standard SerialClose function with a COM port which was opened using the SerialOpenWithLogging function, the data log file will never be properly closed.\n\n\n\n\n\nNOTE:\n\nThis function has been deprecated. Please use the Serial_OpenWithLoggingBool, Serial_CloseWithLogging functions.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$comPort\n\nInteger\n\nThe COM port you wish to open.\n\n\n\n$baudRate\n\nInteger\n\nThe baud rate to initialize the COM port at.\n\nValues:\n\n\u00b7 300\n\n\u00b7 1200\n\n\u00b7 2400\n\n\u00b7 4800\n\n\u00b7 9600\n\n\u00b7 14400\n\n\u00b7 19200\n\n\u00b7 38400\n\n\n\n$byteSize\n\nInteger\n\nThe number of data bits in each byte sent or received. Usually set to '7' or '8'.\n\n\n\n$parity\n\nString\n\nThe data parity to use.\n\nValue:\n\n\u00b7 \"E\" = Even\n\n\u00b7 \"N\" = None ("
 }
,
 "JTS SerialPurge": {
  "prefix": "SerialPurge",
  "body": [
   "SerialPurge($$ComPort);"
  ],
  "description": "\n\n\n\nThis function clears all data out of the send and receive buffers of the communications port.\n\n\n\n\n\nNOTE:\n\nThis function has been deprecated. Please use the Serial_DiscardInBuffer, Serial_DiscardOutBuffer functions.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ComPort\n\nObject\n\nAn instance of an serial port object created using the SerialOpen, SerialOpenWithHandshaking or SerialOpenWithLogging script function.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n\n\n\n\nSerialPurge($ComPort);\n\n\n\n\n\nSerialReceiveBinaryToArray\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SerialReceiveBinaryToArray": {
  "prefix": "SerialReceiveBinaryToArray",
  "body": [
   "$$receiveArray=SerialReceiveBinaryToArray($$comPort,$$waitTime);"
  ],
  "description": "\n\nReceives binary data from the serial port for the specified time and returns it in the returned array.\n\n\n\nNOTE:\n\nThis function has been deprecated. Please use the Serial_Open, Serial_ReceiveBinaryToArray functions.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ComPort\n\nObject\n\nAn instance of an serial port object created using the SerialOpen, SerialOpenWithHandshaking or SerialOpenWithLogging script function.\n\n\n\n$waitTime\n\nInteger\n\nThe number of seconds to receive data before returning the data in an array.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$receiveArray\n\nArray\n\nAll of the binary data received during the wait time.\n\n\n\n\n\nExample:\n\n// Receive binary data for 10 seconds and return it in $receiveArray.\n\n$receiveArray = SerialReceiveBinaryToArray($comPort, 10);\n\n\n\n\n\nSerialReceiveBinaryToArrayWithCount\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SerialReceiveBinaryToArrayWithCount": {
  "prefix": "SerialReceiveBinaryToArrayWithCount",
  "body": [
   "$$receiveArray=SerialReceiveBinaryToArrayWithCount($$comPort,$$count,$$waitTime);"
  ],
  "description": "\n\nReceives the specified number of data items from the serial port and returns them in an array. This function will return an error if the number of data items were not received in the specified time.\n\n\n\nNOTE:\n\nThis function has been deprecated. Please use the Serial_Open, Serial_ReceiveBinaryToArrayWithCount functions.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$comPort\n\nObject\n\nAn instance of a SerialPort object created using the SerialOpen function.\n\n\n\n$count\n\nInteger\n\nNumber of data items to wait for.\n\n\n\n$waitTime\n\nInteger\n\nThe number of milliseconds to wait for the specified number of data items to arrive.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$receiveArray\n\nArray\n\nThe specified number of data items.\n\n\n\n\n\nExample:\n\n// The following example will wait 10 milliseconds to receive 5 bytes of data from the serial port.\n\n$receiveArray = SerialReceiveBinaryToArrayWithCount($comPort, 5, 10);\n\n\n\n\n\nSerialSend\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SerialSend": {
  "prefix": "SerialSend",
  "body": [
   "$$receiveBuffer=SerialSend($$comPort,$$sendString,$$waitString,$$timeOut);"
  ],
  "description": "\n\nSends the $sendString via the $comPort parameter. The function will then wait for the $waitString to be received on the serial port. If the waitString is not found within the $timeOut parameter specified, the function will return a failure. Both the $sendString and the $waitString can be set to an empty string. Before using a serial port, it first must be opened with the SerialOpen function. After use of the serial port is completed, it should be closed with the SerialClose function.\n\n\n\nNOTE:\n\nThis function has been deprecated. Please use the Serial_Open, Serial_Send functions.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$comPort\n\nObject\n\nAn instance of a SerialPort object created with the SerialOpen function.\n\n\n\n$sendString\n\nString\n\nThe string to be sent via the comPort.\n\n\n\n$waitString\n\nString\n\nThe string to wait for in response before continuing. This can be set to an empty string, in which case the test will send the $sendString and wait the $timeOut time.\n\n\n\n$timeOut\n\nInteger\n\nThe number of seconds to wait for the $waitString parameter before generating a failure.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$receiveBuffer\n\nString\n\nAll the characters that have been received on the serial Port since the $sendString had been sent.\n\n\n\n\n\nExample:\n\n// Get a reference to the COM port.\n\n$comPort = 3;\n\n$baudRate = 9600;\n\n$byteSize = 8;\n\n$parity = \"N\";\n\n$stopBits = 1;\n\n$comObject = SerialOpen($comPort, $baudRate, $byteSize, $parity, $stopBits);\n\n\n\n\n\n// Now send our string.\n\n$receiveBuffer = SerialSend($comObject, \"Hello\", \"\", 10);\n\n\n\n\n\nSerialSendBinary\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SerialSendBinary": {
  "prefix": "SerialSendBinary",
  "body": [
   "$$receiveBuffer=SerialSendBinary($$comPort,$$sendString,$$waitString,$$timeOut);"
  ],
  "description": "\n\nSends the $sendString via the $comPort parameter. The function will then wait for the $waitString to be received on the serial port. If the waitString is not found within the $timeOut parameter specified, the function will return a failure. Both the $sendString and the $waitString can be set to an empty string. Before using a serial port, it first must be opened with the SerialOpen function. After use of the serial port is completed, it should be closed with the SerialClose function.\n\nThe SerialSendBinary function differs from the SerialSend function in the fact that the $SendString,$waitStirng and $receiveBuffer are text string representing the hexadecimal values to be sent and received via the comPort. The format of the strings is a collection of 2 digit hexadecimal values separated by spaces.\n\nThe same functionality can be implementing using escape strings with the SerialSend function, but it's much easier to parse binary output with this function than trying to decode a receive string from the other function since you must deal with ANSI/UNICODE conversion, etc.\n\n\n\nNOTE:\n\nThis function has been deprecated. Please use the Serial_Open, Serial_SendBinary functions.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$comPort\n\nObject\n\nAn instance of a Serial Port object created with the SerialOpen function.\n\n\n\n$sendString\n\nString\n\nThe string to be sent via the Com Port.\n\n\n\n$waitString\n\nString\n\nThe string to wait for in response before continuing. This can be set to an empty string, in which case, the function will send the $sendString and wait the $timeOut time.\n\n\n\n$timeOut\n\nInteger\n\nThe number of seconds to wait for the $waitString before generating a failure.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$receiveBuffer\n\nString\n\nAll the characters that have been received on the serial port since the $sendString was sent.\n\n\n\n\n\nExample:\n\n// Send the string \"DOG\" and wait 10 seconds for the string \"CAT\".\n\n$receiveBuffer = SerialSendBinary($comPort, \"44 4F 47\", \"43 41 54\", 10);\n\n\n\n\n\nSerialSendBinaryBool\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SerialSendBinaryBool": {
  "prefix": "SerialSendBinaryBool",
  "body": [
   "($$receiveBuffer,$$waitStringFound)=SerialSendBinaryBool($$comPort,$$sendString,$$waitString,$$timeOut);"
  ],
  "description": "\n\nSends the $sendString via the $comPort parameter. The function will then wait for the $waitString to be received on the serial port. If the waitString is not found within the $timeOut parameter specified, the function will return a failure. Both the $sendString and the $waitString can be set to an empty string. Before using a serial port, it first must be opened with the SerialOpen function. After use of the serial port is completed, it should be closed with the SerialClose function.\n\nThe SerialSendBinary function differs from the SerialSend function in the fact that the $SendString,$waitStirng and $receiveBuffer are text string representing the hexadecimal values to be sent and received via the comPort. The format of the strings is a collection of 2 digit hexadecimal values separated by spaces.\n\nThe same functionality can be implementing using escape strings with the SerialSend function, but it's much easier to parse binary output with this function than trying to decode a receive string from the other function since you must deal with ANSI/UNICODE conversion, etc.\n\n\n\nNOTE:\n\nThis function has been deprecated. Please use the Serial_Open, Serial_SendBinaryBool functions.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$comPort\n\nObject\n\nAn instance of a Serial Port object created with the SerialOpen function.\n\n\n\n$sendString\n\nString\n\nThe string to be sent via the Com Port.\n\n\n\n$waitString\n\nString\n\nThe string to wait for in response before continuing. This can be set to an empty string, in which case, the function will send the $sendString and wait the $timeOut time.\n\n\n\n$timeOut\n\nInteger\n\nThe number of seconds to wait for the $waitString before generating a failure.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$receiveBuffer\n\nString\n\nAll the characters that have been received on the serial port since the $sendString was sent.\n\n\n\n$waitStringFound\n\nBoolean\n\nReturns true if the wait string was found within the $timeOut period, otherwise returns false.\n\n\n\n\n\nExample:\n\n// Send the string \"DOG\" and wait 10 seconds for the string \"CAT\".\n\n($receiveBuffer, $waitStringFound) = SerialSendBinaryBool($comPort, \"44 4F 47\", \"43 41 54\", 10);\n\n\n\n\n\nSerialSendBinaryFromArray\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SerialSendBinaryFromArray": {
  "prefix": "SerialSendBinaryFromArray",
  "body": [
   "SerialSendBinaryFromArray($$comPort,$$sendArray,$$startIndex,$$length);"
  ],
  "description": "\n\nSends the specified part of the send array out the serial port. The array must be of type integer and the lower 8 bits of the array value is sent.\n\n\n\n\n\nNOTE:\n\nThis function has been deprecated. Please use the Serial_Open, Serial_SendBinaryFromArary functions.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$comPort\n\nObject\n\nAn instance of a Serial Port object created with the SerialOpen function.\n\n\n\n$sendArray\n\nArray\n\nThe array from which the data is sent.\n\n\n\n$startIndex\n\nInteger\n\nThe starting index in the array of the data to send.\n\n\n\n$length\n\nInteger\n\nThe number of data bytes to send from the array.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n// Send 8 bytes of data starting at index 3 from the array.\n\nSerialSendBinaryFromArray($comPort, $sendArray, 3, 8);\n\n\n\n\n\nSerialSendBinaryInUnicode\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SerialSendBinaryInUnicode": {
  "prefix": "SerialSendBinaryInUnicode",
  "body": [
   "$$receiveBuffer=SerialSendBinaryInUnicode($$comPort,$$sendString,$$waitString,$$timeOut);"
  ],
  "description": "\n\nThe function is similar to SerialSendBinary. The difference is that the output of this function is in Unicode Hex. If you have some Unicode characters to wait for, you can use this function.\n\n\n\n\n\nNOTE:\n\nThis function has been deprecated. Please use the Serial_Open, Serial_SendBinaryInUnicode functions.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$comPort\n\nObject\n\nAn instance of a SerialPort object created using the SerialOpen command.\n\n\n\n$sendString\n\nString\n\nThe string to be sent via the comPort.\n\n\n\n$waitString\n\nString\n\nThe string to wait for in response before continuing. This can be set to an empty string, in which case the test will send the $sendString and wait the $timeOut time.\n\n\n\n$timeOut\n\nInteger\n\nThe number of seconds to wait for the $waitString before generating a failure.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$receiveBuffer\n\nString\n\nAll the characters that have received on the serial Port since the $sendString was sent.\n\n\n\n\n\nExample:\n\n// Send the string \"FF FF FF\" and wait 10 seconds for the string \"FF FF FF\". Assuming this is a synthesis signal of communication.\n\n\n\n\n\n$receiveBuffer = SerialSendBinary($comPort, \"FF FF FF\", \"FF FF FF\", 10);\n\n\n\n\n\nSerialSendBinaryMilliseconds\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SerialSendBinaryMilliseconds": {
  "prefix": "SerialSendBinaryMilliseconds",
  "body": [
   "$$receiveBuffer=SerialSendBinaryMilliseconds($$comPort,$$sendString,$$waitString,$$timeOut);"
  ],
  "description": "\n\nSends the $sendString via the $comPort parameter. The function will then wait for the $waitString to be received on the serial port. If the waitString is not found within the $timeOut parameter specified, the function will return a failure. Both the $sendString and the $waitString can be set to an empty string. Before using a serial port, it first must be opened with the SerialOpen function. After use of the serial port is completed, it should be closed with the SerialClose function.\n\nThe SerialSendBinaryMilliseconds function differs from the SerialSend function in the fact that the $SendString,$waitStirng and $receiveBuffer are text string representing the hexadecimal values to be sent and received via the comPort. The format of the strings is a collection of 2 digit hexidecimal values seperated by spaces.\n\nThe same functionality can be implementing using escape strings with the SerialSend function, but it's much easier to parse binary output with this function than trying to decode a receive string from the other function since you must deal with ANSI/UNICODE conversion, etc.\n\n\n\nNOTE:\n\nThis function has been deprecated. Please use the Serial_Open, Serial_SendBinaryMilliseconds functions.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$comPort\n\nObject\n\nAn instance of a SerialPort object created with the SerialOpen function.\n\n\n\n$sendString\n\nString\n\nThe string to be sent via the comPort.\n\n\n\n$waitString\n\nString\n\nThe string to wait for in response before continuing. This can be set to an empty string, in which case the test will send the $sendString and wait the $timeOut time.\n\n\n\n$timeOut\n\nInteger\n\nThe number of milliseconds to wait for the $waitString parameter before generating a failure.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$receiveBuffer\n\nString\n\nAll the characters that have been received on the serial Port since the $sendString had been sent.\n\n\n\n\n\nExample:\n\n// Send the string \"DOG\" and wait 10 seconds for the string \"CAT\".\n\n$receiveBuffer = SerialSendBinaryMilliseconds($comPort, \"44 4F 47\", \"43 41 54\", 10000);\n\n\n\n\n\nSerialSendBinaryMillisecondsBool\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SerialSendBinaryMillisecondsBool": {
  "prefix": "SerialSendBinaryMillisecondsBool",
  "body": [
   "($$receiveBuffer,$$WaitStringFound)=SerialSendBinaryMillisecondsBool($$comPort,$$sendString,$$waitString,$$timeOut);"
  ],
  "description": "\n\nSends the $sendString via the $comPort parameter. The function will then wait for the $waitString to be received on the serial port. The function will return whether or not the wait string which was specified was found in the allotted time in the $WaitStringFound return variable.. Both the $sendString and the $waitString can be set to an empty string. Before using a serial port, it first must be opened with the SerialOpen function. After use of the serial port is completed, it should be closed with the SerialClose function.\n\nThe SerialSendBinaryMillisecondsBool function differs from the SerialSend function in the fact that the $SendString,$waitStirng and $receiveBuffer are text string representing the hexadecimal values to be sent and received via the comPort. The format of the strings is a collection of 2 digit hexidecimal values seperated by spaces.\n\nThe same functionality can be implementing using escape strings with the SerialSend function, but it's much easier to parse binary output with this function than trying to decode a receive string from the other function since you must deal with ANSI/UNICODE conversion, etc.\n\n\n\nNOTE:\n\nThis function has been deprecated. Please use the Serial_Open, Serial_SendBinaryMillisecondsBool functions.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$comPort\n\nObject\n\nAn instance of a Serial Port object created with the SerialOpen function.\n\n\n\n$sendString\n\nString\n\nThe string to be sent via the Com Port.\n\n\n\n$waitString\n\nString\n\nThe string to wait for in response before continuing. This can be set to an empty string, in which case, the function will send the $sendString and wait the $timeOut time.\n\n\n\n$timeOut\n\nInteger\n\nThe number of milliseconds to wait for the $waitString before generating a failure.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$receiveBuffer\n\nString\n\nAll the characters that have been received on the serial port since the $sendString was sent.\n\n\n\n$WaitStringFound\n\nBoolean\n\nReturns true if the \"Wait String\" was found within the timeout period. Otherwise, returns false.\n\n\n\n\n\nExample:\n\n// Send the string \"DOG\" and wait 10 seconds for the string \"CAT\".\n\n($receiveBuffer, $WaitStringFound) = SerialSendBinaryMillisecondsBool($comPort, \"44 4F 47\", \"43 41 54\", 10);\n\n\n\n\n\nSerialSendBinaryWithDelays\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SerialSendBinaryWithDelays": {
  "prefix": "SerialSendBinaryWithDelays",
  "body": [
   "$$receiveBuffer=SerialSendBinaryWithDelays($$comPort,$$sendString,$$waitString,$$timeOut,$$delayMS);"
  ],
  "description": "\n\nSends the $sendString via the $comPort parameter. The function will then wait for the $waitString to be received on the serial port. If the waitString is not found within the $timeOut parameter specified, the function will return a failure. Both the $sendString and the $waitString can be set to an empty string. Before using a serial port, it first must be opened with the SerialOpen function. After use of the serial port is completed, it should be closed with the SerialClose function.\n\nThe SerialSendBinaryWithDelays function differs from the SerialSend function in the fact that the $SendString,$waitStirng and $receiveBuffer are text string representing the hexadecimal values to be sent and received via the comPort. The format of the strings is a collection of 2 digit hexidecimal values seperated by spaces.\n\nThe same functionality can be implementing using escape strings with the SerialSend function, but it's much easier to parse binary output with this function than trying to decode a receive string from the other function since you must deal with ANSI/UNICODE conversion, etc.\n\nThis function differs from the traditional SerialSendBinary command because it inserts a delay specified by the $DelayMS argument between each character that is sent out of the serial port. This function is useful for DUT's that don't support a proper FIFO buffer and aren't able to process characters sent at the native baud rate setting of the serial port. The $DelayMS parameter is specified in milliseconds.\n\n\n\nNOTE:\n\nThis function has been deprecated. Please use the Serial_Open, Serial_SendBinaryWithDelays functions.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$comPort\n\nObject\n\nAn instance of a Serial Port object created with the SerialOpen function.\n\n\n\n$sendString\n\nString\n\nThe string to be sent via the Com Port.\n\n\n\n$waitString\n\nString\n\nThe string to wait for in response before continuing. This can be set to an empty string, in which case, the function will send the $sendString and wait the $timeOut time.\n\n\n\n$timeOut\n\nInteger\n\nThe number of milliseconds to wait for the $waitString before generating a failure.\n\n\n\n$delayMS\n\nInteger\n\nThe number of milliseconds to delay between sending each character.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$receiveBuffer\n\nString\n\nAll the characters that have been received on the serial port since the $sendString was sent.\n\n\n\n\n\nExample:\n\n// Send the string \"DOG\" with a 25 millisecond delay between each character, and wait 10 seconds for the string \"CAT\".\n\n$receiveBuffer = SerialSendBinaryWithDelays($comPort, \"44 4F 47\", \"43 41 54\", 10, 25);\n\n\n\n\n\nSerialSendBool\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SerialSendBool": {
  "prefix": "SerialSendBool",
  "body": [
   "($$receiveBuffer,$$WaitStringFound)=SerialSendBool($$comPort,$$sendString,$$waitString,$$timeOut);"
  ],
  "description": "\n\nSends the $sendString via the $comPort parameter. The function will then wait for the $waitString to be received on the serial port. If the waitString is not found within the $timeOut parameter specified, the function will return a passing result, but set the $WaitStringFound return variable to 'False'. In the event that the wait string is found, the $WaitStringFound will be set to 'True'.\n\nBoth the $sendString and the $waitString can be set to an empty string. Before using a serial port, it first must be opened with the SerialOpen function. After use of the serial port is completed, it should be closed with the SerialClose function.\n\n\n\nNOTE:\n\nThis function has been deprecated. Please use the Serial_Open, Serial_SendBool functions.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$comPort\n\nObject\n\nAn instance of a SerialPort object created with the SerialOpen function.\n\n\n\n$sendString\n\nString\n\nThe string to be sent via the comPort.\n\n\n\n$waitString\n\nString\n\nThe string to wait for in response before continuing. This can be set to an empty string, in which case the test will send the $sendString and wait the $timeOut time.\n\n\n\n$timeOut\n\nInteger\n\nThe number of seconds to wait for the $waitString parameter before generating a failure.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$receiveBuffer\n\nString\n\nAll the characters that have been received on the serial Port since the $sendString had been sent.\n\n\n\n$WaitStringFound\n\nBoolean\n\nA boolean value indicating whether or not the wait string was found in the receive buffer.\n\n\n\n\n\nExample:\n\n// Get a reference to the COM port.\n\n$comPort = 3;\n\n$baudRate = 9600;\n\n$byteSize = 8;\n\n$parity = \"N\";\n\n$stopBits = 1;\n\n$comObject = SerialOpen($comPort, $baudRate, $byteSize, $parity, $stopBits);\n\n\n\n\n\n// now send our string.\n\n($receiveBuffer, $WaitStringFound) = SerialSendBool($comObject, \"Hello\", \"\", 10);\n\n\n\n\n\nSerialSendBreak\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SerialSendHex": {
  "prefix": "SerialSendHex",
  "body": [
   "SerialSendHex($$comPort,$$sendValue);"
  ],
  "description": "\n\nSends the ASCII encoded character equivalent of the $sendValue parameter.\n\n\n\nNOTE:\n\nThis function has been deprecated. Please use the Serial_Open, Serial_SendHex functions.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$comPort\n\nObject\n\nAn instance of a SerialPort object created with the SerialOpen function.\n\n\n\n$sendValue\n\nInteger\n\nThe integer value of the ASCII character to send of the Serial port.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n\n\n\n\n// Get a reference to the COM port.\n\n$comPort = 3;\n\n$baudRate = 9600;\n\n$byteSize = 8;\n\n$parity = \"N\";\n\n$stopBits = 1;\n\n$comObject = SerialOpen($comPort, $baudRate, $byteSize, $parity, $stopBits);\n\n\n\n\n\n// now send our character (the space character).\n\n$charToSend = 32;\n\nSerialSendHex($comObject, $charToSend);\n\n\n\n\n\nSerialSendMilliseconds\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SerialSendMilliseconds": {
  "prefix": "SerialSendMilliseconds",
  "body": [
   "$$receiveBuffer=SerialSendMilliseconds($$comPort,$$sendString,$$waitString,$$timeOut);"
  ],
  "description": "\n\nSends the $sendString via the $comPort parameter. The function will then wait for the $waitString to be received on the serial port. If the waitString is not found within the $timeOut parameter specified, the function will return a failure. Both the $sendString and the $waitString can be set to an empty string. Before using a serial port, it first must be opened with the SerialOpen function. After use of the serial port is completed, it should be closed with the SerialClose function.\n\n\n\nNOTE:\n\nThis function has been deprecated. Please use the Serial_Open, Serial_SendMilliseconds functions.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$comPort\n\nObject\n\nAn instance of a SerialPort object created with the SerialOpen function.\n\n\n\n$sendString\n\nString\n\nThe string to be sent via the comPort.\n\n\n\n$waitString\n\nString\n\nThe string to wait for in response before continuing. This can be set to an empty string, in which case the test will send the $sendString and wait the $timeOut time.\n\n\n\n$timeOut\n\nInteger\n\nThe number of milliseconds to wait for the $waitString parameter before generating a failure.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$receiveBuffer\n\nString\n\nAll the characters that have been received on the serial Port since the $sendString had been sent.\n\n\n\n\n\nExample:\n\n// Get a reference to the COM port.\n\n$comPort = 3;\n\n$baudRate = 9600;\n\n$byteSize = 8;\n\n$parity = \"N\";\n\n$stopBits = 1;\n\n$comObject = SerialOpen($comPort, $baudRate, $byteSize, $parity, $stopBits);\n\n\n\n\n\n// Now send our string and wait 1 second (1000 milliseconds).\n\n$receiveBuffer = SerialSendMilliseconds($comObject, \"Hello\", \"\", 1000);\n\n\n\n\n\nSerialSendMillisecondsBool\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SerialSendMillisecondsBool": {
  "prefix": "SerialSendMillisecondsBool",
  "body": [
   "($$receiveBuffer,$$WaitStringFound)=SerialSendMillisecondsBool($$comPort,$$sendString,$$waitString,$$timeOut);"
  ],
  "description": "\n\nSends the $sendString via the $comPort parameter. The function will then wait for the $waitString to be received on the serial port. If the waitString is not found within the $timeOut parameter specified, the function will return a passing result, but set the $WaitStringFound return variable to 'False'. In the event that the wait string is found, the $WaitStringFound will be set to 'True'.\n\nBoth the $sendString and the $waitString can be set to an empty string. Before using a serial port, it first must be opened with the SerialOpen function. After use of the serial port is completed, it should be closed with the SerialClose function.\n\n\n\nNOTE:\n\nThis function has been deprecated. Please use the Serial_Open, Serial_SendMillisecondsBool functions.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$comPort\n\nObject\n\nAn instance of a SerialPort object created with the SerialOpen function.\n\n\n\n$sendString\n\nString\n\nThe string to be sent via the comPort.\n\n\n\n$waitString\n\nString\n\nThe string to wait for in response before continuing. This can be set to an empty string, in which case the test will send the $sendString and wait the $timeOut time.\n\n\n\n$timeOut\n\nInteger\n\nThe number of milliseconds to wait for the $waitString parameter before generating a failure.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$receiveBuffer\n\nString\n\nAll the characters that have been received on the serial Port since the $sendString had been sent.\n\n\n\n$WaitStringFound\n\nBoolean\n\nA boolean value indicating whether or not the wait string was found in the receive buffer.\n\n\n\n\n\nExample:\n\n// Get a reference to the COM port.\n\n$comPort = 3;\n\n$baudRate = 9600;\n\n$byteSize = 8;\n\n$parity = \"N\";\n\n$stopBits = 1;\n\n$comObject = SerialOpen($comPort, $baudRate, $byteSize, $parity, $stopBits);\n\n\n\n\n\n// Now send our string and wait 1 second (1000 milliseconds).\n\n($receiveBuffer, $WaitStringFound) = SerialSendMillisecondsBool($comObject, \"Hello\", \"\", 1000);\n\n\n\n\n\nSerialSendRawBinary\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SerialSendRawBinary": {
  "prefix": "SerialSendRawBinary",
  "body": [
   "$$receive=SerialSendRawBinary($$comPort,$$sendString,$$expectString,$$timeoutms);"
  ],
  "description": "\n\nWrites to the serial port and waits for the given response. Returns the receive buffer if the response is found before the timeout expires, fails otherwise.\n\n\n\n\n\nSend, receive, and expect strings are all raw byte data (formatted as space-separated hexadecimal values). This makes these functions useful when the character encoding of the serial data is unknown.\n\n\n\n\n\nNote: If the response is found, the receive buffer will contain all data up to the expected response.\n\n\n\n\n\nNOTE:\n\nThis function has been deprecated. Please use the Serial_Open, Serial_SendBinary functions.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$comPort\n\nObject\n\nAn instance of a SerialPort object created with the SerialOpen function.\n\n\n\n$sendString\n\nString\n\nThe string of space-separated HEX values to be sent via the comPort.\n\n\n\n$expectString\n\nString\n\nThe string (represented as a series of space-separated HEX values) to wait for in response before continuing. This can be set to an empty string, in which case the test will send the $sendString and wait the $timeOut time.\n\n\n\n$timeoutms\n\nInteger\n\nThe number of milliseconds to wait for the $waitString parameter before generating a failure.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$receive\n\nString\n\nAll the characters that have been received on the serial Port since the $sendString had been sent.\n\n\n\n\n\nExample:\n\n\n\n\n\n//sends \""
 }
,
 "JTS SerialSendRawBinaryBool": {
  "prefix": "SerialSendRawBinaryBool",
  "body": [
   "($$found,$$receive)=SerialSendRawBinaryBool($$comPort,$$sendString,$$expectString,$$timeoutms);"
  ],
  "description": "\n\nWrites to the serial port and waits for the given response. Returns the receive buffer and true if the response is found before the timeout expires, false otherwise.\n\n\n\n\n\nSend, receive, and expect strings are all raw byte data (formatted as space-separated hexadecimal values). This makes these functions useful when the character encoding of the serial data is unknown.\n\n\n\n\n\nNote: If the response is found, the receive buffer will contain all data up to the expected response. If the response is not found before the timeout expires, the receive buffer will still contain all data received up until the timeout.\n\n\n\n\n\nNOTE:\n\nThis function has been deprecated. Please use the Serial_Open, Serial_SendBinaryBool functions.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$comPort\n\nObject\n\nAn instance of a SerialPort object created with the SerialOpen function.\n\n\n\n$sendString\n\nString\n\nThe string of space-separated HEX values to be sent via the comPort.\n\n\n\n$expectString\n\nString\n\nThe string (represented as a series of space-separated HEX values) to wait for in response before continuing. This can be set to an empty string, in which case the test will send the $sendString and wait the $timeOut time.\n\n\n\n$timeoutms\n\nInteger\n\nThe number of milliseconds to wait for the $waitString parameter before generating a failure.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$found\n\nBoolean\n\nTrue if the expected response was received before the timeout, false otherwise.\n\n\n\n$receive\n\nString\n\nAll the characters that have been received on the serial Port since the $sendString had been sent.\n\n\n\n\n\nExample:\n\n\n\n\n\n//sends \""
 }
,
 "JTS SerialSendWithDelays": {
  "prefix": "SerialSendWithDelays",
  "body": [
   "$$receiveBuffer=SerialSendWithDelays($$comPort,$$sendString,$$waitString,$$timeOut,$$DelayMS);"
  ],
  "description": "\n\nSends the $sendString via the $comPort parameter. The function will then wait for the $waitString to be received on the serial port. If the waitString is not found within the $timeOut parameter specified, the function will return a failure. Both the $sendString and the $waitString can be set to an empty string. Before using a serial port, it first must be opened with the SerialOpen function. After use of the serial port is completed, it should be closed with the SerialClose function.\n\nThis function differs from the traditional SerialSend command because it inserts a delay specified by the $DelayMS argument between each character that is sent out of the serial port. This function is useful for DUT's that don't support a proper FIFO buffer and aren't able to process characters sent at the native baud rate setting of the serial port. The $DelayMS parameter is specified in milliseconds.\n\n\n\nNOTE:\n\nThis function has been deprecated. Please use the Serial_Open, Serial_SendWithDelays functions.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$comPort\n\nObject\n\nAn instance of a Serial Port object created with the SerialOpen function.\n\n\n\n$sendString\n\nString\n\nThe string to be sent via the Com Port.\n\n\n\n$waitString\n\nString\n\nThe string to wait for in response before continuing. This can be set to an empty string, in which case, the function will send the $sendString and wait the $timeOut time.\n\n\n\n$timeOut\n\nInteger\n\nThe number of milliseconds to wait for the $waitString before generating a failure.\n\n\n\n$DelayMS\n\nInteger\n\nThe number of milliseconds to delay between sending each character.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$receiveBuffer\n\nString\n\nAll the characters that have been received on the serial port since the $sendString was sent.\n\n\n\n\n\nExample:\n\n\n\n\n\n$Received = SerialSendWithDelays($ComPort, \"ls\\r\", \">\", 1, 100); // Waits 100 Milliseconds between characters\n\n\n\n\n\nSerialSendWithLogging\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SerialSendWithLogging": {
  "prefix": "SerialSendWithLogging",
  "body": [
   "$$receiveBuffer=SerialSendWithLogging($$comPort,$$sendString,$$waitString,$$timeOut);"
  ],
  "description": "\n\nSends the $sendString via the $comPort parameter. The function will then wait for the $waitString to be received on the serial port. If the waitString is not found within the $timeOut parameter specified, the function will return a failure. Both the $sendString and the $waitString can be set to an empty string. Before using a serial port, it first must be opened with the SerialOpen function. After use of the serial port is completed, it should be closed with the SerialClose function.\n\n\n\n\n\nImportant Note: The SerialSendWithLogging function is only compatible with a serial port that has been opened using the SerialOpenWithLogging function. If the serial port was opened with the SerialOpen function, you should use the standard SerialSend command.\n\n\n\n\n\nNOTE:\n\nThis function has been deprecated. Please use the Serial_Open, Serial_SendWithLogging functions.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$comPort\n\nObject\n\nAn instance of a Serial Port object created with the SerialOpen function.\n\n\n\n$sendString\n\nString\n\nThe string to be sent via the Com Port.\n\n\n\n$waitString\n\nString\n\nThe string to wait for in response before continuing. This can be set to an empty string, in which case, the function will send the $sendString and wait the $timeOut time.\n\n\n\n$timeOut\n\nInteger\n\nThe number of milliseconds to wait for the $waitString before generating a failure.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$receiveBuffer\n\nString\n\nAll the characters that have been received on the serial port since the $sendString was sent.\n\n\n\n\n\nExamples::\n\n$Com = SerialOpenWithLogging(1, 9600, 8, \"N\", 1, \"c:\\\\log.txt\");\n\nSetFinalizeFunction(\"CloseCom\");\n\nSerialSendWithLogging($Com, \"\\r\\r\", \">\", 2);\n\nSerialSendWithLogging($Com, \"en\\r\", \"assword:\", 2);\n\nSerialSendWithLogging($Com, \"c\\r\", \"#\", 2);\n\nSerialSendWithLogging($Com, \"exit\\r\", \"started.\", 2);\n\nEnd;\n\n\n\n\n\nfunction CloseCom()\n\n{\n\nSerialCloseWithLogging($Com);\n\nEnd;\n\n}\n\n\n\n\n\nSerialXModem1KReceive\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SerialXModem1KReceive": {
  "prefix": "SerialXModem1KReceive",
  "body": [
   "$$ReturnValue=SerialXModem1KReceive($$comPort,$$FileName,$$TimeOut,$$TimeofRetries);"
  ],
  "description": "\n\nReceives packets of information over the com port specified by $comPort and writes the packets to the specified file $FileName using Xmodem 1K file transfer protocol. Before using a serial port, it first must be opened with the SerialOpen function.\n\n\n\n\n\nResult:\n\n0 if the file be received successfully test produces a pass.\n\n-1 if canceled by remote.\n\n-2 if Synchronization error.\n\n-3 if too many retries error.\n\nRemarks:\n\nThis function was tested with Hyper Terminal.\n\nThis function use Xmodem 1K protocol with 1024 byte packet size and CRC16-CCITT error check.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$comPort\n\nObject\n\nAn instance of a Serial Port object created with the SerialOpen function.\n\n\n\n$FileName\n\nString\n\nPath and file name of the file to save.\n\n\n\n$TimeOut\n\nInteger\n\nSpecifies the interval (in seconds) during which to send the initial handshake character to the transmitter. The character is sent every $TimeOut seconds, up to $TimeofRetries times.\n\n\n\n$TimeofRetries\n\nInteger\n\nSets the maximum number of times for handshake and packet receive.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ReturnValue\n\nInteger\n\nThe result of the test\n\n\n\n\n\nExample:\n\n// Receive the file using XModem 1K protocol.\n\n$fileName = \"C:\\\\Temp\\\\ReceiveFile.bin\";\n\n$comPort = 3;\n\n$baudRate = 9600;\n\n$byteSize = 8;\n\n$parity = \"N\";\n\n$stopBits = 1;\n\n$comPort = SerialOpen($comPort, $baudRate, $byteSize, $parity, $stopBits);\n\n\n\n\n\n// Get the file. Handshake 1 second intervals for 10 times.\n\n$result = SerialXModem1KReceive($comPort, $fileName, 1, 10);\n\n\n\n\n\nSerialXModem1KSend\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SerialXModem1KSend": {
  "prefix": "SerialXModem1KSend",
  "body": [
   "($$ReturnValue,$$numBytes)=SerialXModem1KSend($$comPort,$$FileName,$$TimeOut,$$TimeofRetries);"
  ],
  "description": "\n\nReads data from $FileName file and sends it in packets over the com port specified by $comPort using Xmodem 1K file transfer protocol. This function uses an internal 30 seconds timeout for handshaking. Before using a serial port, it first must be opened with the SerialOpen function.\n\n\n\n\n\nResult:\n\n0 if the file be sent successfully and test produces a pass.\n\n-1 if cancel by remote.\n\n-2 if handshaking fail.\n\n-3 if Exceed the $TimeofRetries\n\n-4 if unknown error exists.\n\n\n\n\n\nRemarks:\n\n\u00b7 This function is tested with HyperTerminal\n\n\u00b7 This function uses the XModem 1K protocol with 1024 byte packet size and CRC16-CCITT error checking.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$comPort\n\nObject\n\nAn instance of a Serial Port object created with the SerialOpen function.\n\n\n\n$FileName\n\nString\n\nPath and file name of the file to send.\n\n\n\n$TimeOut\n\nInteger\n\nSpecifies the interval (in seconds) during which to send the initial handshake character to the transmitter. The character is sent every $TimeOut seconds, up to $TimeofRetries times.\n\n\n\n$TimeofRetries\n\nInteger\n\nSets the maximum number of times for handshake and packet receive.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ReturnValue\n\nInteger\n\nThe result of the test\n\n\n\n\n\nExample:\n\n// Send the file using XModem 1K protocol.\n\n$fileName = \"C:\\\\Temp\\\\ReceiveFile.bin\";\n\n$comPort = 3;\n\n$baudRate = 9600;\n\n$byteSize = 8;\n\n$parity = \"N\";\n\n$stopBits = 1;\n\n$comPort = SerialOpen($comPort, $baudRate, $byteSize, $parity, $stopBits);\n\n\n\n\n\n// Send the file. Handshake 1 second intervals for 10 times.\n\n($result, $numBytes) = SerialXModem1KSend($comPort, $fileName, 1, 10);\n\n\n\n\n\nModbusTCP_Close\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ModbusTCP_Close": {
  "prefix": "ModbusTCP_Close",
  "body": [
   "ModbusTCP_Close($$modbusHandle);"
  ],
  "description": "\n\nThis function will close a TCP connection that was opened with ModbusTCP_Init.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$modbusHandle\n\nObject\n\nThe Modbus instance pointer opened previously.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone.\n\n\n\n\n\nExample:\n\n// Set up the address and port.\n\n$serverAddr = \"192.168.1.1\";\n\n$portNum = 502;\n\n$modbusHandle = ModbusTCP_Init($serverAddr, $portNum);\n\n\n\n\n\nModbusTCP_Close($modbusHandle);\n\n\n\n\n\nModbusTCP_Init\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ModbusTCP_Init": {
  "prefix": "ModbusTCP_Init",
  "body": [
   "$$modbusHandle=ModbusTCP_Init($$serverAddr,$$portNum);"
  ],
  "description": "\n\nThis function will open a TCP connection to the specified server at the specified port.\n\n\n\n\n\nRemarks:\n\n\u00b7 TCP port number default is 502. Use 502 as the port number unless you know it has been changed.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$serverAddr\n\nString\n\nThe IP Address (eg. 192.168.1.1) or server name\n\n\n\n$portNum\n\nInteger\n\nThe port number to connect to.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$modbusHandle\n\nObject\n\nA pointer to this instance of the modbusTCP driver.\n\n\n\n\n\nExample:\n\n// Set up the address and port.\n\n$serverAddr = \"192.168.1.1\";\n\n$portNum = 502;\n\n$modbusHandle = ModbusTCP_Init($serverAddr, $portNum);\n\n\n\n\n\nModbusTCP_ReadCoilStatus\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ModbusTCP_ReadCoilStatus": {
  "prefix": "ModbusTCP_ReadCoilStatus",
  "body": [
   "$$coilArray=ModbusTCP_ReadCoilStatus($$mbHandle,$$instrAddr,$$startAddr,$$numCoils);"
  ],
  "description": "\n\nThis function will query the Modbus instrument and return a number of coil statuses as a boolean array.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$mbHandle\n\nObject\n\nThe Modbus instance pointer opened previously with ModbusTCP_Init.\n\n\n\n$instrAddr\n\nInteger\n\nThe address of the instrument to query (only used for slave devices connected to a server).\n\n\n\n$startAddr\n\nInteger\n\nThe starting address of the coils to return the status of. Must be in the range of 0 to 9999.\n\n\n\n$numCoils\n\nInteger\n\nThe number of coils to return the status of. $startAddr + $numCoils must be less than 10000.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$coilArray\n\nArray\n\nAn array of booleans indicating the status of the requested coils.\n\n\n\n\n\nExample:\n\n// Set up the address and port.\n\n$serverAddr = \"192.168.1.1\";\n\n$portNum = 502;\n\n$mbHandle = ModbusTCP_Init($serverAddr, $portNum);\n\n\n\n\n\n$instrAddr = 17;\n\n$startAddr = 10;\n\n$numCoils = 57;\n\n$coilArray = ModbusTCP_ReadCoilStatus($mbHandle, $instrAddr, $startAddr, $numCoils);\n\n\n\n\n\nModbusTCP_ReadDeviceID\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ModbusTCP_ReadDeviceID": {
  "prefix": "ModbusTCP_ReadDeviceID",
  "body": [
   "$$deviceID=ModbusTCP_ReadDeviceID($$mbHandle,$$instrAddr,$$idItem);"
  ],
  "description": "\n\nThis function will return the requested ID item for the instrument.\n\n\n\n\n\nRemarks:\n\n\u00b7 Only the first 3 items (VendorName, ProductCode and MajorMinorRevision) are required by the Modbus specification. The other items may be included at the manufacturer's discretion.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$mbHandle\n\nObject\n\nThe Modbus instance pointer opened previously with ModbusTCP_Init.\n\n\n\n$instrAddr\n\nInteger\n\nThe address of the instrument to write to (only used for slave devices connected to a server).\n\n\n\n$idItem\n\nString\n\nThe ID item to return. Valid items are:\n\n\u00b7 \"VENDOR\" (vendor name)\n\n\u00b7 \"CODE\" (product code)\n\n\u00b7 \"REVISION\" (product major/minor revision)\n\n\u00b7 \"URL\" (vendor URL)\n\n\u00b7 \"PRODUCT\" (product name)\n\n\u00b7 \"MODEL\" (model name)\n\n\u00b7 \"APPLICATION\" (application name)\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$deviceID\n\nString\n\nThe requested device ID item.\n\n\n\n\n\nExample:\n\n// Set up the address and port.\n\n$serverAddr = \"192.168.1.1\";\n\n$portNum = 502;\n\n$mbHandle = ModbusTCP_Init($serverAddr, $portNum);\n\n\n\n\n\n// Get the Vendor Name for this instrument.\n\n$instrAddr = 17;\n\n$idItem = \"VENDOR\";\n\n$vendName = ModbusTCP_ReadDeviceID($mbHandle, $instrAddr, $idItem);\n\n\n\n\n\nModbusTCP_ReadHoldingRegisters\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ModbusTCP_ReadHoldingRegisters": {
  "prefix": "ModbusTCP_ReadHoldingRegisters",
  "body": [
   "$$regArray=ModbusTCP_ReadHoldingRegisters($$mbHandle,$$instrAddr,$$startAddr,$$numRegs);"
  ],
  "description": "\n\nThis function will query the Modbus instrument and return a number of values from the holding registers as an array of integers.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$mbHandle\n\nObject\n\nThe Modbus instance pointer opened previously with ModbusTCP_Init.\n\n\n\n$instrAddr\n\nInteger\n\nThe address of the instrument to query (only used for slave devices connected to a server).\n\n\n\n$startAddr\n\nInteger\n\nThe starting address of the registers to return the value of. Must be in the range of 40000 to 49999.\n\n\n\n$numRegs\n\nInteger\n\nThe number of registers to return the value of. $startAddr + $numRegs must be less than 50000.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$regArray\n\nArray\n\nAn array of integers holding the values of the requested registers.\n\n\n\n\n\nExample:\n\n// Set up the address and port.\n\n$serverAddr = \"192.168.1.1\";\n\n$portNum = 502;\n\n$mbHandle = ModbusTCP_Init($serverAddr, $portNum);\n\n\n\n\n\n$instrAddr = 17;\n\n$startAddr = 40003;\n\n$numRegs = 57;\n\n$regArray = ModbusTCP_ReadHoldingRegisters($mbHandle, $instrAddr, $startAddr, $numRegs);\n\n\n\n\n\nModbusTCP_ReadInputRegisters\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ModbusTCP_ReadInputRegisters": {
  "prefix": "ModbusTCP_ReadInputRegisters",
  "body": [
   "$$regArray=ModbusTCP_ReadInputRegisters($$mbHandle,$$instrAddr,$$startAddr,$$numRegs);"
  ],
  "description": "\n\nThis function will query the Modbus instrument and return a number of values from the input registers as an array of integers.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$mbHandle\n\nObject\n\nThe Modbus instance pointer opened previously with ModbusTCP_Init.\n\n\n\n$instrAddr\n\nInteger\n\nThe address of the instrument to query (only used for slave devices connected to a server).\n\n\n\n$startAddr\n\nInteger\n\nThe starting address of the registers to return the value of. Must be in the range of 30000 to 39999.\n\n\n\n$numRegs\n\nInteger\n\nThe number of registers to return the value of. $startAddr + $numRegs must be less than 40000.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$regArray\n\nArray\n\nAn array of integers holding the values of the requested registers.\n\n\n\n\n\nExample:\n\n// Set up the address and port.\n\n$serverAddr = \"192.168.1.1\";\n\n$portNum = 502;\n\n$mbHandle = ModbusTCP_Init($serverAddr, $portNum);\n\n\n\n\n\n$instrAddr = 17;\n\n$startAddr = 30010;\n\n$numRegs = 57;\n\n$regArray = ModbusTCP_ReadInputRegisters($mbHandle, $instrAddr, $startAddr, $numRegs);\n\n\n\n\n\nModbusTCP_ReadInputStatus\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ModbusTCP_ReadInputStatus": {
  "prefix": "ModbusTCP_ReadInputStatus",
  "body": [
   "$$inpArray=ModbusTCP_ReadInputStatus($$mbHandle,$$instrAddr,$$startAddr,$$numInputs);"
  ],
  "description": "\n\nThis function will query the Modbus instrument and return a number of discrete digital input statuses as a boolean array.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$mbHandle\n\nObject\n\nThe Modbus instance pointer opened previously with ModbusTCP_Init.\n\n\n\n$instrAddr\n\nInteger\n\nThe address of the instrument to query (only used for slave devices connected to a server).\n\n\n\n$startAddr\n\nInteger\n\nThe starting address of the inputs to return the status of. Must be in the range of 10000 to 19999.\n\n\n\n$numInputs\n\nInteger\n\nThe number of inputs to return the status of. $startAddr + $numInputs must be less than 20000.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$inpArray\n\nArray\n\nAn array of booleans indicating the status of the requested inputs.\n\n\n\n\n\nExample:\n\n// Set up the address and port.\n\n$serverAddr = \"192.168.1.1\";\n\n$portNum = 502;\n\n$mbHandle = ModbusTCP_Init($serverAddr, $portNum);\n\n\n\n\n\n$instrAddr = 17;\n\n$startAddr = 10003;\n\n$numInputs = 57;\n\n$inpArray = ModbusTCP_ReadInputStatus($mbHandle, $instrAddr, $startAddr, $numInputs);\n\n\n\n\n\nModbusTCP_WriteMultipleCoils\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ModbusTCP_WriteMultipleCoils": {
  "prefix": "ModbusTCP_WriteMultipleCoils",
  "body": [
   "$$numWritten=ModbusTCP_WriteMultipleCoils($$mbHandle,$$instrAddr,$$startAddr,$$coilArray);"
  ],
  "description": "\n\nThis function will write the status of a number of coils to the instrument.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$mbHandle\n\nObject\n\nThe Modbus instance pointer opened previously with ModbusTCP_Init.\n\n\n\n$instrAddr\n\nInteger\n\nThe address of the instrument to write to (only used for slave devices connected to a server).\n\n\n\n$startAddr\n\nInteger\n\nThe starting address of the coils to write to. Must be in the range of 0 to 9999.\n\n\n\n$coilArray\n\nArray\n\nAn array of boolean values to set the coils to. Note: a string array with \"ON\", TRUE\", \"1\", or \"T\" for each coil will work as well.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$numWritten\n\nInteger\n\nThe number of coils that were written to.\n\n\n\n\n\nExample:\n\n// Set up the address and port.\n\n$serverAddr = \"192.168.1.1\";\n\n$portNum = 502;\n\n$mbHandle = ModbusTCP_Init($serverAddr, $portNum);\n\n\n\n\n\n// Turn on coils 10 to 19 (10 coils total).\n\n$instrAddr = 17;\n\n$startAddr = 10;\n\n$coilArray = Array1DCreate(\"BOOLEAN\", 10);\n\n$coilCount = 0;\n\nwhile ($coilCount < 10)\n\n{\n\nArray1DSetValue($coilArray, $coilCount, true);\n\n$coilCount = $coilCount + 1;\n\n}\n\n$numWritten = ModbusTCP_WriteMultipleCoils($mbHandle, $instrAddr, $startAddr, $coilArray);\n\n\n\n\n\nModbusTCP_WriteMultipleCoilsHex\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ModbusTCP_WriteMultipleCoilsHex": {
  "prefix": "ModbusTCP_WriteMultipleCoilsHex",
  "body": [
   "$$numWritten=ModbusTCP_WriteMultipleCoilsHex($$mbHandle,$$instrAddr,$$startAddr,$$coilStr);"
  ],
  "description": "\n\nThis function will write the status of a number of coils to the instrument. All numbers and the status are represented as hexadecimal numbers contained in strings.\n\n\n\n\n\nRemarks\n\n\u00b7 The values sent are big-endian. ie. The high bytes and high bits are on the left, the low bytes and low bits are on the right.\n\neg. A5A5 5A5A in binary is: 1010010110100101 101101001011010\n\nThis number will set 32 coils, with bit 0 being on the right (a '0') and bit 31 on the left (a '1').\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$mbHandle\n\nObject\n\nThe Modbus instance pointer opened previously with ModbusTCP_Init.\n\n\n\n$instrAddr\n\nString\n\nThe address of the instrument to write to (only used for slave devices connected to a server) in hexadecimal.\n\n\n\n$startAddr\n\nString\n\nThe starting address of the coils to write to. Must be in the range of 0 to 0x270F.\n\n\n\n$coilStr\n\nString\n\nA string with bit-encoded hexadecimal values to set the coils to. For each bit, a 1 sets the coil on and a 0 sets the coil off.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$numWritten\n\nInteger\n\nThe number of coils that were written to.\n\n\n\n\n\nExample:\n\n// Set up the address and port.\n\n$serverAddr = \"192.168.1.1\";\n\n$portNum = 502;\n\n$mbHandle = ModbusTCP_Init($serverAddr, $portNum);\n\n\n\n\n\n// Turn on coils 10 to 19 (10 coils total).\n\n$instrAddr = \"11\";\n\n$startAddr = \"0A\";\n\n$coilStr = \"3F28CA5\";\n\n$numWritten = ModbusTCP_WriteMultipleCoilsHex($mbHandle, $instrAddr, $startAddr, $coilStr);\n\n\n\n\n\nModbusTCP_WriteMultipleRegisters\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ModbusTCP_WriteMultipleRegisters": {
  "prefix": "ModbusTCP_WriteMultipleRegisters",
  "body": [
   "$$numWritten=ModbusTCP_WriteMultipleRegisters($$mbHandle,$$instrAddr,$$startAddr,$$regArray);"
  ],
  "description": "\n\nThis function will write values to a number of holding registers on the instrument.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$mbHandle\n\nObject\n\nThe Modbus instance pointer opened previously with ModbusTCP_Init.\n\n\n\n$instrAddr\n\nInteger\n\nThe address of the instrument to query (only used for slave devices connected to a server).\n\n\n\n$startAddr\n\nInteger\n\nThe starting address of the registers to write to. Must be in the range of 40000 to 49999.\n\n\n\n$regArray\n\nArray\n\nAn array of integer values to set the registers to. $startAddr + numberOfRegisters can not exceed 50000. Integers can not exceed the value of 16 bits or 65535.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$numWritten\n\nInteger\n\nThe number of registers that were written to.\n\n\n\n\n\nExample:\n\n// Set up the address and port.\n\n$serverAddr = \"192.168.1.1\";\n\n$portNum = 502;\n\n$mbHandle = ModbusTCP_Init($serverAddr, $portNum);\n\n\n\n\n\n// Set values in the registers 40010 to 40019 (10 total).\n\n$instrAddr = 17;\n\n$startAddr = 40010;\n\n$regArray = Array1DCreate(\"INTEGER\", 10);\n\n$regCount = 0;\n\nwhile ($coilCount < 10)\n\n{\n\n$tempNum = GetRandomInteger(0, 65536); // Note: that the upper bound in non-inclusive.\n\nArray1DSetValue($coilArray, $regCount, $tempNum);\n\n$regCount = $regCount + 1;\n\n}\n\n$numWritten = ModbusTCP_WriteMultipleRegisters($mbHandle, $instrAddr, $startAddr, $regArray);\n\n\n\n\n\nModbusTCP_WriteMultipleRegistersHex\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ModbusTCP_WriteMultipleRegistersHex": {
  "prefix": "ModbusTCP_WriteMultipleRegistersHex",
  "body": [
   "$$numWritten=ModbusTCP_WriteMultipleRegistersHex($$mbHandle,$$instrAddr,$$startAddr,$$regStr);"
  ],
  "description": "\n\nThis function will write values to a number of holding registers on the instrument. The values are represented by a series of 16 bit (2 byte) hexadecimal number with spaces between them.\n\n\n\n\n\nRemarks:\n\n\u00b7 The values sent are big-endian. ie. The high bytes and high bits are on the left, the low bytes and low bits are on the right.\n\neg. A5A5 5A5A will set the first register to 5A5A and the second register to A5A5.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$mbHandle\n\nObject\n\nThe Modbus instance pointer opened previously with ModbusTCP_Init.\n\n\n\n$instrAddr\n\nString\n\nThe address of the instrument to write to in hexadecimal (only used for slave devices connected to a server).\n\n\n\n$startAddr\n\nString\n\nThe starting address of the registers to write to. Must be in the range of 0x9C40 to 0xC350.\n\n\n\n$regAStr\n\nString\n\nAn string of integer values with spaces between them to set the registers to. $startAddr + numberOfRegisters can not exceed 0xC351. Integers can not exceed the value of 16 bits or 0xFFFF.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$numWritten\n\nInteger\n\nThe number of registers that were written to.\n\n\n\n\n\nExample:\n\n// Set up the address and port.\n\n$serverAddr = \"192.168.1.1\";\n\n$portNum = 502;\n\n$mbHandle = ModbusTCP_Init($serverAddr, $portNum);\n\n\n\n\n\n// Set values in the registers 40010 to 40019 (10 total).\n\n$instrAddr = \"11\";\n\n$startAddr = \"9C4A\";\n\n$regStr = \"FDCA 3FB8 5486 ABC9 0FCE 34AB CBCB B67A 98F0 2A3D\";\n\n$numWritten = ModbusTCP_WriteMultipleRegistersHex($mbHandle, $instrAddr, $startAddr, $regStr);\n\n\n\n\n\nModbusTCP_WriteSingleCoil\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ModbusTCP_WriteSingleCoil": {
  "prefix": "ModbusTCP_WriteSingleCoil",
  "body": [
   "ModbusTCP_WriteSingleCoil($$mbHandle,$$instrAddr,$$coilAddr,$$coilStatus);"
  ],
  "description": "\n\nThis function will write the status to a single coil on the instrument.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$mbHandle\n\nObject\n\nThe Modbus instance pointer opened previously with ModbusTCP_Init.\n\n\n\n$instrAddr\n\nInteger\n\nThe address of the instrument to write to (only used for slave devices connected to a server).\n\n\n\n$coilAddr\n\nInteger\n\nThe address of the coil to write to. Must be in the range of 0 to 9999.\n\n\n\n$coilStatus\n\nString\n\nThe status to write to the coil. If the status is \"ON\", \"1\", \"TRUE\", \"T\", the coil will be turned on. Otherwise, the coil will be turned off.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone.\n\n\n\n\n\nExample:\n\n// Set up the address and port.\n\n$serverAddr = \"192.168.1.1\";\n\n$portNum = 502;\n\n$mbHandle = ModbusTCP_Init($serverAddr, $portNum);\n\n\n\n\n\n// Turn on coil 10.\n\n$instrAddr = 17;\n\n$coilAddr = 10;\n\n$coilStatus = \"ON\";\n\nModbusTCP_WriteSingleCoil($mbHandle, $instrAddr, $coilAddr, $coilStatus);\n\n\n\n\n\nModbusTCP_WriteSingleRegister\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ModbusTCP_WriteSingleRegister": {
  "prefix": "ModbusTCP_WriteSingleRegister",
  "body": [
   "ModbusTCP_WriteSingleRegister($$mbHandle,$$instrAddr,$$regAddr,$$regValue);"
  ],
  "description": "\n\nThis function will write the value to a single holding register on the instrument.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$mbHandle\n\nObject\n\nThe Modbus instance pointer opened previously with ModbusTCP_Init.\n\n\n\n$instrAddr\n\nInteger\n\nThe address of the instrument to write to (only used for slave devices connected to a server).\n\n\n\n$regAddr\n\nInteger\n\nThe address of the register to write to. Must be in the range of 40000 to 49999.\n\n\n\n$regValue\n\nInteger\n\nThe value to write to the register. Must be between 0 and 65535.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone.\n\n\n\n\n\nExample:\n\n// Set up the address and port.\n\n$serverAddr = \"192.168.1.1\";\n\n$portNum = 502;\n\n$mbHandle = ModbusTCP_Init($serverAddr, $portNum);\n\n\n\n\n\n// Send Value to register at 40010.\n\n$instrAddr = 17;\n\n$regAddr = 40010;\n\n$regValue = 45357;\n\nModbusTCP_WriteSingleRegister($mbHandle, $instrAddr, $regAddr, $regValue);\n\n\n\n\n\nModbusTCP_WriteSingleRegisterHex\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ModbusTCP_WriteSingleRegisterHex": {
  "prefix": "ModbusTCP_WriteSingleRegisterHex",
  "body": [
   "ModbusTCP_WriteSingleRegisterHex($$mbHandle,$$instrAddr,$$regAddr,$$regStr);"
  ],
  "description": "\n\nThis function will write the value to a single holding register on the instrument.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$mbHandle\n\nObject\n\nThe Modbus instance pointer opened previously with ModbusTCP_Init.\n\n\n\n$instrAddr\n\nString\n\nThe address of the instrument to write to in hexadecimal (only used for slave devices connected to a server).\n\n\n\n$regAddr\n\nString\n\nThe address of the register to write to in hexadecimal. Must be in the range of 0x9C40 to 0xC350.\n\n\n\n$regStr\n\nString\n\nThe value to write to the holding register in hexadecimal. Must be in the range of 0x0 to 0xFFFF.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone.\n\n\n\n\n\nExample:\n\n// Set up the address and port.\n\n$serverAddr = \"192.168.1.1\";\n\n$portNum = 502;\n\n$mbHandle = ModbusTCP_Init($serverAddr, $portNum);\n\n\n\n\n\n// Send Value to register at 40010.\n\n$instrAddr = \"11\";\n\n$regAddr = \"9C4A\";\n\n$regStr = \"4FAB\";\n\nModbusTCP_WriteSingleRegisterHex($mbHandle, $instrAddr, $regAddr, $regStr);\n\n\n\n\n\nOPCReadItem\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OPCReadItem": {
  "prefix": "OPCReadItem",
  "body": [
   "$$return=OPCReadItem($$OPCSrvHandle,$$itemID,$$dataSource);"
  ],
  "description": "\n\nThis function will read a value from an OPC Data Server. The returned data will be one of: Byte, Byte Array, Integer or Float. The Byte and Byte Array data types will be returned in a hex string variable.\n\n\n\n\n\nRemarks:\n\nIf the value is a byte, the data will be in a hex string. Example: \"FF\".\n\nIf the value is a byte array, the data will be in a space delimited hex string. Example: \"FF 4D 5E\".\n\nBefore using this command, you should use an OPC Data Server Explorer program to check the data item availability and type.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$OPCSrvHandle\n\nObject\n\nA handle to an OPC server that was opened previously using OPCServerConnectLocal.\n\n\n\n$itemID\n\nString\n\nThe item ID of the data to read.\n\n\n\n$dataSource\n\nString\n\nThe data source from the server. This must be either CACHE or DEVICE.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$return\n\nString, Float, Integer\n\nThe value returned from the OPC server.\n\n\n\n\n\nExample:\n\n\n\n\n\n// Set up the parameters.\n\n$OPCsrv = \"TestServer.OPC.6\";\n\n$item = \"Dev01\\\\G1\\\\D100.S.10\";\n\n$dSource = \"DEVICE\";\n\n\n\n\n\n// Open Communication\n\n$srvHandle = OPCServerConnectLocal($OPCsrv);\n\n\n\n\n\n// Read one item.\n\n$return = OPCReadItem($srvHandle, $item, $dSource);\n\n\n\n\n\nOPCServerConnectLocal\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OPCServerConnectLocal": {
  "prefix": "OPCServerConnectLocal",
  "body": [
   "$$OPCSrvHandle=OPCServerConnectLocal($$serverName);"
  ],
  "description": "\n\nThis function will create a connection to a local OPC server.\n\n\n\n\n\nRemarks:\n\nThis command ONLY supports local servers.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$serverName\n\nString\n\nThe name of the local OPC server to connect to.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$OPCSrvHandle\n\nObject\n\nA handle to the OPC server that can be passed to other OPC functions.\n\n\n\n\n\nExample:\n\n\n\n\n\n// Set up the parameters.\n\n$OPCsrv = \"TestServer.OPC.6\";\n\n$item = \"Dev01\\\\G1\\\\D100.S.10\";\n\n$dSource = \"DEVICE\";\n\n\n\n\n\n// Open Communication\n\n$srvHandle = OPCServerConnectLocal($OPCsrv);\n\n\n\n\n\nOPCServerDisconnect\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OPCServerDisconnect": {
  "prefix": "OPCServerDisconnect",
  "body": [
   "OPCServerDisconnect($$OPCSrvHandle);"
  ],
  "description": "\n\nThis function will disconnect from an OPC server.\n\n\n\n\n\nRemarks:\n\nIf the server connection has already been closed, this function will generate an error.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$OPCSrvHandle\n\nObject\n\nA handle to an OPC server.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n\n\n\n\nOPCServerDisconnect($OPCSrvHandle);\n\n\n\n\n\nOPCWriteItem\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OPCWriteItem": {
  "prefix": "OPCWriteItem",
  "body": [
   "OPCWriteItem($$OPCSrvHandle,$$itemID,$$value);"
  ],
  "description": "\n\nThis function will write a value to an OPC Data Server. The data will be one of: Byte, Byte Array, Integer or Float. The Byte and Byte Array data types should be in a hex string variable.\n\n\n\n\n\nRemarks:\n\nIf the value is a byte, the data will be in a hex string. Example: \"FF\".\n\nIf the value is a byte array, the data will be in a space delimited hex string. Example: \"FF 4D 5E\".\n\nBefore using this command, you should use an OPC Data Server Explorer program to check the data item availability and type.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$OPCSrvHandle\n\nObject\n\nA handle to an OPC server that was opened previously using OPCServerConnectLocal.\n\n\n\n$itemID\n\nString\n\nThe item ID of the data to write.\n\n\n\n$value\n\nString, Float, Integer\n\nThe data to send to the server.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n\n\n\n\n// Set up the parameters.\n\n$OPCsrv = \"TestServer.OPC.6\";\n\n$item = \"Dev01\\\\G1\\\\D100.S.10\";\n\n$data = \"FF D5 C8\";\n\n\n\n\n\n// Open Communication\n\n$srvHandle = OPCServerConnectLocal($OPCsrv);\n\n\n\n\n\n// Write the data.\n\nOPCWriteItem($srvHandle, $item, $data);\n\n\n\n\n\nSFTP_Close\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SFTP_Close": {
  "prefix": "SFTP_Close",
  "body": [
   "SFTP_Close($$sftpSession);"
  ],
  "description": "\n\nCloses SFTP connection, disposing of all resources.\n\n\n\nFunction Arguments\n\n\n\n\n\nParameter\n\n\n\nVariable Type\n\nDescription\n\n\n\n$sftpSession\n\n\n\nObject\n\nHandle to SFTP connection returned by the SFTP_Connect() function.\n\n\n\n\n\nReturn Parameters\n\n\n\n\n\nParameter\n\n\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n--\n\n\n\n\n\nExample:\n\nSFTP_Close($sftpSession);\n\n\n\n\n\nSFTP_Connect\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SFTP_Connect": {
  "prefix": "SFTP_Connect",
  "body": [
   "$$sftpSession=SFTP_Connect($$host,$$port,$$username,$$password,$$timeoutms);"
  ],
  "description": "\n\nOpens a new connection to the SFTP server and authenticates the user using password authentication method. Returns a handle to the connection.\n\n\n\nFunction Arguments\n\n\n\n\n\nParameter\n\n\n\nVariable Type\n\nDescription\n\n\n\n$host\n\nString\n\nHostname or IP address of server to connect to.\n\n\n\n$port\n\nInteger\n\nPort # server is listening on (typically 22).\n\n\n\n$username\n\nString\n\nName of user to login as.\n\n\n\n$password\n\nString\n\nUser's password.\n\n\n\n$timeoutms\n\nInteger\n\nTime to wait for successful connection, in milliseconds. Authentication can take additional time.\n\n\n\n\n\nReturn Parameters\n\n\n\n\n\nParameter\n\n\n\nVariable Type\n\nDescription\n\n\n\n$sftpSession\n\nObject\n\nHandle to SFTP connection.\n\n\n\n\n\nExample:\n\n$sftpSession = SFTP_Connect(\"localhost\", 22, \"root\", \"password123\", 5000); //connect to local SFTP server with a 5s timeout\n\n\n\n\n\nSFTP_ConnectBool\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SFTP_ConnectBool": {
  "prefix": "SFTP_ConnectBool",
  "body": [
   "($$success,$$sftpSession)=SFTP_ConnectBool($$host,$$port,$$username,$$password,$$timeoutms);"
  ],
  "description": "\n\nOpens a new connection to the SFTP server and authenticates the user using password authentication method. Returns whether the connection was successful and a handle to the connection.\n\n\n\n\n\nNote:\n\n\u00b7 A failed connection will not cause the test to fail. The boolean should be checked for a successful connection before attempting any other functions.\n\n\u00b7 An invalid log in name and password will still cause the test to fail.\n\n\n\nFunction Arguments\n\n\n\n\n\nParameter\n\n\n\nVariable Type\n\nDescription\n\n\n\n$host\n\nString\n\nHostname or IP address of server to connect to.\n\n\n\n$port\n\nInteger\n\nPort # server is listening on (typically 22).\n\n\n\n$username\n\nString\n\nName of user to login as.\n\n\n\n$password\n\nString\n\nUser's password.\n\n\n\n$timeoutms\n\nInteger\n\nTime to wait for successful connection, in milliseconds. Authentication can take additional time.\n\n\n\n\n\nReturn Parameters\n\n\n\n\n\nParameter\n\n\n\nVariable Type\n\nDescription\n\n\n\n$success\n\nBoolean\n\nWhether the connection was successful\n\n\n\n$sftpSession\n\nObject\n\nHandle to SFTP connection.\n\n\n\n\n\nExample:\n\n//connect to local SFTP server with a 5s timeout\n\n($success, $sftpSession) = SFTP_ConnectBool(\"localhost\", 22, \"root\", \"password123\", 5000);\n\n\n\n\n\nSFTP_CreateDirectory\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SFTP_CreateDirectory": {
  "prefix": "SFTP_CreateDirectory",
  "body": [
   "SFTP_CreateDirectory($$sftpSession,$$path,$$posixPermissions);"
  ],
  "description": "\n\nCreates a directory at the path specified. Errors out if the directory already exists.\n\n\n\nFunction Arguments\n\n\n\n\n\nParameter\n\n\n\nVariable Type\n\nDescription\n\n\n\n$sftpSession\n\n\n\nObject\n\nHandle to SFTP connection returned by the SFTP_Connect() function.\n\n\n\n$path\n\nString\n\nThe absolute or relative path of the directory to be created.\n\n\n\n$posixPermissions\n\nInteger\n\nThe POSIX permissions for this directory, e.g., \"0700\" (which must be given as 0x1c0 \u2013 Jabil Test does not support constants in octal notation).\n\n\n\n\n\nReturn Parameters\n\n\n\n\n\nParameter\n\n\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n--\n\n\n\n\n\nExample:\n\n//Create directory with full read/write/execute permissions for all users\n\n$remoteDirectory = \"TEST-DIRECTORY\";\n\n$POSIX = 0x1FF; //\u201d777\u201d\n\nSFTP_CreateDirectory($SftpSession, $remoteDirectory, $POSIX);\n\n\n\n\n\nSFTP_DeleteDirectory\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SFTP_DeleteDirectory": {
  "prefix": "SFTP_DeleteDirectory",
  "body": [
   "SFTP_DeleteDirectory($$sftpSession,$$path);"
  ],
  "description": "\n\nDeletes an empty directory.\n\n\n\n\n\nRemarks:\n\nWill error out if the directory is not empty.\n\nErrors out if the directory cannot be found.\n\n\n\nFunction Arguments\n\n\n\n\n\nParameter\n\n\n\nVariable Type\n\nDescription\n\n\n\n$sftpSession\n\n\n\nObject\n\nHandle to SFTP connection returned by the SFTP_Connect() function.\n\n\n\n$path\n\nString\n\nThe absolute or relative path of the directory to remove.\n\n\n\n\n\nReturn Parameters\n\n\n\n\n\nParameter\n\n\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n--\n\n\n\n\n\nExample:\n\n//Remove directory and all files and subdirectories\n\n$remoteDirectory = \"TEST-DIRECTORY\";\n\nSFTP_DeleteDirectory($SftpSession, $remoteDirectory);\n\n\n\n\n\nSFTP_DeleteFile\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SFTP_DeleteFile": {
  "prefix": "SFTP_DeleteFile",
  "body": [
   "SFTP_DeleteFile($$sftpSession,$$path);"
  ],
  "description": "\n\nDeletes a file. Errors out if the file cannot be found.\n\n\n\nFunction Arguments\n\n\n\n\n\nParameter\n\n\n\nVariable Type\n\nDescription\n\n\n\n$sftpSession\n\n\n\nObject\n\nHandle to SFTP connection returned by the SFTP_Connect() function.\n\n\n\n$path\n\nString\n\nAn absolute or relative path specifying the file. Use \"/\" as the directory delimiter.\n\n\n\n\n\nReturn Parameters\n\n\n\n\n\nParameter\n\n\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n--\n\n\n\n\n\nExample:\n\n//Delete file on remote server\n\n$remoteFile = \"TEST-RENAME.TXT\";\n\nSFTP_DeleteFile($SftpSession, $remoteFile);\n\n\n\n\n\nSFTP_DownloadFile\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SFTP_DownloadFile": {
  "prefix": "SFTP_DownloadFile",
  "body": [
   "SFTP_DownloadFile($$sftpSession,$$remoteFile,$$localFile,$$copyMode);"
  ],
  "description": "\n\nCopies a file from the remote server to the local client.\n\n\n\nFunction Arguments\n\n\n\n\n\nParameter\n\n\n\nVariable Type\n\nDescription\n\n\n\n$sftpSession\n\n\n\nObject\n\nHandle to SFTP connection returned by the SFTP_Connect() function.\n\n\n\n$remoteFile\n\nString\n\nAn absolute or relative (from WorkingDirectory) path specifying the file on the server. Use \"/\" as the directory delimiter.\n\n\n\n$localFile\n\nString\n\nAn absolute or relative (from the current working directory) path specifying the file on the client. Use \"/\" as the directory delimiter.\n\n\n\n$copyMode\n\nString\n\nDetermines the type of copy to perform. Valid modes are:\n\n\u00b7 APPEND \u2013 Appends the source file to the destination file. Upon completion of a copy operation, indicates the source file was appended to the destination file.\n\n\u00b7 COPY \u2013 Always over-write existing files with a new copy. Upon completion of a copy operation, indicates the file was overwritten.\n\n\u00b7 RESTART \u2013 If the file timestamps match and the source is larger than the destination, then the necessary trailing bytes from the source are appended to the destination. This mode should only be used to restart a failed copy. If the timestamps match and the sizes match, then no copy is performed (like copy mode \u2018SYNCHRONIZE\u2019). If the timestamps do not match or the source is smaller than the destination, then a full copy is performed. Upon completion of a copy operation, indicates a restart was performed.\n\n\u00b7 SYNCHRONIZE \u2013 If the file timestamps and sizes match, then no copy is performed. Otherwise a full copy is performed. Upon completion of a copy operation, indicates no copy was performed.\n\n\n\n\n\nReturn Parameters\n\n\n\n\n\nParameter\n\n\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n--\n\n\n\n\n\nExample:\n\n//Download file, overwriting it if it already exists\n\n$remoteFile = \"TEST.TXT\";\n\n$localFile = \"C:\\\\TEST\\\\TEST-DL.TXT\";\n\nSFTP_DownloadFile($SftpSession, $remoteFile, $localFile, \"COPY\");\n\n\n\n\n\nSFTP_Rename\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SFTP_Rename": {
  "prefix": "SFTP_Rename",
  "body": [
   "SFTP_Rename($$sftpSession,$$oldPath,$$newPath);"
  ],
  "description": "\n\nRenames or moves a file or directory.\n\n\n\nFunction Arguments\n\n\n\n\n\nParameter\n\n\n\nVariable Type\n\nDescription\n\n\n\n$sftpSession\n\n\n\nObject\n\nHandle to SFTP connection returned by the SFTP_Connect() function.\n\n\n\n$oldPath\n\nString\n\nThe absolute or relative path of an existing directory or file.\n\n\n\n$newPath\n\nString\n\nThe absolute or relative new path.\n\n\n\n\n\nReturn Parameters\n\n\n\n\n\nParameter\n\n\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n--\n\n\n\n\n\nExample:\n\n//Rename directory\n\n$remoteDirectory = \"TEST-DIRECTORY\";\n\n$newDirectoryName = \"TEST-DIRECTORY-RENAME\";\n\nSFTP_Rename($SftpSession, $remoteDirectory, $newDirectoryName);\n\n\n\n\n\nSFTP_UploadFile\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SFTP_UploadFile": {
  "prefix": "SFTP_UploadFile",
  "body": [
   "SFTP_UploadFile($$sftpSession,$$localFile,$$remoteFile,$$copyMode);"
  ],
  "description": "\n\nCopies a file from the local client to the remote server.\n\n\n\nFunction Arguments\n\n\n\n\n\nParameter\n\n\n\nVariable Type\n\nDescription\n\n\n\n$sftpSession\n\n\n\nObject\n\nHandle to SFTP connection returned by the SFTP_Connect() function.\n\n\n\n$localFile\n\nString\n\nAn absolute or relative (from the current working directory) path specifying the file on the client. Use \"/\" as the directory delimiter.\n\n\n\n$remoteFile\n\nString\n\nAn absolute or relative (from WorkingDirectory) path specifying the file on the server. Use \"/\" as the directory delimiter.\n\n\n\n$copyMode\n\nString\n\nDetermines the type of copy to perform. Valid modes are:\n\n\u00b7 APPEND \u2013 Appends the source file to the destination file. Upon completion of a copy operation, indicates the source file was appended to the destination file.\n\n\u00b7 COPY \u2013 Always over-write existing files with a new copy. Upon completion of a copy operation, indicates the file was overwritten.\n\n\u00b7 RESTART \u2013 If the file timestamps match and the source is larger than the destination, then the necessary trailing bytes from the source are appended to the destination. This mode should only be used to restart a failed copy. If the timestamps match and the sizes match, then no copy is performed (like copy mode \u2018SYNCHRONIZE\u2019). If the timestamps do not match or the source is smaller than the destination, then a full copy is performed. Upon completion of a copy operation, indicates a restart was performed.\n\n\u00b7 SYNCHRONIZE \u2013 If the file timestamps and sizes match, then no copy is performed. Otherwise a full copy is performed. Upon completion of a copy operation, indicates no copy was performed.\n\n\n\n\n\nReturn Parameters\n\n\n\n\n\nParameter\n\n\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n--\n\n\n\n\n\nExample:\n\n//Upload a file, overwriting it if it already exists on server\n\n$localFile = \"C:\\\\TEST\\\\TEST.TXT\";\n\n$remoteFile = \"TEST-UL.TXT\";\n\nSFTP_UploadFile($SftpSession, $localFile, $remoteFile, \"COPY\");\n\n\n\n\n\nAardvark_SPI_Close\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Aardvark_SPI_Close": {
  "prefix": "Aardvark_SPI_Close",
  "body": [
   "Aardvark_SPI_Close($$Aardvark_Handle);"
  ],
  "description": "\n\nThis function closes the instrument I/O session created with Aardvark_SPI_Init. It deallocates any memory resources Aardvark uses.\n\n\n\nRemarks:\n\nThis function requires the Aardvark USB drivers from Total Phase to be installed.\n\nThis function is tested with a total phase TP240141 usb device.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Aardvark_Handle\n\nObject\n\nThe instrument handle obtained from Aardvark_SPI_Init that identifies a particular instrument's session.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\nAardvark_SPI_Close($Aardvark_Handle);\n\n\n\n\n\nAardvark_SPI_GetSlaveData\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Aardvark_SPI_GetSlaveData": {
  "prefix": "Aardvark_SPI_GetSlaveData",
  "body": [
   "$$returnString=Aardvark_SPI_GetSlaveData($$Aardvark_Handle,$$Timeoutms);"
  ],
  "description": "\n\nThis function reads/gets data sent to the slave device in the SPI chain.\n\n\n\n\n\nRemarks:\n\nThis function requires the Aardvark USB drivers from Total Phase to be installed.\n\nThis function is tested with a total phase TP240141 usb device.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Aardvark_Handle\n\nObject\n\nThe instrument handle obtained from Aardvark_SPI_Init that identifies a particular instrument's session.\n\n\n\n$Timeoutms\n\nInteger\n\nTimeout value in ms.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$returnString\n\nString\n\nData received by slave device.\n\n\n\n\n\nExample:\n\n// Get data received by the slave device and timeout in 10 ms if no data received.\n\n$returnString = Aardvark_SPI_GetSlaveData($Aardvark_Handle, 10);\n\n\n\n\n\nAardvark_SPI_Init\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Aardvark_SPI_Init": {
  "prefix": "Aardvark_SPI_Init",
  "body": [
   "$$Aardvark_Handle=Aardvark_SPI_Init($$PortNumber,$$Mode);"
  ],
  "description": "\n\nThis function configures and returns a handle to the Aardvark SPI/I2C interface device.\n\n\n\nRemarks:\n\nThis function requires the Aardvark USB drivers from Total Phase to be installed.\n\nThis function is tested with a total phase TP240141 usb device.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$PortNumber\n\nInteger\n\nThe serial port number of the Aardvark SPI device.\n\n\n\n$Mode\n\nInteger\n\nMode of the operation of the device.\n\nValues:\n\n\u00b7 bit 0: Phase 0 = Sample_Setup\n\n1 = Setup_Sample\n\n\u00b7 bit 1: Polarity 0 = Falling\n\n1 = Rising\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nA handle to the Aardvark SPI/I2C controller.\n\n\n\n\n\nExample:\n\n$Aardvark_Handle = Aardvark_SPI_Init($PortNumber, $Mode);\n\n$Aardvark_Handle = Aardvark_SPI_Init(0, 1);\n\n\n\n\n\nAardvark_SPI_MasterBlastDataFile\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Aardvark_SPI_MasterBlastDataFile": {
  "prefix": "Aardvark_SPI_MasterBlastDataFile",
  "body": [
   "$$returnString=Aardvark_SPI_MasterBlastDataFile($$Aardvark_Handle,$$DataFileName);"
  ],
  "description": "\n\nThis function sends data from the device defined as the Master Device in the SPI chain by reading a file containing the data to send.\n\n\n\n\n\nRemarks:\n\nThis function requires the Aardvark USB drivers from Total Phase to be installed.\n\nThis function is tested with a total phase TP240141 usb device.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Aardvark_Handle\n\nObject\n\nThe instrument handle obtained from Aardvark_SPI_Init that identifies a particular instrument's session.\n\n\n\n$DataFileName\n\nString\n\nThe name and path of the file containing the data to send.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$returnString\n\nString\n\nReturns any information from the target device in the SPI chain.\n\n\n\n\n\nExample:\n\n$returnString = Aardvark_SPI_MasterBlastDataFile($Aardvark_Handle, \u201dc:\\\\Datafile\u201d);\n\n\n\n\n\nAardvark_SPI_MasterSendData\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Aardvark_SPI_MasterSendData": {
  "prefix": "Aardvark_SPI_MasterSendData",
  "body": [
   "$$returnString=Aardvark_SPI_MasterSendData($$Aardvark_Handle,$$SPIMsg);"
  ],
  "description": "\n\nThis function sends data from the device defined as the Master Device in the SPI chain.\n\n\n\n\n\nRemarks:\n\nThis function requires the Aardvark USB drivers from Total Phase to be installed.\n\nThis function is tested with a total phase TP240141 usb device.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Aardvark_Handle\n\nObject\n\nThe instrument handle obtained from Aardvark_SPI_Init that identifies a particular instrument's session.\n\n\n\n$SPIMsg\n\nString\n\nHEX string to send to the target.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$returnString\n\nString\n\nReturns any information from the target device in the SPI chain.\n\n\n\n\n\nExample:\n\n$returnString = Aardvark_SPI_MasterSendData($Aardvark_Handle, $SPIMsg);\n\n\n\n\n\nAardvark_SPI_SetMaster\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Aardvark_SPI_SetMaster": {
  "prefix": "Aardvark_SPI_SetMaster",
  "body": [
   "Aardvark_SPI_SetMaster($$Aardvark_Handle,$$BitRate);"
  ],
  "description": "\n\nThis function sets the Aardvark as the Master device in the SPI chain.\n\n\n\nRemarks:\n\nThis function requires the Aardvark USB drivers from Total Phase to be installed.\n\nThis function is tested with a total phase TP240141 usb device.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Aardvark_Handle\n\nObject\n\nThe instrument handle obtained from Aardvark_SPI_Init that identifies a particular instrument's session.\n\n\n\n$BitRate\n\nInteger\n\nBit Rate in kHz.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n// Sets the Aardvark as Master with a 125 kHz bit rate.\n\nAardvark_SPI_SetMaster($Aardvark_Handle, 125);\n\n\n\n\n\nAardvark_SPI_SetSlave\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Aardvark_SPI_SetSlave": {
  "prefix": "Aardvark_SPI_SetSlave",
  "body": [
   "Aardvark_SPI_SetSlave($$Aardvark_Handle);"
  ],
  "description": "\n\nThis function sets the Aardvark as a slave device in the SPI chain.\n\n\n\n\n\nRemarks:\n\nThis function requires the Aardvark USB drivers from Total Phase to be installed.\n\nThis function is tested with a total phase TP240141 usb device.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Aardvark_Handle\n\nObject\n\nThe instrument handle obtained from Aardvark_SPI_Init that identifies a particular instrument's session.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\nAardvark_SPI_SetSlave($Aardvark_Handle);\n\n\n\n\n\nAardvark_SPI_SlaveDisable\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Aardvark_SPI_SlaveDisable": {
  "prefix": "Aardvark_SPI_SlaveDisable",
  "body": [
   "Aardvark_SPI_SlaveDisable($$Aardvark_Handle);"
  ],
  "description": "\n\nThis function disables the slave device and closes the instrument I/O session created with Aardvark_SPI_Init. It deallocates any memory resources Aardvark uses.\n\n\n\n\n\nRemarks:\n\nThis function requires the Aardvark USB drivers from Total Phase to be installed.\n\nThis function is tested with a total phase TP240141 usb device.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Aardvark_Handle\n\nObject\n\nThe instrument handle obtained from Aardvark_SPI_Init that identifies a particular instrument's session.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\nAardvark_SPI_SlaveDisable($Aardvark_Handle);\n\n\n\n\n\nNI_845x_Close\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_845x_Close": {
  "prefix": "NI_845x_Close",
  "body": [
   "$$status=NI_845x_Close($$deviceHandle);"
  ],
  "description": "\n\nThis function closes communication with the NI-845x adapter that was previously opened with the function NI_845x_Open.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$deviceHandle\n\nObject\n\nReference to the NI-845x device.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$status\n\nString\n\nDescription of any errors or warnings returned from the device. This will be blank, \"\", if there is no error.\n\n\n\n\n\nExample:\n\n// Open reference to device.\n\n$MAXname = \"NI-8452\";\n\n($status, $deviceHandle) = NI_845x_Open($MAXname);\n\n\n\n\n\n// Close the reference.\n\n$status =NI_845x_Close($deviceHandle);\n\n\n\n\n\nif ($status == \"\")\n\n{\n\nUpdateStatus(\"No error while closing.\");\n\nEnd;\n\n}\n\n\n\n\n\n// If we got here then there was an error reported.\n\n$outStr = \"Error reported: \" + $status;\n\nUpdateStatus($outStr);\n\nEnd;\n\n\n\n\n\nNI_845x_DioReadLine\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_845x_DioReadLine": {
  "prefix": "NI_845x_DioReadLine",
  "body": [
   "($$status,$$dataRead)=NI_845x_DioReadLine($$deviceHandle,$$portNumber,$$lineNumber);"
  ],
  "description": "\n\nThis function returns the status of one line from one DIO port on the specified device.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$deviceHandle\n\nObject\n\nReference to the NI-845x device.\n\n\n\n$portNumber\n\nInteger\n\nThe DIO port to read the line from.\n\n\n\n$lineNumber\n\nInteger\n\nThe line number to read from.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$status\n\nString\n\nDescription of any errors or warnings returned from the device. This will be blank, \"\", if there is no error.\n\n\n\n$dataRead\n\nInteger\n\nThe status of the line that was read. 0 = line is low, 1 = line is high.\n\n\n\n\n\nExample:\n\n// Open reference to device.\n\n$MAXname = \"NI-8452\";\n\n($status, $deviceHandle) = NI_845x_Open($MAXname);\n\n\n\n\n\n// Read the status from port 0, line 1.\n\n$portNum = 0;\n\n$lineNum = 1;\n\n($status, $data) = NI_845x_DioReadLine($deviceHandle, $portNum, $lineNum);\n\n\n\n\n\n// Close the reference.\n\n$status =NI_845x_Close($deviceHandle);\n\n\n\n\n\nNI_845x_DioReadPort\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_845x_DioReadPort": {
  "prefix": "NI_845x_DioReadPort",
  "body": [
   "($$status,$$dataRead)=NI_845x_DioReadPort($$deviceHandle,$$portNumber);"
  ],
  "description": "\n\nThis function returns the status of all lines from one DIO port on the specified device.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$deviceHandle\n\nObject\n\nReference to the NI-845x device.\n\n\n\n$portNumber\n\nInteger\n\nThe DIO port to read data from.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$status\n\nString\n\nDescription of any errors or warnings returned from the device. This will be blank, \"\", if there is no error.\n\n\n\n$dataRead\n\nInteger\n\nThe status of the port that was read. bit 0 = line 0, bit 1 = line 1, etc.\n\n\n\n\n\nExample:\n\n// Open reference to device.\n\n$MAXname = \"NI-8452\";\n\n($status, $deviceHandle) = NI_845x_Open($MAXname);\n\n\n\n\n\n// Read the status from port 0.\n\n$portNum = 0;\n\n($status, $data) = NI_845x_DioReadPort($deviceHandle, $portNum);\n\n\n\n\n\n// Close the reference.\n\n$status =NI_845x_Close($deviceHandle);\n\n\n\n\n\nNI_845x_DioSetDriverType\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_845x_DioSetDriverType": {
  "prefix": "NI_845x_DioSetDriverType",
  "body": [
   "$$status=NI_845x_DioSetDriverType($$deviceHandle,$$portNumber,$$driverType);"
  ],
  "description": "\n\nThis function sets the output driver type for one port.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$deviceHandle\n\nObject\n\nReference to the NI-845x device.\n\n\n\n$portNumber\n\nInteger\n\nThe DIO port to set the driver type of.\n\n\n\n$driverType\n\nString\n\nThe output driver type to set. Valid values are:\n\n\u00b7 OPENDRAIN\n\n\u00b7 PUSHPULL\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$status\n\nString\n\nDescription of any errors or warnings returned from the device. This will be blank, \"\", if there is no error.\n\n\n\n\n\nExample:\n\n// Open reference to device.\n\n$MAXname = \"NI-8452\";\n\n($status, $deviceHandle) = NI_845x_Open($MAXname);\n\n\n\n\n\n// Set port 0 to Push-Pull.\n\n$portNum = 0;\n\n$driveType = \"PUSHPULL\";\n\n$status = NI_845x_DioSetDriverType($deviceHandle, $portNum, $driveType);\n\n\n\n\n\n// Close the reference.\n\n$status =NI_845x_Close($deviceHandle);\n\n\n\n\n\nNI_845x_DioSetPortLineDirectionMap\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_845x_DioSetPortLineDirectionMap": {
  "prefix": "NI_845x_DioSetPortLineDirectionMap",
  "body": [
   "$$status=NI_845x_DioSetPortLineDirectionMap($$deviceHandle,$$portNumber,$$directionMap);"
  ],
  "description": "\n\nThis function sets the lines of the port to output or input depending on the bits of $directionMap.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$deviceHandle\n\nObject\n\nReference to the NI-845x device.\n\n\n\n$portNumber\n\nInteger\n\nThe DIO port to set the DIO line direction of.\n\n\n\n$directionMap\n\nInteger\n\nBit representation of the line in the port. bit 0 = line 0, bit 1 = line 1, etc. Setting a bit to 0 makes it a digital input line, setting a bit to 1 makes it a digital output line.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$status\n\nString\n\nDescription of any errors or warnings returned from the device. This will be blank, \"\", if there is no error.\n\n\n\n\n\nExample:\n\n// Open reference to device.\n\n$MAXname = \"NI-8452\";\n\n($status, $deviceHandle) = NI_845x_Open($MAXname);\n\n\n\n\n\n// Set odd numbered lines to outputs.\n\n$portNum = 0;\n\n$dirMap = 85; // This is binary 0101 0101\n\n$status = NI_845x_DioSetPortLineDirectionMap($deviceHandle, $portNum, $dirMap);\n\n\n\n\n\n// Close the reference.\n\n$status =NI_845x_Close($deviceHandle);\n\n\n\n\n\nNI_845x_DioSetPortVoltageType\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_845x_DioSetPortVoltageType": {
  "prefix": "NI_845x_DioSetPortVoltageType",
  "body": [
   "$$status=NI_845x_DioSetPortVoltageType($$deviceHandle,$$portNumber,$$voltageType);"
  ],
  "description": "\n\nThis function sets the voltage type for one port.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$deviceHandle\n\nObject\n\nReference to the NI-845x device.\n\n\n\n$portNumber\n\nInteger\n\nThe DIO port to set the voltage type of.\n\n\n\n$voltageType\n\nInteger\n\nThe voltage type for the port.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$status\n\nString\n\nDescription of any errors or warnings returned from the device. This will be blank, \"\", if there is no error.\n\n\n\n\n\nExample:\n\n// Open reference to device.\n\n$MAXname = \"NI-8452\";\n\n($status, $deviceHandle) = NI_845x_Open($MAXname);\n\n\n\n\n\n// Set port 0..\n\n$portNum = 0;\n\n$voltType = 0;\n\n$status = NI_845x_DioSetDriverType($deviceHandle, $portNum, $voltType);\n\n\n\n\n\n// Close the reference.\n\n$status =NI_845x_Close($deviceHandle);\n\n\n\n\n\nNI_845x_DioWriteLine\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_845x_DioWriteLine": {
  "prefix": "NI_845x_DioWriteLine",
  "body": [
   "$$status=NI_845x_DioWriteLine($$deviceHandle,$$portNumber,$$lineNumber,$$dataToWrite);"
  ],
  "description": "\n\nThis function will output data on one line of one port.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$deviceHandle\n\nObject\n\nReference to the NI-845x device.\n\n\n\n$portNumber\n\nInteger\n\nThe DIO port to set an output line of.\n\n\n\n$lineNumber\n\nInteger\n\nThe line to set the output of.\n\n\n\n$dataToWrite\n\nInteger\n\nThe data to send to the line. 0 = set the line low, 1 = set the line high.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$status\n\nString\n\nDescription of any errors or warnings returned from the device. This will be blank, \"\", if there is no error.\n\n\n\n\n\nExample:\n\n// Open reference to device.\n\n$MAXname = \"NI-8452\";\n\n($status, $deviceHandle) = NI_845x_Open($MAXname);\n\n\n\n\n\n// Set port 0, line 1 to high.\n\n$portNum = 0;\n\n$lineNum = 1;\n\n$data = 1;\n\n$status = NI_845x_DioWriteLine($deviceHandle, $portNum, $lineNum, $data);\n\n\n\n\n\n// Close the reference.\n\n$status =NI_845x_Close($deviceHandle);\n\n\n\n\n\nNI_845x_DioWritePort\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_845x_DioWritePort": {
  "prefix": "NI_845x_DioWritePort",
  "body": [
   "$$status=NI_845x_DioWritePort($$deviceHandle,$$portNumber,$$dataToWrite);"
  ],
  "description": "\n\nThis function will output the data on one port. Only lines configured for output will be updated.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$deviceHandle\n\nObject\n\nReference to the NI-845x device.\n\n\n\n$portNumber\n\nInteger\n\nThe DIO port to set an output line of.\n\n\n\n$dataToWrite\n\nInteger\n\nThe data to send to the port.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$status\n\nString\n\nDescription of any errors or warnings returned from the device. This will be blank, \"\", if there is no error.\n\n\n\n\n\nExample:\n\n// Open reference to device.\n\n$MAXname = \"NI-8452\";\n\n($status, $deviceHandle) = NI_845x_Open($MAXname);\n\n\n\n\n\n// Set port 0, even numbered lines high.\n\n$portNum = 0;\n\n$data = 170; // binary 1010 1010.\n\n$status = NI_845x_DioWritePort($deviceHandle, $portNum, $data);\n\n\n\n\n\n// Close the reference.\n\n$status =NI_845x_Close($deviceHandle);\n\n\n\n\n\nNI_845x_Open\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_845x_Open": {
  "prefix": "NI_845x_Open",
  "body": [
   "($$status,$$devicHandle)=NI_845x_Open($$deviceName);"
  ],
  "description": "\n\nThis function opens communication with the named NI-845x adapter.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$deviceName\n\nString\n\nThe name of the device from NI-MAX or the NI-MAX alias for the device.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$status\n\nString\n\nDescription of any errors or warnings returned from the device. This will be blank, \"\", if there is no error.\n\n\n\n$deviceHandle\n\nObject\n\nA reference to the device that can be used by other NI-845x functions.\n\n\n\n\n\nExample:\n\n// Open reference to device.\n\n$MAXname = \"NI-8452\";\n\n($status, $deviceHandle) = NI_845x_Open($MAXname);\n\n\n\n\n\nNI_845x_SetIOVoltageLevel\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_845x_SetIOVoltgeLevel": {
  "prefix": "NI_845x_SetIOVoltgeLevel",
  "body": [
   "$$status=NI_845x_SetIOVoltgeLevel($$deviceHandle,$$voltageLevel);"
  ],
  "description": "\n\nThis function will set the voltage level that equates to a high level (1) on ti DIO lines.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$deviceHandle\n\nObject\n\nReference to the NI-845x device.\n\n\n\n$voltageLevel\n\nInteger\n\nThe voltage level to set the device to. Valid entries are:\n\n\u00b7 12 = 1.2 volts\n\n\u00b7 15 = 1.5 volts\n\n\u00b7 18 = 1.8 volts\n\n\u00b7 25 = 2.5 volts\n\n\u00b7 33 = 3.3 volts.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$status\n\nString\n\nDescription of any errors or warnings returned from the device. This will be blank, \"\", if there is no error.\n\n\n\n\n\nExample:\n\n// Open reference to device.\n\n$MAXname = \"NI-8452\";\n\n($status, $deviceHandle) = NI_845x_Open($MAXname);\n\n\n\n\n\n// Set the device to 2.5 volt operation..\n\n$voltLevel = 25;\n\n$status = NI_845x_SetIOVoltageLevel($deviceHandle, $voltLevel);\n\n\n\n\n\n// Close the reference.\n\n$status =NI_845x_Close($deviceHandle);\n\n\n\n\n\nNI_845x_SpiConfigurationClose\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_845x_SpiConfigurationClose": {
  "prefix": "NI_845x_SpiConfigurationClose",
  "body": [
   "$$status=NI_845x_SpiConfigurationClose($$configHandle);"
  ],
  "description": "\n\nThis function will close a reference to the SPI configuration that was previously opened with NI_845x_SpiConfigurationOpen.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$configHandle\n\nObject\n\nA reference to the SPI configuration.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$status\n\nString\n\nDescription of any errors or warnings returned from the device. This will be blank, \"\", if there is no error.\n\n\n\n\n\nExample:\n\n// Open reference to SPI configuration.\n\n($status, $configHandle) = NI_845x_SpiConfigurationOpen();\n\n\n\n\n\n// Close the reference to the configuration.\n\n$status = NI_845x_SpiConfigurationClose($configHandle);\n\n\n\n\n\nNI_845x_SpiConfigurationGetChipSelect\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_845x_SpiConfigurationGetChipSelect": {
  "prefix": "NI_845x_SpiConfigurationGetChipSelect",
  "body": [
   "($$status,$$chipSelected)=NI_845x_SpiConfigurationGetChipSelect($$configHandle);"
  ],
  "description": "\n\nThis function will return the selected chip on the SPI adapter.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$configHandle\n\nObject\n\nA reference to the SPI configuration.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$status\n\nString\n\nDescription of any errors or warnings returned from the device. This will be blank, \"\", if there is no error.\n\n\n\n$chipSelected\n\nInteger\n\nThe number of the chip selected.\n\n\n\n\n\nExample:\n\n// Open reference to SPI configuration.\n\n($status, $configHandle) = NI_845x_SpiConfigurationOpen();\n\n\n\n\n\n// Get the chip selected.\n\n($status, $chipSel) = NI_845x_SpiConfigurationGetChipSelect($configHandle);\n\n\n\n\n\nNI_845x_SpiConfigurationGetClockRate\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_845x_SpiConfigurationGetClockRate": {
  "prefix": "NI_845x_SpiConfigurationGetClockRate",
  "body": [
   "($$status,$$clockRate)=NI_845x_SpiConfigurationGetClockRate($$configHandle);"
  ],
  "description": "\n\nThis function will return the clock speed on the SPI adapter.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$configHandle\n\nObject\n\nA reference to the SPI configuration.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$status\n\nString\n\nDescription of any errors or warnings returned from the device. This will be blank, \"\", if there is no error.\n\n\n\n$clockRate\n\nInteger\n\nThe clock rate of the SPI adapter.\n\n\n\n\n\nExample:\n\n// Open reference to SPI configuration.\n\n($status, $configHandle) = NI_845x_SpiConfigurationOpen();\n\n\n\n\n\n// Get the clock rate.\n\n($status, $clockRate) = NI_845x_SpiConfigurationGetClockRate($configHandle);\n\n\n\n\n\nNI_845x_SpiConfigurationOpen\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_845x_SpiConfigurationOpen": {
  "prefix": "NI_845x_SpiConfigurationOpen",
  "body": [
   "($$status,$$configHandle)=NI_845x_SpiConfigurationOpen();"
  ],
  "description": "\n\nThis function will open and create a handle to the SPI configuration.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$status\n\nString\n\nDescription of any errors or warnings returned from the device. This will be blank, \"\", if there is no error.\n\n\n\n$configHandle\n\nObject\n\nA reference to the SPI configuration that can be used by other SPI configuration functions.\n\n\n\n\n\nExample:\n\n// Open reference to SPI configuration.\n\n($status, $configHandle) = NI_845x_SpiConfigurationOpen();\n\n\n\n\n\nNI_845x_SpiConfigurationSetChipSelect\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_845x_SpiConfigurationSetChipSelect": {
  "prefix": "NI_845x_SpiConfigurationSetChipSelect",
  "body": [
   "$$status=NI_845x_SpiConfigurationSetChipSelect($$configHandle,$$chipSelect);"
  ],
  "description": "\n\nThis function will set the selected chip on the SPI adapter.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$configHandle\n\nObject\n\nA reference to the SPI configuration.\n\n\n\n$chipSelect\n\nInteger\n\nThe number of the chip to select.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$status\n\nString\n\nDescription of any errors or warnings returned from the device. This will be blank, \"\", if there is no error.\n\n\n\n\n\nExample:\n\n// Open reference to SPI configuration.\n\n($status, $configHandle) = NI_845x_SpiConfigurationOpen();\n\n\n\n\n\n// Set the selected chip.\n\n$chipSelect = 0;\n\n$status = NI_845x_SpiConfigurationSetChipSelect($configHandle, $chipSelect);\n\n\n\n\n\nNI_845x_SpiConfiguration_SetClockRate\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_845x_SpiConfigurationSetClockRate": {
  "prefix": "NI_845x_SpiConfigurationSetClockRate",
  "body": [
   "$$status=NI_845x_SpiConfigurationSetClockRate($$configHandle,$$clockRate);"
  ],
  "description": "\n\nThis function will set the selected chip on the SPI adapter.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$configHandle\n\nObject\n\nA reference to the SPI configuration.\n\n\n\n$clockRate\n\nInteger\n\nThe clock rate to set for the SPI adapter (in kHz).\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$status\n\nString\n\nDescription of any errors or warnings returned from the device. This will be blank, \"\", if there is no error.\n\n\n\n\n\nExample:\n\n// Open reference to SPI configuration.\n\n($status, $configHandle) = NI_845x_SpiConfigurationOpen();\n\n\n\n\n\n// Set the clock rate to 100 kHz.\n\n$clockRate = 100;\n\n$status = NI_845x_SpiConfigurationSetClockRate($configHandle, $clockRate);\n\n\n\n\n\nNI_845x_SpiReadWrite\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NI_845x_SpiReadWrite": {
  "prefix": "NI_845x_SpiReadWrite",
  "body": [
   "($$status,$$readSize,$$readData)=NI_845x_SpiReadWrite($$deviceHandle,$$configHandle,$$writeSizw,$$writeData);"
  ],
  "description": "\n\nThis function will write data to the SPI adapter and then read any returned data.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$deviceHandle\n\nObject\n\nA reference to the SPI device.\n\n\n\n$configHandle\n\nObject\n\nA reference to the SPI configuration.\n\n\n\n$writeSize\n\nInteger\n\nThe number of bytes to write (must not be 0).\n\n\n\n$writeData\n\nArray\n\nArray of bytes to write to the SPI bus.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$status\n\nString\n\nDescription of any errors or warnings returned from the device. This will be blank, \"\", if there is no error.\n\n\n\n$readSize\n\nInteger\n\nThe number of bytes read from the SPI bus.\n\n\n\n$readData\n\nArray\n\nArray of bytes read from the SPI bus.\n\n\n\n\n\nExample:\n\n//Open the device.\n\n($status, $deviceHandle) = NI_845x_Open($MAXname);\n\n\n\n\n\n// Open reference to SPI configuration.\n\n($status, $configHandle) = NI_845x_SpiConfigurationOpen();\n\n\n\n\n\n// Send some data and read some back.\n\n$writeData = Array1DCreate(\"INTEGER\", 2);\n\nArray1DSetValue($writeData, 0, 3);\n\nArray1DSetValue($writeData, 1, 4);\n\n$writeSize = ArrayGetLength($writeData);\n\n\n\n\n\n($status, $readSize, $readData) = NI_845x_SpiReadWrite($deviceHandle, $configHandle, $writeSize, $writeData);\n\n\n\n\n\nSshClose\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SshClose": {
  "prefix": "SshClose",
  "body": [
   "SshClose($$SshConnection);"
  ],
  "description": "\n\nThis function closes a connection to an SSH server, disposing of all resources and closing all open sessions. Failure to call this function can leave the receiver thread running forever.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$SshConnection\n\nObject\n\nHandle to SSH connection returned by the SshConnect function.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\nSshClose($SshConnection);\n\n\n\n\n\nSshConnect\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SshConnect": {
  "prefix": "SshConnect",
  "body": [
   "$$SshConnection=SshConnect($$host,$$port,$$userName,$$password,$$timeoutms);"
  ],
  "description": "\n\nThis function opens a new connection to an SSH server and authenticates the user using a password authentication method. Returns a handle to the connection.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$host\n\nString\n\nHostname or IP address of the server to connect to.\n\n\n\n$port\n\nInteger\n\nPort number the server is listening on (typically 22).\n\n\n\n$userName\n\nString\n\nName of the user to log in as.\n\n\n\n$password\n\nString\n\nThe user's password.\n\n\n\n$timeoutms\n\nInteger\n\nTime to wait for a successful connection, in milliseconds. Authentication can take additional time.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$SshConnection\n\nObject\n\nHandle to the SSH connection for use in other functions.\n\n\n\n\n\nExample:\n\n// Connect to a server on this computer with a 5 second timeout.\n\n$host = \"localhost\";\n\n$port = 22;\n\n$userName = \"root\";\n\n$password = \"password123\";\n\n$timeout = 5000;\n\n\n\n\n\n$SshConnection = SshConnect($host, $port, $userName, $password, $timeout);\n\n\n\n\n\nSshConnectBool\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SshConnectBool": {
  "prefix": "SshConnectBool",
  "body": [
   "($$success,$$SshConnection)=SshConnectBool($$host,$$port,$$userName,$$password,$$timeoutms);"
  ],
  "description": "\n\nOpens a new connection to the SSH server and authenticates the user using password authentication method. Returns whether the connection was successful and a handle to the connection.\n\n\n\n\n\nNote:\n\n\u00b7 A failed connection will not cause the test to fail. The boolean should be checked for a successful connection before attempting any other functions.\n\n\u00b7 An invalid log in name and password will still cause the test to fail.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$host\n\nString\n\nHostname or IP address of the server to connect to.\n\n\n\n$port\n\nInteger\n\nPort number the server is listening on (typically 22).\n\n\n\n$userName\n\nString\n\nName of the user to log in as.\n\n\n\n$password\n\nString\n\nThe user's password.\n\n\n\n$timeoutms\n\nInteger\n\nTime to wait for a successful connection, in milliseconds. Authentication can take additional time.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$success\n\nBoolean\n\nWhether the connection was successful.\n\n\n\n$SshConnection\n\nObject\n\nHandle to the SSH connection for use in other functions.\n\n\n\n\n\nExample:\n\n// Connect to a server on this computer with a 5 second timeout.\n\n$host = \"localhost\";\n\n$port = 22;\n\n$userName = \"root\";\n\n$password = \"password123\";\n\n$timeout = 5000;\n\n\n\n\n\n($success, $SshConnection) = SshConnectBool($host, $port, $userName, $password, $timeout);\n\n\n\n\n\nSshExecuteCommand\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SshExecuteCommand": {
  "prefix": "SshExecuteCommand",
  "body": [
   "$$receive=SshExecuteCommand($$SshConnection,$$command);"
  ],
  "description": "\n\nExecutes a command on the given SSH connection. The response is returned. This command is executed in its own temporary session, and does not affect the state of other sessions already opened. Multiple commands can be issued by separating them with a semi-colon.\n\n\n\n\n\nThis command is useful for when you want to execute independent commands on the server. To execute multiple, dependent commands in a persistent state (a terminal shell), open a new session on the connection with the SshOpenSession() command.\n\n\n\nFunction Arguments\n\n\n\n\n\nParameter\n\n\n\nVariable Type\n\nDescription\n\n\n\n$SshConnection\n\nObject\n\nHandle to SSH connection returned by the SshConnect() function.\n\n\n\n$command\n\nString\n\nCommand to execute on the server.\n\n\n\n\n\nReturn Parameters\n\n\n\n\n\nParameter\n\n\n\nVariable Type\n\nDescription\n\n\n\n$receive\n\nString\n\nContents of receive buffer after command executes.\n\n\n\n\n\nExample:\n\n$receive = SshExecuteCommand($SshConnection, \"pwd;cd ../netapp;pwd;ls -l\\n\"); //change directory and get a listing of files\n\n\n\n\n\nSshOpenSession\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SshOpenSession": {
  "prefix": "SshOpenSession",
  "body": [
   "$$SshSession=SshOpenSession($$SshConnection);"
  ],
  "description": "\n\nOpens a persistent SHH session on the given SSH connection and returns a handle to the SSH session stream.\n\n\n\n\n\nThe session acts like a terminal shell, preserving its state over multiple command executions.\n\n\n\nFunction Arguments\n\n\n\n\n\nParameter\n\n\n\nVariable Type\n\nDescription\n\n\n\n$SshConnection\n\nObject\n\nHandle to SSH connection returned by the SshConnect() function.\n\n\n\n\n\nReturn Parameters\n\n\n\n\n\nParameter\n\n\n\nVariable Type\n\nDescription\n\n\n\n$SshSession\n\nObject\n\nHandle to the new SSH session stream.\n\n\n\n\n\nExample:\n\n$SshSession = SshOpenSession($SshConnection);\n\n\n\n\n\nSshOpenSessionBool\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SshOpenSessionBool": {
  "prefix": "SshOpenSessionBool",
  "body": [
   "($$success,$$SshSession)=SshOpenSessionBool($$SshConnection);"
  ],
  "description": "\n\nOpens a persistent SHH session on the given SSH connection and returns whether the session opening worked and a handle to the SSH session stream.\n\n\n\n\n\nThe session acts like a terminal shell, preserving its state over multiple command executions.\n\n\n\n\n\nNote:\n\n\u00b7 A failed connection will not cause the test to fail. The boolean should be checked for a successful connection before attempting any other functions.\n\n\n\nFunction Arguments\n\n\n\n\n\nParameter\n\n\n\nVariable Type\n\nDescription\n\n\n\n$SshConnection\n\nObject\n\nHandle to SSH connection returned by the SshConnect() function.\n\n\n\n\n\nReturn Parameters\n\n\n\n\n\nParameter\n\n\n\nVariable Type\n\nDescription\n\n\n\n$success\n\nBoolean\n\nWhether opening the session was successful.\n\n\n\n$SshSession\n\nObject\n\nHandle to the new SSH session stream.\n\n\n\n\n\nExample:\n\n($success, $SshSession) = SshOpenSessionBool($SshConnection);\n\n\n\n\n\nSshSessionClose\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SshSessionClose": {
  "prefix": "SshSessionClose",
  "body": [
   "SshSessionClose($$SshSession);"
  ],
  "description": "\n\nCloses the SSH session stream. This call is optional; when the connection to the SSH server is closed with the SshClose() function, all open session are automatically closed.\n\n\n\nFunction Arguments\n\n\n\n\n\nParameter\n\n\n\nVariable Type\n\nDescription\n\n\n\n$SshSession\n\nObject\n\nHandle to SSH session stream returned by the SshOpenSession() function.\n\n\n\n\n\nReturn Parameters\n\n\n\n\n\nParameter\n\n\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n--\n\n\n\n\n\nExample:\n\nSshSessionClose($SshSession);\n\n\n\n\n\nSshSessionSend\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SshSessionSend": {
  "prefix": "SshSessionSend",
  "body": [
   "$$receive=SshSessionSend($$SshSession,$$sendString,$$expectString,$$timeoutms);"
  ],
  "description": "\n\nWrites to the SSH stream and waits for the given response. Returns the receive buffer if the response is found before the timeout expires, returns a failure to Jabil Test otherwise.\n\n\n\n\n\nTo execute commands on the server, add the system's newline character at the end of the send string. E.g., on Unix-based systems, add a line feed character (\"\\n\"); on Windows-based systems, a CR+LF is generally needed (\"\\r\\n\").\n\n\n\nFunction Arguments\n\n\n\n\n\nParameter\n\n\n\nVariable Type\n\nDescription\n\n\n\n$SshSession\n\nObject\n\nHandle to SSH session stream returned by the SshOpenSession() function.\n\n\n\n$sendString\n\nString\n\nData to write to SSH session.\n\n\n\n$expectString\n\nString\n\nReceive response to wait for.\n\n\n\n$timeoutms\n\nInteger\n\nTime to wait for the expected response, in milliseconds.\n\n\n\n\n\nReturn Parameters\n\n\n\n\n\nParameter\n\n\n\nVariable Type\n\nDescription\n\n\n\n$receive\n\nString\n\nContents of receive buffer up to $expectString, if response was found.\n\n\n\n\n\nExample:\n\n$receive = SshSessionSend($SshSession, \"pwd\\n\", \"#\", 2000); //check working directory and wait up to 2s for the bash command prompt\n\n\n\n\n\nSshSessionSendBool\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SshSessionSendBool": {
  "prefix": "SshSessionSendBool",
  "body": [
   "($$found,$$receive)=SshSessionSendBool($$SshSession,$$sendString,$$expectString,$$timeoutms);"
  ],
  "description": "\n\nWrites to the SSH stream and waits for the given response. Returns the receive buffer and true if the response is found before the timeout expires, false otherwise.\n\n\n\n\n\nTo execute commands on the server, add the system's newline character at the end of the send string. E.g., on Unix-based systems, add a line feed character (\"\\n\"); on Windows-based systems, a CR+LF is generally needed (\"\\r\\n\").\n\n\n\n\n\nNote: If the response is found, the receive buffer will contain all data up to the expected response. If the response is not found before the timeout expires, the receive buffer will still contain all data received up until the timeout.\n\n\n\nFunction Arguments\n\n\n\n\n\nParameter\n\n\n\nVariable Type\n\nDescription\n\n\n\n$SshSession\n\nObject\n\nHandle to SSH session stream returned by the SshOpenSession() function.\n\n\n\n$sendString\n\nString\n\nData to write to SSH session.\n\n\n\n$expectString\n\nString\n\nReceive response to wait for.\n\n\n\n$timeoutms\n\nInteger\n\nTime to wait for the expected response, in milliseconds.\n\n\n\n\n\nReturn Parameters\n\n\n\n\n\nParameter\n\n\n\nVariable Type\n\nDescription\n\n\n\n$found\n\nBoolean\n\nTrue if the expected response was received before the timeout, false otherwise.\n\n\n\n$receive\n\nString\n\nContents of receive buffer up to $expectString (if response was found) or up to when the timeout occurs (if response not found).\n\n\n\n\n\nExample:\n\n($found, $receive) = SshSessionSendBool($SshSession, \"pwd\\n\", \"#\", 2000); //check working directory and wait up to 2s for the bash command prompt\n\n\n\n\n\nSshSessionShowTerminal\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SshSessionShowTerminal": {
  "prefix": "SshSessionShowTerminal",
  "body": [
   "SshSessionShowTerminal($$SshSession);"
  ],
  "description": "\n\nOpens an interactive terminal window to the SSH session. The session is preserved in whatever state it was left at when the window closes.\n\n\n\nFunction Arguments\n\n\n\n\n\nParameter\n\n\n\nVariable Type\n\nDescription\n\n\n\n$SshSession\n\nObject\n\nHandle to SSH session stream returned by the SshOpenSession() function.\n\n\n\n\n\nReturn Parameters\n\n\n\n\n\nParameter\n\n\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n--\n\n\n\n\n\nExample:\n\nSshSessionShowTerminal($SshSession);\n\n\n\n\n\nSerial_ChangeEncoding\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Serial_ChangeEncoding": {
  "prefix": "Serial_ChangeEncoding",
  "body": [
   "Serial_ChangeEncoding($$comPort,$$encoding);"
  ],
  "description": "\n\nThis function will set the encoding to use when sending and receiving on a serial port.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$comPort\n\nObject\n\nThe instance of the serial port to change the encoding of. The $comPort object is created by a call to Serial_Open or to Serial_OpenBool.\n\n\n\n$encoding\n\nString\n\nThe name of the encoding to change the port to.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone.\n\n\n\n\n\nExample:\n\n\n\n\n\n$encoding = \"utf-8\";\n\nSerial_ChangeEncoding($comPort, $encoding);\n\n\n\n\n\nSerial_Close\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Serial_Close": {
  "prefix": "Serial_Close",
  "body": [
   "Serial_Close($$comPort);"
  ],
  "description": "\n\nCloses an open Serial Port. If the port was already closed, no error is returned.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$comPort\n\nObject\n\nThe instance of the serial port to close. The $comPort object is created by a call to Serial_Open.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone.\n\n\n\n\n\nExample:\n\n\n\n\n\nSerial_Close($comPort);\n\n\n\n\n\nSerial_CloseWithLogging\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Serial_CloseWithLogging": {
  "prefix": "Serial_CloseWithLogging",
  "body": [
   "Serial_CloseWithLogging($$comPort);"
  ],
  "description": "\n\nCloses an open Serial Port, and also closes and flushes the associated text log file. If the port was already closed when the function is run, no error is returned.\n\nImportant Note: This function should only be used to close a serial port which has been opened with the Serial_OpenWithLogging function. If you are using a serial port that has been opened with the Serial_Open function, use the standard Serial_Close function instead.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$comPort\n\nObject\n\nThe instance of the serial port to close. The $comPort object is created by a call to Serial_OpenWithLogging.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone.\n\n\n\n\n\nExample:\n\n\n\n\n\nSerial_CloseWithLogging($comPort);\n\n\n\n\n\nSerial_DiscardInBuffer\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Serial_DiscardInBuffer": {
  "prefix": "Serial_DiscardInBuffer",
  "body": [
   "Serial_DiscardInBuffer($$comPort);"
  ],
  "description": "\n\nDiscards (clears) all of the data in the serial port's incoming buffer. The data is not read, nor is it retrievable.\n\n\n\n\n\nNote:\n\nThe serial port object must have been opened with Serial_Open, Serial_OpenWithHandshaking, or Serial_OpenWithLogging.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$comPort\n\nObject\n\nAn instance of a Serial Port object created with one of the open functions.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone.\n\n\n\n\n\nExample:\n\n\n\n\n\nSerial_DiscardInBuffer($comPort);\n\n\n\n\n\nSerial_DiscardOutBuffer\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Serial_DiscardOutBuffer": {
  "prefix": "Serial_DiscardOutBuffer",
  "body": [
   "Serial_DiscardOutBuffer($$comPort);"
  ],
  "description": "\n\nDiscards (clears) all of the data in the serial port's outgoing buffer. The data is not read, nor is it retrievable.\n\n\n\n\n\nNote:\n\nThe serial port object must have been opened with Serial_Open, Serial_OpenWithHandshaking, or Serial_OpenWithLogging.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$comPort\n\nObject\n\nAn instance of a Serial Port object created with one of the open functions.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone.\n\n\n\n\n\nExample:\n\n\n\n\n\nSerial_DiscardOutBuffer($comPort);\n\n\n\n\n\nSerial_GetNumberBytesToRead\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Serial_GetNumberBytesToRead": {
  "prefix": "Serial_GetNumberBytesToRead",
  "body": [
   "$$numBytes=Serial_GetNumberBytesToRead($$comPort);"
  ],
  "description": "\n\nReturns the number of unread bytes in the incoming buffer for the serial port.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$comPort\n\nObject\n\nAn instance of a Serial Port object created with one of the open functions.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$numBytes\n\nInteger\n\nThe number of unread bytes in the incoming buffer.\n\n\n\n\n\nExample:\n\n\n\n\n\n$numBytes = Serial_GetNumberBytesToRead($comPort);\n\n\n\n\n\nSerial_GetParameters\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Serial_GetParameters": {
  "prefix": "Serial_GetParameters",
  "body": [
   "($$baud,$$dataBits,$$parity,$$stopBits)=Serial_GetParameters($$comPort);"
  ],
  "description": "\n\nReturns the serial communication parameters for the specified serial port.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$comPort\n\nObject\n\nAn instance of a Serial Port object created with one of the open functions.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$baud\n\nInteger\n\nThe baud rate that the port is set to.\n\n\n\n$dataBits\n\nInteger\n\nThe number of data bits in one character for this port.\n\n\n\n$parity\n\nString\n\nThe parity that the port is set to.\n\n\n\n$stopBits\n\nString\n\nThe number of stop bits in one character for this port.\n\n\n\n\n\nExample:\n\n\n\n\n\n($baud, $dataBits, $parity, $stopBits) = Serial_GetParameters($comPort);\n\n\n\n\n\nSerial_GetPortNames\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Serial_GetPortNames": {
  "prefix": "Serial_GetPortNames",
  "body": [
   "$$portNames=Serial_GetPortNames();"
  ],
  "description": "\n\nReturns the names of all of the available serial ports on the computer.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$portNames\n\nString Array\n\nThe names of the available ports.\n\n\n\n\n\nExample:\n\n\n\n\n\n$portNames = Serial_GetPortNames();\n\n\n\n\n\n// Print out all of the port names.\n\n$total = ArrayGetLength($portNames);\n\n$loopCount = 0;\n\nwhile ($loopCount < $total)\n\n{\n\n$tempStr = Array1DGetValue($portNames, $loopCount);\n\nUpdateStatus($tempStr);\n\n$loopCount = $loopCount + 1;\n\n}\n\n\n\n\n\nSerial_GetPortNamesDescriptions\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Serial_GetPortNamesDescriptions": {
  "prefix": "Serial_GetPortNamesDescriptions",
  "body": [
   "($$portNames,$$portDescripts)=Serial_GetPortNamesDescriptions();"
  ],
  "description": "\n\nThis function returns the names and the descriptions of all of the serial (COM) ports on the computer.\n\n\n\n\n\nNote:\n\nNo serial ports need to be opened to use this function.\n\nThis will also return the names of virtual COM ports that were created for USB to serial adapters.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$portNames\n\nString Array\n\nThe names of all of the serial ports on the computer.\n\n\n\n$portDescripts\n\nString Array\n\nThe descriptions of all of the serial ports on the computer.\n\n\n\n\n\nExample:\n\n\n\n\n\n($ports, $descripts) = Serial_GetPortNamesDescriptions();\n\n\n\n\n\n$numPorts = ArrayGetLength($ports);\n\n\n\n\n\n// Ouput the names and descriptions of the ports.\n\n$loopCount = 0;\n\nwhile ($loopCount < $numPorts)\n\n{\n\n$onePort = Array1DGetValue($ports, $loopCount);\n\n$oneDesc = Array1DGetValue($descripts, $loopCount);\n\n\n\n$outStr = \"Port: \" + $onePort + \"\\tDescription: \" + $oneDesc;\n\nUpdateStatus($outStr);\n\n$loopCount = $loopCount + 1;\n\n}\n\n\n\n\n\nSerial_GetPortNumber\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Serial_GetPortNumber": {
  "prefix": "Serial_GetPortNumber",
  "body": [
   "$$portNum=Serial_GetPortNumber($$comPort);"
  ],
  "description": "\n\nReturns the serial port number for a serial port object that was opened with Serial_Open, Serial_OpenWithHandshaking, or Serial_OpenWithLogging.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$comPort\n\nObject\n\nAn instance of a Serial Port object created with one of the open functions.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$portNum\n\nInteger\n\nThe number of the serial port.\n\n\n\n\n\nExample:\n\n\n\n\n\n$portNum = Serial_GetPortNumber($comPort);\n\n\n\n\n\nSerial_HandshakingManualRead\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Serial_HandshakingManualRead": {
  "prefix": "Serial_HandshakingManualRead",
  "body": [
   "$$pinStatus=Serial_HandshakingManualRead($$comPort,$$pinName);"
  ],
  "description": "\n\nReturns the state of the specified handshaking pin for a serial port object that was opened with Serial_Open, Serial_OpenWithHandshaking, or Serial_OpenWithLogging.\n\n\n\nNotes:\n\nThe state of the \"ring\" signal (sometimes called RI) can not be read by this function. This signal is transitory and the pin would have to be watched constantly in order to catch the signal.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$comPort\n\nObject\n\nAn instance of a Serial Port object created with one of the open functions.\n\n\n\n$pinName\n\nString\n\nThe name of the handshaking pin to read. Valid inputs are:\n\n\u00b7 CTS\n\n\u00b7 DSR\n\n\u00b7 DCD\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$pinStatus\n\nBoolean\n\nThe status of the specified pin.\n\n\n\n\n\nExample:\n\n\n\n\n\n$pinName = \"CTS\";\n\n$pinStatus = Serial_HandshakingManualRead($comPort, $pinName);\n\n\n\n\n\nSerial_HandshakingManualSet\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Serial_HandshakingManualSet": {
  "prefix": "Serial_HandshakingManualSet",
  "body": [
   "Serial_HandshakingManualSet($$comPort,$$pinName,$$pinState);"
  ],
  "description": "\n\nSets the state of the specified handshaking pin on a serial port object that was opened with Serial_Open, Serial_OpenWithHandshaking, or Serial_OpenWithLogging.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$comPort\n\nObject\n\nAn instance of a Serial Port object created with one of the open functions.\n\n\n\n$pinName\n\nString\n\nThe name of the handshaking pin to set. Valid inputs are:\n\n\u00b7 RTS\n\n\u00b7 DTR\n\n\n\n$pinState\n\nBoolean\n\nThe state to set the specified pin to.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone.\n\n\n\n\n\nExample:\n\n\n\n\n\n$pinName = \"RTS\";\n\n$pinState = true;\n\nSerial_HandshakingManualSet($comPort, $pinName, $pinState);\n\n\n\n\n\nSerial_IsOpen\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Serial_IsOpen": {
  "prefix": "Serial_IsOpen",
  "body": [
   "$$openState=Serial_IsOpen($$comPort);"
  ],
  "description": "\n\nReturns whether the serial port is open or not.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$comPort\n\nObject\n\nAn instance of a Serial Port object created with one of the open functions.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$openState\n\nBoolean\n\nTrue if the port is already open, False otherwise.\n\n\n\n\n\nExample:\n\n\n\n\n\n$openState = Serial_IsOpen($comPort);\n\n\n\n\n\nSerial_Open\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Serial_Open": {
  "prefix": "Serial_Open",
  "body": [
   "$$portHandle=Serial_Open($$portNumber,$$baudRate,$$dataBits,$$parity,$$stopBits);"
  ],
  "description": "\n\nOpens a Serial port object for communication. The resulting object is then used with the other serial functions to support communication. In order to close the serial port after it has been opened, use the Serial_Close function. If the specified comPort is in use, this function returns a failure.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$portNumber\n\nInteger\n\nThe COM port number to connect to.\n\n\n\n$baudRate\n\nInteger\n\nThe baud rate to open communications at. This must be a baud rate that is supported by the serial port.\n\n\n\n$dataBits\n\nInteger\n\nThe number of bits in each character of data (must be 7 or 8).\n\n\n\n$parity\n\nCharacter\n\nThe parity for the serial port. Valid inputs are:\n\n\u00b7 \"N\" for no parity\n\n\u00b7 \"M\" for mark parity\n\n\u00b7 \"E\" for even parity\n\n\u00b7 \"O\" for odd parity\n\n\u00b7 \"S\" for space parity\n\n\n\n$stopBits\n\nInteger\n\nThe number of stop bits (must be 0, 1, or 2).\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$portHandle\n\nObject\n\nThe instance of the serial port that is returned.\n\n\n\n\n\nExamples:\n\n\n\n\n\n// Open COM3 at 9600 baud with 8 bits, no parity, 1 stop bit.\n\n$portNum = 3;\n\n$baud = 9600;\n\n$bits = 8;\n\n$parity = \"N\";\n\n$stopBits = 1;\n\n$portHandle = Serial_Open($portNum, $baud, $bits, $parity, $stopBits);\n\n\n\n\n\nSerial_OpenBool\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Serial_OpenBool": {
  "prefix": "Serial_OpenBool",
  "body": [
   "($$portHandle,$$success)=Serial_OpenBool($$portNumber,$$baudRate,$$dataBits,$$parity,$$stopBits);"
  ],
  "description": "\n\nOpens a Serial port object for communication. The resulting object is then used with the other serial functions to support communication. In order to close the serial port after it has been opened, use the Serial_Close function.\n\n\n\nNotes:\n\nIf the specified comPort can not be opened, this function will return a false in the $success variable.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$portNumber\n\nInteger\n\nThe COM port number to connect to.\n\n\n\n$baudRate\n\nInteger\n\nThe baud rate to open communications at. This must be a baud rate that is supported by the serial port.\n\n\n\n$dataBits\n\nInteger\n\nThe number of bits in each character of data (must be 7 or 8).\n\n\n\n$parity\n\nCharacter\n\nThe parity for the serial port. Valid inputs are:\n\n\u00b7 \"N\" for no parity\n\n\u00b7 \"M\" for mark parity\n\n\u00b7 \"E\" for even parity\n\n\u00b7 \"O\" for odd parity\n\n\u00b7 \"S\" for space parity\n\n\n\n$stopBits\n\nInteger\n\nThe number of stop bits (must be 0, 1, or 2).\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$portHandle\n\nObject\n\nThe instance of the serial port that is returned.\n\n\n\n$success\n\nBoolean\n\nReturns True if the com port is successfully opened, False otherwise.\n\n\n\n\n\nExamples:\n\n\n\n\n\n// Open COM3 at 9600 baud with 8 bits, no parity, 1 stop bit.\n\n$portNum = 3;\n\n$baud = 9600;\n\n$bits = 8;\n\n$parity = \"N\";\n\n$stopBits = 1;\n\n\n\n\n\n($portHandle, $success) = Serial_OpenBool($portNum, $baud, $bits, $parity, $stopBits);\n\n\n\n\n\nSerial_OpenWithHandshaking\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Serial_OpenWithHandshaking": {
  "prefix": "Serial_OpenWithHandshaking",
  "body": [
   "$$portHandle=Serial_OpenWithHandshaking($$portNumber,$$baudRate,$$dataBits,$$parity,$$stopBits,$$handshakeMode);"
  ],
  "description": "\n\nOpens a Serial port object for communication. The resulting object is then used with the other serial functions to support communication. In order to close the serial port after it has been opened, use the Serial_Close function. If the specified comPort is in use, this function returns a failure.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$portNumber\n\nInteger\n\nThe COM port number to connect to.\n\n\n\n$baudRate\n\nInteger\n\nThe baud rate to open communications at. This must be a baud rate that is supported by the serial port.\n\n\n\n$dataBits\n\nInteger\n\nThe number of bits in each character of data (must be 7 or 8).\n\n\n\n$parity\n\nCharacter\n\nThe parity for the serial port. Valid inputs are:\n\n\u00b7 \"N\" for no parity\n\n\u00b7 \"M\" for mark parity\n\n\u00b7 \"E\" for even parity\n\n\u00b7 \"O\" for odd parity\n\n\u00b7 \"S\" for space parity\n\n\n\n$stopBits\n\nInteger\n\nThe number of stop bits (must be 0, 1, or 2).\n\n\n\n$handshakeMode\n\nString\n\nThe handshaking mode to use with the serial port. Valid inputs are:\n\n\u00b7 \"NONE\"\n\n\u00b7 \"RTS\"\n\n\u00b7 \"XON/XOFF\"\n\n\u00b7 RTSXON/XOFF\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$portHandle\n\nObject\n\nThe instance of the serial port that is returned.\n\n\n\n\n\nExamples:\n\n\n\n\n\n// Open COM3 at 9600 baud with 8 bits, no parity, 1 stop bit.\n\n$portNum = 3;\n\n$baud = 9600;\n\n$bits = 8;\n\n$parity = \"N\";\n\n$stopBits = 1;\n\n$handshake = \"Xon/Xoff\"; // NOTE: not case sensitive.\n\n$portHandle = Serial_OpenWithHandshaking($portNum, $baud, $bits, $parity, $stopBits, $handshake);\n\n\n\n\n\nSerial_OpenWithHandshakingBool\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Serial_OpenWithHandshakingBool": {
  "prefix": "Serial_OpenWithHandshakingBool",
  "body": [
   "($$portHandle,$$success)=Serial_OpenWithHandshakingBool($$portNumber,$$baudRate,$$dataBits,$$parity,$$stopBits,$$handshakeMode);"
  ],
  "description": "\n\nOpens a Serial port object for communication. The resulting object is then used with the other serial functions to support communication. In order to close the serial port after it has been opened, use the Serial_Close function.\n\n\n\nNotes:\n\nIf the specified comPort can not be opened, this function will return a false in the $success variable.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$portNumber\n\nInteger\n\nThe COM port number to connect to.\n\n\n\n$baudRate\n\nInteger\n\nThe baud rate to open communications at. This must be a baud rate that is supported by the serial port.\n\n\n\n$dataBits\n\nInteger\n\nThe number of bits in each character of data (must be 7 or 8).\n\n\n\n$parity\n\nCharacter\n\nThe parity for the serial port. Valid inputs are:\n\n\u00b7 \"N\" for no parity\n\n\u00b7 \"M\" for mark parity\n\n\u00b7 \"E\" for even parity\n\n\u00b7 \"O\" for odd parity\n\n\u00b7 \"S\" for space parity\n\n\n\n$stopBits\n\nInteger\n\nThe number of stop bits (must be 0, 1, or 2).\n\n\n\n$handshakeMode\n\nString\n\nThe handshaking mode to use with the serial port. Valid inputs are:\n\n\u00b7 \"NONE\"\n\n\u00b7 \"RTS\"\n\n\u00b7 \"XON/XOFF\"\n\n\u00b7 RTSXON/XOFF\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$portHandle\n\nObject\n\nThe instance of the serial port that is returned.\n\n\n\n$success\n\nBoolean\n\nReturns True if the com port is successfully opened, False otherwise.\n\n\n\n\n\nExamples:\n\n\n\n\n\n// Open COM3 at 9600 baud with 8 bits, no parity, 1 stop bit.\n\n$portNum = 3;\n\n$baud = 9600;\n\n$bits = 8;\n\n$parity = \"N\";\n\n$stopBits = 1;\n\n$handshake = \"Xon/Xoff\"; // NOTE: not case sensitive.\n\n\n\n\n\n($portHandle, $success) = Serial_OpenWithHandshakingBool($portNum, $baud, $bits, $parity, $stopBits, $handshake);\n\n\n\n\n\nSerial_OpenWithLogging\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Serial_OpenWithLogging": {
  "prefix": "Serial_OpenWithLogging",
  "body": [
   "$$portHandle=Serial_OpenWithLogging($$portNumber,$$baudRate,$$dataBits,$$parity,$$stopBits,$$logFilePath);"
  ],
  "description": "\n\nCreates and Opens a Serial port object for communication, and creates a log file that will record all the information sent to/from the serial port.\n\n\n\n\n\nRemarks:\n\nIn order to record data sent to and from the serial port, use the Serial_SendWithLogging function.\n\nIf you do not wish a particular serial action to be recorded to the log, use the standard Serial_Send function.\n\nThe resulting object is then used with the other serial functions to support communication. In order to close the serial port after it has been created, use the Serial_CloseWithLogging function.\n\nIf the specified comPort is in use, this function returns a failure.\n\nIf you use the standard Serial_Close function with a COM port which was opened using the Serial_OpenWithLogging function, the data log file will never be properly closed.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$portNumber\n\nInteger\n\nThe COM port number to connect to.\n\n\n\n$baudRate\n\nInteger\n\nThe baud rate to open communications at. This must be a baud rate that is supported by the serial port.\n\n\n\n$dataBits\n\nInteger\n\nThe number of bits in each character of data (must be 7 or 8).\n\n\n\n$parity\n\nCharacter\n\nThe parity for the serial port. Valid inputs are: \"N\" for no parity\n\n\"M\" for mark parity\n\n\"E\" for even parity\n\n\"O\" for odd parity\n\n\"S\" for space parity\n\n\n\n\n\n$stopBits\n\nInteger\n\nThe number of stop bits (must be 0, 1, or 2).\n\n\n\n$logFilePath\n\nString\n\nThe path and filename for the log file.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$portHandle\n\nObject\n\nThe instance of the port handle that is returned.\n\n\n\n\n\nExample:\n\n\n\n\n\n// Open COM3 at 9600 baud with 8 bits, no parity, 1 stop bit.\n\n$portNum = 3;\n\n$baud = 9600;\n\n$bits = 8;\n\n$parity = \"N\";\n\n$stopBits = 1;\n\n$logFile = \"C:\\\\Temp\\\\Serial_Log.txt\";\n\n\n\n$portHandle = Serial_OpenWithLogging($portNum, $baud, $bits, $parity, $stopBits, $logFile);\n\n\n\n\n\nSerial_OpenWithLoggingBool\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Serial_OpenWithLoggingBool": {
  "prefix": "Serial_OpenWithLoggingBool",
  "body": [
   "($$portHandle,$$success)=Serial_OpenWithLoggingBool($$portNumber,$$baudRate,$$dataBits,$$parity,$$stopBits,$$logFilePath);"
  ],
  "description": "\n\nCreates and Opens a Serial port object for communication, and creates a log file that will record all the information sent to/from the serial port.\n\n\n\n\n\nRemarks:\n\nIn order to record data sent to and from the serial port, use the Serial_SendWithLogging function.\n\nIf you do not wish a particular serial action to be recorded to the log, use the standard Serial_Send function.\n\nThe resulting object is then used with the other serial functions to support communication. In order to close the serial port after it has been created, use the Serial_CloseWithLogging function.\n\nIf you use the standard Serial_Close function with a COM port which was opened using the Serial_OpenWithLoggingBool function, the data log file will never be properly closed.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$portNumber\n\nInteger\n\nThe COM port number to connect to.\n\n\n\n$baudRate\n\nInteger\n\nThe baud rate to open communications at. This must be a baud rate that is supported by the serial port.\n\n\n\n$dataBits\n\nInteger\n\nThe number of bits in each character of data (must be 7 or 8).\n\n\n\n$parity\n\nCharacter\n\nThe parity for the serial port. Valid inputs are: \"N\" for no parity\n\n\"M\" for mark parity\n\n\"E\" for even parity\n\n\"O\" for odd parity\n\n\"S\" for space parity\n\n\n\n\n\n$stopBits\n\nInteger\n\nThe number of stop bits (must be 0, 1, or 2).\n\n\n\n$logFilePath\n\nString\n\nThe path and filename for the log file.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$portHandle\n\nObject\n\nThe instance of the port handle that is returned.\n\n\n\n$success\n\nBoolean\n\nReturns True if the comp port is successfully opened, False otherwise.\n\n\n\n\n\nExample:\n\n\n\n\n\n// Open COM3 at 9600 baud with 8 bits, no parity, 1 stop bit.\n\n$portNum = 3;\n\n$baud = 9600;\n\n$bits = 8;\n\n$parity = \"N\";\n\n$stopBits = 1;\n\n$logFile = \"C:\\\\Temp\\\\Serial_Log.txt\";\n\n\n\n($portHandle, $success) = Serial_OpenWithLoggingBool($portNum, $baud, $bits, $parity, $stopBits, $logFile);\n\n\n\n\n\nSerial_ReadByte\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Serial_ReadByte": {
  "prefix": "Serial_ReadByte",
  "body": [
   "$$oneByte=Serial_ReadByte($$comPort,$$timeout);"
  ],
  "description": "\n\nReturns one byte from the input buffer of the specified serial port object that was opened with Serial_Open, Serial_OpenWithHandshaking, or Serial_OpenWithLogging.\n\n\n\n\n\nRemarks:\n\nIf no data is received before the timeout has expired, this function will return a FAIL. To avoid the fail result, use the function Serial_GetNumberBytesToRead to ensure there is data in the buffer.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$comPort\n\nObject\n\nAn instance of a Serial Port object created with one of the open functions.\n\n\n\n$timeout\n\nInteger\n\nThe maximum number of seconds to wait for a byte to appear in the incoming buffer.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$oneByte\n\nInteger\n\nOne byte from the incoming data buffer.\n\n\n\n\n\nExample:\n\n\n\n\n\n$timeout = 2; // wait for two seconds.\n\n$oneByte = Serial_ReadByte($comPort, $timeout);\n\n\n\n\n\nSerial_ReadExisting\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Serial_ReadExisting": {
  "prefix": "Serial_ReadExisting",
  "body": [
   "$$input=Serial_ReadExisting($$comPort,$$timeout);"
  ],
  "description": "\n\nReturns all of the data from the input buffer of the specified serial port object that was opened with Serial_OpenWithLogging. Also saves all of the data to the file that was opened when the serial port was opened.\n\n\n\n\n\nRemarks:\n\nIf no data is received before the timeout has expired, this function will return a FAIL. To avoid the fail result, use the function Serial_GetNumberBytesToRead to ensure there is data in the buffer.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$comPort\n\nObject\n\nAn instance of a Serial Port object created with one of the open functions.\n\n\n\n$timeout\n\nInteger\n\nThe maximum number of seconds to wait for data coming in to the incoming buffer.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$input\n\nString\n\nAll of the data currently in the incoming buffer.\n\n\n\n\n\nExample:\n\n\n\n\n\n$timeout = 2; // wait for two seconds.\n\n$input = Serial_ReadExistingWithLogging($comPort, $timeout);\n\n\n\n\n\nSerial_ReadLine\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Serial_ReadLine": {
  "prefix": "Serial_ReadLine",
  "body": [
   "$$line=Serial_ReadLine($$comPort,$$timeout);"
  ],
  "description": "\n\nReturns one line from the data in the input buffer of the specified serial port up to a New Line character.\n\n\n\n\n\nRemarks:\n\nThe serial port object must have been opened with Serial_Open, Serial_OpenWithHandshaking, or Serial_OpenWithLogging.\n\nThe New Line character(s) is set using the Serial_SetNewLine function.\n\nIf no data is received before the timeout has expired, this function will return a FAIL. To avoid the fail result, use the function Serial_GetNumberBytesToRead to ensure there is data in the buffer.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$comPort\n\nObject\n\nAn instance of a Serial Port object created with one of the open functions.\n\n\n\n$timeout\n\nInteger\n\nThe maximum number of seconds to wait for a line of data to come into the incoming buffer.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$line\n\nString\n\nOne line of data from the incoming buffer.\n\n\n\n\n\nExample:\n\n\n\n\n\n$newLineChar = \"\\r\\n\"; // Set end of line to the carriage return, line feed characters.\n\nSerial_SetNewLine($comPort, $newLineChar);\n\n\n\n\n\n$timeout = 2; // wait for two seconds.\n\n$line = Serial_ReadLine($comPort, $timeout);\n\n\n\n\n\nSerial_ReceiveBinaryToArray\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Serial_ReceiveBinaryToArray": {
  "prefix": "Serial_ReceiveBinaryToArray",
  "body": [
   "$$byteArray=Serial_ReceiveBinaryToArray($$comPort,$$timeout);"
  ],
  "description": "\n\nReceives data from a serial port for a specified amount of time. The data is returned in an integer array.\n\n\n\n\n\nNote:\n\nThe serial port object must have been opened with Serial_Open, Serial_OpenWithHandshaking, or Serial_OpenWithLogging.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$comPort\n\nObject\n\nAn instance of a Serial Port object created with one of the open functions.\n\n\n\n$timeout\n\nInteger\n\nThe maximum number of seconds to wait for a line of data to come into the incoming buffer.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$byteArray\n\nInteger Array\n\nThe data received by the serial port.\n\n\n\n\n\nExample:\n\n\n\n\n\n$timeout = 2; // wait for two seconds.\n\n$byteArray = Serial_ReceiveBinaryToArray($comPort, $timeout);\n\n\n\n\n\nSerial_ReceiveBinaryToArrayWithCount\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Serial_ReceiveBinaryToArrayWithCount": {
  "prefix": "Serial_ReceiveBinaryToArrayWithCount",
  "body": [
   "($$byteArray,$$numBytes)=Serial_ReceiveBinaryToArrayWithCount($$comPort,$$timeout);"
  ],
  "description": "\n\nReceives data from a serial port for a specified amount of time. The data is returned in an integer array. The number of bytes received is also returned.\n\n\n\n\n\nNote:\n\nThe serial port object must have been opened with Serial_Open, Serial_OpenWithHandshaking, or Serial_OpenWithLogging.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$comPort\n\nObject\n\nAn instance of a Serial Port object created with one of the open functions.\n\n\n\n$timeout\n\nInteger\n\nThe maximum number of seconds to wait for a line of data to come into the incoming buffer.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$byteArray\n\nInteger Array\n\nThe data received by the serial port.\n\n\n\n$numBytes\n\nInteger\n\nThe number of bytes received by the serial port.\n\n\n\n\n\nExample:\n\n\n\n\n\n$timeout = 2; // wait for two seconds.\n\n($byteArray, $numBytes) = Serial_ReceiveBinaryToArrayWithCount($comPort, $timeout);\n\n\n\n\n\nSerial_Send\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Serial_Send": {
  "prefix": "Serial_Send",
  "body": [
   "$$returned=Serial_Send($$comPort,$$sendString,$$waitString,$$timeout);"
  ],
  "description": "\n\nThis function sends a string to the output buffer of a serial port and waits for a specified string to be returned.\n\n\n\nRemarks:\n\nThe serial port object must have been opened with Serial_Open, Serial_OpenWithHandshaking, or Serial_OpenWithLogging.\n\nIf the wait string is not received within the time out time, the test will return a Fail.\n\nIf the send string is empty, the function will send nothing and wait for the wait string to be received.\n\nIf the wait string is empty, the send string will be sent and the function will return after the timeout has expired.\n\nIf the wait string is empty and the timeout value is set to 0, the send string will be sent and anything already in the receive buffer will be immediately returned.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$comPort\n\nObject\n\nAn instance of a Serial Port object created with one of the open functions.\n\n\n\n$sendString\n\nString\n\nThe string to be sent to the com port.\n\n\n\n$waitString\n\nString\n\nThe string to wait for in response before continuing.\n\n\n\n$timeout\n\nInteger\n\nThe maximum number of seconds to wait for data to come into the incoming buffer.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$returned\n\nString\n\nThe data received by the serial port. This will include all of the data received including the wait string, if it was received.\n\n\n\n\n\nExample:\n\n\n\n\n\n$sendString = \"Send To Port\";\n\n$waitString = \"Return\";\n\n$timeout = 2; // Wait for two seconds.\n\n\n\n$returned = Serial_Send($comPort, $sendString, $waitString, $timeout);\n\n\n\n\n\nSerial_SendBinary\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Serial_SendBinary": {
  "prefix": "Serial_SendBinary",
  "body": [
   "$$returned=Serial_SendBinary($$comPort,$$sendString,$$waitString,$$timeout);"
  ],
  "description": "\n\nSends a string to the output buffer of a serial port and waits for a specified string to be returned.\n\n\n\n\n\nThe Serial_SendBinary function differs from the Serial_Send function in the fact that the $sendString, $waitStirng and $returned are text strings representing the hexadecimal values to be sent and received via the comPort. The format of the strings is a collection of 2 digit hexadecimal values separated by spaces.\n\n\n\n\n\nNote:\n\nThe serial port object must have been opened with Serial_Open, Serial_OpenWithHandshaking, or Serial_OpenWithLogging.\n\nIf the wait string is not received within the time out time, the test will return a Fail.\n\nIf the send string is empty, the function will send nothing and wait for the wait string to be received.\n\nIf the wait string is empty, the send string will be sent and the function will return after the timeout has expired.\n\nIf the wait string is empty and the timeout value is set to 0, the send string will be sent and anything already in the receive buffer will be immediately returned.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$comPort\n\nObject\n\nAn instance of a Serial Port object created with one of the open functions.\n\n\n\n$sendString\n\nString\n\nThe string to be sent to the com port.\n\n\n\n$waitString\n\nString\n\nThe string to wait for in response before continuing.\n\n\n\n$timeout\n\nInteger\n\nThe maximum number of seconds to wait for data to come into the incoming buffer.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$returned\n\nString\n\nThe data received by the serial port. This will include all of the data received including the wait string, if it was received.\n\n\n\n\n\nExample:\n\n\n\n\n\n// Send the string \"DOG\" and wait 2 seconds for the string \"CAT\".\n\n$sendString = \"44 4F 47\";\n\n$waitString = \"43 41 54\";\n\n$timeout = 2; // wait for two seconds.\n\n$returned = Serial_SendBinary($comPort, $sendString, $waitString, $timeout);\n\n\n\n\n\nSerial_SendBinaryBool\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Serial_SendBinaryBool": {
  "prefix": "Serial_SendBinaryBool",
  "body": [
   "($$returned,$$found)=Serial_SendBinaryBool($$comPort,$$sendString,$$waitString,$$timeout);"
  ],
  "description": "\n\nSends a string to the output buffer of a serial port and waits for a specified string to be returned.\n\n\n\n\n\nThe Serial_SendBinary function differs from the Serial_Send function in the fact that the $sendString, $waitStirng and $returned are text strings representing the hexadecimal values to be sent and received via the comPort. The format of the strings is a collection of 2 digit hexadecimal values separated by spaces.\n\n\n\n\n\nNote:\n\nThe serial port object must have been opened with Serial_Open, Serial_OpenWithHandshaking, or Serial_OpenWithLogging.\n\nIf the wait string is not received within the time out time, the test will not return a Fail. The boolean value for whether the string was found will be false.\n\nIf the send string is empty, the function will send nothing and wait for the wait string to be received or the timeout to expire.\n\nIf the wait string is empty, the send string will be sent and the function will return after the timeout has expired. Anything in the receive buffer will be returned.\n\nIf the wait string is empty and the timeout value is set to 0, the send string will be sent and anything already in the receive buffer will be immediately returned.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$comPort\n\nObject\n\nAn instance of a Serial Port object created with one of the open functions.\n\n\n\n$sendString\n\nString\n\nThe string to be sent to the com port.\n\n\n\n$waitString\n\nString\n\nThe string to wait for in response before continuing.\n\n\n\n$timeout\n\nInteger\n\nThe maximum number of seconds to wait for data to come into the incoming buffer.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$returned\n\nString\n\nThe data received by the serial port. This will include all of the data received including the wait string, if it was received.\n\n\n\n$found\n\nBoolean\n\nTrue if the wait string was found, False otherwise.\n\n\n\n\n\nExample:\n\n\n\n\n\n// Send the string \"DOG\" and wait 2 seconds for the string \"CAT\".\n\n$sendString = \"44 4F 47\";\n\n$waitString = \"43 41 54\";\n\n$timeout = 2; // wait for two seconds.\n\n($returned, $found) = Serial_SendBinaryBool($comPort, $sendString, $waitString, $timeout);\n\n\n\n\n\nSerial_SendBinaryFromArray\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Serial_SendBinaryFromArray": {
  "prefix": "Serial_SendBinaryFromArray",
  "body": [
   "Serial_SendBinaryFromArray($$comPort,$$sendArray,$$index,$$numBytes);"
  ],
  "description": "\n\nSends a string to the output buffer of a serial port from the starting index of an array for the specified number of bytes.\n\n\n\n\n\nNote:\n\nThe serial port object must have been opened with Serial_Open, Serial_OpenWithHandshaking, or Serial_OpenWithLogging.\n\nThe array must be of integers and only the lower 8 bits will be sent.\n\nArray indices are zero-based. The first byte in the array has an index of zero.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$comPort\n\nObject\n\nAn instance of a Serial Port object created with one of the open functions.\n\n\n\n$sendArray\n\nInteger Array\n\nThe data to be sent to the com port.\n\n\n\n$index\n\nInteger\n\nThe byte of the array to start sending from.\n\n\n\n$numBytes\n\nInteger\n\nThe number of bytes to send from the buffer (from the starting index).\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone.\n\n\n\n\n\nExample:\n\n\n\n\n\n// Send 8 bytes of data starting at index 3 from the array.\n\nSerial_SendBinaryFromArray($comPort, $sendArray, 3, 8);\n\n\n\n\n\nSerial_SendBinaryInUnicode\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Serial_SendBinaryInUnicode": {
  "prefix": "Serial_SendBinaryInUnicode",
  "body": [
   "$$returned=Serial_SendBinaryInUnicode($$comPort,$$sendString,$$waitString,$$timeout);"
  ],
  "description": "\n\nThis function sends a string to the output buffer of a serial port and waits for a specified string to be returned.\n\nThe Serial_SendBinaryInUnicode function differs from the Serial_SendBinary function in the fact that the values are interpreted as multi-byte Unicode characters where appropriate.\n\n\n\nRemarks:\n\nThe serial port object must have been opened with Serial_Open, Serial_OpenWithHandshaking, or Serial_OpenWithLogging.\n\nIf the wait string is not received within the time out time, the test will return a Fail.\n\nIf the send string is empty, the function will send nothing and wait for the wait string to be received.\n\nIf the wait string is empty, the send string will be sent and the function will return after the timeout has expired.\n\nIf the wait string is empty and the timeout value is set to 0, the send string will be sent and anything already in the receive buffer will be immediately returned.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$comPort\n\nObject\n\nAn instance of a Serial Port object created with one of the open functions.\n\n\n\n$sendString\n\nString\n\nThe string to be sent to the com port.\n\n\n\n$waitString\n\nString\n\nThe string to wait for in response before continuing.\n\n\n\n$timeout\n\nInteger\n\nThe maximum number of seconds to wait for data to come into the incoming buffer.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$returned\n\nString\n\nThe data received by the serial port. This will include all of the data received including the wait string, if it was received.\n\n\n\n\n\nExample:\n\n\n\n\n\n// Send the string \"DOG\" and wait 2 seconds for the string \"CAT\".\n\n$sendString = \"44 4F 47\";\n\n$waitString = \"43 41 54\";\n\n$timeout = 2; // Wait for two seconds.\n\n\n\n$returned = Serial_SendBinaryInUnicode($comPort, $sendString, $waitString, $timeout);\n\n\n\n\n\nSerial_SendBinaryMilliseconds\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Serial_SendBinaryMilliseconds": {
  "prefix": "Serial_SendBinaryMilliseconds",
  "body": [
   "$$returned=Serial_SendBinaryMilliseconds($$comPort,$$sendString,$$waitString,$$timeout);"
  ],
  "description": "\n\nSends a string to the output buffer of a serial port and waits for a specified string to be returned.\n\n\n\n\n\nThe Serial_SendBinaryMilliseconds function differs from the Serial_Send function in the fact that the $sendString, $waitStirng and $returned are text strings representing the hexadecimal values to be sent and received via the comPort and the timeout value is in milliseconds. The format of the strings is a collection of 2 digit hexadecimal values separated by spaces.\n\n\n\n\n\nNote:\n\nThe serial port object must have been opened with Serial_Open, Serial_OpenWithHandshaking, or Serial_OpenWithLogging.\n\nIf the wait string is not received within the time out time, the test will return a Fail.\n\nIf the send string is empty, the function will send nothing and wait for the wait string to be received.\n\nIf the wait string is empty, the send string will be sent and the function will return after the timeout has expired.\n\nIf the wait string is empty and the timeout value is set to 0, the send string will be sent and anything already in the receive buffer will be immediately returned.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$comPort\n\nObject\n\nAn instance of a Serial Port object created with one of the open functions.\n\n\n\n$sendString\n\nString\n\nThe string to be sent to the com port.\n\n\n\n$waitString\n\nString\n\nThe string to wait for in response before continuing.\n\n\n\n$timeout\n\nInteger\n\nThe maximum number of milliseconds to wait for a line of data to come into the incoming buffer.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$returned\n\nString\n\nThe data received by the serial port. This will include all of the data received including the wait string, if it was received.\n\n\n\n\n\nExample:\n\n\n\n\n\n// Send the string \"DOG\" and wait 2 seconds for the string \"CAT\".\n\n$sendString = \"44 4F 47\";\n\n$waitString = \"43 41 54\";\n\n$timeout = 2000; // wait for two seconds.\n\n$returned = Serial_SendBinary($comPort, $sendString, $waitString, $timeout);\n\n\n\n\n\nSerial_SendBinaryMillisecondsBool\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Serial_SendBinaryMillisecondsBool": {
  "prefix": "Serial_SendBinaryMillisecondsBool",
  "body": [
   "($$returned,$$found)=Serial_SendBinaryMillisecondsBool($$comPort,$$sendString,$$waitString,$$timeout);"
  ],
  "description": "\n\nSends a string to the output buffer of a serial port and waits for a specified string to be returned.\n\n\n\n\n\nThe Serial_SendBinaryMillisecondsBool function differs from the Serial_Send function in the fact that the $sendString, $waitStirng and $returned are text strings representing the hexadecimal values to be sent and received via the comPort and the timeout value is in milliseconds. The format of the strings is a collection of 2 digit hexadecimal values separated by spaces.\n\n\n\n\n\nNote:\n\nThe serial port object must have been opened with Serial_Open, Serial_OpenWithHandshaking, or Serial_OpenWithLogging.\n\nIf the wait string is not received within the time out time, the test will not return a Fail. The boolean value for whether the string was found will be false.\n\nIf the send string is empty, the function will send nothing and wait for the wait string to be received.\n\nIf the wait string is empty, the send string will be sent and the function will return after the timeout has expired. Anything in the receive buffer will be returned.\n\nIf the wait string is empty and the timeout value is set to 0, the send string will be sent and anything already in the receive buffer will be immediately returned.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$comPort\n\nObject\n\nAn instance of a Serial Port object created with one of the open functions.\n\n\n\n$sendString\n\nString\n\nThe string to be sent to the com port.\n\n\n\n$waitString\n\nString\n\nThe string to wait for in response before continuing.\n\n\n\n$timeout\n\nInteger\n\nThe maximum number of milliseconds to wait for a line of data to come into the incoming buffer.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$returned\n\nString\n\nThe data received by the serial port. This will include all of the data received including the wait string, if it was received.\n\n\n\n$found\n\nBoolean\n\nTrue if the wait string was found, False otherwise.\n\n\n\n\n\nExample:\n\n\n\n\n\n// Send the string \"DOG\" and wait 2 seconds for the string \"CAT\".\n\n$sendString = \"44 4F 47\";\n\n$waitString = \"43 41 54\";\n\n$timeout = 2000; // wait for two seconds.\n\n($returned, $found) = Serial_SendBinaryMillisecondsBool($comPort, $sendString, $waitString, $timeout);\n\n\n\n\n\nSerial_SendBinaryWithDelays\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Serial_SendBinaryWithDelays": {
  "prefix": "Serial_SendBinaryWithDelays",
  "body": [
   "$$returned=Serial_SendBinaryWithDelays($$comPort,$$sendString,$$waitString,$$timeout,$$delay);"
  ],
  "description": "\n\nThis function sends a string to the output buffer of a serial port and waits for a specified string to be returned.\n\nThe Serial_SendBinaryWithDelays function differs from the Serial_Send function in the fact that the $sendString, $waitString and $returned are text strings representing the hexadecimal values to be sent and received via the comPort and the timeout value is in milliseconds. The format of the strings is a collection of 2 digit hexadecimal values separated by spaces.\n\nThe Serial_SendBinaryWithDelays function differs from the Serial_SendBinary function in the fact that it inserts a delay specified by the $delay argument between each character that is sent out of the serial port. This function is useful for DUT's that don't support a proper FIFO buffer and aren't able to process characters sent at the native baud rate setting of the serial port.\n\n\n\nRemarks:\n\nThe serial port object must have been opened with Serial_Open, Serial_OpenWithHandshaking, or Serial_OpenWithLogging.\n\nIf the wait string is not received within the time out time, the test will return a Fail.\n\nIf the send string is empty, the function will send nothing and wait for the wait string to be received.\n\nIf the wait string is empty, the send string will be sent and the function will return after the timeout has expired.\n\nIf the wait string is empty and the timeout value is set to 0, the send string will be sent and anything already in the receive buffer will be immediately returned.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$comPort\n\nObject\n\nAn instance of a Serial Port object created with one of the open functions.\n\n\n\n$sendString\n\nString\n\nThe string to be sent to the com port.\n\n\n\n$waitString\n\nString\n\nThe string to wait for in response before continuing.\n\n\n\n$timeout\n\nInteger\n\nThe maximum number of seconds to wait for data to come into the incoming buffer.\n\n\n\n$delay\n\nInteger\n\nThe number of milliseconds to wait between each byte sent.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$returned\n\nString\n\nThe data received by the serial port. This will include all of the data received including the wait string, if it was received.\n\n\n\n\n\nExample:\n\n\n\n\n\n// Send the string \"DOG\" and wait 2 seconds for the string \"CAT\".\n\n$sendString = \"44 4F 47\";\n\n$waitString = \"43 41 54\";\n\n$timeout = 2; // Wait for two seconds.\n\n$delay = 15; // Fifteen milliseconds between bytes.\n\n\n\n$returned = Serial_SendBinaryWithDelays($comPort, $sendString, $waitString, $timeout, $delay);\n\n\n\n\n\nSerial_SendBool\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Serial_SendBool": {
  "prefix": "Serial_SendBool",
  "body": [
   "($$returned,$$found)=Serial_SendBool($$comPort,$$sendString,$$waitString,$$timeout);"
  ],
  "description": "\n\nThis function sends a string to the output buffer of a serial port and waits for a specified string to be returned. Returns all the data received and a boolean indicating whether the wait string was found.\n\n\n\nRemarks:\n\nThe serial port object must have been opened with Serial_Open, Serial_OpenWithHandshaking, or Serial_OpenWithLogging.\n\nIf the wait string is not received within the time out time, the test will return a Fail.\n\nIf the send string is empty, the function will send nothing and wait for the wait string to be received.\n\nIf the wait string is empty, the send string will be sent and the function will return after the timeout has expired.\n\nIf the wait string is empty and the timeout value is set to 0, the send string will be sent and anything already in the receive buffer will be immediately returned.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$comPort\n\nObject\n\nAn instance of a Serial Port object created with one of the open functions.\n\n\n\n$sendString\n\nString\n\nThe string to be sent to the com port.\n\n\n\n$waitString\n\nString\n\nThe string to wait for in response before continuing.\n\n\n\n$timeout\n\nInteger\n\nThe maximum number of seconds to wait for data to come into the incoming buffer.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$returned\n\nString\n\nThe data received by the serial port. This will include all of the data received including the wait string, if it was received.\n\n\n\n$found\n\nBoolean\n\nTrue if the wait string was found, False otherwise.\n\n\n\n\n\nExample:\n\n\n\n\n\n$sendString = \"Send To Port\";\n\n$waitString = \"Return\";\n\n$timeout = 2; // Wait for two seconds.\n\n\n\n($returned, $found) = Serial_SendBool($comPort, $sendString, $waitString, $timeout);\n\n\n\n\n\nSerial_SendBreak\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Serial_SendBreak": {
  "prefix": "Serial_SendBreak",
  "body": [
   "Serial_SendBreak($$comPort,$$breakLength);"
  ],
  "description": "\n\nSends a break signal on the com port.\n\nA break signal is defined as the voltage level that represents a zero, held for a time longer than one character space. This function lets the user define the length to hold it in milliseconds.\n\n\n\n\n\nNotes:\n\nThe serial port object must have been opened with Serial_Open, Serial_OpenWithHandshaking, or Serial_OpenWithLogging.\n\nAt 9600 baud, each bit is 0.104 milliseconds. Since the minimum hold time for this function is 1 millisecond, this is equivalent to almost 10 bits and should be recognized by the instrument connected to the computer.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$comPort\n\nObject\n\nAn instance of a Serial Port object created with one of the open functions.\n\n\n\n$breakLength\n\nInteger\n\nThe number of milliseconds to hold the break signal before releasing the com port for normal operations.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone.\n\n\n\n\n\nExample:\n\n\n\n\n\n$breakLength = 2; // Hold Break for 2 milliseconds.\n\nSerial_SendBreak($comPort, $breakLength);\n\n\n\n\n\nSerial_SendHex\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Serial_SendHex": {
  "prefix": "Serial_SendHex",
  "body": [
   "Serial_SendHex($$comPort,$$sendValue);"
  ],
  "description": "\n\nSends the ASCII encoded character equivalent of the $sendValue parameter.\n\nNote:\n\nThe serial port object must have been opened with Serial_Open, Serial_OpenWithHandshaking, or Serial_OpenWithLogging.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$comPort\n\nObject\n\nAn instance of a Serial Port object created with one of the open functions.\n\n\n\n$sendValue\n\nInteger\n\nThe integer value of the ASCII character to send of the Serial port.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone.\n\n\n\n\n\nExample:\n\n\n\n\n\n// Get a reference to the COM port.\n\n$comPort = 3;\n\n$baudRate = 9600;\n\n$byteSize = 8;\n\n$parity = \"N\";\n\n$stopBits = 1;\n\n$comObject = Serial_Open($comPort, $baudRate, $byteSize, $parity, $stopBits);\n\n\n\n\n\n// now send our character (the space character).\n\n$charToSend = 32;\n\nSerial_SendHex($comObject, $charToSend);\n\n\n\n\n\nSerial_SendMilliseconds\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Serial_SendMilliseconds": {
  "prefix": "Serial_SendMilliseconds",
  "body": [
   "$$returned=Serial_SendMilliseconds($$comPort,$$sendString,$$waitString,$$timeout);"
  ],
  "description": "\n\nThis function sends a string to the output buffer of a serial port and waits for a specified string to be returned.\n\n\n\nRemarks:\n\nThe serial port object must have been opened with Serial_Open, Serial_OpenWithHandshaking, or Serial_OpenWithLogging.\n\nIf the wait string is not received within the time out time, the test will return a Fail.\n\nIf the send string is empty, the function will send nothing and wait for the wait string to be received.\n\nIf the wait string is empty, the send string will be sent and the function will return after the timeout has expired.\n\nIf the wait string is empty and the timeout value is set to 0, the send string will be sent and anything already in the receive buffer will be immediately returned.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$comPort\n\nObject\n\nAn instance of a Serial Port object created with one of the open functions.\n\n\n\n$sendString\n\nString\n\nThe string to be sent to the com port.\n\n\n\n$waitString\n\nString\n\nThe string to wait for in response before continuing.\n\n\n\n$timeout\n\nInteger\n\nThe maximum number of milliseconds to wait for data to come into the incoming buffer.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$returned\n\nString\n\nThe data received by the serial port. This will include all of the data received including the wait string, if it was received.\n\n\n\n\n\nExample:\n\n\n\n\n\n$sendString = \"Send To Port\";\n\n$waitString = \"Return\";\n\n$timeout = 2000; // Wait for two seconds.\n\n\n\n$returned = Serial_SendMilliseconds($comPort, $sendString, $waitString, $timeout);\n\n\n\n\n\nSerial_SendMillisecondsBool\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Serial_SendMillisecondsBool": {
  "prefix": "Serial_SendMillisecondsBool",
  "body": [
   "($$returned,$$found)=Serial_SendMillisecondsBool($$comPort,$$sendString,$$waitString,$$timeout);"
  ],
  "description": "\n\nThis function sends a string to the output buffer of a serial port and waits for a specified string to be returned. Returns all the data received and a boolean indicating whether the wait string was found.\n\n\n\nRemarks:\n\nThe serial port object must have been opened with Serial_Open, Serial_OpenWithHandshaking, or Serial_OpenWithLogging.\n\nIf the wait string is not received within the time out time, the test will return a Fail.\n\nIf the send string is empty, the function will send nothing and wait for the wait string to be received.\n\nIf the wait string is empty, the send string will be sent and the function will return after the timeout has expired.\n\nIf the wait string is empty and the timeout value is set to 0, the send string will be sent and anything already in the receive buffer will be immediately returned.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$comPort\n\nObject\n\nAn instance of a Serial Port object created with one of the open functions.\n\n\n\n$sendString\n\nString\n\nThe string to be sent to the com port.\n\n\n\n$waitString\n\nString\n\nThe string to wait for in response before continuing.\n\n\n\n$timeout\n\nInteger\n\nThe maximum number of milliseconds to wait for data to come into the incoming buffer.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$returned\n\nString\n\nThe data received by the serial port. This will include all of the data received including the wait string, if it was received.\n\n\n\n$found\n\nBoolean\n\nTrue if the wait string was found, False otherwise.\n\n\n\n\n\nExample:\n\n\n\n\n\n$sendString = \"Send To Port\";\n\n$waitString = \"Return\";\n\n$timeout = 2000; // Wait for two seconds.\n\n\n\n($returned, $found) = Serial_SendMillisecondsBool($comPort, $sendString, $waitString, $timeout);\n\n\n\n\n\nSerial_SendMillisecondsMultiWait\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Serial_SendMillisecondsMultiWait": {
  "prefix": "Serial_SendMillisecondsMultiWait",
  "body": [
   "$$returned=Serial_SendMillisecondsMultiWait($$comPort,$$sendString,$$waitStrings,$$timeout);"
  ],
  "description": "\n\nThis function sends a string to the output buffer of a serial port and waits for any of the specified strings to be returned.\n\n\n\nRemarks:\n\nThe serial port object must have been opened with Serial_Open, Serial_OpenWithHandshaking, or Serial_OpenWithLogging.\n\nIf one of the wait strings is not received within the time out time, the test will return a Fail.\n\nIf the send string is empty, the function will send nothing and wait for one of the wait strings to be received.\n\nThe array of wait strings must contain at least one string.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$comPort\n\nObject\n\nAn instance of a Serial Port object created with one of the open functions.\n\n\n\n$sendString\n\nString\n\nThe string to be sent to the com port.\n\n\n\n$waitStrings\n\nArray\n\nAn array of strings to wait for in response before continuing. Only one of the strings must be received.\n\n\n\n$timeout\n\nInteger\n\nThe maximum number of milliseconds to wait for data to come into the incoming buffer.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$returned\n\nString\n\nThe data received by the serial port. This will include all of the data received including the wait string, if it was received.\n\n\n\n\n\nExample:\n\n\n\n\n\n$sendString = \"Send To Port\";\n\n$waitStrings = Array1DCreate(\"STRING\", 3);\n\nArray1DSetValue($waitStrings, 0, \"Wait_String_1\");\n\nArray1DSetValue($waitStrings, 1, \"Wait_String_2\");\n\nArray1DSetValue($waitStrings, 2, \"Wait_String_3\");\n\n$timeout = 2000; // Wait for two seconds.\n\n\n\n$returned = Serial_SendMillisecondsMultiWait($comPort, $sendString, $waitStrings, $timeout);\n\n\n\n\n\nSerial_SendMillisecondsMultiWaitBool\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Serial_SendMillisecondsMultiWaitBool": {
  "prefix": "Serial_SendMillisecondsMultiWaitBool",
  "body": [
   "($$returned,$$found)=Serial_SendMillisecondsMultiWaitBool($$comPort,$$sendString,$$waitStrings,$$timeout);"
  ],
  "description": "\n\nThis function sends a string to the output buffer of a serial port and waits for any of the specified strings to be returned. Returns all the data received and a boolean indicating whether the wait string was found.\n\n\n\nRemarks:\n\nThe serial port object must have been opened with Serial_Open, Serial_OpenWithHandshaking, or Serial_OpenWithLogging.\n\nIf one of the wait strings is not received within the time out time, the test will not return a Fail. The boolean value for whether the string was found will be false.\n\nIf the send string is empty, the function will send nothing and wait for one of the wait strings to be received.\n\nThe array of wait strings must contain at least one string.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$comPort\n\nObject\n\nAn instance of a Serial Port object created with one of the open functions.\n\n\n\n$sendString\n\nString\n\nThe string to be sent to the com port.\n\n\n\n$waitStrings\n\nArray\n\nAn array of strings to wait for in response before continuing. Only one of the strings must be received.\n\n\n\n$timeout\n\nInteger\n\nThe maximum number of milliseconds to wait for data to come into the incoming buffer.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$returned\n\nString\n\nThe data received by the serial port. This will include all of the data received including the wait string, if it was received.\n\n\n\n$found\n\nBoolean\n\nTrue if one of the wait strings was found, False otherwise.\n\n\n\n\n\nExample:\n\n\n\n\n\n$sendString = \"Send To Port\";\n\n$waitStrings = Array1DCreate(\"STRING\", 3);\n\nArray1DSetValue($waitStrings, 0, \"Wait_String_1\");\n\nArray1DSetValue($waitStrings, 1, \"Wait_String_2\");\n\nArray1DSetValue($waitStrings, 2, \"Wait_String_3\");\n\n$timeout = 2000; // Wait for two seconds.\n\n\n\n($returned, $found) = Serial_SendMillisecondsMultiWait($comPort, $sendString, $waitStrings, $timeout);\n\n\n\n\n\nSerial_SendWithDelays\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Serial_SendWithDelays": {
  "prefix": "Serial_SendWithDelays",
  "body": [
   "$$returned=Serial_SendWithDelays($$comPort,$$sendString,$$waitString,$$timeout,$$delay);"
  ],
  "description": "\n\nThis function sends a string to the output buffer of a serial port and waits for a specified string to be returned.\n\nThe Serial_SendWithDelays function differs from the Serial_Send function in the fact that it inserts a delay specified by the $delay argument between each character that is sent out of the serial port. This function is useful for DUT's that don't support a proper FIFO buffer and aren't able to process characters sent at the native baud rate setting of the serial port.\n\n\n\nRemarks:\n\nThe serial port object must have been opened with Serial_Open, Serial_OpenWithHandshaking, or Serial_OpenWithLogging.\n\nIf the wait string is not received within the time out time, the test will return a Fail.\n\nIf the send string is empty, the function will send nothing and wait for the wait string to be received.\n\nIf the wait string is empty, the send string will be sent and the function will return after the timeout has expired.\n\nIf the wait string is empty and the timeout value is set to 0, the send string will be sent and anything already in the receive buffer will be immediately returned.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$comPort\n\nObject\n\nAn instance of a Serial Port object created with one of the open functions.\n\n\n\n$sendString\n\nString\n\nThe string to be sent to the com port.\n\n\n\n$waitString\n\nString\n\nThe string to wait for in response before continuing.\n\n\n\n$timeout\n\nInteger\n\nThe maximum number of seconds to wait for data to come into the incoming buffer.\n\n\n\n$delay\n\nInteger\n\nThe number of milliseconds to wait between every bytes sent.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$returned\n\nString\n\nThe data received by the serial port. This will include all of the data received including the wait string, if it was received.\n\n\n\n\n\nExample:\n\n\n\n\n\n$sendString = \"Send To Port\";\n\n$waitString = \"Return\";\n\n$timeout = 2; // Wait for two seconds.\n\n$delay = 15; // Fifteen milliseconds between bytes.\n\n\n\n$returned = Serial_SendWithDelays($comPort, $sendString, $waitString, $timeout, $delay);\n\n\n\n\n\nSerial_SendWithLogging\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Serial_SendWithLogging": {
  "prefix": "Serial_SendWithLogging",
  "body": [
   "$$returned=Serial_SendWithLogging($$comPort,$$sendString,$$waitString,$$timeout);"
  ],
  "description": "\n\nThis function sends a string to the output buffer of a serial port and waits for a specified string to be returned. Both the sent string and the returned string are recorded in the previously opened logging file.\n\n\n\nRemarks:\n\nThe serial port object must have been opened with Serial_OpenWithLogging.\n\nIf the wait string is not received within the time out time, the test will return a Fail.\n\nIf the send string is empty, the function will send nothing and wait for the wait string to be received.\n\nIf the wait string is empty, the send string will be sent and the function will return after the timeout has expired.\n\nIf the wait string is empty and the timeout value is set to 0, the send string will be sent and anything already in the receive buffer will be immediately returned.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$comPort\n\nObject\n\nAn instance of a Serial Port object created with Serial_OpenWithLogging\n\n\n\n$sendString\n\nString\n\nThe string to be sent to the com port.\n\n\n\n$waitString\n\nString\n\nThe string to wait for in response before continuing.\n\n\n\n$timeout\n\nInteger\n\nThe maximum number of seconds to wait for data to come into the incoming buffer.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$returned\n\nString\n\nThe data received by the serial port. This will include all of the data received including the wait string, if it was received.\n\n\n\n\n\nExample:\n\n\n\n\n\n$sendString = \"Send To Port\";\n\n$waitString = \"Return\";\n\n$timeout = 2; // Wait for two seconds.\n\n\n\n$returned = Serial_SendWithLogging($comPort, $sendString, $waitString, $timeout);\n\n\n\n\n\nSerial_SendWithLoggingBool\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Serial_SendWithLoggingBool": {
  "prefix": "Serial_SendWithLoggingBool",
  "body": [
   "($$returned,$$found)=Serial_SendWithLoggingBool($$comPort,$$sendString,$$waitString,$$timeout);"
  ],
  "description": "\n\nThis function sends a string to the output buffer of a serial port and waits for a specified string to be returned. Both the sent string and the returned string are recorded in the previously opened logging file. If the string waited for is not found, the test does not fail.\n\n\n\nRemarks:\n\nThe serial port object must have been opened with Serial_OpenWithLogging.\n\nIf the send string is empty, the function will send nothing and wait for the wait string to be received.\n\nIf the wait string is empty, the send string will be sent and the function will return after the timeout has expired.\n\nIf the wait string is empty and the timeout value is set to 0, the send string will be sent and anything already in the receive buffer will be immediately returned.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$comPort\n\nObject\n\nAn instance of a Serial Port object created with Serial_OpenWithLogging\n\n\n\n$sendString\n\nString\n\nThe string to be sent to the com port.\n\n\n\n$waitString\n\nString\n\nThe string to wait for in response before continuing.\n\n\n\n$timeout\n\nInteger\n\nThe maximum number of seconds to wait for data to come into the incoming buffer.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$returned\n\nString\n\nThe data received by the serial port. This will include all of the data received including the wait string, if it was received.\n\n\n\n$found\n\nBoolean\n\nTrue if one of the wait strings was found, False otherwise.\n\n\n\n\n\nExample:\n\n\n\n\n\n$sendString = \"Send To Port\";\n\n$waitString = \"Return\";\n\n$timeout = 2; // Wait for two seconds.\n\n\n\n($returned, $found) = Serial_SendWithLoggingBool($comPort, $sendString, $waitString, $timeout);\n\n\n\nif($found)\n\n{ UpdateStatus(\"The wait string was found.\");\n\n}\n\n\n\n\n\nSerial_SetNewLine\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Serial_SetNewLine": {
  "prefix": "Serial_SetNewLine",
  "body": [
   "Serial_SetNewLine($$comPort,$$newLineChar);"
  ],
  "description": "\n\nSets the newline character(s) for Serial_ReadLine and Serial_WriteLine functions for the specified serial port object that was opened with Serial_Open, Serial_OpenWithHandshaking, or Serial_OpenWithLogging.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$comPort\n\nObject\n\nAn instance of a Serial Port object created with one of the open functions.\n\n\n\n$newLineChar\n\nString\n\nThe character or characters that will designate the end of a line for Serial_ReadLine and will be appended to the end of a line for Serial_WriteLine.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone.\n\n\n\n\n\nExample:\n\n\n\n\n\n$newLineChar = \"\\r\\n\"; // Set end of line to the carriage return, line feed characters.\n\nSerial_SetNewLine($comPort, $newLineChar);\n\n\n\n\n\nSerial_Write\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Serial_Write": {
  "prefix": "Serial_Write",
  "body": [
   "Serial_Write($$comPort,$$sendString);"
  ],
  "description": "\n\nSends the send string to the specified serial port object that was opened with Serial_Open, Serial_OpenWithHandshaking, or Serial_OpenWithLogging.\n\n\n\n\n\nThis function differs from the Serial_Send function in that this function does not wait for any returned data or wait for a specified amount of time.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$comPort\n\nObject\n\nAn instance of a Serial Port object created with one of the open functions.\n\n\n\n$sendString\n\nString\n\nThe string of characters that will be sent to the serial port.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone.\n\n\n\n\n\nExample:\n\n\n\n\n\n$sendString = \"Data to Send\";\n\nSerial_Write($comPort, $sendString);\n\n\n\n\n\nSerial_WriteLine\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Serial_WriteLine": {
  "prefix": "Serial_WriteLine",
  "body": [
   "Serial_WriteLine($$comPort,$$sendString);"
  ],
  "description": "\n\nSends the send string to the specified serial port object that was opened with Serial_Open, Serial_OpenWithHandshaking, or Serial_OpenWithLogging. The NewLine character(s) that are specified with the Serial_SetNewLine function are appended to the string.\n\n\n\n\n\nThis function differs from the Serial_Send function in that this function does not wait for any returned data or wait for a specified amount of time.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$comPort\n\nObject\n\nAn instance of a Serial Port object created with one of the open functions.\n\n\n\n$sendString\n\nString\n\nThe string of characters that will be sent to the serial port with the NewLine character(s) appended.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone.\n\n\n\n\n\nExample:\n\n\n\n\n\n$newLineChar = \"\\r\\n\"; // Set end of line to the carriage return, line feed characters.\n\nSerial_SetNewLine($comPort, $newLineChar);\n\n\n\n\n\n$sendString = \"Data to Send\";\n\nSerial_WriteLine($comPort, $sendString);\n\n\n\n\n\nSerial_XModem1KReceive\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Serial_XModem1KReceive": {
  "prefix": "Serial_XModem1KReceive",
  "body": [
   "$$ReturnValue=Serial_XModem1KReceive($$comPort,$$FileName,$$TimeOut,$$NumberRetries);"
  ],
  "description": "\n\nReceives packets of information over the com port specified by $comPort and writes the packets to the specified file $FileName using Xmodem 1K file transfer protocol. Before using a serial port, it first must be opened with the Serial_Open function.\n\n\n\n\n\nResult:\n\n0 if the file be received successfully test produces a pass.\n\n-1 if canceled by remote.\n\n-2 if Synchronization error.\n\n-3 if too many retries error.\n\n\n\n\n\nRemarks:\n\nThis function was tested with Tera Term on 64 bit Windows 7.\n\nThis function uses XModem protocol with 1024 bye packet size and CRC16-CCITT error checking.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$comPort\n\nObject\n\nAn instance of a Serial Port object created with the Serial_Open function.\n\n\n\n$FileName\n\nString\n\nPath and file name of the file to save.\n\n\n\n$TimeOut\n\nInteger\n\nSpecifies the interval (in seconds) during which to send the initial handshake character to the transmitter. The character is sent every $TimeOut seconds, up to $NumberRetries times.\n\n\n\n$NumberRetries\n\nInteger\n\nSets the maximum number of times for handshake and packet receive.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ReturnValue\n\nInteger\n\nThe result of the test\n\n\n\n\n\nExample:\n\n// Receive the file using XModem 1K protocol.\n\n$fileName = \"C:\\\\Temp\\\\ReceiveFile.bin\";\n\n$comPort = 3;\n\n$baudRate = 9600;\n\n$byteSize = 8;\n\n$parity = \"N\";\n\n$stopBits = 1;\n\n$comPort = Serial_Open($comPort, $baudRate, $byteSize, $parity, $stopBits);\n\n\n\n\n\n// Get the file. Handshake 1 second intervals for 10 times.\n\n$result = Serial_XModem1KReceive($comPort, $fileName, 1, 10);\n\n\n\n\n\nSerial_XModem1KSend\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Serial_XModem1KSend": {
  "prefix": "Serial_XModem1KSend",
  "body": [
   "($$ReturnValue,$$numBytes)=Serial_XModem1KSend($$comPort,$$FileName,$$TimeOut,$$NumberRetries);"
  ],
  "description": "\n\nReads data from $FileName file and sends it in packets over the com port specified by $comPort using Xmodem 1K file transfer protocol. This function uses an internal 30 second timeout for handshaking. Before using a serial port, it first must be opened with the Serial_Open function.\n\n\n\n\n\nResult:\n\n0 if the file be sent successfully and test produces a pass.\n\n-1 if cancel by remote.\n\n-2 if handshaking fail.\n\n-3 if Exceed the $TimeofRetries\n\n-4 if unknown error exists.\n\n\n\n\n\nRemarks:\n\nThis function was tested with Tera Term on 64 bit Windows 7.\n\nThis function uses XModem protocol with 1024 bye packet size and CRC16-CCITT error checking.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$comPort\n\nObject\n\nAn instance of a Serial Port object created with the Serial_Open function.\n\n\n\n$FileName\n\nString\n\nPath and file name of the file to send.\n\n\n\n$TimeOut\n\nInteger\n\nSpecifies the interval (in seconds) during which to send the initial handshake character to the transmitter. The character is sent every $TimeOut seconds, up to $NumberRetries times.\n\n\n\n$NumberRetries\n\nInteger\n\nSets the maximum number of times for handshake and packet receive.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ReturnValue\n\nInteger\n\nThe result of the test\n\n\n\n\n\nExample:\n\n// Send the file using XModem 1K protocol.\n\n$fileName = \"C:\\\\Temp\\\\ReceiveFile.bin\";\n\n$comPort = 3;\n\n$baudRate = 9600;\n\n$byteSize = 8;\n\n$parity = \"N\";\n\n$stopBits = 1;\n\n$comPort = Serial_Open($comPort, $baudRate, $byteSize, $parity, $stopBits);\n\n\n\n\n\n// Send the file. Handshake 1 second intervals for 10 times.\n\n($result, $numBytes) = Serial_XModem1KSend($comPort, $fileName, 1, 10);\n\n\n\n\n\nTelnetClose\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS TelnetClose": {
  "prefix": "TelnetClose",
  "body": [
   "TelnetClose($$telnetHandle);"
  ],
  "description": "\n\nThis function closes a connection with a Telnet server.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$telnetHandle\n\nObject\n\nTelnet connection handle from TelnetConnect, TelnetConnectBool, or TelnetConnectBoolRaw.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\n\n\n\n\n// Example without timeout value.\n\n$target = \"india.colorado.edu\"; // Univ. of Colorado telnet time server.\n\n$portNumber = 13;\n\n\n\n\n\n$telnetHandle = TelnetConnect($target, $portNumber);\n\n\n\n\n\n// Do some Telnet communication here.\n\n\n\n\n\nTelnetClose($telnetHandle);\n\n\n\n\n\nTelnetConnect\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS TelnetConnect": {
  "prefix": "TelnetConnect",
  "body": [
   "$$telnetHandle=TelnetConnect($$target,$$portNumber,[$$timeout]);"
  ],
  "description": "\n\nThis function opens a telnet connection to the $target parameter using the port number specified in the $portNumber argument. This function does not login to the telnet server, it merely creates the telnet connection. Any steps required for logging into the server (such as supplying a user name or password) must be scripted after opening the connection. For an automatic login to a server, see the TelnetLogin function. If the server port can't be opened, a failure will be generated by this function.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$target\n\nString\n\nThe DNS name or IP address in xxx.xxx.xxx.xxx notation of the telnet server.\n\n\n\n$portNumber\n\nInteger\n\nThe port number (1 - 65535) of the telnet server.\n\n\n\n$timeout\n\nInteger\n\nOptional: The number of seconds to wait for a response from the server. If the timeout value is not specified, the default of 10 seconds will be used.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$telnetHandle\n\nObject\n\nThe handle to the telnet connection for other telnet commands to use.\n\n\n\n\n\nExamples:\n\n\n\n\n\n// Example without timeout value.\n\n$target = \"india.colorado.edu\"; // Univ. of Colorado telnet time server.\n\n$portNumber = 13;\n\n\n\n\n\n$telnetHandle = TelnetConnect($target, $portNumber);\n\n\n\n\n\n// Example with timeout.\n\n$target = \"192.168.1.21\";\n\n$portNumber = 59123;\n\n$timeout = 25; // 25 second timeout.\n\n\n\n\n\n$telnetHandle = TelnetConnect($target, $portNumber, $timeout);\n\n\n\n\n\nTelnetConnectBool\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS TelnetConnectBool": {
  "prefix": "TelnetConnectBool",
  "body": [
   "($$Success,$$telnetHandle)=TelnetConnectBool($$target,$$portNumber,[$$timeout]);"
  ],
  "description": "\n\nThis function opens a telnet connection to the $target parameter using the port number specified in the $portNumber argument. This function does not login to the telnet server, it merely creates the telnet connection. Any steps required for logging into the server (such as supplying a user name or password) must be scripted after opening the connection. For an automatic login to a server, see the TelnetLogin function.\n\nIf a connection to the telnet server can not be established, the $Success variable is returned as false, and the $telnetHandle is returned in an unconnected status.\n\nUpon successful connection, the $Success return value is set to true, and the returned $TelnetHandle is functionally connected to the server.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$target\n\nString\n\nThe DNS name or IP address in xxx.xxx.xxx.xxx notation of the telnet server.\n\n\n\n$portNumber\n\nInteger\n\nThe port number (1 - 65535) of the telnet server.\n\n\n\n$timeout\n\nInteger\n\nOptional: The number of seconds to wait for a response from the server. If the timeout value is not specified, the default of 10 seconds will be used.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Success\n\nBoolean\n\nA boolean variable indicating whether or not the connection to the server was successful. This variable can be used to retry the connection multiple times.\n\n\n\n$telnetHandle\n\nObject\n\nThe handle to the telnet connection for other telnet commands to use.\n\n\n\n\n\nExamples:\n\n\n\n\n\n// Example without timeout value.\n\n$target = \"india.colorado.edu\"; // Univ. of Colorado telnet time server.\n\n$portNumber = 13;\n\n\n\n\n\n($Success, $telnetHandle) = TelnetConnectBool($target, $portNumber);\n\n\n\n\n\n// Example with timeout.\n\n$target = \"192.168.1.21\";\n\n$portNumber = 59123;\n\n$timeout = 25; // 25 second timeout.\n\n\n\n\n\n// Set up the loop and loop until connected.\n\n$Success = false;\n\nwhile (!$Success)\n\n{\n\n($Success, $telnetHandle) = TelnetConnectBool($target, $portNumber, $timeout);\n\n}\n\n\n\n\n\nTelnetConnectBoolRaw\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS TelnetConnectBoolRaw": {
  "prefix": "TelnetConnectBoolRaw",
  "body": [
   "($$Success,$$telnetHandle)=TelnetConnectBoolRaw($$target,$$portNumber,[$$timeout]);"
  ],
  "description": "\n\nThis function opens a telnet connection to the $target parameter using the port number specified in the $portNumber argument. All terminal type negotiation is turned off. This function does not login to the telnet server, it merely creates the telnet connection. Any steps required for logging into the server (such as supplying a user name or password) must be scripted after opening the connection. For an automatic login to a server, see the TelnetLogin function.\n\nIf a connection to the telnet server can not be established, the $Success variable is returned as false, and the $telnetHandle is returned in an unconnected status.\n\nUpon successful connection, the $Success return value is set to true, and the returned $TelnetHandle is functionally connected to the server.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$target\n\nString\n\nThe DNS name or IP address in xxx.xxx.xxx.xxx notation of the telnet server.\n\n\n\n$portNumber\n\nInteger\n\nThe port number (1 - 65535) of the telnet server.\n\n\n\n$timeout\n\nInteger\n\nOptional: The number of seconds to wait for a response from the server. If the timeout value is not specified, the default of 10 seconds will be used.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Success\n\nBoolean\n\nA boolean variable indicating whether or not the connection to the server was successful. This variable can be used to retry the connection multiple times.\n\n\n\n$telnetHandle\n\nObject\n\nThe handle to the telnet connection for other telnet commands to use.\n\n\n\n\n\nExamples:\n\n\n\n\n\n// Example without timeout value.\n\n$target = \"india.colorado.edu\"; // Univ. of Colorado telnet time server.\n\n$portNumber = 13;\n\n\n\n\n\n($Success, $telnetHandle) = TelnetConnectBoolRaw($target, $portNumber);\n\n\n\n\n\n// Example with timeout.\n\n$target = \"192.168.1.21\";\n\n$portNumber = 59123;\n\n$timeout = 25; // 25 second timeout.\n\n\n\n\n\n// Set up the loop and loop until connected.\n\n$Success = false;\n\nwhile (!$Success)\n\n{\n\n($Success, $telnetHandle) = TelnetConnectBoolRaw($target, $portNumber, $timeout);\n\n}\n\n\n\n\n\nTelnetFlush\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS TelnetFlush": {
  "prefix": "TelnetFlush",
  "body": [
   "$$success=TelnetFlush($$telnetHandle);"
  ],
  "description": "\n\nThis function flushes the output stream and clears the receive buffer.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$telnetHandle\n\nObject\n\nTelnet connection handle from TelnetConnect, TelnetConnectBool, or TelnetConnectBoolRaw.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$success\n\nBoolean\n\nTrue if the stream was successfully flushed and the receive buffer successfully cleared.\n\n\n\n\n\nExamples:\n\n\n\n\n\n// Example without timeout value.\n\n$target = \"india.colorado.edu\"; // Univ. of Colorado telnet time server.\n\n$portNumber = 13;\n\n\n\n\n\n$telnetHandle = TelnetConnect($target, $portNumber);\n\n\n\n\n\n$success = TelnetFlush($telnetHandle);\n\n\n\n\n\nTelnetLogin\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS TelnetLogin": {
  "prefix": "TelnetLogin",
  "body": [
   "$$telnetHandle=TelnetLogin($$target,$$userName,$$password,$$timeOut,$$prompt);"
  ],
  "description": "\n\nThis function automatically logs into a telnet server session hosted by the $target argument, with the supplied $userName and $password arguments. If the $prompt response is not found before the $timeOut argument has expired, the function will return a failure. This function works by recogizing several different typical username and password prompts commonly used for telnet services. In the event that this function is unsuccessful, you can also use the TelnetConnect function, and manually script the login steps involved for the host.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$target\n\nString\n\nThe DNS name or IP address in xxx.xxx.xxx.xxx notation of the telnet server.\n\n\n\n$userName\n\nString\n\nThe username to be issued in response to the login prompt.\n\n\n\n$password\n\nString\n\nThe password to be issued in response to the password prompt.\n\n\n\n$timeOut\n\nInteger\n\nThe time in seconds to wait to see the $prompt variable after the $password argument has been sent.\n\n\n\n$prompt\n\nString\n\nThis argument can be used to verify a successful connection by specifying the prompt that the telnet session should expect to receive after a successful login. This argument is optional, and a blank string (\"\")may be supplied for this parameter.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$telnetHandle\n\nObject\n\nThe function returns an object of type Telnet which can be passed to the other telnet script commands.\n\n\n\n\n\nTelnetLoginBool\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS TelnetLoginBool": {
  "prefix": "TelnetLoginBool",
  "body": [
   "($$success,$$telnetHandle)=TelnetLoginBool($$target,$$userName,$$password,$$timeOut,$$prompt);"
  ],
  "description": "\n\nThis function automatically logs into a telnet server session hosted by the $target argument, with the supplied $userName and $password arguments. If the $prompt response is not found before the $timeOut argument has expired, the function will return a False in the $success variable. This function works by recognizing several different typical username and password prompts commonly used for telnet services. In the event that this function is unsuccessful, you can also use the TelnetConnect function, and manually script the login steps involved for the host.\n\nNotes:\n\nThis function will not fail a test.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$target\n\nString\n\nThe DNS name or IP address in xxx.xxx.xxx.xxx notation of the telnet server.\n\n\n\n$userName\n\nString\n\nThe username to be issued in response to the login prompt.\n\n\n\n$password\n\nString\n\nThe password to be issued in response to the password prompt.\n\n\n\n$timeOut\n\nInteger\n\nThe time in seconds to wait to see the $prompt variable after the $password argument has been sent.\n\n\n\n$prompt\n\nString\n\nThis argument can be used to verify a successful connection by specifying the prompt that the telnet session should expect to receive after a successful login. This argument is optional, and a blank string (\"\")may be supplied for this parameter.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$success\n\nBoolean\n\nTrue if successfully connected and logged in to the specified telnet server.\n\n\n\n$telnetHandle\n\nObject\n\nAn object of type Telnet which can be passed to the other telnet script commands.\n\n\n\n\n\nExample:\n\n\n\n\n\n// Set up the parameters to log in to the server.\n\n$target = \"telnet.server.com\";\n\n$userName = \"myLogin\";\n\n$password = \"myPassword\";\n\n$timeOut = 10;\n\n$prompt = \"Command>\";\n\n\n\n\n\n($success, $tnHandle) = TelnetLoginBool($target, $userName, $password, $timeOut, $prompt);\n\n\n\n\n\nTelnetLogout\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS TelnetLogout": {
  "prefix": "TelnetLogout",
  "body": [
   "TelnetLogout($$telnetHandle);"
  ],
  "description": "\n\nThis function automatically closes and logs out of a telnet connection. This function will always generate a passing result, assuming that the input parameter was a valid Telnet object. In the event that the argument passed in is not a valid Telnet object, a failure will be generated.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$telnetHandle\n\nObject\n\nThe instance of a Telnet object to be closed.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nTelnetReceiveBool\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS TelnetReceiveBool": {
  "prefix": "TelnetReceiveBool",
  "body": [
   "($$found,$$received)=TelnetReceiveBool($$telnetHandle,$$waitForString,$$timeOut);"
  ],
  "description": "\n\nThis function will read data from the Telnet server specified in the $telnetHandle.\n\nIf the $waitForString is received before the $timeOut variable expires, the function returns a 'true' value to the $found return variable, and all the characters in the receive buffer are returned as a string to the executive. If the $waitForString is not received before the $timeOut period, the function returns a 'false' value to the $found return variable and all received data.\n\nIf $waitForString is an empty string, function waits for period of time (equal to $timeOut) and returns all data received. When there is no data received, returns 'false' and $received will be empty.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$telnetHandle\n\nObject\n\nTelnet connection handle from TelnetConnect, TelnetConnectBool, or TelnetConnectBoolRaw.\n\n\n\n$waitForString\n\nString\n\nThe string to wait for before continuing. If left blank, the function will wait until $timeOut has expired before continuing.\n\n\n\n$timeOut\n\nInteger\n\nThe time in seconds to wait for $waitForString to be received before failing.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$found\n\nBoolean\n\nTrue if $waitForString was received before the time specified in $timeOut\n\n\n\n$received\n\nString\n\nAll of the characters received from the time the function was called until either $waitForString was received or $timeOut happened.\n\n\n\n\n\nExamples:\n\n\n\n\n\n// Example without timeout value.\n\n$target = \"india.colorado.edu\"; // Univ. of Colorado telnet time server.\n\n$portNumber = 13;\n\n\n\n\n\n$telnetHandle = TelnetConnect($target, $portNumber);\n\n\n\n\n\n// Get characters until \">\" or 10 seconds.\n\n($found, $received) = TelnetReceiveBool($telnetHandle, \">\", 10);\n\n\n\n\n\nTelnetClose($telnetHandle);\n\n\n\n\n\nTelnetReceiveMillisecondsBool\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS TelnetReceiveMillisecondsBool": {
  "prefix": "TelnetReceiveMillisecondsBool",
  "body": [
   "($$found,$$received)=TelnetReceiveMillisecondsBool($$telnetHandle,$$waitForString,$$timeOut);"
  ],
  "description": "\n\nThis function will read data from the Telnet server specified in the $telnetHandle.\n\nIf the $waitForString is received before the $timeOut variable expires, the function returns a 'true' value to the $found return variable, and all the characters in the receive buffer are returned as a string to the executive. If the $waitForString is not received before the $timeOut period, the function returns a 'false' value to the $found return variable and all received data.\n\nIf $waitForString is an empty string, function waits for period of time (equal to $timeOut) and returns all data received. When there is no data received, returns 'false' and $received will be empty.\n\nThis function differs from TelnetReceiveBool in that this function has a millisecond time out value (as opposed to a second time out value).\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$telnetHandle\n\nObject\n\nTelnet connection handle from TelnetConnect, TelnetConnectBool, or TelnetConnectBoolRaw.\n\n\n\n$waitForString\n\nString\n\nThe string to wait for before continuing. If left blank, the function will wait until $timeOut has expired before continuing.\n\n\n\n$timeOut\n\nInteger\n\nThe time in milliseconds to wait for $waitForString to be received before failing.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$found\n\nBoolean\n\nTrue if $waitForString was received before the time specified in $timeOut\n\n\n\n$received\n\nString\n\nAll of the characters received from the time the function was called until either $waitForString was received or $timeOut happened.\n\n\n\n\n\nExamples:\n\n\n\n\n\n// Example without timeout value.\n\n$target = \"india.colorado.edu\"; // Univ. of Colorado telnet time server.\n\n$portNumber = 13;\n\n\n\n\n\n$telnetHandle = TelnetConnect($target, $portNumber);\n\n\n\n\n\n// Get characters until \">\" or 10 seconds.\n\n($found, $received) = TelnetReceiveMillisecondsBool($telnetHandle, \">\", 10);\n\n\n\n\n\nTelnetClose($telnetHandle);\n\n\n\n\n\nTelnetSend\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS TelnetSend": {
  "prefix": "TelnetSend",
  "body": [
   "$$receiveBuffer=TelnetSend($$telnetHandle,$$sendString,$$waitForString,$$timeOut);"
  ],
  "description": "\n\nThis function will send the $sendString argument on the $telnetHandle supplied. If the $waitForString is received before the $timeOut variable expires, a pass is generated, and all the characters in the receive buffer are returned as a string to the executive. If the $waitForString is not received before the $timeOut period, a failure is generated.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$telnetHandle\n\nObject\n\nThe instance of a Telnet object to be closed.\n\n\n\n$sendString\n\nString\n\nThe string to be sent.\n\n\n\n$waitForString\n\nString\n\nThe string to be received before continuing. A blank $waitForString is a valid argument. When a blank string is supplied, the executive will send the $sendString argument, and then continue immediately.\n\n\n\n$timeOut\n\nInteger\n\nThe time in seconds to wait for the $waitForString before failing. If the $waitForString is an empty string, this argument has no effect.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$receiveBuffer\n\nString\n\nAll the characters received from the time that the send string is sent, to the time that the $waitFor string is received.\n\n\n\n\n\nTelnetSendBool\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS TelnetSendBool": {
  "prefix": "TelnetSendBool",
  "body": [
   "($$Found,$$receiveBuffer)=TelnetSendBool($$telnetHandle,$$sendString,$$waitForString,$$timeOut);"
  ],
  "description": "\n\nThis function will send the $sendString argument on the $telnetHandle supplied.\n\nIf the $waitForString is received before the $timeOut variable expires, the function returns a 'True' value to the $Found return variable, and all the characters in the receive buffer are returned as a string to the executive. If the $waitForString is not received before the $timeOut period, the function returns a 'False' value to the $Found return variable. This function works in exactly the same way as the TelnetSend function, but is useful for occasions when you want to decide a specific behavior other than forcing a test failure in the event that the $waitForString is not found in the time allotted.\n\nIn other words, as long as the function is able to send it's sendString successfully via the Telnet protocol, this function will never generate a test failure.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$telnetHandle\n\nObject\n\nThe instance of a Telnet object to be closed.\n\n\n\n$sendString\n\nString\n\nThe string to be sent.\n\n\n\n$waitForString\n\nString\n\nThe string to be received before continuing. A blank $waitForString is a valid argument. When a blank string is supplied, the executive will send the $sendString argument, and then continue immediately.\n\n\n\n$timeOut\n\nInteger\n\nThe time in seconds to wait for the $waitForString before failing. If the $waitForString is an empty string, this argument has no effect.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Found\n\nBoolean\n\nReturns true of false depending on whether or not the expect string was found in the receive buffer.\n\n\n\n$receiveBuffer\n\nString\n\nAll the characters received from the time that the send string is sent, to the time that the $waitFor string is received.\n\n\n\n\n\nTelnetSendBoolNoCRLF\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS TelnetSendBoolNoCRLF": {
  "prefix": "TelnetSendBoolNoCRLF",
  "body": [
   "($$Found,$$receiveBuffer)=TelnetSendBoolNoCRLF($$telnetHandle,$$sendString,$$waitForString,$$timeOut);"
  ],
  "description": "\n\nThis function will send the $sendString argument on the $telnetHandle supplied without automatically appending a carriage-return, line-feed character combination at the end of the sent message. Otherwise this function is identical to the TelnetSendBool function.\n\nIf the $waitForString is received before the $timeOut variable expires, the function returns a 'True' value to the $Found return variable, and all the characters in the receive buffer are returned as a string to the executive. If the $waitForString is not received before the $timeOut period, the function returns a 'False' value to the $Found return variable. This function works in exactly the same way as the TelnetSend function, but is useful for occasions when you want to decide a specific behavior other than forcing a test failure in the event that the $waitForString is not found in the time allotted.\n\nIn other words, as long as the function is able to send it's sendString successfully via the Telnet protocol, this function will never generate a test failure.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$telnetHandle\n\nObject\n\nThe instance of a Telnet object to be closed.\n\n\n\n$sendString\n\nString\n\nThe string to be sent.\n\n\n\n$waitForString\n\nString\n\nThe string to be received before continuing. A blank $waitForString is a valid argument. When a blank string is supplied, the executive will send the $sendString argument, and then continue immediately.\n\n\n\n$timeOut\n\nInteger\n\nThe time in seconds to wait for the $waitForString before failing. If the $waitForString is an empty string, this argument has no effect.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Found\n\nBoolean\n\nReturns true of false depending on whether or not the expect string was found in the receive buffer.\n\n\n\n$receiveBuffer\n\nString\n\nAll the characters received from the time that the send string is sent, to the time that the $waitFor string is received.\n\n\n\n\n\nTelnetSendMilliseconds\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS TelnetSendMilliseconds": {
  "prefix": "TelnetSendMilliseconds",
  "body": [
   "$$received=TelnetSendMilliseconds($$telnetHandle,$$sendString,$$waitForString,$$timeOut);"
  ],
  "description": "\n\nThis function will send $sendString to the Telnet server specified in the $telnetHandle and wait for $waitForString to be returned or $timeOut to elapse.\n\nIf the $waitForString is received before the $timeOut variable expires, the function will Pass and the received data will be returned in $received. If the $waitForString is not received before the $timeOut period elapses, the function will generate a Fail.\n\nThis function differs from TelnetSend in that this function has a millisecond time out value (as opposed to a second time out value).\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$telnetHandle\n\nObject\n\nTelnet connection handle from TelnetConnect, TelnetConnectBool, or TelnetConnectBoolRaw.\n\n\n\n$sendString\n\nString\n\nThe string to be sent to the Telnet server.\n\n\n\n$waitForString\n\nString\n\nThe string to wait for before continuing. If left blank, the function will wait until $timeOut has expired before continuing.\n\n\n\n$timeOut\n\nInteger\n\nThe time in milliseconds to wait for $waitForString to be received before failing.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$received\n\nString\n\nAll of the characters received from the time $sendString was sent until either $waitForString was received.\n\n\n\n\n\nExamples:\n\n\n\n\n\n// Example without timeout value.\n\n$target = \"india.colorado.edu\"; // Univ. of Colorado telnet time server.\n\n$portNumber = 13;\n\n\n\n\n\n$telnetHandle = TelnetConnect($target, $portNumber);\n\n\n\n\n\n// Send \"Hello\" then get characters until \">\" or 1 second.\n\n($found, $received) = TelnetSendMilliseconds($telnetHandle, \"Hello\", \">\", 1000);\n\n\n\n\n\nTelnetClose($telnetHandle);\n\n\n\n\n\nTelnetSendMillisecondsBool\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS TelnetSendMillisecondsBool": {
  "prefix": "TelnetSendMillisecondsBool",
  "body": [
   "($$found,$$received)=TelnetSendMillisecondsBool($$telnetHandle,$$sendString,$$waitForString,$$timeOut);"
  ],
  "description": "\n\nThis function will send $sendString to the Telnet server specified in the $telnetHandle and wait for $waitForString to be returned or $timeOut to elapse.\n\nIf the $waitForString is received before the $timeOut variable expires, the function returns a 'true' value to the $found return variable, and all the characters in the receive buffer are returned as a string to the executive. If the $waitForString is not received before the $timeOut period, the function returns a 'false' value to the $found return variable and all received data.\n\nIf $waitForString is an empty string, function waits for period of time (equal to $timeOut) and returns all data received. When there is no data received, returns 'false' and $received will be empty.\n\nThis function differs from TelnetSendBool in that this function has a millisecond time out value (as opposed to a second time out value).\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$telnetHandle\n\nObject\n\nTelnet connection handle from TelnetConnect, TelnetConnectBool, or TelnetConnectBoolRaw.\n\n\n\n$sendString\n\nString\n\nThe string to be sent to the Telnet server.\n\n\n\n$waitForString\n\nString\n\nThe string to wait for before continuing. If left blank, the function will wait until $timeOut has expired before continuing.\n\n\n\n$timeOut\n\nInteger\n\nThe time in milliseconds to wait for $waitForString to be received before failing.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$found\n\nBoolean\n\nTrue if $waitForString was received before the time specified in $timeOut\n\n\n\n$received\n\nString\n\nAll of the characters received from the time the function was called until either $waitForString was received or $timeOut happened.\n\n\n\n\n\nExamples:\n\n\n\n\n\n// Example without timeout value.\n\n$target = \"india.colorado.edu\"; // Univ. of Colorado telnet time server.\n\n$portNumber = 13;\n\n\n\n\n\n$telnetHandle = TelnetConnect($target, $portNumber);\n\n\n\n\n\n// Send \"Hello\" then get characters until \">\" or 1 second.\n\n($found, $received) = TelnetSendMillisecondsBool($telnetHandle, \"Hello\", \">\", 1000);\n\n\n\n\n\nTelnetClose($telnetHandle);\n\n\n\n\n\nTelnetSendMillisecondsBoolNoCRLF\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS TelnetSendMillisecondsBoolNoCRLF": {
  "prefix": "TelnetSendMillisecondsBoolNoCRLF",
  "body": [
   "($$found,$$received)=TelnetSendMillisecondsBoolNoCRLF($$telnetHandle,$$sendString,$$waitForString,$$timeOut);"
  ],
  "description": "\n\nThis function will send $sendString to the Telnet server specified in the $telnetHandle and wait for $waitForString to be returned or $timeOut to elapse.\n\nIf the $waitForString is received before the $timeOut variable expires, the function returns a 'true' value to the $found return variable, and all the characters in the receive buffer are returned as a string to the executive. If the $waitForString is not received before the $timeOut period, the function returns a 'false' value to the $found return variable and all received data.\n\nIf $waitForString is an empty string, function waits for period of time (equal to $timeOut) and returns all data received. When there is no data received, returns 'false' and $received will be empty.\n\nThis function differs from TelnetSendMillisecondsBool in that this function does not append Carriage Return and Line Feed (CRLF) characters to the end of $sendString\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$telnetHandle\n\nObject\n\nTelnet connection handle from TelnetConnect, TelnetConnectBool, or TelnetConnectBoolRaw.\n\n\n\n$sendString\n\nString\n\nThe string to be sent to the Telnet server.\n\n\n\n$waitForString\n\nString\n\nThe string to wait for before continuing. If left blank, the function will wait until $timeOut has expired before continuing.\n\n\n\n$timeOut\n\nInteger\n\nThe time in milliseconds to wait for $waitForString to be received before failing.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$found\n\nBoolean\n\nTrue if $waitForString was received before the time specified in $timeOut\n\n\n\n$received\n\nString\n\nAll of the characters received from the time the function was called until either $waitForString was received or $timeOut happened.\n\n\n\n\n\nExamples:\n\n\n\n\n\n// Example without timeout value.\n\n$target = \"india.colorado.edu\"; // Univ. of Colorado telnet time server.\n\n$portNumber = 13;\n\n\n\n\n\n$telnetHandle = TelnetConnect($target, $portNumber);\n\n\n\n\n\n// Send \"Hello\" then get characters until \">\" or 1 second.\n\n($found, $received) = TelnetSendMillisecondsBoolNoCRLF($telnetHandle, \"Hello\", \">\", 1000);\n\n\n\n\n\nTelnetClose($telnetHandle);\n\n\n\n\n\nUdpSendHexString\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS UdpSendHexSting": {
  "prefix": "UdpSendHexSting",
  "body": [
   "$$ReturnString=UdpSendHexSting($$IpAddress,$$Port,$$LocalIP,$$HexToSend,$$TimeOut);"
  ],
  "description": "\n\n\n\nThis connects to the specified IP Address at the specified Port and sends the Hex String to the connected instrument using a UDP protocol.\n\n\n\n\n\nNote: If you have multiple network interface cards in the computer, you must specify which one to use by supplying the local IP Address of the interface to use. If you only have one network interface card, the local IP Address can be left as Null (\"\").\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$IpAddress\n\nString\n\nThe IP Address of the instrument to connect to and send the string to in dot format.\n\n\n\n$Port\n\nString\n\nThe port number to connect to and send the string to.\n\n\n\n$LocalIP\n\nString\n\nThe IP Address of the local network interface to send the string from. This can be Null (\"\") if there is only one network interface.\n\n\n\n$HexToSend\n\nString\n\nThe hex string to send to the connected instrument.\n\n\n\n$TimeOut\n\nInteger\n\nThe number of seconds to wait for a reply from the instrument before generating a Time Out error.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ReturnString\n\nString\n\nThe return string from the instrument.\n\n\n\n\n\nUsage Example:\n\n\n\n\n\n$ReturnString = UdpSendHexString(\"192.168.1.100\", \"2010\", \"192.168.1.2\", \"3A2B1C\", 3);\n\n\n\n\n\nUdpSendString\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS UdpSendSting": {
  "prefix": "UdpSendSting",
  "body": [
   "$$ReturnString=UdpSendSting($$IpAddress,$$Port,$$LocalIP,$$StringToSend,$$TimeOut);"
  ],
  "description": "\n\n\n\nThis connects to the specified IP Address at the specified Port and sends the String to the connected instrument using a UDP protocol.\n\n\n\n\n\nNote: If you have multiple network interface cards in the computer, you must specify which one to use by supplying the local IP Address of the interface to use. If you only have one network interface card, the local IP Address can be left as Null (\"\").\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$IpAddress\n\nString\n\nThe IP Address of the instrument to connect to and send the string to in dot format.\n\n\n\n$Port\n\nString\n\nThe port number to connect to and send the string to.\n\n\n\n$LocalIP\n\nString\n\nThe IP Address of the local network interface to send the string from. This can be Null (\"\") if there is only one network interface.\n\n\n\n$StringToSend\n\nString\n\nThe string to send to the connected instrument.\n\n\n\n$TimeOut\n\nInteger\n\nThe number of seconds to wait for a reply from the instrument before generating a Time Out error.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ReturnString\n\nString\n\nThe return string from the instrument.\n\n\n\n\n\nUsage Example:\n\n\n\n\n\n$ReturnString = UdpSendString(\"192.168.1.100\", \"2010\", \"192.168.1.2\", \"Hello Instrument\", 3);\n\n\n\n\n\nUSB_CheckDeviceExists\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS USB_CheckDeviceExists": {
  "prefix": "USB_CheckDeviceExists",
  "body": [
   "$$DeviceExists=USB_CheckDeviceExists($$VID,$$PID);"
  ],
  "description": "\n\n\n\nThis function walks the USB devices connected to the computer and returns true or false depending on whether or not a USB device with the supplied Vendor ID (VID) and Product ID (PID) exists on the USB hub.\n\n\n\n\n\nNote: This function requires the open source LibUSB-Win32 driver to be installed on the host computer in order to use these functions.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$VID\n\nString\n\nThe hexadecimal string for the vendor ID to locate.\n\n\n\n$PID\n\nString\n\nThe hexadecimal string for the product ID to locate\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$DeviceExists\n\nBoolean\n\nThis value will be set to 'True' or 'False' depending on if a USB device with the given VID and PID is connected and powered on.\n\n\n\n\n\nUsage Example:\n\n\n\n\n\n$DeviceExists = USB_CheckDeviceExists(\"0A21\",\"0030\");\n\n\n\n\n\nUSB_ClaimDeviceInterface\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS USB_ClaimDeviceInterface": {
  "prefix": "USB_ClaimDeviceInterface",
  "body": [
   "USB_ClaimDeviceInterface($$UsbDevice,$$Interface);"
  ],
  "description": "\n\n\n\nThis function reserves the interface specified on the current USB device's currently selected configuration for communication.\n\n\n\n\n\nNote: This function requires the open source LibUSB-Win32 driver to be installed on the host computer in order to use these functions. The interfaces for a particular configuration of a device can be listed by using the USB_ListDeviceConfigurations function.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$UsbDevice\n\nObject\n\nThe handle to the USB device for communication.\n\n\n\n$Interface\n\nInteger\n\nThe index number of the interface to reserve for communication on the current configuration profile.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nUsage Example:\n\n$Message = USB_CreateMessage(\"01 03 02 00 08 02\");\n\n$Device = USB_GetDeviceByVIDPID(\"0A21\",\"0030\");\n\nUSB_OpenDevice($Device);\n\nSetFinalizeFunction(\"Cleanup\");\n\nUSB_SetDeviceConfiguration($Device,1);\n\nUSB_ClaimDeviceInterface($Device,0);\n\n$MyWriter = USB_OpenEndPointWriter($Device,2,\"INTERRUPT\",0);\n\n$BytesSent = USB_WriteMessage($MyWriter,$Message,200,\"TRUE\");\n\nEnd;\n\n\n\n\n\nfunction Cleanup()\n\n{\n\nUSB_CloseDevice($Device);\n\nUSB_CloseEndPointWriter($MyWriter);\n\nEnd;\n\n}\n\n\n\n\n\nUSB_CloseDevice\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS USB_CloseDevice": {
  "prefix": "USB_CloseDevice",
  "body": [
   "USB_CloseDevice($$UsbDevice);"
  ],
  "description": "\n\n\n\nCloses the given USB device for communication.\n\n\n\n\n\nNote: This function requires the open source LibUSB-Win32 driver to be installed on the host computer in order to use these functions.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$UsbDevice\n\nObject\n\nThe handle to the USB device for communication.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nUsage Example:\n\nUSB_CloseDevice($Device);\n\n\n\n\n\nUSB_CloseEndPointReader\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS USB_CloseEndPointReader": {
  "prefix": "USB_CloseEndPointReader",
  "body": [
   "USB_CloseEndPointReader($$UsbEndPointReader);"
  ],
  "description": "\n\n\n\nThis function disposes of the EndPointReader object created by the USB_OpenEndPointReader function. Once the EndPointReader has been closed, no further information can be read from it, however, if any messages remain in the queue, they will be received and processed before the EndPoint is closed.\n\n\n\n\n\nNote: This function requires the open source LibUSB-Win32 driver to be installed on the host computer in order to use these functions. The interfaces for a particular configuration of a device can be listed by using the USB_ListDeviceConfigurations function.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$UsbEndPointReader\n\nObject\n\nA handle to the USB endpoint reader to be disposed. The USB endpoint reader is created by using the USB_OpenEndPointReader function.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nUsage Example:\n\n\n\n\n\nfunction Cleanup()\n\n{\n\nUSB_CloseEndPointReader($MyReader);\n\nUSB_CloseDevice($Device);\n\n\n\n\n\nEnd;\n\n}\n\n\n\n\n\nUSB_CloseEndPointWriter\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS USB_CloseEndPointWriter": {
  "prefix": "USB_CloseEndPointWriter",
  "body": [
   "USB_CloseEndPointWriter($$UsbEndPointWriter);"
  ],
  "description": "\n\n\n\nThis function disposes of the EndPointWriter object created by the USB_OpenEndPointWriter function. Once the EndPointWriter has been closed, no further information can be written to it, however, if any messages remain in the queue, they will be sent and processed before the EndPoint is closed.\n\n\n\n\n\nNote: This function requires the open source LibUSB-Win32 driver to be installed on the host computer in order to use these functions. The interfaces for a particular configuration of a device can be listed by using the USB_ListDeviceConfigurations function.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$UsbEndPointWriter\n\nObject\n\nA handle to the USB endpoint writer to be disposed. The USB endpoint writer is created by using the USB_OpenEndPointWriter function.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nUsage Example:\n\n$Message = USB_CreateMessage(\"01 03 02 00 08 02\");\n\n$Device = USB_GetDeviceByVIDPID(\"0A21\",\"0030\");\n\nUSB_OpenDevice($Device);\n\nSetFinalizeFunction(\"Cleanup\");\n\nUSB_SetDeviceConfiguration($Device,1);\n\nUSB_ClaimDeviceInterface($Device,0);\n\n$MyWriter = USB_OpenEndPointWriter($Device,2,\"INTERRUPT\",0);\n\n$BytesSent = USB_WriteMessage($MyWriter,$Message,200,\"TRUE\");\n\nEnd;\n\n\n\n\n\nfunction Cleanup()\n\n{\n\nUSB_CloseDevice($Device);\n\nUSB_CloseEndPointWriter($MyWriter);\n\nEnd;\n\n}\n\n\n\n\n\nUSB_CreateMessage\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS USB_CreateMessage": {
  "prefix": "USB_CreateMessage",
  "body": [
   "$$USBMessage=USB_CreateMessage($$MessageBytes);"
  ],
  "description": "\n\n\n\nThis function creates a message consisting of an array of bytes which are passed into the function as a string containing a list of bytes in the order to be sent. Each byte is separated by a single-blank space.\n\n\n\n\n\nNote: This function requires the open source LibUSB-Win32 driver to be installed on the host computer in order to use these functions. The interfaces for a particular configuration of a device can be listed by using the USB_ListDeviceConfigurations function.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$MessageBytes\n\nString\n\nA space delimited string containing the bytes for the USB message being created.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$USBMessage\n\nObject\n\nA USB message which can be used in conjunction with the USB_WriteMessage function.\n\n\n\n\n\nUsage Example:\n\n$Message = USB_CreateMessage(\"01 03 02 00 08 02\");\n\n$Device = USB_GetDeviceByVIDPID(\"0A21\",\"0030\");\n\nUSB_OpenDevice($Device);\n\nSetFinalizeFunction(\"Cleanup\");\n\nUSB_SetDeviceConfiguration($Device,1);\n\nUSB_ClaimDeviceInterface($Device,0);\n\n$MyWriter = USB_OpenEndPointWriter($Device,2,\"INTERRUPT\",0);\n\n$BytesSent = USB_WriteMessage($MyWriter,$Message,200,\"TRUE\");\n\nEnd;\n\n\n\n\n\nfunction Cleanup()\n\n{\n\nUSB_CloseDevice($Device);\n\nUSB_CloseEndPointWriter($MyWriter);\n\nEnd;\n\n}\n\n\n\n\n\nUSB_GetDeviceByVIDPID\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS USB_GetDeviceByVIDPID": {
  "prefix": "USB_GetDeviceByVIDPID",
  "body": [
   "$$deviceHandle=USB_GetDeviceByVIDPID($$VID,$$PID);"
  ],
  "description": "\n\nThis function returns a handle to the first USB device specified by it's vendor ID and Product ID.\n\n\n\n\n\nRemarks:\n\nThis function requires the open source LibUSB-Win32 driver to be installed on the host computer in order to use these functions.\n\nIf a device is not found with the given VID/PID, then the function returns a failure.\n\nIf multiple devices are found that have the specified VID and PID, only the first one in the list will be returned. To return handles to other ones, use USB_GetDeviceByVIDPIDNumber.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$VID\n\nString\n\nThe hexadecimal string for the Vendor ID to locate.\n\n\n\n$PID\n\nString\n\nThe hexadecimal string for the Product ID to locate.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$deviceHandle\n\nObject\n\nThe handle to communicate with the specified device.\n\n\n\n\n\nExample:\n\n\n\n\n\n// Get a handle to a device.\n\n$VID = \"0A21\";\n\n$PID = \"0030\";\n\n$device = USB_GetDeviceByVIDPID($VID, $PID);\n\n\n\n\n\nUSB_GetDeviceByVIDPIDNumber\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS USB_GetDeviceByVIDPIDNumber": {
  "prefix": "USB_GetDeviceByVIDPIDNumber",
  "body": [
   "$$deviceHandle=USB_GetDeviceByVIDPIDNumber($$VID,$$PID,$$number);"
  ],
  "description": "\n\nThis function returns a handle to the given USB device specified by it's vendor ID, Product ID and it's place in the list of all devices with the same VID, PID. This function allows for multiple devices with the same VID, PID to exist in the system and still be individually accessed.\n\n\n\n\n\nRemarks:\n\nThis function requires the open source LibUSB-Win32 driver to be installed on the host computer in order to use these functions.\n\nIf a device is not found with the given VID/PID/number, then the function returns a failure.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$VID\n\nString\n\nThe hexadecimal string for the Vendor ID to locate.\n\n\n\n$PID\n\nString\n\nThe hexadecimal string for the Product ID to locate.\n\n\n\n$number\n\nInteger\n\nThe location of the device to connect to in a list of devices with the same VID/PID. The first device has number = 1.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$deviceHandle\n\nObject\n\nThe handle to communicate with the specified device.\n\n\n\n\n\nExample:\n\n\n\n\n\n// Get a handle to a device.\n\n$VID = \"0A21\";\n\n$PID = \"0030\";\n\n$number = 2; // The second device with this VID/PID.\n\n$device = USB_GetDeviceByVIDPIDNumber($VID, $PID, $number);\n\n\n\n\n\nUSB_GetDeviceInfo\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS USB_GetDeviceInfo": {
  "prefix": "USB_GetDeviceInfo",
  "body": [
   "($$DescriptorType,$$DeviceClass,$$DeviceSubclass,$$DeviceFileName,$$Manufacturer,$$ProductDescription,$$SerialNumber,$$MaxPacketSize)=USB_GetDeviceInfo($$UsbDevice);"
  ],
  "description": "\n\n\n\nReturns an array of information about the given USB device.\n\n\n\n\n\nNote: This function requires the open source LibUSB-Win32 driver to be installed on the host computer in order to use these functions.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$UsbDevice\n\nObject\n\nThe handle to the USB device\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$DescriptorType\n\nInteger\n\nThe descriptor type of the USB device\n\n\n\n$DeviceClass\n\nInteger\n\nThe device class of the USB device\n\n\n\n$DeviceSubclass\n\nInteger\n\nThe device subclass of the USB device\n\n\n\n$DeviceFileName\n\nString\n\nThe filename of the USB device\n\n\n\n$Manufacturer\n\nString\n\nThe manufacturer of the USB device\n\n\n\n$ProductDescription\n\nString\n\nThe product description of the USB device\n\n\n\n$SerialNumber\n\nString\n\nThe serial number of the USB device\n\n\n\n$MaxPacketSize\n\nInteger\n\nThe maximum packet size of the USB device\n\n\n\n\n\nUsage Example:\n\n\n\n\n\n($DescriptorType,$DeviceClass,$DeviceSubClass,$DeviceFileName,$Manufacturer,$ProductDescription,$SerialNumber,$MaxPacketSize) = USB_GetDeviceInfo($Device);\n\n\n\n\n\nUSB_GetListOfDevices\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS USB_GetListOfDevices": {
  "prefix": "USB_GetListOfDevices",
  "body": [
   "$$devList=USB_GetListOfDevices();"
  ],
  "description": "\n\nThis function returns an array of devices that are registered on the USB busses of the computer.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$devList\n\nArray\n\nThe list of devices registered on the USB busses.\n\n\n\n\n\nExample:\n\n$devList = USB_GetListOfDevices();\n\n\n\n\n\nUSB_ListDeviceConfigurations\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS USB_ListDeviceConfigurations": {
  "prefix": "USB_ListDeviceConfigurations",
  "body": [
   "USB_ListDeviceConfigurations($$UsbDevice);"
  ],
  "description": "\n\n\n\nThis function dumps all the available configuration information for the supplied USB device into the debug output window. The information from this function is useful in determining the required settings to be passed into subsequent functions to establish the USB communications session.\n\n\n\n\n\nNote: This function requires the open source LibUSB-Win32 driver to be installed on the host computer in order to use these functions. The interfaces for a particular configuration of a device can be listed by using the USB_ListDeviceConfigurations function.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$UsbDevice\n\nObject\n\nThe handle to the USB device for communication.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample Output:\n\nNow Enumerating All USB Configurations For Device...\n\n---- USB Device [\\\\.\\libusb0-0004--0x0a21-0x0030] CONFIGURATION VALUE [1] ----\n\nBM Attributes: 64\n\nConfiguration String: Cruiser\n\nConfiguration Index: 4\n\nDescriptor Type: 2\n\nLength:9\n\nMax Power: 0\n\nTotal Length: 46\n\nNumber of Interfaces: 1\n\n---- Interface [1 ]Information For Configuration ---\n\nAlternate Setting: 0\n\nDescriptor Type: 4\n\nInterface Class: 0\n\nInterface Index: 0\n\nInterface Number: 0\n\nInterface Protocol: 0\n\nInterface String:\n\nInterface Sub Class: 0\n\nInterface Endpoint Count: 4\n\n--- Endpoint [1] Information For Interface [1]---\n\nBM Attributes: 3\n\nDescriptor Type: 5\n\nEndpoint Address: 2\n\nPolling Interval: 1\n\nLength: 7\n\nMax Packet Size: 64\n\nSynch Address: 0\n\n--- Endpoint [2] Information For Interface [1]---\n\nBM Attributes: 3\n\nDescriptor Type: 5\n\nEndpoint Address: 4\n\nPolling Interval: 1\n\nLength: 7\n\nMax Packet Size: 64\n\nSynch Address: 0\n\n--- Endpoint [3] Information For Interface [1]---\n\nBM Attributes: 3\n\nDescriptor Type: 5\n\nEndpoint Address: 129\n\nPolling Interval: 1\n\nLength: 7\n\nMax Packet Size: 64\n\nSynch Address: 0\n\n--- Endpoint [4] Information For Interface [1]---\n\nBM Attributes: 3\n\nDescriptor Type: 5\n\nEndpoint Address: 131\n\nPolling Interval: 5\n\nLength: 7\n\nMax Packet Size: 64\n\nSynch Address: 0\n\n\n\n\n\nUsage Example:\n\n$Message = USB_CreateMessage(\"01 03 02 00 08 02\");\n\n$Device = USB_GetDeviceByVIDPID(\"0A21\",\"0030\");\n\nUSB_OpenDevice($Device);\n\nSetFinalizeFunction(\"Cleanup\");\n\nUSB_SetDeviceConfiguration($Device,1);\n\nUSB_ClaimDeviceInterface($Device,0);\n\n$MyWriter = USB_OpenEndPointWriter($Device,2,\"INTERRUPT\",0);\n\n$BytesSent = USB_WriteMessage($MyWriter,$Message,200,\"TRUE\");\n\nEnd;\n\n\n\n\n\nfunction Cleanup()\n\n{\n\nUSB_CloseDevice($Device);\n\nUSB_CloseEndPointWriter($MyWriter);\n\nEnd;\n\n}\n\n\n\n\n\nUSB_OpenDevice\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS USB_OpenDevice": {
  "prefix": "USB_OpenDevice",
  "body": [
   "USB_OpenDevice($$UsbDevice);"
  ],
  "description": "\n\n\n\nOpens the given USB device for communication.\n\n\n\n\n\nNote: This function requires the open source LibUSB-Win32 driver to be installed on the host computer in order to use these functions.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$UsbDevice\n\nObject\n\nThe handle to the USB device for communication.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nUsage Example:\n\nUSB_OpenDevice($Device);\n\n\n\n\n\nUSB_OpenEndPointReader\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS USB_OpenEndPointReader": {
  "prefix": "USB_OpenEndPointReader",
  "body": [
   "$$EndPointReader=USB_OpenEndPointReader($$USBDevice,$$EndPoint,$$EndPointType,$$PacketSize,$$ReadBufferSize);"
  ],
  "description": "\n\n\n\nThis function opens a channel to a specified endpoint on a USB device for communication. Once the endpoint has been opened, messages can be read from the endpoint using the USB_ReadMessage function.\n\n\n\n\n\nNote: This function requires the open source LibUSB-Win32 driver to be installed on the host computer in order to use these functions. The interfaces for a particular configuration of a device can be listed by using the USB_ListDeviceConfigurations function.\n\n\n\n\n\nNotes on Read End Points:\n\nThe read endpoint addresses are offset differently than write endpoints in the USB specification. The following table lists the correct address mappings:\n\nEndpoint 1 = 0x81\n\nEndpoint 2 = 0x82\n\nEndpoint 3 = 0x83\n\nEndpoint 4 = 0x84\n\nEndpoint 5 = 0x85\n\nEndpoint 6 = 0x86\n\nEndpoint 7 = 0x87\n\nEndpoint 8 = 0x88\n\nEndpoint 9 = 0x89\n\nEndpoint 10 = 0x8A\n\nEndpoint 11 = 0x8B\n\nEndpoint 12 = 0x8C\n\nEndpoint 13 = 0x8D\n\nEndpoint 14 = 0x8E\n\nEndpoint 15 = 0x8F\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$UsbDevice\n\nObject\n\nThe handle to the USB device for communication.\n\n\n\n$Endpoint\n\nInteger\n\nThe number of the endpoint to establish communications.\n\n\n\n$EndPointType\n\nString\n\nThe type of USB endpoint to open for communcation. Allowable values are:\n\n\u00b7 \"BULK\" = Opens the Endpoint for Bulk Style Communication\n\n\u00b7 \"ISOCHRONOUS\" = Opens the Endpoint for Isochronous communcation. If the endpoint type is set to Isochronous, you must supply a valid value for the $PacketSize parameter\n\n\u00b7 \"Interrupt\" = Opens the Endpoint for interrupt drive communications (this is the most common type of USB endpoint)\n\n\n\n$PacketSize\n\nInteger\n\nA packet size for isochronous end points. If any other endpoint type is specified this field is ignored.\n\n\n\n$ReadBufferSize\n\nInteger\n\nThe number of bytes to reserve for the read buffer.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$EndPointReader\n\nObject\n\nThe handle to the newly opened endpoint reader.\n\n\n\n\n\nUsage Example:\n\n$MyReader = USB_OpenEndPointReader($Device,1,\"INTERRUPT\",64,256);\n\n\n\n\n\nUSB_OpenEndPointWriter\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS USB_OpenEndPointWriter": {
  "prefix": "USB_OpenEndPointWriter",
  "body": [
   "$$EndPointWriter=USB_OpenEndPointWriter($$USBDevice,$$EndPoint,$$EndPointType,$$PacketSize);"
  ],
  "description": "\n\n\n\nThis function opens a channel to a specified endpoint on a USB device for communication. Once the endpoint has been opened, messages can be sent to the endpoint using the USB_WriteMessage function.\n\n\n\n\n\nNote: This function requires the open source LibUSB-Win32 driver to be installed on the host computer in order to use these functions. The interfaces for a particular configuration of a device can be listed by using the USB_ListDeviceConfigurations function.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$UsbDevice\n\nObject\n\nThe handle to the USB device for communication.\n\n\n\n$Endpoint\n\nInteger\n\nThe number of the endpoint to establish communications.\n\n\n\n$EndPointType\n\nString\n\nThe type of USB endpoint to open for communcation. Allowable values are:\n\n\u00b7 \"BULK\" = Opens the Endpoint for Bulk Style Communication\n\n\u00b7 \"ISOCHRONOUS\" = Opens the Endpoint for Isochronous communcation. If the endpoint type is set to Isochronous, you must supply a valid value for the $PacketSize parameter\n\n\u00b7 \"Interrupt\" = Opens the Endpoint for interrupt drive communications (this is the most common type of USB endpoint)\n\n\n\n$PacketSize\n\nInteger\n\nA packet size for isochronous end points. If any other endpoint type is specified this field is ignored.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$EndPointWriter\n\nObject\n\nThe handle to the newly opened endpoint writer.\n\n\n\n\n\nUsage Example:\n\n$Message = USB_CreateMessage(\"01 03 02 00 08 02\");\n\n$Device = USB_GetDeviceByVIDPID(\"0A21\",\"0030\");\n\nUSB_OpenDevice($Device);\n\nSetFinalizeFunction(\"Cleanup\");\n\nUSB_SetDeviceConfiguration($Device,1);\n\nUSB_ClaimDeviceInterface($Device,0);\n\n$MyWriter = USB_OpenEndPointWriter($Device,2,\"INTERRUPT\",0);\n\n$BytesSent = USB_WriteMessage($MyWriter,$Message,200,\"TRUE\");\n\nEnd;\n\n\n\n\n\nfunction Cleanup()\n\n{\n\nUSB_CloseDevice($Device);\n\nUSB_CloseEndPointWriter($MyWriter);\n\nEnd;\n\n}\n\n\n\n\n\nUSB_ReadMessage\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS USB_ReadMessage": {
  "prefix": "USB_ReadMessage",
  "body": [
   "($$BytesRead,$$Message)=USB_ReadMessage($$EndPointReader,$$Timeout);"
  ],
  "description": "\n\n\n\nThis functions reads all the bytes waiting on the endpoint that are stored in the buffer. The number of bytes read is returned as $BytesRead. The message is returned as a string of space-separated hex bytes.\n\n\n\n\n\nIf no bytes are read, the returned message is blank. If an error occurs accessing the USB endpoint, the function returns a failure.\n\n\n\n\n\nNote: This function requires the open source LibUSB-Win32 driver to be installed on the host computer in order to use these functions. The interfaces for a particular configuration of a device can be listed by using the USB_ListDeviceConfigurations function.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$EndPointReader\n\nObject\n\nThe handle to the $EndPointReader which was created using the 'USB_OpenEndPointReader' function.\n\n\n\n$Timeout\n\nInteger\n\nThe timeout value specified in milliseconds. The function will wait for the timeout to see if more message bytes become available in the queue.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$BytesRead\n\nInteger\n\nThe number of bytes that were read from the endpoint within the $Timeout period.\n\n\n\n$Message\n\nString\n\nThe bytes received from the USB endpoint converted to a hexadecimal space-delimited string.\n\n\n\n\n\nUsage Example:\n\n($BytesReceived,$Message) = USB_ReadMessage($MyEndPointReader,200);\n\n\n\n\n\nUSB_SetDeviceConfiguration\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS USB_SetDeviceConfiguration": {
  "prefix": "USB_SetDeviceConfiguration",
  "body": [
   "USB_SetDeviceConfiguration($$UsbDevice,$$DesiredConfiguration);"
  ],
  "description": "\n\n\n\nThis function selects the desired configuration profile to use for the USB device. The available configuration profiles for the given USB device can be viewed by using the USB_ListDeviceConfigurations function.\n\n\n\n\n\nNote: This function requires the open source LibUSB-Win32 driver to be installed on the host computer in order to use these functions. The interfaces for a particular configuration of a device can be listed by using the USB_ListDeviceConfigurations function.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$UsbDevice\n\nObject\n\nThe handle to the USB device for communication.\n\n\n\n$DesiredConfiguration\n\nInteger\n\nThe index of the desired configuration to use for the USB device.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nUsage Example:\n\n$Message = USB_CreateMessage(\"01 03 02 00 08 02\");\n\n$Device = USB_GetDeviceByVIDPID(\"0A21\",\"0030\");\n\nUSB_OpenDevice($Device);\n\nSetFinalizeFunction(\"Cleanup\");\n\nUSB_SetDeviceConfiguration($Device,1);\n\nUSB_ClaimDeviceInterface($Device,0);\n\n$MyWriter = USB_OpenEndPointWriter($Device,2,\"INTERRUPT\",0);\n\n$BytesSent = USB_WriteMessage($MyWriter,$Message,200,\"TRUE\");\n\nEnd;\n\n\n\n\n\nfunction Cleanup()\n\n{\n\nUSB_CloseDevice($Device);\n\nUSB_CloseEndPointWriter($MyWriter);\n\nEnd;\n\n}\n\n\n\n\n\nUSB_WriteMessage\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS USB_WriteMessage": {
  "prefix": "USB_WriteMessage",
  "body": [
   "$$BytesSent=USB_WriteMessage($$EndPointWriter,$$Message,$$Timeout,$$FailOnError);"
  ],
  "description": "\n\n\n\nThis functions sends a message that has been created using the 'USB_CreateMessage' command to the supplied endpoint, and returns the number of bytes that were successfully written. If the number of bytes written is negative, it means that a communication error occurred on the USB bus. If the $FailOnError argument is set to TRUE, it causes the function to generate a failure if any error in communication occurs. If the $FailOnError argument is set to false, the function will pass but will return a negative value for the number of bytes sent indicating an error occurred.\n\n\n\n\n\nNote: This function requires the open source LibUSB-Win32 driver to be installed on the host computer in order to use these functions. The interfaces for a particular configuration of a device can be listed by using the USB_ListDeviceConfigurations function.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$EndPointWriter\n\nObject\n\nThe handle to the $EndPointWriter which was created using the 'USB_OpenEndPointWriter' function.\n\n\n\n$Message\n\nObject\n\nThe handle to the USB Message which was created using the 'USB_CreateMessage' function.\n\n\n\n$Timeout\n\nInteger\n\nThe timeout value specified in milliseconds. If the timeout limit is exceeded, the function will pass, but will return a number of bytes sent which is smaller than the original USB message length to be sent.\n\n\n\n$FailOnError\n\nBoolean\n\nThis argument specifies whether or not the USB WriteMessage function should fail the test on a communication error.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$BytesSent\n\nInteger\n\nThe number of bytes sent to the endpoint. If this value is a negative number, it indicates that a communication failure occurred executing the function.\n\n\n\n\n\nUsage Example:\n\n$Message = USB_CreateMessage(\"01 03 02 00 08 02\");\n\n$Device = USB_GetDeviceByVIDPID(\"0A21\",\"0030\");\n\nUSB_OpenDevice($Device);\n\nSetFinalizeFunction(\"Cleanup\");\n\nUSB_SetDeviceConfiguration($Device,1);\n\nUSB_ClaimDeviceInterface($Device,0);\n\n$MyWriter = USB_OpenEndPointWriter($Device,2,\"INTERRUPT\",0);\n\n$BytesSent = USB_WriteMessage($MyWriter,$Message,200,\"TRUE\");\n\nEnd;\n\n\n\n\n\nfunction Cleanup()\n\n{\n\nUSB_CloseDevice($Device);\n\nUSB_CloseEndPointWriter($MyWriter);\n\nEnd;\n\n}\n\n\n\n\n\nIviVISA_Close\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS IviVISA_Close": {
  "prefix": "IviVISA_Close",
  "body": [
   "IviVISA_Close($$VisaHandle);"
  ],
  "description": "\n\nThis function closes communication with the instrument.\n\n\n\nRemarks:\n\n\u00b7 This function requires the IVI Foundation VISA drivers. Both the IVI Shared Components and the VISA Shared Components.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$VisaHandle\n\nObject\n\nThe GPIB resource handle opened with the IviVISA_Open or IviVISA_OpenBool function.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n// Connect to the instrument.\n\n$resourceString = \"USB0::0x0699::0x0408::0x010469::0::INSTR\";\n\n$timeOut = 2000; // Time out = 2 seconds.\n\n$visa = IviVISA_Open($resourceString, $timeOut);\n\n\n\n\n\n// Other functions to work with the instrument.\n\n\n\n\n\nIviVISA_Close($visa);\n\n\n\n\n\nIviVISA_Open\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS IviVISA_Open": {
  "prefix": "IviVISA_Open",
  "body": [
   "$$VisaHandle=IviVISA_Open($$resourceString,$$timeOut);"
  ],
  "description": "\n\nThis function creates a connection to the instrument specified in the resource string.\n\n\n\nRemarks:\n\n\u00b7 This function requires the IVI Foundation VISA drivers. Both the IVI Shared Components and the VISA Shared Components.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$resourceString\n\nString\n\nThe resource string pointing to the instrument. Prefix with the bus type. Different bus types require different information. Consult the Jabil Test Wiki for information on addressing different buses.\n\n\n\n$timeOut\n\nInteger\n\nThe time out value to use for communicating with the instrument in milliseconds.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$VisaHandle\n\nObject\n\nThe reference to the instrument that will be used in other VISA functions.\n\n\n\n\n\nExample:\n\n// Connect to the instrument.\n\n$resourceString = \"USB0::0x0699::0x0408::0x010469::0::INSTR\";\n\n$timeOut = 2000; // Time out = 2 seconds.\n\n$visa = IviVISA_Open($resourceString, $timeOut);\n\n\n\n\n\nIviVISA_OpenBool\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS IviVISA_OpenBool": {
  "prefix": "IviVISA_OpenBool",
  "body": [
   "($$VisaHandle,$$success)=IviVISA_OpenBool($$resourceString,$$timeOut);"
  ],
  "description": "\n\nThis function creates a connection to the instrument specified in the resource string and returns the connection reference and a success boolean.\n\n\n\nRemarks:\n\n\u00b7 This function requires the IVI Foundation VISA drivers. Both the IVI Shared Components and the VISA Shared Components.\n\n\u00b7 This function will not Fail a test.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$resourceString\n\nString\n\nThe resource string pointing to the instrument. Prefix with the bus type. Different bus types require different information. Consult the Jabil Test Wiki for information on addressing different buses.\n\n\n\n$timeOut\n\nInteger\n\nThe time out value to use for communicating with the instrument in milliseconds.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$VisaHandle\n\nObject\n\nThe reference to the instrument that will be used in other VISA functions.\n\n\n\n$success\n\nBoolean\n\nA status boolean indicating whether the connection succeeded.\n\n\n\n\n\nExample:\n\n// Connect to the instrument.\n\n$resourceString = \"USB0::0x0699::0x0408::0x010469::0::INSTR\";\n\n$timeOut = 2000; // Time out = 2 seconds.\n\n($visa, $success) = IviVISA_OpenBool($resourceString, $timeOut);\n\n\n\n\n\nIviVISA_Read\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS IviVISA_Read": {
  "prefix": "IviVISA_Read",
  "body": [
   "$$inString=IviVISA_Read($$VisaHandle);"
  ],
  "description": "\n\nThis function reads a string from the instrument up to a termination character.\n\n\n\nRemarks:\n\n\u00b7 This function requires the IVI Foundation VISA drivers. Both the IVI Shared Components and the VISA Shared Components.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$VisaHandle\n\nObject\n\nThe VISA resource handle opened with the IviVISA_Open or IviVISA_OpenBool function.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$inString\n\nString\n\nThe string read back from the instrument.\n\n\n\n\n\nExample:\n\n// Connect to the instrument.\n\n$resourceString = \"USB0::0x0699::0x0408::0x010469::0::INSTR\";\n\n$timeOut = 2000; // Time out = 2 seconds.\n\n$visa = IviVISA_Open($resourceString, $timeOut);\n\n\n\n\n\n$inString = IviVISA_Read($visa);\n\n\n\n\n\n$outStr = \"The instrument responded: \" + $inString;\n\nUpdateStatus($outStr);\n\n\n\n\n\nIviVISA_ReadBool\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS IviVISA_ReadBool": {
  "prefix": "IviVISA_ReadBool",
  "body": [
   "($$inString,$$success)=IviVISA_ReadBool($$VisaHandle);"
  ],
  "description": "\n\nThis function reads a string from the instrument up to a termination character and also returns a boolean indicating whether the read was successful.\n\n\n\nRemarks:\n\n\u00b7 This function requires the IVI Foundation VISA drivers. Both the IVI Shared Components and the VISA Shared Components.\n\n\u00b7 This function will not fail a test.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$VisaHandle\n\nObject\n\nThe VISA resource handle opened with the IviVISA_Open or IviVISA_OpenBool function.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$inString\n\nString\n\nThe string read back from the instrument.\n\n\n\n$success\n\nBoolean\n\nA status boolean indicating whether the read was successful.\n\n\n\n\n\nExample:\n\n// Connect to the instrument.\n\n$resourceString = \"USB0::0x0699::0x0408::0x010469::0::INSTR\";\n\n$timeOut = 2000; // Time out = 2 seconds.\n\n$visa = IviVISA_Open($resourceString, $timeOut);\n\n\n\n\n\n($inString, $success) = IviVISA_ReadBool($visa);\n\n\n\n\n\n$outStr = \"The instrument responded: \" + $inString;\n\nUpdateStatus($outStr);\n\n\n\n\n\nIviVISA_SetSendEndEnabled\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS IviVISA_SetSendEndEnabled": {
  "prefix": "IviVISA_SetSendEndEnabled",
  "body": [
   "IviVISA_SetSendEndEnabled($$VisaHandle,$$enabled);"
  ],
  "description": "\n\nThis function will set whether the END signal is sent when the last character has been transmitted.\n\n\n\nRemarks:\n\nThe END signal is a separate line on a GPIB bus.\n\nThis setting has no effect on busses other than the GPIB bus.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$VisaHandle\n\nObject\n\nThe VISA resource handle opened with the IviVISA_Open or IviVISA_OpenBool function.\n\n\n\n$enabled\n\nBoolean\n\nWhether the END signal is set at the end of a transmission (true = enabled, false = disabled).\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n\n\n\n\n// Open communication to the instrument.\n\n$resource = \"GPIB0::11::INSTR\";\n\n$timeout = 5000;\n\n$handle = IviVISA_Open($resource, $timeout);\n\n\n\n// Set the send end enabled.\n\nIviVISA_SetSendEndEnabled($handle, true);\n\n\n\n\n\nIviVISA_SetTerminationCharacter\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS IviVISA_SetTerminationCharacter": {
  "prefix": "IviVISA_SetTerminationCharacter",
  "body": [
   "IviVISA_SetTerminationCharacter($$VisaHandle,$$termChar);"
  ],
  "description": "\n\nThis function will set the termination character that is expected at the end of a received string.\n\n\n\nRemarks:\n\nThe VISA resource must already have been opened.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$VisaHandle\n\nObject\n\nThe VISA resource handle opened with the IviVISA_Open or IviVISA_OpenBool function.\n\n\n\n$termChar\n\nString\n\nThe character that marks the end of a received string.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n\n\n\n\n// Open communication to the instrument.\n\n$resource = \"GPIB0::11::INSTR\";\n\n$timeout = 5000;\n\n$handle = IviVISA_Open($resource, $timeout);\n\n\n\n// Set the termination character.\n\n$termChar = \"\\n\";\n\nIviVISA_SetTerminationCharacter($handle, $termChar);\n\n\n\n\n\nIviVISA_SetTerminationCharacterEnabled\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS IviVISA_SetTerminationCharacterEnabled": {
  "prefix": "IviVISA_SetTerminationCharacterEnabled",
  "body": [
   "IviVISA_SetTerminationCharacterEnabled($$VisaHandle,$$enabled);"
  ],
  "description": "\n\nThis function will set whether to look for a termination character at the end of a received string.\n\n\n\nRemarks:\n\nThe VISA resource must already have been opened.\n\nWhen the termination character is enabled, receiving the character will end the receive (any characters after the termination character will be ignored).\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$VisaHandle\n\nObject\n\nThe VISA resource handle opened with the IviVISA_Open or IviVISA_OpenBool function.\n\n\n\n$enabled\n\nBoolean\n\nWhether the termination character will end a receive (true = enabled, false = disabled).\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n\n\n\n\n// Open communication to the instrument.\n\n$resource = \"GPIB0::11::INSTR\";\n\n$timeout = 5000;\n\n$handle = IviVISA_Open($resource, $timeout);\n\n\n\n// Set the termination character enabled.\n\nIviVISA_SetTerminationCharacterEnabled($handle, true);\n\n\n\n\n\nIviVISA_Write\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS IviVISA_Write": {
  "prefix": "IviVISA_Write",
  "body": [
   "IviVISA_Write($$VisaHandle,$$outString);"
  ],
  "description": "\n\nThis function writes a string to the instrument.\n\n\n\n\n\nRemarks:\n\n\u00b7 This function requires the IVI Foundation VISA drivers. Both the IVI Shared Components and the VISA Shared Components.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$GpibHandle\n\nObject\n\nThe VISA resource handle opened with the IviVISA_Open or IviVISA_OpenBool function.\n\n\n\n$outString\n\nString\n\nThe string to send to the instrument.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n// Connect to the instrument.\n\n$resourceString = \"USB0::0x0699::0x0408::0x010469::0::INSTR\";\n\n$timeOut = 2000; // Time out = 2 seconds.\n\n$visa = IviVISA_Open($resourceString, $timeOut);\n\n\n\n\n\n$outString = \""
 }
,
 "JTS IviVISA_WriteBool": {
  "prefix": "IviVISA_WriteBool",
  "body": [
   "$$success=IviVISA_WriteBool($$VisaHandle,$$outString);"
  ],
  "description": "\n\nThis function writes a string to the instrument and returns a boolean indicating whether the write was successful.\n\n\n\n\n\nRemarks:\n\n\u00b7 This function requires the IVI Foundation VISA drivers. Both the IVI Shared Components and the VISA Shared Components.\n\n\u00b7 This function will not fail a test.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$GpibHandle\n\nObject\n\nThe VISA resource handle opened with the IviVISA_Open or IviVISA_OpenBool function.\n\n\n\n$outString\n\nString\n\nThe string to send to the instrument.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$success\n\nBoolean\n\nA status boolean indicating whether the write was successful.\n\n\n\n\n\nExample:\n\n// Connect to the instrument.\n\n$resourceString = \"USB0::0x0699::0x0408::0x010469::0::INSTR\";\n\n$timeOut = 2000; // Time out = 2 seconds.\n\n$visa = IviVISA_Open($resourceString, $timeOut);\n\n\n\n\n\n$outString = \""
 }
,
 "JTS NIVISA_Close": {
  "prefix": "NIVISA_Close",
  "body": [
   "NIVISA_Close($$handle);"
  ],
  "description": "\n\nCloses the VISA session to the instrument.\n\nNotes:\n\nRequires NI-VISA v5.0.0 + to be installed on the system. Make sure to install the \"NI Measurement Studio Common .NET Assemblies for .NET x.x\".\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$handle\n\nObject\n\nInstance of the message-based session created with the NIVISA_Open or NIVISA_OpenBool functions.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nUsage Example:\n\n\n\n\n\n$Handle = NIVISA_Open(\"GPIB0::2::Instr\");\n\nNIVISA_SetTimeout($Handle, 1000);\n\nSetFinalizeFunction(\"Cleanup\");\n\nNIVISA_Write($Handle, \""
 }
,
 "JTS NIVISA_Open": {
  "prefix": "NIVISA_Open",
  "body": [
   "$$handle=NIVISA_Open($$resourceString);"
  ],
  "description": "\n\nOpens a VISA session to the instrument. Supports multiple hardware bus types, including GPIB, USB, Serial, and Ethernet.\n\nNotes:\n\nRequires NI-VISA v5.0.0 + to be installed on the system. Make sure to install the \"NI Measurement Studio Common .NET Assemblies for .NET x.x\".\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$resourceString\n\nString\n\nThe resource string identifying the instrument. For example, \"GPIB0::9::Instr\".\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$handle\n\nObject\n\nThe object representing the instance of the GPIB instrument.\n\n\n\n\n\nUsage Example:\n\n\n\n\n\n$Handle = NIVISA_Open(\"GPIB0::2::Instr\");\n\n\n\n\n\nNIVISA_SetTimeout($Handle, 1000);\n\nSetFinalizeFunction(\"Cleanup\");\n\nNIVISA_Write($Handle, \""
 }
,
 "JTS NIVISA_OpenBool": {
  "prefix": "NIVISA_OpenBool",
  "body": [
   "($$VISAHandle,$$success)=NIVISA_OpenBool($$resourceString);"
  ],
  "description": "\n\nOpens a VISA session to the instrument. Supports multiple hardware bus types, including GPIB, USB, Serial, and Ethernet. Also returns a boolean indicator for whether the connection was successful.\n\n\n\n\n\nNotes:\n\nRequires NI-VISA v5.0.0 + to be installed on the system. Make sure to install the \"NI Measurement Studio Common .NET Assemblies for .NET x.x\".\n\nIf the instrument is not successfully connected to, this function will not fail, but will return a FALSE in the success boolean.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$resourceString\n\nString\n\nThe resource string identifying the instrument. For example, \"GPIB0::9::Instr\".\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$VISAHandle\n\nObject\n\nThe object representing the instance of the GPIB instrument.\n\n\n\n$success\n\nBoolean\n\nTrue if the instrument was successfully connected to, False otherwise.\n\n\n\n\n\nUsage Example:\n\n// Connect to the instrument.\n\nLabel InstrConnect:\n\n\n\n\n\n($VISAHandle, $success) = NIVISA_OpenBool(\"GPIB0::11::Instr\");\n\n\n\n\n\nif (!$success)\n\n{\n\n// Did not connect, wait 1 second and try again.\n\nSleep(1);\n\ngoto InstrConnect;\n\n}\n\n\n\n\n\nNIVISA_Read\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NIVISA_Read": {
  "prefix": "NIVISA_Read",
  "body": [
   "$$response=NIVISA_Read($$handle);"
  ],
  "description": "\n\nReads response string back from instrument.\n\nNotes:\n\nRequires NI-VISA v5.0.0 + to be installed on the system. Make sure to install the \"NI Measurement Studio Common .NET Assemblies for .NET x.x\".\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$handle\n\nObject\n\nInstance of the message-based session created with the NIVISA_Open or NIVISA_OpenBool functions.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$response\n\nString\n\nThe string read back from the instrument.\n\n\n\n\n\nUsage Example:\n\n\n\n\n\n$Handle = NIVISA_Open(\"GPIB0::2::Instr\");\n\nNIVISA_SetTimeout($Handle, 1000);\n\nSetFinalizeFunction(\"Cleanup\");\n\nNIVISA_Write($Handle, \""
 }
,
 "JTS NIVISA_ReadBool": {
  "prefix": "NIVISA_ReadBool",
  "body": [
   "($$response,$$success)=NIVISA_ReadBool($$handle);"
  ],
  "description": "\n\nReads response string back from instrument and returns a status for whether it was successful.\n\n\n\n\n\nNotes:\n\nWill not fail the test (always passes).\n\nRequires NI-VISA v5.0.0 + to be installed on the system. Make sure to install the \"NI Measurement Studio Common .NET Assemblies for .NET x.x\".\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$handle\n\nObject\n\nInstance of the message-based session created with the NIVISA_Open or NIVISA_OpenBool functions.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$response\n\nString\n\nThe string read back from the instrument.\n\n\n\n$success\n\nBoolean\n\nTrue if the instrument was successfully written to, False otherwise.\n\n\n\n\n\nUsage Example:\n\n\n\n\n\n$Handle = NIVISA_Open(\"GPIB0::2::Instr\");\n\nNIVISA_SetTimeout($Handle, 1000);\n\nSetFinalizeFunction(\"Cleanup\");\n\nNIVISA_Write($Handle, \""
 }
,
 "JTS NIVISA_SetTimeout": {
  "prefix": "NIVISA_SetTimeout",
  "body": [
   "NIVISA_SetTimeout($$handle,$$timeoutMS);"
  ],
  "description": "\n\nSets the communication timeout value for the VISA session. The timeout value is specified in milliseconds.\n\nNotes:\n\nRequires NI-VISA v5.0.0 + to be installed on the system. Make sure to install the \"NI Measurement Studio Common .NET Assemblies for .NET x.x\".\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$handle\n\nObject\n\nInstance of the message-based session created with the NIVISA_Open or NIVISA_OpenBool functions.\n\n\n\n$timeoutMS\n\nInteger\n\nCommunication timeout value in milliseconds.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nUsage Example:\n\n\n\n\n\n$Handle = NIVISA_Open(\"GPIB0::2::Instr\");\n\n\n\n\n\nNIVISA_SetTimeout($Handle, 1000);\n\n\n\n\n\nSetFinalizeFunction(\"Cleanup\");\n\nNIVISA_Write($Handle, \""
 }
,
 "JTS NIVISA_Write": {
  "prefix": "NIVISA_Write",
  "body": [
   "NIVISA_Write($$handle,$$message);"
  ],
  "description": "\n\nWrites command string to instrument.\n\nNotes:\n\nRequires NI-VISA v5.0.0 + to be installed on the system. Make sure to install the \"NI Measurement Studio Common .NET Assemblies for .NET x.x\".\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$handle\n\nObject\n\nInstance of the message-based session created with the NIVISA_Open or NIVISA_OpenBool functions.\n\n\n\n$message\n\nString\n\nCommand to write to the instrument.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nUsage Example:\n\n\n\n\n\n$Handle = NIVISA_Open(\"GPIB0::2::Instr\");\n\nNIVISA_SetTimeout($Handle, 1000);\n\nSetFinalizeFunction(\"Cleanup\");\n\n\n\n\n\nNIVISA_Write($Handle, \""
 }
,
 "JTS NIVISA_WriteBool": {
  "prefix": "NIVISA_WriteBool",
  "body": [
   "$$success=NIVISA_WriteBool($$handle,$$message);"
  ],
  "description": "\n\nWrites command string to instrument and returns a status for whether it was successful.\n\n\n\n\n\nNotes:\n\nWill not fail the test (always passes).\n\nRequires NI-VISA v5.0.0 + to be installed on the system. Make sure to install the \"NI Measurement Studio Common .NET Assemblies for .NET x.x\".\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$handle\n\nObject\n\nInstance of the message-based session created with the NIVISA_Open or NIVISA_OpenBool functions.\n\n\n\n$message\n\nString\n\nCommand to write to the instrument.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$success\n\nBoolean\n\nTrue if the instrument was successfully written to, False otherwise.\n\n\n\n\n\nUsage Example:\n\n\n\n\n\n$Handle = NIVISA_Open(\"GPIB0::2::Instr\");\n\nNIVISA_SetTimeout($Handle, 1000);\n\nSetFinalizeFunction(\"Cleanup\");\n\n\n\n\n\n$success = NIVISA_WriteBool($Handle, \""
 }
,
 "JTS NumericComparison": {
  "prefix": "NumericComparison",
  "body": [
   "$$result=NumericComparison($$value1,$$value2,$$logicalOperator);"
  ],
  "description": "\n\nThis function returns a boolean resulting from the comparison of two numeric script variables and/or numbers. The comparison type is defined by the $logicalOperator.\n\n\n\n\n\nRemarks:\n\nThis function has been deprecated. It still works, but is no longer required. All of the comparison operators can be used in-line. Example: if ($value1 >= $value2)...\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$value1\n\nInteger, Float, Byte\n\nFirst comparison value.\n\n\n\n$value2\n\nInteger, Float, Byte\n\nSecond comparison value.\n\n\n\n$logicalOperator\n\nString\n\nThe logical comparison operation to be performed on the supplied values. Valid logical operators are:\n\n\u00b7 \"==\" : Equal To\n\n\u00b7 \"<\" : Less Than\n\n\u00b7 \">\" : Greater Than\n\n\u00b7 \"<=\" : Less Than or Equal To\n\n\u00b7 \">=\" : Greater Than or Equal To\n\n\u00b7 \"!=\" : Not Equal To\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$result\n\nBoolean\n\nThe result of the logical comparison.\n\n\n\n\n\nExample:\n\n// Test the value in a variable.\n\n$result = NumericComparison($value, 3000, \">=\");\n\n// Will return true if the number in $value is greater than or equal to 3000.\n\n\n\n\n\nBinaryStringToInteger\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS BinaryStringToInteger": {
  "prefix": "BinaryStringToInteger",
  "body": [
   "$$Value=BinaryStringToInteger($$BinaryString);"
  ],
  "description": "\n\n\n\n\n\nReturns an Integer representing the value of the binary string supplied to the function. If the supplied string is not a valid binary value, a failure is generated.\n\nNote:\n\nBinary strings can contain any number of whitespace. Values larger than 2^32 \u2013 1 (0b0111 1111 1111 1111 1111 1111 1111 1111) are returned as the negative-valued two\u2019s complement of the binary string.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$BinaryString\n\nString\n\nThe binary string (which can contain whitespace)\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Value\n\nInteger\n\nThe integer value of the binary string\n\n\n\n\n\nExample:\n\n\n\n\n\n$Value = BinaryStringToInteger (\u201c10 1001 0001\u201d);\n\n\n\n\n\nByteArrayToASCIIString\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ByteArrayToASCIIString": {
  "prefix": "ByteArrayToASCIIString",
  "body": [
   "$$returnString=ByteArrayToASCIIString($$byteArray);"
  ],
  "description": "\n\n\n\n\n\nThis function will convert an array of bytes into a series of ASCII characters that is then returned as a string.\n\n\n\n\n\nRemarks:\n\nIf the input array is an array of integers, the value of each one must be between 0 and 255.\n\nALL elements of the array will be converted. Including all elements that contain a 0 value.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$byteArray\n\nArray\n\nAn array of integers or bytes that will be converted to an ASCII string. If this is an integer array, all elements must have a value between 0 and 255.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$returnString\n\nString\n\nA string containing the ASCII representation of the bytes from the input array.\n\n\n\n\n\nExample:\n\n// Create our byte array.\n\n$charArray = Array1DCreate(\"INTEGER\", 5);\n\nArray1DSetValue($charArray, 0, 72); // H\n\nArray1DSetValue($charArray, 1, 101); // e\n\nArray1DSetValue($charArray, 2, 108); // l\n\nArray1DSetValue($charArray, 3, 108); // l\n\nArray1DSetValue($charArray, 4, 111); // o\n\n\n\n\n\n// Convert to String.\n\n$returnString = ByteArrayToASCIIString($charArray);\n\n// the string will now be \"Hello\".\n\n\n\n\n\nDecimalToHexString\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS DecimalToHexString": {
  "prefix": "DecimalToHexString",
  "body": [
   "$$hexString=DecimalToHexString($$value);"
  ],
  "description": "\n\nThis function will convert a decimal number (stored in an integer, a float or a string) into its hexadecimal equivalent and return that as a string.\n\n\n\n\n\nRemarks:\n\nIf the number is in a float or a string, it must not contain a decimal point. It must be able to be parsed as an integer.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$value\n\nInteger, Float or String\n\nThe value to be converted to a hexadecimal string.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$hexString\n\nString\n\nThe string containing the hexadecimal representation of the value supplied.\n\n\n\n\n\nExample:\n\n// Convert a number to hexadecimal.\n\n$value = 123456789;\n\n$hexString = DecimalToHexString($value);\n\n\n\n\n\n$outStr = \"The value \" + $value + \" in hexadecimal is \" + $hexString;\n\nUpdateStatus($outStr);\n\n// Outputs: The value 123456789 in hexadecimal is 75BCD15\n\n\n\n\n\nDecimalToHexStringSpecifyWidth\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS DecimalToHexStringSpecifyWidth": {
  "prefix": "DecimalToHexStringSpecifyWidth",
  "body": [
   "$$HexString=DecimalToHexStringSpecifyWidth($$Value,$$Width);"
  ],
  "description": "\n\nConverts a decimal number (either Integer, Float or String) to a hexadecimal string representation of the number. The $Width parameter specifies the number of characters that will be returned in the hex string. This parameter is useful if the returned value needs to be padded with leading 0's.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Value\n\nInteger, Float or String\n\nThe value to be converted to an hexadecimal string.\n\n\n\n$Width\n\nInteger\n\nThe number of characters to be returned in the hexadecimal string.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$HexString\n\nString\n\nThe string representing the Hexadecimal representation of the value supplied to the function.\n\n\n\n\n\nExample:\n\n\n\n\n\n$value = 12345;\n\n$width = 8;\n\n\n\n$hexString = DecimalToHexStringSpecifyWidth($value, $width);\n\n\n\n$outStr = \"The hex string is: \" + $hexString;\n\nUpdateStatus($outStr);\n\n\n\nEnd;\n\n\n\n\n\nHexStringToBinaryString\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS HexStringToBinaryString": {
  "prefix": "HexStringToBinaryString",
  "body": [
   "$$value=HexStringToBinaryString($$HexString);"
  ],
  "description": "\n\nReturns an binary string representing the value of the Hexadecimal string supplied to the function. If the supplied string is not a valid hexadecimal value, a failure is generated.\n\nExample:\n\n$value = HexStringToBinaryString(\"f0f\");\n\nThen, value would contain the string \"111100001111\";\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$HexString\n\nString\n\nThe hexadecimal string.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$value\n\nString\n\nThe binary string representation of the hexadecimal value.\n\n\n\n\n\nHexStringToBinaryStringSpecifyWidth\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS HexStringToBinaryStringSpecifyWidth": {
  "prefix": "HexStringToBinaryStringSpecifyWidth",
  "body": [
   "$$value=HexStringToBinaryStringSpecifyWidth($$HexString,$$ByteWidth);"
  ],
  "description": "\n\nReturns an binary string representing the value of the Hexadecimal string supplied to the function. If the supplied string is not a valid hexadecimal value, a failure is generated.\n\nThe byte width parameter allows setting the number of bits used to represent the binary string. If the value is shorter than the number of bytes specified, it will be left padded with leading zero's.\n\nExample:\n\n$value = HexStringToBinaryStringSpecifyWidth(\"f\",2);\n\nThen, value would contain the string \"0000000000001111\";\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$HexString\n\nString\n\nThe hexadecimal string.\n\n\n\n$ByteWidth\n\nInteger\n\nThe number of bytes to use to represent the binary string.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$value\n\nString\n\nThe binary string representation of the hexadecimal value.\n\n\n\n\n\nHexStringToFloat\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS HexStringToFloat": {
  "prefix": "HexStringToFloat",
  "body": [
   "$$value=HexStringToFloat($$HexString);"
  ],
  "description": "\n\nReturns a Float data-type representing the value of the Hexadecimal string supplied to the function. If the supplied string is not a valid hexadecimal value, a failure is generated.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$HexString\n\nString\n\nThe hexadecimal string.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$value\n\nFloat\n\nThe floating-point value of the supplied hexadecimal string.\n\n\n\n\n\nHexStringToInteger\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS HexStringToInteger": {
  "prefix": "HexStringToInteger",
  "body": [
   "$$value=HexStringToInteger($$HexString);"
  ],
  "description": "\n\nReturns an Integer representing the value of the Hexadecimal string supplied to the function. If the supplied string is not a valid hexadecimal value, a failure is generated.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$HexString\n\nString\n\nThe hexadecimal string.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$value\n\nInteger\n\nThe integer value of the supplied hexadecimal string.\n\n\n\n\n\nHexStringToString\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS HexStringToString": {
  "prefix": "HexStringToString",
  "body": [
   "$$return=HexStringToString($$hexString,$$separatorString);"
  ],
  "description": "\n\nThis function converts a Hex Format byte string to an ASCII string. This is the opposite of the StringToHexString function.\n\n\n\n\n\nRemarks:\n\nThe Hex numbers must be two bytes. If single byte numbers are present these must be padded out to 2 digits by adding a leading 0. Example: 55 2 ff will become 55 02 ff.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$hexString\n\nString\n\nByte string in hex format.\n\n\n\n$separatorString\n\nString\n\nThis is the bye used to separate the hex numbers in the string. This is usually a space \" \".\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$return\n\nString\n\nThe ASCII string from the input $hexString.\n\n\n\n\n\nExample:\n\n// Convert the hex string \"4A 41 42 49 4C\" to an ASCII string.\n\n// It will return the word \"JABIL\".\n\n$hexString = \"4A 41 42 49 4C\";\n\n$sepStr = \" \";\n\n\n\n\n\n$return = HexStringToString($hexString, $sepStr);\n\n\n\n\n\n$outStr = \"The hex string \" + $hexString + \"\\nin ASCII is \" + $return;\n\nUpdateStatus($outStr);\n\n\n\n\n\nIntegerToBinaryStringSpecifyWidth\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS IntegerToBinaryStringSpecifyWidth": {
  "prefix": "IntegerToBinaryStringSpecifyWidth",
  "body": [
   "$$ValueString=IntegerToBinaryStringSpecifyWidth($$IntegerNumber,$$NumberOfBits);"
  ],
  "description": "\n\n\n\n\n\nThis function will format the integer supplied as a binary string. The $NumberOfBits parameter will determine how many characters the binary string will contain. In the event that the binary representation of the number requires fewer bits than the number of characters specified, it will be left padded with zeros.\n\nNote:\n\nA warning will be thrown if the number of bits needed to represent the integer exceeds $NumberOfBits, but no failure will be returned.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$IntegerNumber\n\nInteger\n\nThe integer number to convert to a binary string\n\n\n\n$NumberOfBits\n\nInteger\n\nThe number of bits to use to represent the number. This parameter is used to control the padding.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ValueString\n\nString\n\nThe binary string representing the integer supplied to the function.\n\n\n\n\n\nExample:\n\n\n\n\n\n$ValueString = IntegerToBinaryStringSpecifyWidth (15123, 16);\n\n\n\n\n\nIntegerToHexString\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS IntegerToHexString": {
  "prefix": "IntegerToHexString",
  "body": [
   "$$valueString=IntegerToHexString($$IntegerNumber,$$NumberOfCharacters);"
  ],
  "description": "\n\nThis function will format the integer supplied as a hexadecimal string. The $NumberOfCharacters parameter will determine how many characters the hex string will have. In the event that the hexadecimal representation of the number requires less characters than specified, it will be left padded with zeros.\n\nExample:\n\n$ValueString = IntegerToHexString(15123,6);\n\n$ValueString = \"003B13\";\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$IntegerNumber\n\nInteger\n\nThe number to convert to a hex string\n\n\n\n$NumberOfCharacters\n\nInteger\n\nThe number of characters for representing the number. This is useful for left padding a value with 0's to create a string of the desired length.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$valueString\n\nString\n\nThe hexadecimal string representing the integer supplied to the function.\n\n\n\n\n\nStringToFloat\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS StringToFloat": {
  "prefix": "StringToFloat",
  "body": [
   "$$floatNumber=StringToFloat($$stringToConvert);"
  ],
  "description": "\n\nThis function converts a string containing a float number to a float variable.\n\n\n\nRemarks:\n\nThe float number must be at the start of the string and must be the only item in the string (no other text).\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$stringToConvert\n\nString\n\nThe string that contains the float number.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$floatNumber\n\nFloat\n\nThe number that was in the string converted to a float.\n\n\n\n\n\nExample:\n\n\n\n\n\n// Convert a float number from a string.\n\n$convertString = \"3.141592654\";\n\n$floatNum = StringToFloat($convertString);\n\n\n\n\n\nStringToHexString\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS StringToHexString": {
  "prefix": "StringToHexString",
  "body": [
   "$$return=StringToHexString($$String);"
  ],
  "description": "\n\nThis function convents an ASCII string to a byte string in Hex format.\n\nExample:\n\nThe input String is \u201cJABIL\u201d, and the return will be \u201c4A 41 42 49 4C\u201d.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$String\n\nString\n\nASCII string.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$return\n\nString\n\nByte string in Hex format.\n\n\n\n\n\nTwosComplementHexStringToInteger\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS TwosComplementHexStringToInteger": {
  "prefix": "TwosComplementHexStringToInteger",
  "body": [
   "$$Value=TwosComplementHexStringToInteger($$HexString);"
  ],
  "description": "\n\nThis function converts the supplied two's complement hexadecimal string to a signed integer value. The length of the supplied hexadecimal string must be 2,4,8, or 16 bytes in length (representing 8 bit, 16 bit, 32 bit, or 64 bit signed integer values).\n\n\n\n\n\nNote:\n\nIf the input string supplied to the function doesn't match a supported string length, the function will generate an error.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$HexString\n\nString\n\nThe hexadecimal string representing the number\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Value\n\nString\n\nInteger return value.\n\n\n\n\n\nExample:\n\n\n\n\n\n// Test Byte\n\n$MyHex = \"F1\";\n\n$MyByte = TwosComplementHexStringToInteger($MyHex);\n\n$MyString = \"The Byte is [\" + $MyByte + \"]\";\n\nUpdateStatus($MyString);\n\n\n\n\n\n// Test Short\n\n$MyHex = \"FFF1\";\n\n$MyShort = TwosComplementHexStringToInteger($MyHex);\n\n$MyString = \"The Short is [\" + $MyShort + \"]\";\n\nUpdateStatus($MyString);\n\n\n\n\n\n// Test Int\n\n$MyHex = \"FFFFFFF1\";\n\n$MyInt = TwosComplementHexStringToInteger($MyHex);\n\n$MyString = \"The Int is [\" + $MyInt + \"]\";\n\nUpdateStatus($MyString);\n\n\n\n\n\n// Test Long\n\n$MyHex = \"FFFFFFF1\";\n\n$MyLong = TwosComplementHexStringToInteger($MyHex);\n\n$MyString = \"The Long is [\" + $MyLong + \"]\";\n\nUpdateStatus($MyString);\n\n\n\n\n\n// Should Blow up with an error\n\n$MyHex = \"FFFFFF1\";\n\n$MyLong = TwosComplementHexStringToInteger($MyHex);\n\n$MyString = \"The Long is [\" + $MyLong + \"]\";\n\nUpdateStatus($MyString);\n\n\n\n\n\nExample Output:\n\n\n\n\n\n$MyHex = \"F1\";\n\n$MyString = \"The Byte is [\" + -15 + \"]\";\n\nThe Byte is [-15]\n\n$MyHex = \"FFF1\";\n\n$MyString = \"The Short is [\" + -15 + \"]\";\n\nThe Short is [-15]\n\n$MyHex = \"FFFFFFF1\";\n\n$MyString = \"The Int is [\" + -15 + \"]\";\n\nThe Int is [-15]\n\n$MyHex = \"FFFFFFF1\";\n\n$MyString = \"The Long is [\" + -15 + \"]\";\n\nThe Long is [-15]\n\n$MyHex = \"FFFFFF1\";\n\nTwosComplementHexStringToInteger: Invalid Length of Hex String... Valid String Lengths are (2=byte,4=short,8=int,16=long)\n\n\n\n\n\nAES128CBC_DecryptByteArrayToByteArray\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AES128CBC_DecryptByteArrayToByteArray": {
  "prefix": "AES128CBC_DecryptByteArrayToByteArray",
  "body": [
   "$$decryptedArray=AES128CBC_DecryptByteArrayToByteArray($$arrayToDecrypt,$$encryptKey,$$encryptIV);"
  ],
  "description": "\n\nThis function will decrypt a byte array using the AES-128 CBC algorythm. The decrypted data is returned as a byte array.\n\n\n\n\n\nRemarks:\n\nThe encryption key and Initialization Vector (IV) must be 16 or 32 bytes long.\n\nThe encryption key and IV are hex strings - ie. hex bytes in a string.\n\nHex strings may contain spaces between each byte , but do not have to.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$arrayToDecrypt\n\nArray\n\nA 1 dimensional array of bytes or integers that can be converted to bytes (values between 0 and 255).\n\n\n\n$encryptKey\n\nString\n\nA hex string containing the encryption key.\n\n\n\n$encryptIV\n\nString\n\nA hex string containing the encryption Initialization Vector.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$decryptedArray\n\nArray\n\nThe decrypted data returned as an array of bytes.\n\n\n\n\n\nExample:\n\n// Decrypt a byte array.\n\n$encKey = \"01 23 45 67 89 AB CD EF 01 23 45 67 89 AB CD EF\"; // Hex string with spaces.\n\n$encIV = \"0F1E2D3C4B5A69788796A5B4C3D2E1F0\"; // Hex string without spaces.\n\n\n\n\n\n$decArr = AES128CBC_DecryptByteArrayToByteArray($encryptedArray, $encKey, $encIV);\n\n\n\n\n\nAES128CBC_DecryptByteArrayToHexString\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AES128CBC_DecryptByteArrayToString": {
  "prefix": "AES128CBC_DecryptByteArrayToString",
  "body": [
   "$$decryptedString=AES128CBC_DecryptByteArrayToString($$arrayToDecrypt,$$encryptKey,$$encryptIV);"
  ],
  "description": "\n\nThis function will decrypt a byte array using the AES-128 CBC algorythm. The decrypted data is returned as a string.\n\n\n\n\n\nRemarks:\n\nThe encryption and decryption of strings relies on the ASCII value of each character in the string. Values above 0x7F are converted to '?' characters (0x3F).\n\nThe encryption key and Initialization Vector (IV) must be 16 or 32 bytes long.\n\nThe encryption key and IV are hex strings - ie. hex bytes in a string.\n\nHex strings may contain spaces between each byte , but do not have to.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$arrayToDecrypt\n\nArray\n\nA 1 dimensional array of bytes or integers that can be converted to bytes (values between 0 and 255).\n\n\n\n$encryptKey\n\nString\n\nA hex string containing the encryption key.\n\n\n\n$encryptIV\n\nString\n\nA hex string containing the encryption Initialization Vector.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$decryptedString\n\nArray\n\nThe decrypted data returned as an ASCII string.\n\n\n\n\n\nExample:\n\n// Decrypt a byte array.\n\n$encKey = \"01 23 45 67 89 AB CD EF 01 23 45 67 89 AB CD EF\"; // Hex string with spaces.\n\n$encIV = \"0F1E2D3C4B5A69788796A5B4C3D2E1F0\"; // Hex string without spaces.\n\n\n\n\n\n$decStr = AES128CBC_DecryptByteArrayToString($encryptedArray, $encKey, $encIV);\n\n\n\n\n\nAES128CBC_DecryptHexStringToHexString\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AES128CBC_DecryptByteArrayToHexString": {
  "prefix": "AES128CBC_DecryptByteArrayToHexString",
  "body": [
   "$$decryptedHexString=AES128CBC_DecryptByteArrayToHexString($$hexStringToDecrypt,$$encryptKey,$$encryptIV);"
  ],
  "description": "\n\nThis function will decrypt a hex string using the AES-128 CBC algorythm. The decrypted data is returned as a hex string with spaces.\n\n\n\n\n\nRemarks:\n\nThe encryption key and Initialization Vector (IV) must be 16 or 32 bytes long.\n\nThe encryption key and IV are hex strings - ie. hex bytes in a string.\n\nHex strings may contain spaces between each byte , but do not have to.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$hexStringToDecrypt\n\nString\n\nA hex string containing the data to decrypt.\n\n\n\n$encryptKey\n\nString\n\nA hex string containing the encryption key.\n\n\n\n$encryptIV\n\nString\n\nA hex string containing the encryption Initialization Vector.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$decryptedHexString\n\nString\n\nThe decrypted data returned as a hex string with spaces.\n\n\n\n\n\nExample:\n\n// Decrypt a byte array.\n\n$encKey = \"01 23 45 67 89 AB CD EF 01 23 45 67 89 AB CD EF\"; // Hex string with spaces.\n\n$encIV = \"0F1E2D3C4B5A69788796A5B4C3D2E1F0\"; // Hex string without spaces.\n\n\n\n\n\n$decHexStr = AES128CBC_DecryptHexStringToHexString($encryptedHexStr, $encKey, $encIV);\n\n\n\n\n\nAES128CBC_EncryptByteArrayToByteArray\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AES128CBC_EncryptByteArrayToByteArray": {
  "prefix": "AES128CBC_EncryptByteArrayToByteArray",
  "body": [
   "$$encryptedArray=AES128CBC_EncryptByteArrayToByteArray($$arrayToEncrypt,$$encryptKey,$$encryptIV);"
  ],
  "description": "\n\nThis function will encrypt a byte array using the AES-128 CBC algorythm. The encrypted data is returned as a byte array.\n\n\n\n\n\nRemarks:\n\nThe encryption key and Initialization Vector (IV) must be 16 or 32 bytes long.\n\nThe encryption key and IV are hex strings - ie. hex bytes in a string.\n\nHex strings may contain spaces between each byte , but do not have to.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$arrayToEncrypt\n\nArray\n\nA 1 dimensional array of bytes or integers that can be converted to bytes (values between 0 and 255).\n\n\n\n$encryptKey\n\nString\n\nA hex string containing the encryption key.\n\n\n\n$encryptIV\n\nString\n\nA hex string containing the encryption Initialization Vector.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$encryptedArray\n\nArray\n\nThe encrypted data returned as an array of bytes.\n\n\n\n\n\nExample:\n\n// Encrypt a byte array.\n\n$encKey = \"01 23 45 67 89 AB CD EF 01 23 45 67 89 AB CD EF\"; // Hex string with spaces.\n\n$encIV = \"0F1E2D3C4B5A69788796A5B4C3D2E1F0\"; // Hex string without spaces.\n\n\n\n\n\n$encArr = AES128CBC_EncryptByteArrayToByteArray($arrayToEncrypt, $encKey, $encIV);\n\n\n\n\n\nAES128CBC_EncryptHexStringToByteArray\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AES128CBC_EncryptHexStringToByteArray": {
  "prefix": "AES128CBC_EncryptHexStringToByteArray",
  "body": [
   "$$encryptedArray=AES128CBC_EncryptHexStringToByteArray($$hexStringToEncrypt,$$encryptKey,$$encryptIV);"
  ],
  "description": "\n\nThis function will encrypt a hex string using the AES-128 CBC algorythm. The encrypted data is returned as a byte array.\n\n\n\n\n\nRemarks:\n\nThe encryption key and Initialization Vector (IV) must be 16 or 32 bytes long.\n\nThe encryption key and IV are hex strings - ie. hex bytes in a string.\n\nHex strings may contain spaces between each byte , but do not have to.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$hexStringToEncrypt\n\nString\n\nA hex string containing the data to encrypt.\n\n\n\n$encryptKey\n\nString\n\nA hex string containing the encryption key.\n\n\n\n$encryptIV\n\nString\n\nA hex string containing the encryption Initialization Vector.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$encryptedArray\n\nArray\n\nThe encrypted data returned as an array of bytes.\n\n\n\n\n\nExample:\n\n// Encrypt a byte array.\n\n$encKey = \"01 23 45 67 89 AB CD EF 01 23 45 67 89 AB CD EF\"; // Hex string with spaces.\n\n$encIV = \"0F1E2D3C4B5A69788796A5B4C3D2E1F0\"; // Hex string without spaces.\n\n\n\n\n\n$encArr = AES128CBC_EncryptHexStringToByteArray($hexStringToEncrypt, $encKey, $encIV);\n\n\n\n\n\nAES128CBC_EncryptHexStringToHexString\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AES128CBC_EncryptHexStringToHexString": {
  "prefix": "AES128CBC_EncryptHexStringToHexString",
  "body": [
   "$$encryptedHexString=AES128CBC_EncryptHexStringToHexString($$hexStringToEncrypt,$$encryptKey,$$encryptIV);"
  ],
  "description": "\n\nThis function will encrypt a hex string using the AES-128 CBC algorythm. The encrypted data is returned as a hex string with spaces.\n\n\n\n\n\nRemarks:\n\nThe encryption key and Initialization Vector (IV) must be 16 or 32 bytes long.\n\nThe encryption key and IV are hex strings - ie. hex bytes in a string.\n\nHex strings may contain spaces between each byte , but do not have to.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$hexStringToEncrypt\n\nString\n\nA hex string containing the data to encrypt.\n\n\n\n$encryptKey\n\nString\n\nA hex string containing the encryption key.\n\n\n\n$encryptIV\n\nString\n\nA hex string containing the encryption Initialization Vector.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$encryptedHexString\n\nString\n\nThe encrypted data returned as a hex string with spaces.\n\n\n\n\n\nExample:\n\n// Encrypt a byte array.\n\n$encKey = \"01 23 45 67 89 AB CD EF 01 23 45 67 89 AB CD EF\"; // Hex string with spaces.\n\n$encIV = \"0F1E2D3C4B5A69788796A5B4C3D2E1F0\"; // Hex string without spaces.\n\n\n\n\n\n$encHexStr = AES128CBC_EncryptHexStringToHexString($hexStringToEncrypt, $encKey, $encIV);\n\n\n\n\n\nAES128CBC_EncryptStringToByteArray\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AES128CBC_EncryptStringToByteArray": {
  "prefix": "AES128CBC_EncryptStringToByteArray",
  "body": [
   "$$encryptedArray=AES128CBC_EncryptStringToByteArray($$stringToEncrypt,$$encryptKey,$$encryptIV);"
  ],
  "description": "\n\nThis function will encrypt a string using the AES-128 CBC algorythm. The encrypted data is returned as a byte array.\n\n\n\n\n\nRemarks:\n\nThe encryption and decryption of strings relies on the ASCII value of each character in the string. Values above 0x7F are converted to '?' characters (0x3F).\n\nThe encryption key and Initialization Vector (IV) must be 16 or 32 bytes long.\n\nThe encryption key and IV are hex strings - ie. hex bytes in a string.\n\nHex strings may contain spaces between each byte , but do not have to.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$stringToEncrypt\n\nString\n\nA string to encrypt.\n\n\n\n$encryptKey\n\nString\n\nA hex string containing the encryption key.\n\n\n\n$encryptIV\n\nString\n\nA hex string containing the encryption Initialization Vector.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$encryptedArray\n\nArray\n\nThe encrypted data returned as an array of bytes.\n\n\n\n\n\nExample:\n\n// Encrypt a byte array.\n\n$encKey = \"01 23 45 67 89 AB CD EF 01 23 45 67 89 AB CD EF\"; // Hex string with spaces.\n\n$encIV = \"0F1E2D3C4B5A69788796A5B4C3D2E1F0\"; // Hex string without spaces.\n\n\n\n\n\n$encArr = AES128CBC_EncryptStringToByteArray($stringToEncrypt, $encKey, $encIV);\n\n\n\n\n\nDataRow_GetValueByColumnName\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS DataRow_GetValueByColumnName": {
  "prefix": "DataRow_GetValueByColumnName",
  "body": [
   "$$MyValue1=DataRow_GetValueByColumnName($$Row,$$ColumnName);"
  ],
  "description": "\n\nDataTable_GetValueByColumnName is the function which reads the value from the Data Row for the given Column Name. Function arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Row\n\nObject\n\nData Row Object returned from the DataTable_Create Function.\n\n\n\n$ColumnName\n\nString\n\nThe Column Name of element to drag the element from the Data Row\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$MyValue1\n\nObject\n\nThe Return Value from the Data Row is assigned to this Variable.\n\n\n\n\n\nExample:\n\n\n\n\n\n$MyTable = DataTable_Create(\"Employees\");\n\nDataTable_AddColumn($MyTable,\"id\");\n\nDataTable_AddColumn($MyTable,\"name\");\n\nDataTable_AddColumn($MyTable,\"Place\");\n\n\n\n\n\n$emp1 = DataTable_CreateRow($MyTable);\n\nDataRow_SetValue($emp1,0,\"24\");\n\nDataRow_SetValue($emp1,1,\"Peter\");\n\nDataRow_SetValue($emp1,2,\"USA\");\n\n\n\n\n\nDataTable_AddRow($MyTable,$emp1);\n\n\n\n\n\n$emp2 =DataTable_CreateRow($MyTable);\n\n\n\n\n\n$MyValue1 = DataRow_GetValueByColumnName($emp1,\"name\");\n\nUpdateStatus($MyValue1);\n\nEnd;\n\n\n\n\n\nDataRow_SetValue\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS DataRow_SetValue": {
  "prefix": "DataRow_SetValue",
  "body": [
   "DataRow_SetValue($$Row,$$ColumnIndex,$$SetValue);"
  ],
  "description": "\n\nDataRow_SetValue is the function which takes the Data Row Object, ColumnIndex and the value that needs to be assigned. Function arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Row\n\nObject\n\nData Row Object returned from the DataTable_Create Function.\n\n\n\n$ColumnIndex\n\nInteger\n\nThe Column Index of the element of the Data Row that needs to be changed.\n\n\n\n$SetValue\n\nObject\n\nThe value that should be assigned to that corresponding element in the Data Row.\n\n\n\n\n\nExample:\n\n\n\n\n\n$MyTable = DataTable_Create(\"Employees\");\n\nDataTable_AddColumn($MyTable,\"id\");\n\nDataTable_AddColumn($MyTable,\"name\");\n\nDataTable_AddColumn($MyTable,\"Place\");\n\n\n\n\n\n$emp1 = DataTable_CreateRow($MyTable);\n\nDataRow_SetValue($emp1,0,\"24\");\n\nDataRow_SetValue($emp1,1,\"Peter\");\n\nDataRow_SetValue($emp1,2,\"USA\");\n\n\n\n\n\nDataTable_AddRow($MyTable,$emp1);\n\n\n\n\n\n$emp2 =DataTable_CreateRow($MyTable);\n\nDataRow_SetValue($emp2,0,\"36\");\n\nDataRow_SetValue($emp2,1,\"John\");\n\nDataRow_SetValue($emp2,2,\"Florida\");\n\n\n\n\n\nDataTable_AddRow($MyTable,$emp2);\n\nEnd;\n\n\n\n\n\nDataRow_SetValueByColumnName\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS DataRow_SetValueByColumnName": {
  "prefix": "DataRow_SetValueByColumnName",
  "body": [
   "DataRow_SetValueByColumnName($$Row,$$ColumnName,$$SetValue);"
  ],
  "description": "\n\nDataRow_SetValueByColumnName is the function which takes the Data Row, ColumnName and the value that needs to be assigned . Function arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Row\n\nObject\n\nData Row Object returned from the DataTable_Create Function.\n\n\n\n$ColumnName\n\nString\n\nThe Column Name is the name of the Column of the Data Row which value needs to be updated.\n\n\n\n$SetValue\n\nObject\n\nThe value that should be assigned to that corresponding element in the Data Row.\n\n\n\n\n\nExample:\n\n\n\n\n\n$MyTable = DataTable_Create(\"Employees\");\n\nDataTable_AddColumn($MyTable,\"id\");\n\nDataTable_AddColumn($MyTable,\"name\");\n\nDataTable_AddColumn($MyTable,\"Place\");\n\n\n\n\n\n$emp1 = DataTable_CreateRow($MyTable);\n\nDataRow_SetValueByColumnName($emp1,\"id\",24);\n\nDataRow_SetValueByColumnName($emp1,\"name\",\"Peter\");\n\nDataRow_SetValueByColumnName($emp1,\"Place\",\"USA\");\n\n\n\n\n\nDataTable_AddRow($MyTable,$emp1);\n\n\n\n\n\n$emp2 =DataTable_CreateRow($MyTable);\n\nDataRow_SetValueByColumnName($emp2,\"id\",36);\n\nDataRow_SetValueByColumnName($emp2,\"name\",\"Dan\");\n\nDataRow_SetValueByColumnName($emp2,\"Place\",\"Florida\");\n\n\n\n\n\nDataTable_AddRow($MyTable,$emp2);\n\nEnd;\n\n\n\n\n\nDataTable_AddColumn\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS DataTable_AddColumn": {
  "prefix": "DataTable_AddColumn",
  "body": [
   "DataTable_AddColumn($$Table,$$ColumnName);"
  ],
  "description": "\n\nThis function adds new Columns to the Data Table.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Table\n\nObject\n\nThe Data Table.\n\n\n\n\n\n$ColumnName\n\nString\n\nName of the New Column Created.\n\n\n\n\n\nExample:\n\n\n\n\n\n$MyTable = DataTable_Create(\"Data Table\");\n\nDataTable_AddColumn($MyTable,\"Column Name\");\n\n\n\n\n\nDataTable_AddRow\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS DataTable_AddRow": {
  "prefix": "DataTable_AddRow",
  "body": [
   "DataTable_AddRow($$Table,$$Row);"
  ],
  "description": "\n\nThis function adds new row to the data table.Before adding the row, it needs to be created. It is the DataTable_AddRow function which inserts the newly created rows to the Data Table. Function arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Table\n\nObject\n\nVariable that holds the name of the Data Table.\n\n\n\n\n\n$Row\n\nObject\n\nNew Data Row that needs to be added to the Data Table.\n\n\n\n\n\nExample:\n\n$emp1 = DataTable_CreateRow($MyTable);\n\n//Adds a String Name to a New Row...\n\nDataRow_SetValue($emp1,0,\"24\");\n\nDataRow_SetValue($emp1,1,\"Peter\");\n\nDataRow_SetValue($emp1,2,\"USA\");\n\n//Actually Adds a Row to the Data Table\n\nDataTable_AddRow($MyTable,$emp1);\n\n\n\n\n\nDataTable_Create\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS DataTable_Create": {
  "prefix": "DataTable_Create",
  "body": [
   "$$Table=DataTable_Create($$DataTableName);"
  ],
  "description": "\n\nThis function creates a Data Table named \"$Table\". After the Data Table is created, Rows and Columns can be directly added by their respective functions.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$DataTableName\n\nString\n\nName of the Data Table.\n\n\n\n\n\nReturn arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Table\n\nObject\n\n\n\n\n\nThe Returned Data Table.\n\n\n\n\n\nExample:\n\n\n\n\n\n$MyTable = DataTable_Create(\"Data Table\");\n\n\n\n\n\nDataTable_CreateRow\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS DataTable_CreateRow": {
  "prefix": "DataTable_CreateRow",
  "body": [
   "$$emp1=DataTable_CreateRow($$MyTable);"
  ],
  "description": "\n\nThis function create new Rows in the data table. Function arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$MyTable\n\nObject\n\nThe Data Table.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$emp1\n\nObject\n\nReturns the Created Data Row.\n\n\n\n\n\nExample:\n\n$MyTable = DataTable_Create(\"Employees\");\n\n$emp1 = DataTable_CreateRow($MyTable);\n\n\n\n\n\nDataTable_FillValueByColumn\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS DataTable_FillValueByColumn": {
  "prefix": "DataTable_FillValueByColumn",
  "body": [
   "DataTable_FillValueByColumn($$Table,$$ColumnName,$$SetValue);"
  ],
  "description": "\n\nDataTable_FillValueByColumn fills all values in the given Column Name using the Set Value supplied. Function arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Table\n\nObject\n\nThe Data Table.\n\n\n\n$ColumnName\n\nString\n\nThe Column Name is the Name of the Column in the Data Table.\n\n\n\n$SetValue\n\nObject\n\nThe value that should be assigned.\n\n\n\n\n\nExample:\n\n\n\n\n\nDataTable_AddColumn($MeasurementDataTable,\"SerialNumber\");\n\nDataTable_FillValueByColumn($MeasurementDataTable,\"SerialNumber\",$SerialNumber);\n\n\n\n\n\nDataTable_GetValue\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS DataTable_GetValue": {
  "prefix": "DataTable_GetValue",
  "body": [
   "$$MyValue1=DataTable_GetValue($$MyTable,$$RowIndex,$$ColumnIndex);"
  ],
  "description": "\n\nDataTable_GetValue is the function which reads the value from the Data Table for the given Row Index and Column Index. Function arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Table\n\nObject\n\nThe DataTable.\n\n\n\n\n\n$RowIndex\n\nInteger\n\nThe Row Index of the element of the DataTable that needs to be changed.\n\n\n\n$ColumnIndex\n\nInteger\n\nThe Column Index of the element of the DataTable that needs to be changed.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$MyValue1\n\nObject\n\nThe Return Value from the Data Table is assigned to this Variable.\n\n\n\n\n\nExample:\n\n\n\n\n\n$MyTable = DataTable_Create(\"Employees\");\n\nDataTable_AddColumn($MyTable,\"id\");\n\nDataTable_AddColumn($MyTable,\"name\");\n\nDataTable_AddColumn($MyTable,\"Place\");\n\n\n\n\n\n$emp1 = DataTable_CreateRow($MyTable);\n\nDataRow_SetValue($emp1,0,\"24\");\n\nDataRow_SetValue($emp1,1,\"Peter\");\n\nDataRow_SetValue($emp1,2,\"USA\");\n\n\n\n\n\nDataTable_AddRow($MyTable,$emp1);\n\n\n\n\n\n$emp2 =DataTable_CreateRow($MyTable);\n\n\n\n\n\n$MyValue1 = DataTable_GetValue($MyTable,1,1);\n\nUpdateStatus($MyValue1);\n\nEnd;\n\n\n\n\n\nDataTable_GetValueByColumnName\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS DataTable_GetValueByColumnName": {
  "prefix": "DataTable_GetValueByColumnName",
  "body": [
   "$$MyValue1=DataTable_GetValueByColumnName($$MyTable,$$RowIndex,$$ColumnName);"
  ],
  "description": "\n\nDataTable_GetValueByColumnName is the function which reads the value from the Data Table for given Row Index and Column Name. Function arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Table\n\nObject\n\nThe DataTable.\n\n\n\n\n\n$RowIndex\n\nInteger\n\nThe Row Index of the element to drag the element from the DataTable.\n\n\n\n$ColumnName\n\nString\n\nThe Column Name of element to drag the element from the Data Table.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$MyValue1\n\nObject\n\nThe Return Value from the Data Table is assigned to this Variable.\n\n\n\n\n\nExample:\n\n\n\n\n\n$MyTable = DataTable_Create(\"Employees\");\n\nDataTable_AddColumn($MyTable,\"id\");\n\nDataTable_AddColumn($MyTable,\"name\");\n\nDataTable_AddColumn($MyTable,\"Place\");\n\n\n\n\n\n$emp1 = DataTable_CreateRow($MyTable);\n\nDataRow_SetValue($emp1,0,\"24\");\n\nDataRow_SetValue($emp1,1,\"Peter\");\n\nDataRow_SetValue($emp1,2,\"USA\");\n\n\n\n\n\nDataTable_AddRow($MyTable,$emp1);\n\n\n\n\n\n$emp2 =DataTable_CreateRow($MyTable);\n\n\n\n\n\n$MyValue1 = DataTable_GetValueByColumnName($MyTable,1,\"name\");\n\nUpdateStatus($MyValue1);\n\nEnd;\n\n\n\n\n\nDataTable_InsertToSQL\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS DataTable_InsertToSQL": {
  "prefix": "DataTable_InsertToSQL",
  "body": [
   "DataTable_InsertToSQL($$ConnectionString,$$DestinationTable,$$DataTable);"
  ],
  "description": "\n\nDataTable_InsertToSQL performs a bulk copy to an existing SQL table. Function arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ConnectionString\n\nString\n\nValid SQL connection string.\n\n\n\n$DestinationTable\n\nString\n\nThe name of the destination table within the supplied connection string catalog\n\n\n\n$DataTable\n\nObject\n\nThe DataTable to be copied.\n\n\n\n\n\nExample:\n\n\n\n\n\nDataTable_InsertToSQL(\"Data Source=localhost\\\\SQLEXPRESS;Initial Catalog=Glucose;Integrated Security=True;Connect Timeout=30\",\"ElectricalMeasurements\",$MeasurementDataTable);\n\n\n\n\n\nDataTable_ReplaceMatchingValueByColumnName\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS DataTable_ReplaceMatchingValueByColumnName": {
  "prefix": "DataTable_ReplaceMatchingValueByColumnName",
  "body": [
   "DataTable_ReplaceMatchingValueByColumnName($$DataTable,$$ColumnName,$$MatchValue,$$SetValue);"
  ],
  "description": "\n\nDataTable_ReplaceMatchingValueByColumnName is the function which replaces all the matching values with the specified column and replaces them with the supplied set value. Function arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$DataTable\n\nObject\n\nThe Data Table.\n\n\n\n$ColumnName\n\nString\n\nThe name of the Column to replace values by matching\n\n\n\n$MatchValue\n\nObject\n\nThe matching value of the data to be replaced\n\n\n\n$SetValue\n\nObject\n\nThe value that should be assigned.\n\n\n\n\n\nExample:\n\nDataTable_ReplaceMatchingValueByColumnName($MeasurementDataTable,\"Channel\",\"101\",\"SampleChamber1\");\n\n\n\n\n\nDataTable_RowCount\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS DataTable_RowCount": {
  "prefix": "DataTable_RowCount",
  "body": [
   "$$count=DataTable_RowCount($$Table);"
  ],
  "description": "\n\nThe RowCount function computes the number of rows in the Data Table. Function arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Table\n\nObject\n\nThe DataTable.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$count\n\nInteger\n\nRow count in the Data Table.\n\n\n\n\n\nExample:\n\n$Table = DataTable_Create(\"Data Table\");\n\n$row1=DataTable_AddRow($Table,\"Row Name1\");\n\n$row2=DataTable_AddRow($Table,\"Row Name2\");\n\n$count=DataTable_RowCount($Table);\n\nEnd;\n\n\n\n\n\nDataTable_SetValue\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS DataTable_SetValue": {
  "prefix": "DataTable_SetValue",
  "body": [
   "DataTable_SetValue($$Table,$$RowIndex,$$ColumnIndex,$$SetValue);"
  ],
  "description": "\n\nDataTable_SetValue is the function which takes the RowIndex, ColumnIndex and the value that needs to be assigned. Function arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Table\n\nObject\n\nThe Data Table\n\n\n\n\n\n$RowIndex\n\nInteger\n\nThe Row Index of the element that needs to be changed.\n\n\n\n$ColumnIndex\n\nInteger\n\nThe Column Index of the element that needs to be changed.\n\n\n\n$SetValue\n\nObject\n\nThe value that should be assigned .\n\n\n\n\n\nExample:\n\n\n\n\n\n$MyTable = DataTable_Create(\"Data Table\");\n\nDataTable_AddColumn($MyTable,\"Column1\");\n\nDataTable_AddColumn($MyTable,\"Column2\");\n\nDataTable_AddRow($MyTable,\"Row1\");\n\nDataTable_AddRow($MyTable,\"Row2\");\n\n//Assign 45 to the 2nd Row and 3rd Column of $MyTable...\n\nDataTable_SetValue($MyTable,1, 2,\"45\");\n\n\n\n\n\nDataTable_SetValueByColumnName\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS DataTable_SetValueByColumnName": {
  "prefix": "DataTable_SetValueByColumnName",
  "body": [
   "DataTable_SetValueByColumnName($$Table,$$RowIndex,$$ColumnName,$$SetValue);"
  ],
  "description": "\n\nDataTable_SetValueByColumnName is the function which takes the Row Index, Column Name and the value that needs to be assigned. Function arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Table\n\nObject\n\nThe Data Table.\n\n\n\n$RowIndex\n\nInteger\n\nThe Row Index of the element that needs to be changed.\n\n\n\n$ColumnName\n\nString\n\nThe Column Name is the Name of the Column in the Data Table.\n\n\n\n$SetValue\n\nObject\n\nThe value that should be assigned.\n\n\n\n\n\nExample:\n\n\n\n\n\n$MyTable = DataTable_Create(\"Employees\");\n\nDataTable_AddColumn($MyTable,\"id\");\n\nDataTable_AddColumn($MyTable,\"name\");\n\nDataTable_AddColumn($MyTable,\"Place\");\n\n\n\n\n\n$emp1 = DataTable_CreateRow($MyTable);\n\nDataTable_SetValue($MyTable,1,0,\"24\");\n\nDataTable_SetValue($MyTable,1,1,\"Peter\");\n\nDataTable_SetValue($MyTable,1,2,\"USA\");\n\nDataTable_AddRow($MyTable,$emp1);\n\nDataTable_SetValueByColumnName($MyTable,1,\"Place\",\"Florida\");\n\nEnd;\n\n\n\n\n\nDataTable_ShowInWindow\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS DataTable_ShowInWindow": {
  "prefix": "DataTable_ShowInWindow",
  "body": [
   "DataTable_ShowInWindow($$Table);"
  ],
  "description": "\n\n\n\n\n\nThis command shows the supplied data table in a separate window in a grid/column view that's useful for script debugging, or presenting tabular data to the user.\n\n\n\n\n\nThe name of the table being viewed will be displayed on the pop-up window.\n\nThe columns and rows of the grid view may be re-ordered, sorted, and resized to simplify the viewing of the data table.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Table\n\nObject\n\nThe Data Table to be viewed in the window.\n\n\n\n\n\nExample:\n\n\n\n\n\n$MyTable = DataTable_Create(\"Employees\");\n\nDataTable_ShowInWindow($MyTable);\n\n\n\n\n\nSQL_Close\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SQL_Close": {
  "prefix": "SQL_Close",
  "body": [
   "SQL_Close($$sqlHandle);"
  ],
  "description": "\n\n\n\n\n\nThis function will close a connection to a SQL database that was opened with the SQL_Connect function.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$sqlHandle\n\nObject\n\nA handle to a SQL database connection.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n\n\nSQL_Close($sqlHandle);\n\n\n\n\n\nSQL_Connect\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SQL_Connect": {
  "prefix": "SQL_Connect",
  "body": [
   "$$sqlHandle=SQL_Connect($$server,$$database,$$userName,$$password);"
  ],
  "description": "\n\n\n\n\n\nThis function will open a connection to a SQL database and return a handle to the SQL connections.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$server\n\nString\n\nThe name or URL of the server on which the database resides.\n\n\n\n$database\n\nString\n\nThe name of the database to connect to on the server.\n\n\n\n$userName\n\nString\n\nThe user name to use for logging into the database on the server.\n\n\n\n$password\n\nString\n\nThe password for the user name being use to log in to the database.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$sqlHandle\n\nObject\n\nA handle to the SQL connection that can be used in subsequent SQL functions.\n\n\n\n\n\nExample:\n\n\n\n\n\n$server = \"theServer\";\n\n$database = \"SQLDataBase\";\n\n$userName = \"Noone\";\n\n$password = \"Nada\";\n\n$sqlHandle = SQL_Connect($server, $database, $userName, $password);\n\n\n\n\n\nSQL_Query\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SQL_Query": {
  "prefix": "SQL_Query",
  "body": [
   "($$dataTable,$$rows,$$columns)=SQL_Query($$sqlHandle,$$query);"
  ],
  "description": "\n\n\n\n\n\nThis function will send a query to a database previously opened with the SQL_Connect function and return a table of the data based on the query. It also returns the number of rows and number of columns in the table.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$sqlHandle\n\nObject\n\nA handle to a SQL database connection.\n\n\n\n$query\n\nString\n\nA SQL query string.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$dataTable\n\nTable\n\nA table of data returned from the database based on the query. Access the data using the Jabil Test Data Table functions.\n\n\n\n$rows\n\nInteger\n\nThe number of rows in the returned data table.\n\n\n\n$columns\n\nInteger\n\nThe number of columns in the returned data table.\n\n\n\n\n\nExample:\n\n\n\n\n\n// Set the Finalize function.\n\nSetFinalizeFunction(\"ScriptComplete\");\n\n\n\n\n\n// Connect to the server.\n\n$server = \"theServer\";\n\n$database = \"SQLDataBase\";\n\n$userName = \"Noone\";\n\n$password = \"Nada\";\n\n$sqlHandle = SQL_Connect($server, $database, $userName, $password);\n\n\n\n\n\n// Get the data from the table in the database.\n\n$query = \"SELECT "
 }
,
 "JTS MongoDB_Connect": {
  "prefix": "MongoDB_Connect",
  "body": [
   "$$databaseHandle=MongoDB_Connect($$connectionString,$$databaseName);"
  ],
  "description": "\n\nThis function will create a connection to the specified database on the specified server and return a handle to this database that can be used to connect to one or more collections within that database.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$connectionString\n\nString\n\nThe string used to connect to the server with the database on it. This can include the IP address or the name of the server, as well as the port number.\n\n\n\n$databaseName\n\nString\n\nThe name of the database to connect to.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$databaseHandle\n\nObject\n\nA link to the database handle that can be used to connect to any number of collections within the database.\n\n\n\n\n\nExample:\n\n\n\n\n\n// Link to a database on a server.\n\n$connectStr = \"mongodb://192.168.10.112:27017\";\n\n$dbName = \"myDataBase\";\n\n\n\n$dbHandle = MongoDB_Connect($connectStr, $dbName);\n\n\n\n\n\nMongoDB_DocumentExistsById\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS MongoDB_DocumentExistsById": {
  "prefix": "MongoDB_DocumentExistsById",
  "body": [
   "$$documentFound=MongoDB_DocumentExistsById($$collectionHandle,$$documentId);"
  ],
  "description": "\n\nThis function will return whether a document with the given Id exists in the collection that was opened using the MongoDB_UseCollection function.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$collectionHandle\n\nObject\n\nA handle to a collection in the database that was previously opened with the MongoDB_UseCollection function.\n\n\n\n$documentId\n\nString\n\nThe Id of a document within the collection.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$documentFound\n\nBoolean\n\nTrue if the document was found in the collection and False otherwise.\n\n\n\n\n\nExample:\n\n// Link to a database on a server.\n\n$connectStr = \"192.168.10.112:27017\";\n\n$dbName = \"myDataBase\";\n\n\n\n\n\n$dbHandle = MongoDB_Connect($connectStr, $dbName);\n\n\n\n\n\n// Link to a collection.\n\n$collectStr = \"myCollection\";\n\n\n\n\n\n$collectHandle = MongoDB_UseCollection($dbHandle, $collectStr);\n\n\n\n\n\n// Check for a document.\n\n$docFound = MongoDB_DocumentExistsById($collectHandle, $docId);\n\n\n\n\n\nMongoDB_DocumentExistsByName\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS MongoDB_DocumentExistsByName": {
  "prefix": "MongoDB_DocumentExistsByName",
  "body": [
   "$$documentFound=MongoDB_DocumentExistsByName($$collectionHandle,$$documentName);"
  ],
  "description": "\n\nThis function will return whether the named document exists in the collection that was opened using the MongoDB_UseCollection function.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$collectionHandle\n\nObject\n\nA handle to a collection in the database that was previously opened with the MongoDB_UseCollection function.\n\n\n\n$documentName\n\nString\n\nThe name of the document to look for in the collection.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$documentFound\n\nBoolean\n\nTrue if the document was found in the collection and False otherwise.\n\n\n\n\n\nExample:\n\n// Link to a database on a server.\n\n$connectStr = \"192.168.10.112:27017\";\n\n$dbName = \"myDataBase\";\n\n\n\n\n\n$dbHandle = MongoDB_Connect($connectStr, $dbName);\n\n\n\n\n\n// Link to a collection.\n\n$collectStr = \"myCollection\";\n\n\n\n\n\n$collectHandle = MongoDB_UseCollection($dbHandle, $collectStr);\n\n\n\n\n\n// Check for a document.\n\n$docName = \"myDocument\";\n\n$docFound = MongoDB_DocumentExistsByName($collectHandle, $docName);\n\n\n\n\n\nMongoDB_FindAllDocumentsByName\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS MongoDB_FindAllDocumentsByName": {
  "prefix": "MongoDB_FindAllDocumentsByName",
  "body": [
   "($$documentIds,$$documentDateTimes,$$documentTypes)=MongoDB_FindAllDocumentsByName($$collectionHandle,$$documentName);"
  ],
  "description": "\n\nThis function will retrieve the Ids, Date/Time last updated, and Types of all documents that match $documentName from the collection that was opened using the MongoDB_UseCollection function. The $documentIName is the name that was given to the documents in the MongoDB_UpdateDocument function when the documents were added to the collection.\n\n\n\n\n\nRemarks:\n\nThe data is returned in three parallel arrays. Parallel in that the same index is used for one document in each array. Example: element 0 in the Id array is for the same document as element 0 in the Date/Time last updated, and Type arrays.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$collectionHandle\n\nObject\n\nA handle to a collection in the database that was previously opened with the MongoDB_UseCollection function.\n\n\n\n$documentName\n\nString\n\nThe name of the documents in the collection of the database.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$documentIds\n\nString Array\n\nThe Ids of all of the documents found in the database that have the specified document name.\n\n\n\n$documentDateTimes\n\nString Array\n\nThe date and time that the documents were last updated. In the format: YYYY/MM/DD hh:mm:ss.\n\n\n\n$documentTypes\n\nString Array\n\nThe type of the data for each of the documents. This will be one of: Array, Boolean, Float, Integer, Object, String.\n\n\n\n\n\nExample:\n\n// Link to a database on a server.\n\n$connectStr = \"192.168.10.112:27017\";\n\n$dbName = \"myDataBase\";\n\n\n\n\n\n$dbHandle = MongoDB_Connect($connectStr, $dbName);\n\n\n\n\n\n// Link to a collection.\n\n$collectStr = \"myCollection\";\n\n\n\n\n\n$collectHandle = MongoDB_UseCollection($dbHandle, $collectStr);\n\n\n\n\n\n// Get information about documents by name.\n\n$docName = \"myDocument\";\n\n($docIds, $docDateTimes, $docTypes) = MongoDB_FindAllDocumentsByName($collectHandle, $docName);\n\n\n\n\n\nMongoDB_FindDocumentById\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS MongoDB_FindDocumentById": {
  "prefix": "MongoDB_FindDocumentById",
  "body": [
   "($$documentName,$$documentDateTime,$$documentType)=MongoDB_FindDocumentById($$collectionHandle,$$documentId);"
  ],
  "description": "\n\nThis function will return the Name, Date/Time last updated and Type of a document from the collection that was opened using the MongoDB_UseCollection function. The $documentId is unique for each document, so there is only one document that will match the $documentId.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$collectionHandle\n\nObject\n\nA handle to a collection in the database that was previously opened with the MongoDB_UseCollection function.\n\n\n\n$documentId\n\nString\n\nThe ID of the document in the collection of the database.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$documentName\n\nString\n\nThe name of the document from the database.\n\n\n\n$documentDateTime\n\nString\n\nThe date and time that the document was last updated. In the format: YYYY/MM/DD hh:mm:ss.\n\n\n\n$documentType\n\nString\n\nThe type of the data for the document. This will be one of: Array, Boolean, Float, Integer, Object, String.\n\n\n\n\n\nExample:\n\n// Link to a database on a server.\n\n$connectStr = \"192.168.10.112:27017\";\n\n$dbName = \"myDataBase\";\n\n\n\n\n\n$dbHandle = MongoDB_Connect($connectStr, $dbName);\n\n\n\n\n\n// Link to a collection.\n\n$collectStr = \"myCollection\";\n\n\n\n\n\n$collectHandle = MongoDB_UseCollection($dbHandle, $collectStr);\n\n\n\n\n\n// Get information about a document that we know the ID of.\n\n($docData, $docDateTime, $docType) = MongoDB_FindDocumentById($collectHandle, $documentId);\n\n\n\n\n\nMongoDB_GetDocumentById\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS MongoDB_GetDocumentById": {
  "prefix": "MongoDB_GetDocumentById",
  "body": [
   "($$documentData,$$documentDateTime,$$documentType)=MongoDB_GetDocumentById($$collectionHandle,$$documentId);"
  ],
  "description": "\n\nThis function will retrieve a document from the collection that was opened using the MongoDB_UseCollection function. The $documentId is the unique ID that was assigned to the document when it was added with the MongoDB_UpdateDocument function.\n\n\n\n\n\nRemarks:\n\nThe document ID can be found using the MongoDB_FindAllDocumentsByName function.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$collectionHandle\n\nObject\n\nA handle to a collection in the database that was previously opened with the MongoDB_UseCollection function.\n\n\n\n$documentId\n\nString\n\nThe ID of the document in the collection of the database.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$documentData\n\nObject\n\nThe document from the database. If the referenced document does not exist, this will be null.\n\n\n\n$documentDateTime\n\nString\n\nThe date and time that the document was last updated. In the format: YYYY/MM/DD hh:mm:ss.\n\n\n\n$documentType\n\nString\n\nThe type of the data for the document. This will be one of: Array, Boolean, Float, Integer, Object, String.\n\n\n\n\n\nExample:\n\n// Link to a database on a server.\n\n$connectStr = \"192.168.10.112:27017\";\n\n$dbName = \"myDataBase\";\n\n\n\n\n\n$dbHandle = MongoDB_Connect($connectStr, $dbName);\n\n\n\n\n\n// Link to a collection.\n\n$collectStr = \"myCollection\";\n\n\n\n\n\n$collectHandle = MongoDB_UseCollection($dbHandle, $collectStr);\n\n\n\n\n\n// Retrieve a document that we already know the ID of.\n\n($docData, $docDateTime, $docType) = MongoDB_GetDocumentById($collectHandle, $documentId);\n\n\n\n\n\nMongoDB_GetFirstDocumentByName\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS MongoDB_GetFirstDocumentByName": {
  "prefix": "MongoDB_GetFirstDocumentByName",
  "body": [
   "($$documentData,$$documentDateTime,$$documentType)=MongoDB_GetFirstDocumentByName($$collectionHandle,$$documentName);"
  ],
  "description": "\n\nThis function will retrieve the first document that matches $documentName from the collection that was opened using the MongoDB_UseCollection function. The $documentIName is the name that was given to the document in the MongoDB_UpdateDocument function when the document was added to the collection.\n\n\n\n\n\nRemarks:\n\nTo get all of the documents with a specified name, use the MongoDB_FindAllDocumentsByName function and then get the document for each ID using the MongoDB_GetDocumentById function.\n\nTo get a named document other than the first one, use the MongoDB_GetDocumentById function.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$collectionHandle\n\nObject\n\nA handle to a collection in the database that was previously opened with the MongoDB_UseCollection function.\n\n\n\n$documentName\n\nString\n\nThe name of the document in the collection of the database.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$documentData\n\nVaries\n\nThe document from the database. If the referenced document does not exist, this will be null. The type that is returned is based on the document data type that was set when the document was created.\n\n\n\n$documentDateTime\n\nString\n\nThe date and time that the document was last updated. In the format: YYYY/MM/DD hh:mm:ss.\n\n\n\n$documentType\n\nString\n\nThe type of the data for the document. This will be one of: Array, Boolean, Float, Integer, Object, String.\n\n\n\n\n\nExample:\n\n// Link to a database on a server.\n\n$connectStr = \"192.168.10.112:27017\";\n\n$dbName = \"myDataBase\";\n\n\n\n\n\n$dbHandle = MongoDB_Connect($connectStr, $dbName);\n\n\n\n\n\n// Link to a collection.\n\n$collectStr = \"myCollection\";\n\n\n\n\n\n$collectHandle = MongoDB_UseCollection($dbHandle, $collectStr);\n\n\n\n\n\n// Retrieve a document by name.\n\n$docName = \"myDocument\";\n\n($docData, $docDateTime, $docType) = MongoDB_GetFirstDocumentByName($collectHandle, $docName);\n\n\n\n\n\nMongoDB_RemoveDocumentById\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS MongoDB_RemoveDocumentById": {
  "prefix": "MongoDB_RemoveDocumentById",
  "body": [
   "MongoDB_RemoveDocumentById($$collectionHandle,$$documentId);"
  ],
  "description": "\n\nThis function will remove a document from the collection that was opened using the MongoDB_UseCollection function. The $documentId is the ID that was assigned to the document when the MongoDB_UpdateDocument function added the document to the collection.\n\n\n\n\n\nRemarks:\n\nThe document ID can be found using the MongoDB_FindAllDocumentsByName function.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$collectionHandle\n\nObject\n\nA handle to a collection in the database that was previously opened with the MongoDB_UseCollection function.\n\n\n\n$documentId\n\nString\n\nThe ID of the document in the collection of the database.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nnone\n\n\n\n\n\nExample:\n\n// Link to a database on a server.\n\n$connectStr = \"192.168.10.112:27017\";\n\n$dbName = \"myDataBase\";\n\n\n\n\n\n$dbHandle = MongoDB_Connect($connectStr, $dbName);\n\n\n\n\n\n// Link to a collection.\n\n$collectStr = \"myCollection\";\n\n\n\n\n\n$collectHandle = MongoDB_UseCollection($dbHandle, $collectStr);\n\n\n\n\n\n// Remove a document that we already know the ID of.\n\nMongoDB_RemoveDocumentById($collectHandle, $documentId);\n\n\n\n\n\nMongoDB_RemoveDocumentByName\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS MongoDB_RemoveDocumentByName": {
  "prefix": "MongoDB_RemoveDocumentByName",
  "body": [
   "MongoDB_RemoveDocumentByName($$collectionHandle,$$documentName);"
  ],
  "description": "\n\nThis function will remove all documents that match $documentName from the collection that was opened using the MongoDB_UseCollection function. The $documentName is the name that was given to the document in the MongoDB_UpdateDocument function when the document was added to the collection.\n\n\n\n\n\nRemarks:\n\nIf there are multiple documents that have the same name and you need to remove only one of them, you need to use the MongoDB_RemoveDocumentById function.\n\nThe document ID can be found using the MongoDB_FindAllDocumentsByName function.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$collectionHandle\n\nObject\n\nA handle to a collection in the database that was previously opened with the MongoDB_UseCollection function.\n\n\n\n$documentName\n\nString\n\nThe name of the document(s) in the collection.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nnone\n\n\n\n\n\nExample:\n\n// Link to a database on a server.\n\n$connectStr = \"192.168.10.112:27017\";\n\n$dbName = \"myDataBase\";\n\n\n\n\n\n$dbHandle = MongoDB_Connect($connectStr, $dbName);\n\n\n\n\n\n// Link to a collection.\n\n$collectStr = \"myCollection\";\n\n\n\n\n\n$collectHandle = MongoDB_UseCollection($dbHandle, $collectStr);\n\n\n\n\n\n// Remove a document.\n\n$docName = \"myDocument\";\n\nMongoDB_RemoveDocumentByName($collectHandle, $docName);\n\n\n\n\n\nMongoDB_UpdateDocumentById\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS MongoDB_UpdateDocumentById": {
  "prefix": "MongoDB_UpdateDocumentById",
  "body": [
   "MongoDB_UpdateDocumentById($$collectionHandle,$$documentId,$$dataType,$$documentData);"
  ],
  "description": "\n\nThis function will update all existing documents that match $documentId.\n\n\n\n\n\nRemarks:\n\nIf a document with this Id does not exist, an error will be generated.\n\nThere should be only one document with the Id. All Ids should be unique.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$collectionHandle\n\nObject\n\nA handle to a collection in the database that was previously opened with the MongoDB_UseCollection function.\n\n\n\n$documentId\n\nString\n\nThe Id of the document to update.\n\n\n\n$dataType\n\nString\n\nThe type of the data that is being stored. Valid entries are:\n\n\u00b7 Array\n\n\u00b7 Boolean\n\n\u00b7 Float\n\n\u00b7 Integer\n\n\u00b7 Object\n\n\u00b7 String\n\n\n\n$documentData\n\nVaries\n\nThe data to put into the collection in the database.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nnone\n\n\n\n\n\nExample:\n\n// Link to a database on a server.\n\n$connectStr = \"192.168.10.112:27017\";\n\n$dbName = \"myDataBase\";\n\n\n\n\n\n$dbHandle = MongoDB_Connect($connectStr, $dbName);\n\n\n\n\n\n// Link to a collection.\n\n$collectStr = \"myCollection\";\n\n\n\n\n\n$collectHandle = MongoDB_UseCollection($dbHandle, $collectStr);\n\n\n\n\n\n// Put a new document into the collection.\n\n$docType = GetVariableType($document);\n\n\n\n\n\nMongoDB_UpdateDocumentById($collectHandle, $docId, $docType, $document);\n\n\n\n\n\nMongoDB_UpdateDocumentByName\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS MongoDB_UpdateDocumentByName": {
  "prefix": "MongoDB_UpdateDocumentByName",
  "body": [
   "MongoDB_UpdateDocumentByName($$collectionHandle,$$documentName,$$dataType,$$documentData);"
  ],
  "description": "\n\nThis function will update all existing documents that match $documentName or insert one new document if it does not exist in the collection.\n\n\n\n\n\nRemarks:\n\nIf the database has multiple documents with the same name and you need to update one of them, use the MongoDB_UpdateDocumentById function.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$collectionHandle\n\nObject\n\nA handle to a collection in the database that was previously opened with the MongoDB_UseCollection function.\n\n\n\n$documentName\n\nString\n\nThe name of the document to update or insert.\n\n\n\n$dataType\n\nString\n\nThe type of the data that is being stored. Valid entries are:\n\n\u00b7 Array\n\n\u00b7 Boolean\n\n\u00b7 Float\n\n\u00b7 Integer\n\n\u00b7 Object\n\n\u00b7 String\n\n\n\n$documentData\n\nVaries\n\nThe data to put into the collection in the database.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nnone\n\n\n\n\n\nExample:\n\n// Link to a database on a server.\n\n$connectStr = \"192.168.10.112:27017\";\n\n$dbName = \"myDataBase\";\n\n\n\n\n\n$dbHandle = MongoDB_Connect($connectStr, $dbName);\n\n\n\n\n\n// Link to a collection.\n\n$collectStr = \"myCollection\";\n\n\n\n\n\n$collectHandle = MongoDB_UseCollection($dbHandle, $collectStr);\n\n\n\n\n\n// Put a new document into the collection.\n\n$docName = \"MyNewDocument\";\n\n$docType = GetVariableType($document);\n\n\n\n\n\nMongoDB_UpdateDocumentByName($collectHandle, $docName, $docType, $document);\n\n\n\n\n\nMongoDB_UseCollection\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS MongoDB_UseCollection": {
  "prefix": "MongoDB_UseCollection",
  "body": [
   "$$collectionHandle=MongoDB_UseCollection($$databaseHandle,$$collectionName);"
  ],
  "description": "\n\nThis function will create a connection to the specified collection within the database specified in the $databaseHandle that was opened using the MongoDB_Connect function.\n\nThis function can be used multiple times on the same database to open handles to multiple collections.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$databaseHandle\n\nObject\n\nThe handle to the database that was previously opened using the MongoDB_Connect function.\n\n\n\n$collectionName\n\nString\n\nThe name of the collection to connect to within the database.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$collectionHandle\n\nObject\n\nA link to the collection within the database that can be passed to the functions for retrieving or manipulating the data.\n\n\n\n\n\nExample:\n\n// Link to a database on a server.\n\n$connectStr = \"192.168.10.112:27017\";\n\n$dbName = \"myDataBase\";\n\n\n\n\n\n$dbHandle = MongoDB_Connect($connectStr, $dbName);\n\n\n\n\n\n// Link to a collection.\n\n$collectStr = \"myCollection\";\n\n\n\n\n\n$collectHandle = MongoDB_UseCollection($dbHandle, $collectStr);\n\n\n\n\n\nDateAddTime\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS DateAddTime": {
  "prefix": "DateAddTime",
  "body": [
   "$$newDate=DateAddTime($$oldDate,$$days,$$hours,$$minutes,$$seconds);"
  ],
  "description": "\n\nThis function will add the specified number of days, hours, minutes and seconds to the given date/time.\n\n\n\nRemarks:\n\nUses the DateTime class formatting for all date/time strings.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$oldDate\n\nString\n\nStarting date/time (must be a valid DateTime string).\n\n\n\n$days\n\nInteger\n\nThe number of days to add.\n\n\n\n$hours\n\nInteger\n\nThe number of hours to add.\n\n\n\n$minutes\n\nInteger\n\nThe number of minutes to add.\n\n\n\n$seconds\n\nInteger\n\nThe number of seconds to add.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$newDate\n\nString\n\nThe new date/time result from adding all parameters to the old date/time (returned in DateTime format).\n\n\n\n\n\nExample:\n\n\n\n\n\n// Set up the old date and the times to add.\n\n$oldDate = \"12/23/2009 10:39:18 AM\";\n\n$days = 2;\n\n$hours = 1;\n\n$minutes = 0;\n\n$seconds = 44;\n\n\n\n// Calculate and display the new date/time.\n\n$newDate = DateAddTime($oldDate, $days, $hours, $minutes, $seconds);\n\n\n\n$outString = \"New Date and Time = \" + $newDate;\n\nUpdateStatus($outString);\n\n\n\n\n\nDateParse\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS DateParse": {
  "prefix": "DateParse",
  "body": [
   "($$month,$$day,$$year,$$hour,$$minute,$$second,$$dayOfWeek)=DateParse($$dateTime);"
  ],
  "description": "\n\nThis function will parse the supplied DateTime and return the results in individual variables.\n\n\n\nRemarks:\n\nUses the DateTime class formatting for all date/time strings.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$dateTime\n\nString\n\nThe date/time (must be a valid DateTime string).\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$month\n\nInteger\n\nThe parsed month (1 = January, 12 = December).\n\n\n\n$day\n\nInteger\n\nThe parsed day of the month (1 - 31).\n\n\n\n$year\n\nInteger\n\nThe parsed year in 4-digit format.\n\n\n\n$hour\n\nInteger\n\nThe parsed hour (0 - 23).\n\n\n\n$minute\n\nInteger\n\nThe parsed minute (0 - 59).\n\n\n\n$second\n\nInteger\n\nThe parsed second (0 - 59).\n\n\n\n$dayOfWeek\n\nInteger\n\nThe parsed day of the week (1 = Sunday, 7 = Saturday).\n\n\n\n\n\nExample:\n\n\n\n\n\n// Set up a date and time to parse.\n\n$dateToParse = \"12/23/2009 10:39:18 AM\";\n\n\n\n// Parse and display the date/time components.\n\n($month, $day, $year, $hour, $minute, $second, $dayOfWeek) = DateParse($dateToParse);\n\n\n\n$outString = \"Date and Time:\\r\\n\\tMonth =\\t\\t\" + $month;\n\nUpdateStatus($outString);\n\n$outString = \"\\tDay =\\t\\t\" + $day;\n\nUpdateStatus($outString);\n\n$outString = \"\\tYear =\\t\\t\" + $year;\n\nUpdateStatus($outString);\n\n$outString = \"\\tHour =\\t\\t\" + $hour;\n\nUpdateStatus($outString);\n\n$outString = \"\\tMinute =\\t\\t\" + $minute;\n\nUpdateStatus($outString);\n\n$outString = \"\\tSecond =\\t\\t\" + $second;\n\nUpdateStatus($outString);\n\n$outString = \"\\tDay of Week =\\t\" + $dayOfWeek;\n\nUpdateStatus($outString);\n\n\n\n\n\nDateParseISO\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS DateParseISO": {
  "prefix": "DateParseISO",
  "body": [
   "($$month,$$day,$$year,$$hour,$$minute,$$second,$$dayOfWeek,$$weekOfYear)=DateParseISO($$dateTime,$$FirstDayOfWeek,$$WeekOfYearMethod);"
  ],
  "description": "\n\nUses DateTime class formatting for all date/time strings.\n\nParses out the supplied DateTime string and returns the results in individual variables.\n\nThe parameters for specifying the first day of the week, and the Week of Year Method are used to determine the value returned for the $weekOfYear variable. These two parameters are used to determine week 1 of the year.\n\n\n\n\n\nNote: The day of week is returned in ISO 8601 format (1 = Monday, 7 = Sunday) regardless of the argument pass in for the $FirstDayOfWeek Function arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$dateTime\n\nString\n\nDate/time (must be valid DateTime string).\n\n\n\n$FirstDayOfWeek\n\nString\n\nSpecifies the first day of the week to be used in the calulcation for the week of the year. Allowable values include:\n\n\u00b7 \"MONDAY\"\n\n\u00b7 \"TUESDAY\"\n\n\u00b7 \"WEDNESDAY\"\n\n\u00b7 \"THURSDAY\"\n\n\u00b7 \"FRIDAY\"\n\n\u00b7 \"SATURDAY\"\n\n\u00b7 \"SUNDAY\"\n\n\n\n$WeekOfYearMethod\n\nString\n\nSpecifies the method for determining the first week of the year. Allowable values include:\n\n\u00b7 \"FIRSTDAY\"\n\n\u00b7 \"FIRSTFOURDAYWEEK\"\n\n\u00b7 \"FIRSTFULLWEEK\"\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$month\n\nInteger\n\nMonth (January = 1, December = 12)\n\n\n\n$day\n\nInteger\n\nDay of month (1 - 31)\n\n\n\n$year\n\nInteger\n\nYear in 4-digit format\n\n\n\n$hour\n\nInteger\n\nHour of day (0 - 23)\n\n\n\n$minute\n\nInteger\n\nMinute of hour ( 0 - 59)\n\n\n\n$second\n\nInteger\n\nSecond of minute (0 - 59)\n\n\n\n$dayOfWeek\n\nInteger\n\nDay of the week (Monday = 1, Sunday = 7)\n\n\n\n$WeekOfYear\n\nInteger\n\nThe week of the year. Note that the value of this parameter is determined by the function arguments passed in for the $FirstDayOfWeek and\n\n\n\n\n\nExample:\n\n\n\n\n\n($month,$day,$year,$hour,$minute,$second,$DayOfWeek,$WeekOfYear)= DateParseISO(\"11/11/2010 2:35:01 pm\",\"SUNDAY\",\"FIRSTFOURDAYWEEK\");\n\nUpdateStatus($month);\n\nUpdateStatus($day);\n\nUpdateStatus($year);\n\nUpdateStatus($minute);\n\nUpdateStatus($second);\n\nUpdateStatus($DayOfWeek);\n\nUpdateStatus($WeekOfYear);\n\n\n\n\n\nGetSystemTicks\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS GetSystemTicks": {
  "prefix": "GetSystemTicks",
  "body": [
   "$$Ticks=GetSystemTicks();"
  ],
  "description": "\n\nReturns the number of System Ticks that have occured since since 12:00:00 midnight, January 1, 0001. A system tick is 100 nanoseconds.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Ticks\n\nInteger\n\nThe number of system ticks.\n\n\n\n\n\nGetSystemTime\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS GetSystemTime": {
  "prefix": "GetSystemTime",
  "body": [
   "$$currentTime=GetSystemTime();"
  ],
  "description": "\n\nUses DateTime class formatting for all date/time strings.\n\nReturns the current local system time.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n-\n\n-\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$currentTime\n\nString\n\nCurrent local system time (returned in DateTime format).\n\n\n\n\n\nExample:\n\n\n\n\n\n$currentTime = GetSystemTime();\n\nUpdateStatus($currentTime);\n\n\n\n\n\nOutput:\n\n12/23/2009 10:39:18 AM\n\n\n\n\n\nGetSystemTimeWithFormat\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS GetSystemTimeWithFormat": {
  "prefix": "GetSystemTimeWithFormat",
  "body": [
   "$$timeString=GetSystemTimeWithFormat($$formatString);"
  ],
  "description": "\n\nThis function returns the current system time in a the specified format.\n\n\n\nRemarks:\n\nThe format string consists of the following parts:\n\n\n\nCharacter Return Description\n\ny Year Display the characters for the year. yy = 16, yyyy = 2016\n\nM Month Display the characters for the month. M = 8, MM = 08, MMM = Aug, MMMM = August\n\nd Day Display the characters for the day. d = 1, dd = 01, ddd = Fri, dddd = Friday\n\nh Hour (12 hour) Display the characters for the hour in a 12 hour format. h = 6, hh = 06\n\nH Hour (24 hour) Display the characters for the hour in a 24 hour format. H = HH = 16\n\nm Minutes Display the characters for the minutes. m = 5, mm = 05\n\ns Seconds Display the characters for the seconds. s = 9, ss = 09\n\nf Second Fraction Display the characters for the fraction of a second. f = 6, ff = 61, fff = 610, etc.\n\nF Second Fraction Display the characters for the fraction of a second - no trailing zeros. F = 6, FF = 61, FFF = 61, etc.\n\nt AM/PM Display the characters for AM / PM. t = P, tt = PM\n\nz Time Zone Display the characters for the Time Zone. z = -4, zz = -04, zzz = -04:00\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$formatString\n\nString\n\nThe format to return the time in the string. See the table above for the format.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$timeString\n\nString\n\nThe current system time in the requested format.\n\n\n\n\n\nExample:\n\n\n\n\n\n// Return the system time in the example format of \"06/30/2016 4:07:21.1234 PM\".\n\n$format = \"MM/dd/yyyy h:mm:ss.ffff tt\";\n\n\n\n$time = GetSystemTimeWithFormat($format);\n\n\n\n// Print out the time.\n\n$outString = \"The current time is: \" + $time;\n\nUpdateStatus($outString);\n\n\n\n\n\nGetTimeSpan\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS GetTimeSpan": {
  "prefix": "GetTimeSpan",
  "body": [
   "($$Days,$$Hours,$$Minutes,$$Seconds,$$Milliseconds)=GetTimeSpan($$Date1,Date2);"
  ],
  "description": "\n\nThis function returns the difference in Days, Hours, Minutes, Seconds, and Milliseconds between two dates. Each measurement is the total number. Date Strings can be retrieved using the GetUTCTime function.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Date1\n\nString\n\nA date string in a parseable format.\n\n\n\n$Date2\n\nString\n\nA date string in a parseable format.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Days\n\nFloat\n\nThe number of days returned as a floating point number\n\n\n\n$Hours\n\nFloat\n\nThe number of hours returned as a floating point number\n\n\n\n$Minutes\n\nFloat\n\nThe number of minutes returned as a floating point number.\n\n\n\n$Seconds\n\nFloat\n\nThe number of seconds returned as a floating point number.\n\n\n\n$Milliseconds\n\nFloat\n\nThe number of milliseconds returned as a floating point number.\n\n\n\n\n\nGetTimeZone\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS GetTimeZone": {
  "prefix": "GetTimeZone",
  "body": [
   "($$TimeZoneName,$$TimeZoneOffSet,$$IsDaylightSavings)=GetTimeZone();"
  ],
  "description": "\n\nThis function returns the Computer's current time zone to the scripting language.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$TimeZoneName\n\nString\n\nThe international name of the current time zone returned as a string.\n\n\n\n$TimeZoneOffSet\n\nInteger\n\nThe time offset from UTC returned as a integer.\n\n\n\n$IsDaylightSavings\n\nBoolean\n\nA boolean value that contains whether or not the current time zone is in a Daylight savings period.\n\n\n\n\n\nGetUTCTime\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS GetUTCTime": {
  "prefix": "GetUTCTime",
  "body": [
   "$$UTCTime=GetUTCTime();"
  ],
  "description": "\n\nReturns the current system time to a text string.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$UTCTime\n\nString\n\nReturns the Current Time in a string.\n\n\n\n\n\nGetWeekOfYear\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS GetWeekOfYear": {
  "prefix": "GetWeekOfYear",
  "body": [
   "($$Week,$$Year)=GetWeekOfYear();"
  ],
  "description": "\n\nReturns the week of the year and the year.\n\nNote: that this function calculates the week of the year based on the first day of the year. For alternative methods for calculating the week of the year, see the 'DateParseISO' function.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Week\n\nInteger\n\nThe week of the year.\n\n\n\n$Year\n\nInteger\n\nThe year\n\n\n\n\n\nStopwatchControl\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS StopwatchControl": {
  "prefix": "StopwatchControl",
  "body": [
   "StopwatchControl($$swHandle,$$functionType);"
  ],
  "description": "\n\nControls the timer functionality of a stopwatch created with the StopwatchCreate() function.\n\n\n\nFunction Arguments\n\n\n\n\n\nParameter\n\n\n\nVariable Type\n\nDescription\n\n\n\n$swHandle\n\nObject\n\nHandle to stopwatch created with the StopwatchCreate() function.\n\n\n\n$functionType\n\nString\n\nType of function to perform on the stopwatch:\n\n\n\n\n\n\u00b7 \"START\" - starts the timer.\n\n\u00b7 \"STOP\" - stops the timer. All time values remain constant until the stopwatch is restarted or reset.\n\n\u00b7 \"RESET\" - stops the timer and resets the elapsed time.\n\n\n\n\n\nReturn Parameters\n\n\n\n\n\nParameter\n\n\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n--\n\n\n\n\n\nExample:\n\nStopwatchControl($timer, \"START\"); //start timer\n\nSleepMilliseconds(9000); //wait\n\nStopwatchControl($timer, \"STOP\"); //stop timer\n\n\n\n\n\nStopwatchControl($timer, \"RESET\"); //reset timer - stops timer and sets all values to 0\n\n\n\n\n\nStopwatchCreate\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS StopwatchCreate": {
  "prefix": "StopwatchCreate",
  "body": [
   "$$swHandle=StopwatchCreate();"
  ],
  "description": "\n\nCreates an instance of a stopwatch timer. The stopwatch can be used to track elapsed time to millisecond precision.\n\n\n\nFunction Arguments\n\n\n\n\n\nParameter\n\n\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n--\n\n\n\n\n\nReturn Parameters\n\n\n\n\n\nParameter\n\n\n\nVariable Type\n\nDescription\n\n\n\n$swHandle\n\nObject\n\nHandle to stopwatch created used by other functions.\n\n\n\n\n\nExample:\n\n$timer = StopwatchCreate();\n\n\n\n\n\nStopwatchQuery\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS StopwatchQuery": {
  "prefix": "StopwatchQuery",
  "body": [
   "$$returnTime=StopwatchQuery($$swHandle,$$returnType);"
  ],
  "description": "\n\nQueries a stopwatch, returning the total time elapsed between a START and STOP command in the requested format. If no STOP has been issues, the total time elapsed between a START command and this function call is returned.\n\n\n\nFunction Arguments\n\n\n\n\n\nParameter\n\n\n\nVariable Type\n\nDescription\n\n\n\n$swHandle\n\nObject\n\nHandle to stopwatch created with the StopwatchCreate() function.\n\n\n\n$returnType\n\nString\n\nFormat of the elapsed time to return:\n\n\n\n\n\n\u00b7 \"SECONDS\" - returns the total time elapsed in fractional seconds.\n\n\u00b7 \"MILLISECONDS\" - returns the total time elapsed in whole milliseconds.\n\n\u00b7 \"TICKS\" - returns the amount of ticks elapsed. These ticks are based off of the processor frequency and are NOT the same as the DateTime function ticks (which are exactly 100ns).\n\n\n\n\n\nReturn Parameters\n\n\n\n\n\nParameter\n\n\n\nVariable Type\n\nDescription\n\n\n\n$returnTime\n\nFloat\n\nTotal elapsed time in the format specified by the $returnType argument.\n\n\n\n\n\nExample:\n\n$timeSec = StopwatchQuery($timer, \"SECONDS\"); //get elapsed time in seconds\n\n$timeMS = StopwatchQuery($timer, \"MILLISECONDS\"); //get elapsed time in milliseconds\n\n\n\n\n\nUpdateStatus(\"\\nSTOPWATCH:\");\n\nUpdateStatus($timeSec);\n\nUpdateStatus($timeMS);\n\n\n\n\n\nSystemTime\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SystemTime": {
  "prefix": "SystemTime",
  "body": [
   "($$month,$$day,$$year,$$hour,$$min,$$sec,$$dayOfWeek)=SystemTime();"
  ],
  "description": "\n\nReturns the current system time to an array of script variables.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$month\n\nInteger\n\nThe current month of the year (January = 1, December = 12)\n\n\n\n$day\n\nInteger\n\nThe current day of the month (1-31)\n\n\n\n$year\n\nInteger\n\nThe current year in 4-digit format.\n\n\n\n$hour\n\nInteger\n\nThe current hour (0-23)\n\n\n\n$min\n\nInteger\n\nThe current minute (0-59)\n\n\n\n$sec\n\nInteger\n\nThe current second (0-59)\n\n\n\n$dayOfWeek\n\nInteger\n\nThe current day of the week (Sunday = 1, Saturday = 7)\n\n\n\n\n\nDictionary_CheckKeyExists\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Dictionary_CheckKeyExists": {
  "prefix": "Dictionary_CheckKeyExists",
  "body": [
   "$$KeyExists=Dictionary_CheckKeyExists($$Dictionary,$$Key);"
  ],
  "description": "\n\n\n\nThis function checks the dictionary to see if a given key is present. If the key is present in the dictionary, the function returns TRUE. If the key isn't found in the dictionary, this function returns false.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Dictionary\n\nObject\n\nThe dictionary object created using the Dictionary_Create function\n\n\n\n$Key\n\nVarious\n\nThe key of the value to retrieve from the dictionary. The key can be any type of object and simply points to the given value inside of the dictionary.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$KeyExists\n\nBoolean\n\nThis value will be set to 'True' or 'False' depending on if the key is present in the given dictionary.\n\n\n\n\n\nUsage Example:\n\n$Result1 = Dictionary_CheckKeyExists($Dictionary,1);\n\n\n\n\n\nDictionary_Create\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Dictionary_Create": {
  "prefix": "Dictionary_Create",
  "body": [
   "$$Dictionary=Dictionary_Create();"
  ],
  "description": "\n\n\n\nThis function creates a new dictionary which can be used to store and retrieve key/value pairs from the Jabil Test scripting language. The key can be any object type (integer, string, float, object) and the values stored can also be any type of object. This dictionary is thread-safe and can be shared safely between multiple test cells.\n\n\n\n\n\nThe $Dictionary object returns is internally implemented as a .Net Generic<object,object> generic collection.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Dictionary\n\nObject\n\nThis function returns the newly created, empty dictionary.\n\n\n\n\n\nUsage Example:\n\n$Dictionary = Dictionary_Create();\n\nDictionary_SetValue($Dictionary,1,5);\n\nDictionary_SetValue($Dictionary,2,10);\n\nDictionary_SetValue($Dictionary,\"MyKey\",\"Here is a value\");\n\nDictionary_SetValue($Dictionary,\"MyOtherKey\",190);\n\n\n\n\n\nDictionary_GetValue\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Dictionary_GetValue": {
  "prefix": "Dictionary_GetValue",
  "body": [
   "$$MyValue=Dictionary_GetValue($$Dictionary,$$Key);"
  ],
  "description": "\n\n\n\nThis function returns the value pointed to by the $Key argument supplied to the function. If the given key isn't present in the dictionary, the function returns a failure.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Dictionary\n\nObject\n\nThe dictionary object created using the Dictionary_Create function.\n\n\n\n$Key\n\nVarious\n\nThe key pointing to a given value inside of the dictionary.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Value\n\nVarious\n\nThe value pointed to by the given key in the dictionary.\n\n\n\n\n\nUsage Example:\n\n$Value1 = Dictionary_GetValue($Dictionary,1);\n\n$Value2 = Dictionary_GetValue($Dictionary,2);\n\n$Value1 = Dictionary_GetValue($Dictionary,\"MyKey1\");\n\n$Value2 = Dictionary_GetValue($Dictionary,\"MyKey2\");\n\n\n\n\n\nDictionary_RemoveValue\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Dictionary_RemoveValue": {
  "prefix": "Dictionary_RemoveValue",
  "body": [
   "Dictionary_RemoveValue($$Dictionary,$$Key);"
  ],
  "description": "\n\n\n\nThis function deletes the key/value entry pointed to by the $Key argument supplied to the function. If the given key isn't present in the dictionary, the function returns a failure.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Dictionary\n\nObject\n\nThe dictionary object created using the Dictionary_Create function.\n\n\n\n$Key\n\nVarious\n\nThe key pointing to a given value inside of the dictionary.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n--\n\n\n\n\n\nUsage Example:\n\n$Dictionary = Dictionary_Create();\n\nDictionary_SetValue($Dictionary,\"TESTKEY\",\"TESTVALUE\");\n\n\n\n\n\n$KeyExists = Dictionary_CheckKeyExists($Dictionary,\"TESTKEY\");\n\nif($KeyExists)\n\n{\n\n$MyValue = Dictionary_GetValue($Dictionary,\"TESTKEY\");\n\nUpdateStatus($MyValue);\n\n}\n\n\n\n\n\nDictionary_RemoveValue($Dictionary,\"TESTKEY\");\n\n$KeyExists = Dictionary_CheckKeyExists($Dictionary,\"TESTKEY\");\n\nif(!$KeyExists)\n\n{\n\nUpdateStatus(\"Key not found!\");\n\n}\n\n\n\n\n\nDictionary_SetValue\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Dictionary_SetValue": {
  "prefix": "Dictionary_SetValue",
  "body": [
   "Dictionary_SetValue($$Dictionary,$$Key,$$Value);"
  ],
  "description": "\n\n\n\nThis function sets the given $Key in the dictionary to the value supplied to the function. If the key is already present in the dictionary, the value is replaced by the new value. If the given key is not already present in the dictionary, it is added automatically.\n\n\n\n\n\nThe $Key and $Value arguments can be any object type.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Dictionary\n\nObject\n\nThe dictionary object created using the Dictionary_Create function.\n\n\n\n$Key\n\nVarious\n\nThe key pointing to a given value inside of the dictionary.\n\n\n\n$Value\n\nVarious\n\nThe value pointed that will be pointed to by the given key.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nUsage Example:\n\nSetTestName(\"Dictionary Function Test\");\n\n$Dictionary = Dictionary_Create();\n\nDictionary_SetValue($Dictionary,1,5);\n\nDictionary_SetValue($Dictionary,2,10);\n\n\n\n// Make Sure the Keys Were Stored\n\n$Result1 = Dictionary_CheckKeyExists($Dictionary,1);\n\n$Result2 = Dictionary_CheckKeyExists($Dictionary,2);\n\nif ($Result1 == false || $Result2 == false)\n\n{\n\nFail(\"Dictionary Keys Were Not Stored Successfully.\");\n\n}\n\n// Test Retreiving the Keys\n\n$Value1 = Dictionary_GetValue($Dictionary,1);\n\n$Value2 = Dictionary_GetValue($Dictionary,2);\n\n$Value3 = $Value1 + $Value2;\n\nif ($Value3 != 15)\n\n{\n\nFail(\"Dictionary Keys Were Not Successfully Retrieved.\");\n\n}\n\n// OK, Now Let's Work with Strings\n\nDictionary_SetValue($Dictionary,\"MyKey1\",\"This is a good \");\n\nDictionary_SetValue($Dictionary,\"MyKey2\",\"Test\");\n\n$Value1 = Dictionary_GetValue($Dictionary,\"MyKey1\");\n\n$Value2 = Dictionary_GetValue($Dictionary,\"MyKey2\");\n\n$Value3 = StringCat($Value1,$Value2);\n\nif ($Value3 != \"This is a good Test\")\n\n{\n\nFail(\"Dictionary Keys (using Strings) Were Not Successfully Retreived.\");\n\n}\n\nRecordMeasurement(\"Dictionary Function Validation\",\"PASSED\",\"PASS/FAIL\",\"FALSE\");\n\nreturn;\n\n\n\n\n\nDAS_EnableAbortButton\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS DAS_EnableAbortButton": {
  "prefix": "DAS_EnableAbortButton",
  "body": [
   "DAS_EnableAbortButton($$Enabled);"
  ],
  "description": "\n\n\n\n\n\nThis function disables or enables the abort button on the DAS user interface. The abort button is available for use whenever the DAS script is waiting for user interaction via the DAS_PromptForUserNavigation or DAS_PromptForUserInput functions.\n\n\n\n\n\nImportant Notes:\n\n\u00b7 In order to use this function the DAS panel visibility must be set to 'TRUE'. See the DAS_SetDASPanelVisibility function for more details.\n\n\u00b7 When a user clicks on the Abort button - the running test script is Aborted. Normal running of the script is stopped and the finalize function is run if it has been enabled with the SetFinalizeFunction script function. After that the script will end and the status of the test cell will be set to Abort.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Enabled\n\nBoolean\n\nA boolean value indicating whether or not the Abort Button Should be active on the DAS window.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nUsage Example:\n\n\n\n\n\nDAS_EnableAbortButton(true);\n\n\n\n\n\nDAS_EnableFailButton\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS DAS_EnableFailButton": {
  "prefix": "DAS_EnableFailButton",
  "body": [
   "DAS_EnableFailButton($$Enabled);"
  ],
  "description": "\n\n\n\n\n\nThis function disables or enables the fail button on the DAS user interface. The fail button is available for use whenever the DAS script is waiting for user interaction via the DAS_PromptForUserNavigation or DAS_PromptForUserInput functions.\n\n\n\n\n\nImportant Notes:\n\n\u00b7 In order to use this function the DAS panel visibility must be set to 'TRUE'. See the DAS_SetDASPanelVisibility function for more details.\n\n\u00b7 When a user clicks on the Fail button - the running test script is Stopped. Normal running of the script is stopped and the fail function is run if it has been enabled with the SetFailFunction script function (followed by the finalize function if that has been enabled with the SetFinalizeFunction script function). After that the script will end and the status of the test cell will be set to Fail.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Enabled\n\nBoolean\n\nA boolean value indicating whether or not the Fail Button Should be active on the DAS window.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nUsage Example:\n\n\n\n\n\nDAS_EnableFailButton(true);\n\n\n\n\n\nDAS_EnablePreviousButton\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS DAS_EnablePreviousButton": {
  "prefix": "DAS_EnablePreviousButton",
  "body": [
   "DAS_EnablePreviousButton($$Enabled);"
  ],
  "description": "\n\n\n\n\n\nThis function disables or enables the previous button on the DAS user interface. The previous button is available for use whenever the DAS script is waiting for user interaction via the DAS_PromptForUserNavigation or DAS_PromptForUserInput functions.\n\n\n\n\n\nImportant Note: In order to use this function the DAS panel visibility must be set to 'TRUE'. See the DAS_SetDASPanelVisibility function for more details.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Enabled\n\nBoolean\n\nA boolean value indicating whether or not the Previous Button Should be active on the DAS window.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nUsage Example:\n\n\n\n\n\nDAS_EnablePreviousButton(true);\n\n\n\n\n\nDAS_PromptForUserInput\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS DAS_PromptForUserInput": {
  "prefix": "DAS_PromptForUserInput",
  "body": [
   "($$NavigationType,$$UserInput)=DAS_PromptForUserInput($$NextLocation,$$PreviousLocation);"
  ],
  "description": "\n\n\n\n\n\nThis function blocks further script execution until the user enters a value into the user input window, and clicks a navigation button on the DAS form (either NEXT or PREVIOUS).\n\n\n\n\n\nThe $NextLocation argument provides a string label location where the test script execution will proceed in the event that the user clicks the 'Next Button'. If the argument is left blank, the script execution continues at the next line of the test script immediately following the DAS_PromptForUserNavigation command.\n\n\n\n\n\nThe $PreviousLocation argument provides a string label location where the test script execution will proceed in the event that the user clicks the 'Previous Button'. If the argument is left blank, the script execution continues at the next line of the test script immediately following the DAS_PromptForUserNavigation command.\n\n\n\n\n\nThe user supplied input is returned to the test script as a return value of the function.\n\n\n\n\n\nImportant Note: In order to use this function the DAS panel visibility must be set to 'TRUE'. See the DAS_SetDASPanelVisibility function for more details.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NextLocation\n\nString\n\nA string value containing the label name in the script where to continue execution in the event that the user clicks the 'Next Location' button. If the argument is left blank, the script continues execution at the next line of script code.\n\n\n\n$PreviousLocation\n\nString\n\nA string value containing the label name in the script where to continue execution in the event that the user clicks the 'Previous Location' button. If the argument is left blank, the script continues execution at the next line of script code.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NavigationType\n\nString\n\nReturns the navigation event selected by the user. Possible values are:\n\n\u00b7 \"Next\"\n\n\u00b7 \"Previous\"\n\n\n\n$UserInput\n\nString\n\nA string containing the value entered by the user. This value can then be tested for against a valid range, or recorded using the RecordMeasurementXXX functions.\n\n\n\n\n\nUsage Example:\n\n\n\n\n\n// Set up the document to show the user and give instructions.\n\nBrowserSetDocument(\"c:\\\\perf 1.pdf\");\n\nDAS_SetDASPanelVisibility(true);\n\nDAS_SetInstructionsFontSize(25);\n\nDAS_SetInstructions(\"Please Enter A Measurement Value\");\n\n\n\n\n\n// Now wait for the input from the user.\n\n($NavType, $UserInput) = DAS_PromptForUserInput(\"\", \"\");\n\n\n\n\n\nDAS_PromptForUserNavigation\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS DAS_PromptForUserNavigation": {
  "prefix": "DAS_PromptForUserNavigation",
  "body": [
   "$$NavigationType=DAS_PromptForUserNavigation($$NextLocation,$$PreviousLocation);"
  ],
  "description": "\n\n\n\n\n\nThis function blocks further script execution until the user clicks a navigation button on the DAS form (either NEXT or PREVIOUS).\n\n\n\n\n\nThe $NextLocation argument provides a string label location where the test script execution will proceed in the event that the user clicks the 'Next Button'. If the argument is left blank, the script execution continues at the next line of the test script immediately following the DAS_PromptForUserNavigation command.\n\n\n\n\n\nThe $PreviousLocation argument provides a string label location where the test script execution will proceed in the event that the user clicks the 'Previous Button'. If the argument is left blank, the script execution continues at the next line of the test script immediately following the DAS_PromptForUserNavigation command.\n\n\n\n\n\nImportant Note: In order to use this function the DAS panel visibility must be set to 'TRUE'. See the DAS_SetDASPanelVisibility function for more details.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NextLocation\n\nString\n\nA string value containing the label name in the script where to continue execution in the event that the user clicks the 'Next Location' button. If the argument is left blank, the script continues execution at the next line of script code.\n\n\n\n$PreviousLocation\n\nString\n\nA string value containing the label name in the script where to continue execution in the event that the user clicks the 'Previous Location' button. If the argument is left blank, the script continues execution at the next line of script code.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NavigationType\n\nString\n\nReturns the navigation event selected by the user. Possible values are:\n\n\u00b7 \"Next\"\n\n\u00b7 \"Previous\"\n\n\n\n\n\nUsage Example:\n\n\n\n\n\nAutomatic Navigation Example\n\n\n\n\n\nUpdateStatus(\"Start Example Script\");\n\n\n\n\n\nLabel ZeroStep:\n\nSetTestName(\"Step 0\");\n\nDAS_SetDASPanelVisibility(true); //Make the DAS Panel visible\n\nDAS_SetInstructions(\"Step 0\");\n\nDAS_EnablePreviousButton(false);\n\nBrowserSetDocument(\"c:\\\\dasstuff\\\\das0.jpg\"); //Put picture in panel\n\nSetCellViewMode(\"BROWSER\"); //View the Browser tab\n\nDAS_PromptForUserNavigation(\"\", \"\");\n\n\n\n\n\nLabel FirstStep:\n\nSetTestName(\"Step 1\");\n\nDAS_SetInstructions(\"Step 1\");\n\nDAS_EnablePreviousButton(true);\n\nBrowserSetDocument(\"c:\\\\dasstuff\\\\das1.jpg\");\n\nDAS_PromptForUserNavigation(\"\", \"ZeroStep\");\n\n\n\n\n\nLabel SecondStep:\n\nSetTestName(\"Step 2\");\n\nDAS_SetInstructions(\"Step 2\");\n\nDAS_EnablePreviousButton(true);\n\nBrowserSetDocument(\"c:\\\\dasstuff\\\\das2.jpg\");\n\nDAS_PromptForUserNavigation(\"\", \"FirstStep\");\n\n\n\n\n\nLabel ThirdStep:\n\nSetTestName(\"Step 3\");\n\nDAS_SetInstructions(\"Step 3\");\n\nDAS_EnablePreviousButton(true);\n\nBrowserSetDocument(\"c:\\\\dasstuff\\\\das3.jpg\");\n\nDAS_PromptForUserNavigation(\"\", \"SecondStep\");\n\n\n\n\n\nLabel FourthStep:\n\nSetTestName(\"Step 4\");\n\nDAS_SetInstructions(\"Step 4\");\n\nDAS_EnablePreviousButton(true);\n\nBrowserSetDocument(\"c:\\\\dasstuff\\\\das4.jpg\");\n\nDAS_PromptForUserNavigation(\"\", \"ThirdStep\");\n\n\n\n\n\nLabel FifthStep:\n\nSetTestName(\"Step 5\");\n\nDAS_SetInstructions(\"Step 5\");\n\nDAS_EnablePreviousButton(true);\n\nBrowserSetDocument(\"c:\\\\dasstuff\\\\das5.jpg\");\n\nDAS_PromptForUserNavigation(\"\", \"FourthStep\");\n\n\n\n\n\nDAS_SetDASPanelVisibility(false); //Hide the DAS Panel\n\nEnd;\n\n\n\n\n\nManual Navigation Example\n\n\n\n\n\n$NavType = DAS_PromptForUserNavigation(\"\", \"\");\n\nIf ($NavType == \"Previous\")\n\n{\n\ngoto LastStepLocation;\n\n}\n\n\n\n\n\nDAS_SetDASPanelVisibility\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS DAS_SetDASPanelVisibility": {
  "prefix": "DAS_SetDASPanelVisibility",
  "body": [
   "DAS_SetDASPanelVisibility($$IsVisibile);"
  ],
  "description": "\n\n\n\n\n\nThis function sets the visibility of the DAS panel. In order to use the other DAS specific functions, the DAS panel must be visible.\n\n\n\n\n\nNote: You must be on the Browser View tab of the test cell to see the DAS panel. You can use the Browser View functions to change the document displayed under the panel.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$IsVisible\n\nBoolean\n\nThe property that specifies whether or not the DAS prompt panel is visible inside of the Browser View window on the main Jabil Test cell Panel.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nUsage Example:\n\nDAS_SetDASPanelVisibility(true);\n\n\n\n\n\nDAS_SetInstructions\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS DAS_SetInstructions": {
  "prefix": "DAS_SetInstructions",
  "body": [
   "DAS_SetInstructions($$Instructions);"
  ],
  "description": "\n\n\n\n\n\nThis function sets the text in the instruction window displayed on the DAS form to the value contained by the $Instructions argument.\n\n\n\n\n\nImportant Note: In order to use this function the DAS panel visibility must be set to 'TRUE'. See the DAS_SetDASPanelVisibility function for more details.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Instructions\n\nString\n\nThe instructions to be displayed to the user along with the selected visual aid value.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nUsage Example:\n\n\n\n\n\nDAS_SetInstructions(\"Step 1: Configure Switches, Record DMM Current Measurement\");\n\n\n\n\n\nDAS_SetInstructionsFontSize\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS DAS_SetInstructionsFontSize": {
  "prefix": "DAS_SetInstructionsFontSize",
  "body": [
   "DAS_SetInstructionsFontSize($$FontSize);"
  ],
  "description": "\n\n\n\n\n\nThis function sets the text font size in the instruction window displayed on the DAS form to the value contained by the $FontSize argument.\n\n\n\n\n\nImportant Note: In order to use this function the DAS panel visibility must be set to 'TRUE'. See the DAS_SetDASPanelVisibility function for more details.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$FontSize\n\nInteger\n\nThe font size specified in points for the instruction text displayed to the test operator.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nUsage Example:\n\nDAS_SetInstructionsFontSize(25);\n\n\n\n\n\nDAS_SetInstructionWindowHeight\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS DAS_SetInstructionWindowHeight": {
  "prefix": "DAS_SetInstructionWindowHeight",
  "body": [
   "DAS_SetInstructionWindowHeight($$WindowHeight);"
  ],
  "description": "\n\n\n\n\n\nThis function sets the vertical window height of the instruction window displayed on the DAS form to the value contained by the $WindowHeight argument. The window height is specified in pixels.\n\n\n\n\n\nThe Instruction panel window will be resized automatically and adjust to the new instruction window size.\n\n\n\n\n\nImportant Note: In order to use this function the DAS panel visibility must be set to 'TRUE'. See the DAS_SetDASPanelVisibility function for more details.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$WindowHeight\n\nInteger\n\nThe height specified in pixels of the instruction window on the DAS form.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nUsage Example:\n\nDAS_SetInstructionWindowHeight(200);\n\n\n\n\n\nDAS_AddProcessMeasurementStep\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS DAS_AddProcessMeasurementStep": {
  "prefix": "DAS_AddProcessMeasurementStep",
  "body": [
   "DAS_AddProcessMeasurementStep($$AssemblyProcess,$$ProcessStepName,$$StepType,$$TextOrURL,$$MeasurementPrompt,$$VariableName);"
  ],
  "description": "\n\n\n\nThis function adds a new assembly step to an existing assembly process which has been created using the DAS_CreateProcess function.\n\n\n\n\n\nAn Assembly step is given a name, and can be either a text based assembly step,graphical assembly step, or a document assembly step. If the assembly step uses a text string to instruct the operator, then the fourth parameter is a string containing the text to describe the operation required to the operator. If the assembly step is using a graphic to display an image to the operator, the fourth parameter is the file path or URL to the image to be displayed.\n\n\n\n\n\nIf a document assembly step is used, the $TextOrURL parameter should be the path to the document. Documents can be any document that Internet Explorer can handle such as PDF, Office Documents, etc.\n\n\n\n\n\nAfter all the process steps have been added, the process can be displayed to the user by using the DAS_DisplayProcess function.\n\n\n\n\n\nIn addition to prompting the operator, this function also provides a pop-up prompt allowing the test operator to enter a value into the form along with a description which is supplied by the $MeasurementPrompt argument.\n\n\n\n\n\nThe value that the operator enters into the form is stored in the variable name specified by the $VariableName argument.\n\n\n\n\n\nImportant Note:\n\nIf you add an assembly step with the StepType set to document, a web browser control is used to display the document to the operator. In order for this control to function properly. Jabil Test must be configured to use a Single-Threaded Apartment model. This is not the default setting of Jabil Test, so it will be necessary to change the system threading mode using in the Global Cell Options dialog which can be accessed from the main pull-down menu.\n\n\n\n\n\nNote concerning using an Adobe PDF file as a process step:\n\n\n\n\n\nIf you are using an Adobe PDF file as a process step when you have the step type argument set to 'DOCUMENT', you can open the PDF document to a specific page by using the following syntax:\n\n\n\n\n\nDAS_AddProcessStep($MyProcess,\"PDF Page Example\",\"DOCUMENT\",\"c:\\\\example.pdf#Page=2\");\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AssemblyProcess\n\nObject\n\nThe assembly process which has been created using the DAS_CreateProcess command.\n\n\n\n$ProcessStepName\n\nString\n\nThe process step name\n\n\n\n$StepType\n\nString\n\nA string containing whether the assembly step will display a text string or a graphical image to the operator. Allowable values are:\n\n\u00b7 \"TEXT\"\n\n\u00b7 \"IMAGE\"\n\n\u00b7 \"DOCUMENT\"\n\n\n\n$TextOrURL\n\nString\n\nThe text string to display to the operator, or a text string containing the file path or URL to the image to be displayed.\n\n\n\n$MeasurementPrompt\n\nString\n\nThe text shown to the operator on the Measurement Prompt form.\n\n\n\n$VariableName\n\nString\n\nThe name of the variable to which the operator supplied value is stored.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nUsage Example:\n\n\n\n\n\n$MyProcess = DAS_CreateProcess(\"Assembly Process\",\"TRUE\");\n\nDAS_AddProcessStep($MyProcess,\"Assembly Process 1\",\"TEXT\",\"This is an assembly Process\");\n\nDAS_AddProcessStep($MyProcess,\"Assembly Process 2\",\"TEXT\",\"This is an another assembly Process!\");\n\nDAS_AddProcessStep($MyProcess,\"Another Assembly Process\",\"IMAGE\",\"c:\\\\server.jpg\");\n\nDAS_AddProcessStep($MyProcess,\"Another Assembly Process\",\"IMAGE\",\"c:\\\\instr1.gif\");\n\nDAS_AddProcessStep($MyProcess,\"PDF Assembly Process\",\"DOCUMENT\",\"c:\\\\dxf.pdf\");\n\nDAS_AddProcessMeasurementStep($MyProcess,\"New Measurement Process\",\"TEXT\",\"DO SOME STUFF, AND ENTER THE MEASUREMENT\",\"RECORD VALUE FROM Frequency Counter\",\"myMeasurement\");\n\nDAS_AddProcessMeasurementStepWithLimits($MyProcess,\"New Measurement Process\",\"TEXT\",\"DO SOME STUFF, AND ENTER THE MEASUREMENT\",\"RECORD VALUE FROM Frequency Counter\",\"myMeasurement\",100,200);\n\n\n\n\n\nDAS_DisplayProcess($MyProcess);\n\n\n\n\n\nDAS_AddProcessMeasurementStepWithLimits\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS DAS_AddProcessMeasurementStepWithLimits": {
  "prefix": "DAS_AddProcessMeasurementStepWithLimits",
  "body": [
   "DAS_AddProcessMeasurementStepWithLimits($$AssemblyProcess,$$ProcessStepName,$$StepType,$$TextOrURL,$$MeasurementPrompt,$$VariableName,$$LowerLimit,$$UpperLimit);"
  ],
  "description": "\n\n\n\nThis function adds a new assembly step to an existing assembly process which has been created using the DAS_CreateProcess function.\n\n\n\n\n\nAn Assembly step is given a name, and can be either a text based assembly step,graphical assembly step, or a document assembly step. If the assembly step uses a text string to instruct the operator, then the fourth parameter is a string containing the text to describe the operation required to the operator. If the assembly step is using a graphic to display an image to the operator, the fourth parameter is the file path or URL to the image to be displayed.\n\n\n\n\n\nIf a document assembly step is used, the $TextOrURL parameter should be the path to the document. Documents can be any document that Internet Explorer can handle such as PDF, Office Documents, etc.\n\n\n\n\n\nAfter all the process steps have been added, the process can be displayed to the user by using the DAS_DisplayProcess function.\n\n\n\n\n\nIn addition to prompting the operator, this function also provides a pop-up prompt allowing the test operator to enter a value into the form along with a description which is supplied by the $MeasurementPrompt argument.\n\n\n\n\n\nThe value that the operator enters into the form is stored in the variable name specified by the $VariableName argument. If the values supplied by the $LowerLimit or $UpperLimit parameters is exceeded by the operator entered measurement value, this function automatically generates a failing test.\n\n\n\n\n\nImportant Note:\n\nIf you add an assembly step with the StepType set to document, a web browser control is used to display the document to the operator. In order for this control to function properly. Jabil Test must be configured to use a Single-Threaded Apartment model. This is not the default setting of Jabil Test, so it will be necessary to change the system threading mode using in the Global Cell Options dialog which can be accessed from the main pull-down menu.\n\n\n\n\n\nNote concerning using an Adobe PDF file as a process step:\n\n\n\n\n\nIf you are using an Adobe PDF file as a process step when you have the step type argument set to 'DOCUMENT', you can open the PDF document to a specific page by using the following syntax:\n\n\n\n\n\nDAS_AddProcessStep($MyProcess,\"PDF Page Example\",\"DOCUMENT\",\"c:\\\\example.pdf#Page=2\");\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AssemblyProcess\n\nObject\n\nThe assembly process which has been created using the DAS_CreateProcess command.\n\n\n\n$ProcessStepName\n\nString\n\nThe process step name\n\n\n\n$StepType\n\nString\n\nA string containing whether the assembly step will display a text string or a graphical image to the operator. Allowable values are:\n\n\u00b7 \"TEXT\"\n\n\u00b7 \"IMAGE\"\n\n\u00b7 \"DOCUMENT\"\n\n\n\n$TextOrURL\n\nString\n\nThe text string to display to the operator, or a text string containing the file path or URL to the image to be displayed.\n\n\n\n$MeasurementPrompt\n\nString\n\nThe text shown to the operator on the Measurement Prompt form.\n\n\n\n$VariableName\n\nString\n\nThe name of the variable to which the operator supplied value is stored.\n\n\n\n$LowerLimit\n\nFloat\n\nThe lower bound for the manually entered measurememt value.\n\n\n\n$UpperLimit\n\nFloat\n\nThe upper bound for the manually entered measurement value.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nUsage Example:\n\n\n\n\n\n$MyProcess = DAS_CreateProcess(\"Assembly Process\",\"TRUE\");\n\nDAS_AddProcessStep($MyProcess,\"Assembly Process 1\",\"TEXT\",\"This is an assembly Process\");\n\nDAS_AddProcessStep($MyProcess,\"Assembly Process 2\",\"TEXT\",\"This is an another assembly Process!\");\n\nDAS_AddProcessStep($MyProcess,\"Another Assembly Process\",\"IMAGE\",\"c:\\\\server.jpg\");\n\nDAS_AddProcessStep($MyProcess,\"Another Assembly Process\",\"IMAGE\",\"c:\\\\instr1.gif\");\n\nDAS_AddProcessStep($MyProcess,\"PDF Assembly Process\",\"DOCUMENT\",\"c:\\\\dxf.pdf\");\n\nDAS_AddProcessMeasurementStep($MyProcess,\"New Measurement Process\",\"TEXT\",\"DO SOME STUFF, AND ENTER THE MEASUREMENT\",\"RECORD VALUE FROM Frequency Counter\",\"myMeasurement\");\n\nDAS_AddProcessMeasurementStepWithLimits($MyProcess,\"New Measurement Process\",\"TEXT\",\"DO SOME STUFF, AND ENTER THE MEASUREMENT\",\"RECORD VALUE FROM Frequency Counter\",\"myMeasurement\",100,200);\n\n\n\n\n\nDAS_DisplayProcess($MyProcess);\n\n\n\n\n\nDAS_AddProcessStep\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS DAS_AddProcessStep": {
  "prefix": "DAS_AddProcessStep",
  "body": [
   "DAS_AddProcessStep($$AssemblyProcess,$$ProcessStepName,$$StepType,$$TextOrURL);"
  ],
  "description": "\n\n\n\n\n\nThis function adds a new assembly step to an existing assembly process which has been created using the DAS_CreateProcess function.\n\n\n\n\n\nAn Assembly step is given a name, and can be either a text based assembly step,graphical assembly step, or a document assembly step. If the assembly step uses a text string to instruct the operator, then the fourth parameter is a string containing the text to describe the operation required to the operator. If the assembly step is using a graphic to display an image to the operator, the fourth parameter is the file path or URL to the image to be displayed.\n\n\n\n\n\nIf a document assembly step is used, the $TextOrURL parameter should be the path to the document. Documents can be any document that Internet Explorer can handle such as PDF, Office Documents, etc.\n\n\n\n\n\nAfter all the process steps have been added, the process can be displayed to the user by using the DAS_DisplayProcess function.\n\n\n\n\n\nImportant Note:\n\nIf you add an assembly step with the StepType set to document, a web browser control is used to display the document to the operator. In order for this control to function properly. Jabil Test must be configured to use a Single-Threaded Apartment model. This is not the default setting of Jabil Test, so it will be necessary to change the system threading mode using in the Global Cell Options dialog which can be accessed from the main pull-down menu.\n\n\n\n\n\nNote concerning using an Adobe PDF file as a process step:\n\n\n\n\n\nIf you are using an Adobe PDF file as a process step when you have the step type argument set to 'DOCUMENT', you can open the PDF document to a specific page by using the following syntax:\n\n\n\n\n\nDAS_AddProcessStep($MyProcess,\"PDF Page Example\",\"DOCUMENT\",\"c:\\\\example.pdf#Page=2\");\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AssemblyProcess\n\nObject\n\nThe assembly process which has been created using the DAS_CreateProcess command.\n\n\n\n$ProcessStepName\n\nString\n\nThe process step name\n\n\n\n$StepType\n\nString\n\nA string containing whether the assembly step will display a text string or a graphical image to the operator. Allowable values are:\n\n\u00b7 \"TEXT\"\n\n\u00b7 \"IMAGE\"\n\n\u00b7 \"DOCUMENT\"\n\n\n\n$TextOrURL\n\nString\n\nThe text string to display to the operator, or a text string containing the file path or URL to the image to be displayed.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nUsage Example:\n\n\n\n\n\n$MyProcess = DAS_CreateProcess(\"Assembly Process\",\"TRUE\");\n\nDAS_AddProcessStep($MyProcess,\"Assembly Process 1\",\"TEXT\",\"This is an assembly Process\");\n\nDAS_AddProcessStep($MyProcess,\"Assembly Process 2\",\"TEXT\",\"This is an another assembly Process!\");\n\nDAS_AddProcessStep($MyProcess,\"Another Assembly Process\",\"IMAGE\",\"c:\\\\server.jpg\");\n\nDAS_AddProcessStep($MyProcess,\"Another Assembly Process\",\"IMAGE\",\"c:\\\\instr1.gif\");\n\nDAS_AddProcessStep($MyProcess,\"PDF Assembly Process\",\"DOCUMENT\",\"c:\\\\dxf.pdf\");\n\nDAS_DisplayProcess($MyProcess);\n\n\n\n\n\nDAS_CreateProcess\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS DAS_CreateProcess": {
  "prefix": "DAS_CreateProcess",
  "body": [
   "$$MyProcess=DAS_CreateProcess($$ProcessName,$$AllowMovementToPreviousStep);"
  ],
  "description": "\n\n\n\n\n\nThis function creates a new directed assembly process. The directed assembly process can consist of an unlimited number of individual steps which are displayed to the operator. The directed assembly functions can be used in place of the normal Operator Interaction functions in the event that an operator needs the ability to move forward and backward through a list of required online work instructions.\n\n\n\n\n\nOnce a new Directed Assembly Process is created using the DAS_CreateProcess function, new steps can be added using the DAS_AddProcessStep function. Finally, the complete process is displayed to the test operator by using the DAS_DisplayProcess script command.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ProcessName\n\nString\n\nThe name of the assembly process or sub-process\n\n\n\n$AllowMovementToPreviousStep\n\nBoolean\n\nIf this boolean argument is set to true, it allows the operator to move freely back and forth through the list of required assembly or test operations.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$MyProcess\n\nObject\n\nThis returns a reference to the newly created assembly process. After the process is created, assembly steps must be added to the process by using the DAS_AddProcessStep command.\n\n\n\n\n\nUsage Example:\n\n\n\n\n\n$MyProcess = DAS_CreateProcess(\"Assembly Process\",\"TRUE\");\n\nDAS_AddProcessStep($MyProcess,\"Assembly Process 1\",\"TEXT\",\"This is an assembly Process\");\n\nDAS_AddProcessStep($MyProcess,\"Assembly Process 2\",\"TEXT\",\"This is an another assembly Process!\");\n\nDAS_AddProcessStep($MyProcess,\"Another Assembly Process\",\"IMAGE\",\"c:\\\\server.jpg\");\n\nDAS_AddProcessStep($MyProcess,\"Another Assembly Process\",\"IMAGE\",\"c:\\\\instr1.gif\");\n\nDAS_DisplayProcess($MyProcess);\n\n\n\n\n\nDAS_DisplayProcess\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS DAS_DisplayProcess": {
  "prefix": "DAS_DisplayProcess",
  "body": [
   "DAS_DisplayProcess($$Process);"
  ],
  "description": "\n\n\n\n\n\nThis script function displays a previously created assembly process to the user. The assembly process is created using the DAS_CreateProcess function and populating it with assembly steps using the DAS_AddProcessStep function.\n\n\n\n\n\nThis command displays the graphical operator interface which will direct the operator through the list of assembly steps to be performed.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Process\n\nObject\n\nThe assembly process which has been created using the DAS_CreateProcess command.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nUsage Example:\n\n\n\n\n\n$MyProcess = DAS_CreateProcess(\"Assembly Process\",\"TRUE\");\n\nDAS_AddProcessStep($MyProcess,\"Assembly Process 1\",\"TEXT\",\"This is an assembly Process\");\n\nDAS_AddProcessStep($MyProcess,\"Assembly Process 2\",\"TEXT\",\"This is an another assembly Process!\");\n\nDAS_AddProcessStep($MyProcess,\"Another Assembly Process\",\"IMAGE\",\"c:\\\\server.jpg\");\n\nDAS_AddProcessStep($MyProcess,\"Another Assembly Process\",\"IMAGE\",\"c:\\\\instr1.gif\");\n\nDAS_DisplayProcess($MyProcess);\n\n\n\n\n\nDAS_DisplayProcessWithOptions\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS DAS_DisplayProcessWithOptions": {
  "prefix": "DAS_DisplayProcessWithOptions",
  "body": [
   "DAS_DisplayProcessWithOptions($$Process,$$WindowWidth,$$WindowHeight,$$SidePanelWidth,$$Maximized);"
  ],
  "description": "\n\n\n\n\n\nThis script function displays a previously created assembly process to the user. The assembly process is created using the DAS_CreateProcess function and populating it with assembly steps using the DAS_AddProcessStep function.\n\n\n\n\n\nThis command displays the graphical operator interface which will direct the operator through the list of assembly steps to be performed.\n\n\n\n\n\nThis command allows specifying the size of the DAS window, as well as the size of the process list panel inside of the window when it is displayed.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Process\n\nObject\n\nThe assembly process which has been created using the DAS_CreateProcess command.\n\n\n\n$WindowWidth\n\nInteger\n\nThe width of the DAS window in Pixels\n\n\n\n$WindowHeight\n\nInteger\n\nThe height of the DAS window in Pixels\n\n\n\n$SidePanelWidth\n\nInteger\n\nThe width of the DAS process list panel in Pixels\n\n\n\n$Maximized\n\nBoolean\n\nA boolean value indicating whether or not the window should be opened as 'Maximized'. If this is set to true, the window is always shown full screen and the $WindowWidth and $WindowHeight properties are ignored.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nUsage Example:\n\n\n\n\n\n$MyProcess = DAS_CreateProcess(\"Assembly Process\",\"TRUE\");\n\n\n\n\n\nDAS_AddProcessStep($MyProcess,\"SHOW PDF FILE PAGE 2\",\"DOCUMENT\",\"c:\\\\a.pdf#Page=2\");\n\n\n\n\n\nDAS_DisplayProcessWithOptions($MyProcess,900,400,500,true);\n\n\n\n\n\nDisplayFullScreenImage\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS DisplayFullScreenImage": {
  "prefix": "DisplayFullScreenImage",
  "body": [
   "$$formHandle=DisplayFullScreenImage($$DisplayId,$$FilePath);"
  ],
  "description": "\n\nDisplays an a given image file full screen on a given display. In the event that the file, or the display doesn't exist, a failure is returned to the script interpreter.\n\nThis function supports JPB,BMP,GIF,PNG, and TIFF image files.\n\nNote: The image will automatically close when the script execution has ended. In the event that you would like to close the image during script execution, you can use the CloseForm function.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$DisplayId\n\nInteger\n\nThe ID of the display on which you would like to display the image\n\n\n\n$FilePath\n\nString\n\nThe filename and path of the image file that you would like to display. Supported image types are JPG,BMP,GIF,PNG,TIFF\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$formHandle\n\nObject\n\nThe handle to the image displayed.\n\n\n\n\n\nDisplayPixelSelector\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS DisplayPixelSelector": {
  "prefix": "DisplayPixelSelector",
  "body": [
   "$$PixelList=DisplayPixelSelector($$DisplayID,$$CursorRed,$$CursorGreen,$$CursorBlue,$$BackgroundRed,$$BackgroundGreen,$$BackgroundBlue,$$InstructionString,$$DefectOptionString);Note:ThisfunctiondisplaysacontrolpanelonthedefaultdisplayrunningJabilTest,andgeneratesapixelselectionareaonanauxiliarymonitor.Inordertousethisfunction,thePCrunningJabilTestmusthavemultiplemonitorsinstalledandconfiguredusingtheDisplayPropertiesoftheControlPanel."
  ],
  "description": "\n\nThis function generates a Pixel Selection control panel which allows the user to choose a set of pixels on a given display. The pixels selected are returned as a semicolon delimited string containing X/Y coordinates. In the event that the $DefectOptionString contains a list of defects, the pixel list is returned with the operator specified defect in the particular location.\n\nIf the $DefectOptionString is populated with a semicolon delimited list of options, then a context menu will be displayed on each mouse click which allows the operator to choose one of the defects from the list. If the $DefectOptionString is an empty string, no context menu will be displayed and only the X/Y pixel coordinates are turned in the $PixelList variable.\n\nExample of function call :\n\n$PixelList = DisplayPixelSelector(1,255,255,255,0,0,0,\"Please Select The Stuck Pixels\",\"Pixel Stuck On;Pixel Stuck Off\");\n\nExample of returned data:\n\n$PixelList = \"(216,222,Pixel Stuck On);(923,222,Pixel Stuck Off)\";\n\n\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$DisplayID\n\nInteger\n\nThe ID of the display on which to display the pixel selection panel.\n\n\n\n$CursorRed\n\nInteger\n\nSets the intensity value of the color component for the cross hairs. Valid values are 0-255.\n\n\n\n$CursorGreen\n\nInteger\n\nSets the intensity value of the color component for the cross hairs. Valid values are 0-255.\n\n\n\n$CursorBlue\n\nInteger\n\nSets the intensity value of the color component for the cross hairs. Valid values are 0-255.\n\n\n\n$BackgroundRed\n\nInteger\n\nSets the intensity value of the color component for the background. Valid values are 0-255.\n\n\n\n$BackgroundGreen\n\nInteger\n\nSets the intensity value of the color component for the background. Valid values are 0-255.\n\n\n\n$BackgroundBlue\n\nInteger\n\nSets the intensity value of the color component for the background. Valid values are 0-255.\n\n\n\n$InstructionString\n\nInteger\n\nSpecifies the instructions that will be displayed to the test operator.\n\n\n\n$DefectOptionString\n\nInteger\n\nSpecifies a list of defect options that the test operator can choose from when selecting a pixel. The list should be a semicolon delimited string as shown in the example.\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$PixelList\n\nString\n\nA semicolon delimited list of pixel coordinates and their associated defects.\n\n\n\n\n\nDisplayRegionSelector\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS DisplayRegionSelector": {
  "prefix": "DisplayRegionSelector",
  "body": [
   "$$RegionList=DisplayRegionSelector($$DisplayID,$$CursorRed,$$CursorGreen,$$CursorBlue,$$BackgroundRed,$$BackgroundGreen,$$BackgroundBlue,$$InstructionString,$$DefectOptionString);Note:ThisfunctiondisplaysacontrolpanelonthedefaultdisplayrunningJabilTest,andgeneratesaregionselectionareaonanauxiliarymonitor.Inordertousethisfunction,thePCrunningJabilTestmusthavemultiplemonitorsinstalledandconfiguredusingtheDisplayPropertiesoftheControlPanel."
  ],
  "description": "\n\nThis function generates a Region Selection control panel which allows the user to choose a set of pixels on a given display. The regions selected are returned as a semicolon delimited string containing X/Y coordinates. In the event that the $DefectOptionString contains a list of defects, the pixel list is returned with the operator specified defect in the particular location.\n\nIf the $DefectOptionString is populated with a semicolon delimited list of options, then a context menu will be displayed on each mouse click which allows the operator to choose one of the defects from the list. If the $DefectOptionString is an empty string, no context menu will be displayed and only the X/Y region coordinates are turned in the $RegionList variable.\n\nExample of function call :\n\n$RegionList = DisplayRegionSelector(1,255,255,255,0,0,0,\"Please Select The Defective Regions\",\"Region failure 1;Region Failure 2\");\n\nExample of returned data:\n\n$RegionList = \"(216,222,300,400);(923,222,988,233)\";\n\n\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$DisplayID\n\nInteger\n\nThe display ID on which to display the region selection screen.\n\n\n\n$CursorRed\n\nInteger\n\nSets the intensity value of the color component for the cross hairs. Valid values are 0-255.\n\n\n\n$CursorGreen\n\nInteger\n\nSets the intensity value of the color component for the cross hairs. Valid values are 0-255.\n\n\n\n$CursorBlue\n\nInteger\n\nSets the intensity value of the color component for the cross hairs. Valid values are 0-255.\n\n\n\n$BackgroundRed\n\nInteger\n\nSets the intensity value of the color component for the background. Valid values are 0-255.\n\n\n\n$BackgroundGreen\n\nInteger\n\nSets the intensity value of the color component for the background. Valid values are 0-255.\n\n\n\n$BackgroundBlue\n\nInteger\n\nSets the intensity value of the color component for the background. Valid values are 0-255.\n\n\n\n$InstructionString\n\nInteger\n\nSpecifies the instructions that will be displayed to the test operator.\n\n\n\n$DefectOptionString\n\nInteger\n\nSpecifies a list of defect options that the test operator can choose from when selecting a pixel. The list should be a semicolon delimited string as shown in the example.\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$RegionList\n\nString\n\nA semicolon delimited list of region coordinates and their associated defects.\n\n\n\n\n\nTestCircularRegionViolation\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS TestCircularRegionViolation": {
  "prefix": "TestCircularRegionViolation",
  "body": [
   "($$Failed,$$FailList)=TestCircularRegionViolation($$PixelList,$$XRes,$$YRes,$$DisplayWidth,$$DisplayHeight,$$RegionAxisX,$$RegionAxisY,$$RegionRadius,$$NumAllowableDefects,$$AllowableDefectDistance);"
  ],
  "description": "\n\nThis function tests a given list of pixels in a region for failure criteria. The pixel list which can be generated manually, or returned from the Pixel test functions, is tested against the allowable number of failures per region, as well as a minimum distance between defects. The $FailList variable will contain a list of all pixel defects within the region. The $Failed variable will contain TRUE if the test failed, or FALSE if the list of pixel defects was within allowable criteria.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$PixelList\n\nString\n\nA pixel list string in one of the following two formats:\n\n\u00b7 (x,y);(x,y);(x,y);(x,y)\n\n\u00b7 (x,y,\"Defect Description\");(x,y,\"Defect Description\")\n\n\n\n$XResolution\n\nInteger\n\nThe number of pixels on the horizontal plane of the display. For instance, on an UXGA display this number would be 1280.\n\n\n\n$YResolution\n\nInteger\n\nThe number of pixels on the vertical plane of the display. For instance, on an UXGA display this number would be 1024.\n\n\n\n$DisplayWidth\n\nFloat\n\nThe physical width of the display. This value is used to calculate the physical width of a single pixel.\n\n\n\n$DisplayHeight\n\nFloat\n\nThe physical height of the display. This value is sued to calculate the physical height of a single pixel.\n\n\n\n$RegionAxisX\n\nInteger\n\nThe X axis specified in pixel coordinates of the region to test for fail criteria.\n\n\n\n$RegionAxisY\n\nInteger\n\nThe Y axis specified in pixel coordinates of the region to test for fail criteria.\n\n\n\n$RegionRadius\n\nFloat\n\nThe radius of the region to test for failure criteria\n\n\n\n$NumAllowableDefects\n\nInteger\n\nThe number of pixel defects that are allowed within the given region.\n\n\n\n$AllowableDefectDistance\n\nFloat\n\nThe acceptable physical distance between pixel defects within the given region.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Failed\n\nBoolean\n\nA boolean variable indicating whether or not the supplied pixel list fails against the supplied acceptable criteria.\n\n\n\n$FailList\n\nString\n\nA list of the failure criteria, suitable for passing to the Fail function or RecordMeasurement function for TARS recording.\n\n\n\n\n\nTestRectangleRegionViolation\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS TestRectangleRegionViolation": {
  "prefix": "TestRectangleRegionViolation",
  "body": [
   "($$Failed,$$FailList)=TestRectangleRegionViolation($$PixelList,$$XRes,$$YRes,$$DisplayWidth,$$DisplayHeight,$$RegionLeftX,$$RegionRightX,$$RegionTopY,$$RegionBottomY,$$NumAllowableDefects,$$AllowableDefectDistance);"
  ],
  "description": "\n\nThis function tests a given list of pixels in a region for failure criteria. The pixel list which can be generated manually, or returned from the Pixel test functions, is tested against the allowable number of failures per region, as well as a minimum distance between defects. The $FailList variable will contain a list of all pixel defects within the region. The $Failed variable will contain TRUE if the test failed, or FALSE if the list of pixel defects was within allowable criteria.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$PixelList\n\nString\n\nA pixel list string in one of the following two formats:\n\n\u00b7 (x,y);(x,y);(x,y);(x,y)\n\n\u00b7 (x,y,\"Defect Description\");(x,y,\"Defect Description\")\n\n\n\n$XResolution\n\nInteger\n\nThe number of pixels on the horizontal plane of the display. For instance, on an UXGA display this number would be 1280.\n\n\n\n$YResolution\n\nInteger\n\nThe number of pixels on the vertical plane of the display. For instance, on an UXGA display this number would be 1024.\n\n\n\n$DisplayWidth\n\nFloat\n\nThe physical width of the display. This value is used to calculate the physical width of a single pixel.\n\n\n\n$DisplayHeight\n\nFloat\n\nThe physical height of the display. This value is sued to calculate the physical height of a single pixel.\n\n\n\n$RegionLeftX\n\nInteger\n\nThe left edge of the region of interest. This is specified in pixels.\n\n\n\n$RegionRightX\n\nInteger\n\nThe right edge of the region of interest. This is specified in pixels.\n\n\n\n$RegionTopY\n\nInteger\n\nThe top edge of the region of interest. This is specified in pixels.\n\n\n\n$RegionBottomY\n\nInteger\n\nThe bottom edge of the region of interest. This is specified in pixels.\n\n\n\n$NumAllowableDefects\n\nInteger\n\nThe number of pixel defects that are allowed within the given region.\n\n\n\n$AllowableDefectDistance\n\nFloat\n\nThe acceptable physical distance between pixel defects within the given region.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Failed\n\nBoolean\n\nA boolean variable indicating whether or not the supplied pixel list fails against the supplied acceptable criteria.\n\n\n\n$FailList\n\nString\n\nA list of the failure criteria, suitable for passing to the Fail function or RecordMeasurement function for TARS recording.\n\n\n\n\n\nFileBinaryWriteByte\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS FileBinaryWriteByte": {
  "prefix": "FileBinaryWriteByte",
  "body": [
   "FileBinaryWriteByte($$FileHandle,$$Byte);"
  ],
  "description": "\n\n\n\nThis function writes a single byte to a file handle that was created using the FileBinaryWriteOpen script command. The $Byte argument is an integer which must have a value between 0 and 255.\n\n\n\n\n\nImportant Note: The writes to the file are queued in a FIFO buffer so some bytes may not be flushed to the file until it is closed using the FileBinaryWriteClose function. This behavior is dependent on the Write Cache settings configured for the operating system.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$FileHandle\n\nObject\n\nA file handle that was created using the FileBinaryWriteOpen function\n\n\n\n$Byte\n\nInteger\n\nAn integer value representing the byte value to write to the file. The integer must be between 0 and 255\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n\n\n\n\n$FileHandle = FileBinaryWriteOpen(\"c:\\\\test\\\\output.bin\");\n\nFileBinaryWriteByte($FileHandle,127);\n\nFileBinaryWriteByte($FileHandle,128);\n\nFileBinaryWriteByte($FileHandle,129);\n\nFileBinaryWriteClose($FileHandle);\n\n\n\n\n\nFileBinaryWriteByteArray\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS FileBinaryWriteByteArray": {
  "prefix": "FileBinaryWriteByteArray",
  "body": [
   "FileBinaryWriteByteArray($$FileHandle,$$ByteArray,$$StartIndex,$$Length);"
  ],
  "description": "\n\n\n\nThis function will append an array of bytes to a file handle that was created using the FileBinaryWriteOpen script command. $ByteArray can be an integer or byte array. If it is an integer array, the values must all be between 0 and 255.\n\n\n\n\n\nImportant Note: Writes to the file are queued in a FIFO buffer so some bytes may not be flushed to the file until it is closed using the FileBinaryWriteClose function. This behavior is dependent on the Write Cache settings configured for the operating system.\n\nCalling this function will append to a file. To start over from the beginning of a file, close the file using FileBinaryWriteClose and reopen it with FileBinaryWriteOpen.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$FileHandle\n\nObject\n\nA file handle that was created using the FileBinaryWriteOpen function\n\n\n\n$ByteArray\n\nArray\n\nAn array of integers or bytes that will be written to the binary file. If this is an integer array, all elements must have a value between 0 and 255.\n\n\n\n$StartIndex\n\nInteger\n\nThe location in $ByteArray to start writing from. Enter 0 to begin writing from the first element of the array.\n\n\n\n$Length\n\nInteger\n\nThe number of bytes to write to the binary file. Entering 0 will write from $StartIndex to the end of the array.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n// Assume we have an array of 100 bytes.\n\n// Write from byte 50 to the end of the array.\n\n$FileHandle = FileBinaryWriteOpen(\"c:\\\\test\\\\output.bin\");\n\nFileBinaryWriteByteArray($FileHandle, $ByteArray, 50, 0);\n\nFileBinaryWriteClose($FileHandle);\n\n\n\n\n\n// Write 15 bytes starting at byte 10.\n\nFileBinaryWriteByteArray($FileHandle, $ByteArray, 10, 15);\n\n\n\n\n\n// Write entire array to file.\n\nFileBinaryWriteByteArray($FileHandle, $ByteArray, 0, 0);\n\n\n\n\n\nFileBinaryWriteClose\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS FileBinaryWriteClose": {
  "prefix": "FileBinaryWriteClose",
  "body": [
   "FileBinaryWriteClose($$FileHandle);"
  ],
  "description": "\n\n\n\nThis function closes a binary file handle that was created with the FileBinaryWriteOpen command. When this function is called, any remaining bytes written to the file are flushed from the buffer and written to the file system before the file is closed.\n\n\n\n\n\nIf the file can't be closed, an error is returned from the function.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$FileHandle\n\nObject\n\nA file handle that was created using the FileBinaryWriteOpen function\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n\n\n\n\nFileBinaryWriteClose($FileHandle);\n\n\n\n\n\nFileBinaryWriteOpen\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS FileBinaryWriteOpen": {
  "prefix": "FileBinaryWriteOpen",
  "body": [
   "$$FileHandle=FileBinaryWriteOpen($$FileName);"
  ],
  "description": "\n\n\n\nThis functions opens a file on the local file system or mapped drive for writing binary files. In th eevent that the file can't be created or opened, the function returns a failure. If the filename supplied already exists on the file system, it will be replaced with the new file.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$FileName\n\nString\n\nThe filename and path to create the new binary file (or overwrite an existing file)\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$FileHandle\n\nObject\n\nThe returned file handle which can be used for writing data into the file.\n\n\n\n\n\nExample:\n\n\n\n\n\n$FileHandle = FileBinaryWriteOpen(\"c:\\\\mydirectory\\\\myfile.bin\");\n\n\n\n\n\nFileCompare\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS FileCompare": {
  "prefix": "FileCompare",
  "body": [
   "$$ReturnValue=FileCompare($$SourceFile,$$FileToCompare,$$FailTest);"
  ],
  "description": "\n\nThis function tests byte per byte if the $SourceFile and the $FileToCompare are equal.\n\n\n\nResult\n\n0 if the $SourceFile and the$FileToCompare are equal.\n\n-1 if the $SourceFile cannot be opened for reading.\n\n-2 if the $FileToCompare cannot be opened for reading.\n\n-3 if the $SourceFile and the $FileToCompare have different file length.\n\n-4 if the $SourceFile and the $FileToCompare are NOT equal.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$SourceFile\n\nString\n\nThe source file for the comparison to be made.\n\n\n\n$FileToCompare\n\nString\n\nThe file that will be compared to the $SourceFile.\n\n\n\n$FailTest\n\nBoolean\n\nWhether to fail the script if the comparison fails (files are not equal or cannot be loaded).\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ReturnValue\n\nInteger\n\nThe result of the test.\n\n\n\n\n\nExamples:\n\n\n\n\n\n$ReturnValue = FileCompare(\"c:\\\\source.txt\", \"c:\\\\FileToCompare.txt\", false);\n\n// returns 0.\n\n\n\n$ReturnValue = FileCompare(\"c:\\\\sourceNotExists.txt\", \"c:\\\\FileToCompare.txt\", false);\n\n// returns -1.\n\n\n\n$ReturnValue = FileCompare(\"c:\\\\source.txt\", \"c:\\\\FileToCompareNotExists.txt\", false);\n\n// returns -2.\n\n\n\n$ReturnValue = FileCompare(\"c:\\\\source.txt\", \"c:\\\\FileToCompareDifferentLength.txt\", false);\n\n// returns -3.\n\n\n\n$ReturnValue = FileCompare(\"c:\\\\source.txt\", \"c:\\\\FileToCompareBad.txt\", false);\n\n// returns -4.\n\n\n\n\n\nFileReadAllBytes\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS FileReadAllBytes": {
  "prefix": "FileReadAllBytes",
  "body": [
   "$$ByteArray=FileReadAllBytes($$FilePath);"
  ],
  "description": "\n\n\n\nThis function reads all the bytes of a file into a 1-D array of bytes. The length of the file determines the length of the returned byte array.\n\n\n\nRemarks:\n\n\u00b7 If the file is not found, the test generates a failure.\n\n\n\nExamples:\n\n\n\n\n\n$ByteArray = FileReadAllBytes(\"c:\\\\test\\\\testfile.dat\");\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$FilePath\n\nString\n\nThe complete file path of the file to be read.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ByteArray\n\nArray\n\nThe returned array of bytes contained in the file.\n\n\n\n\n\nFileReadAllBytesToHexString\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS FileReadAllBytesToHexString": {
  "prefix": "FileReadAllBytesToHexString",
  "body": [
   "$$byteString=FileReadAllBytesToHexString($$FilePath);"
  ],
  "description": "\n\n\n\nThis function reads all the bytes of a file into a string of space-separated hexadecimal values.\n\n\n\nRemarks:\n\n\u00b7 If the file is not found, the test generates a failure.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$FilePath\n\nString\n\nThe complete file path of the file to be read.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$byteString\n\nString\n\nThe bytes contents of the file returned as a string of space-separated hexadecimal values.\n\n\n\n\n\nExamples:\n\n\n\n\n\n$byteString = FileReadAllBytes(\"c:\\\\test\\\\testfile.dat\");\n\nUpdateStatus($byteString); //prints out something like \"10 53 07 00 3C 01 00 97\"...etc\n\n\n\n\n\nGenerateFileHash\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS GenerateFileHash": {
  "prefix": "GenerateFileHash",
  "body": [
   "$$Hash=GenerateFileHash($$FileName);"
  ],
  "description": "\n\nThis function generates a cryptographically secure SHA1 hash for the supplied file.\n\n\n\n\n\nNote: Prior to Jabil Test 7.17.01, this hash function could drop leading zeroes in the string of hexadecimal characters (returned in $Hash). As of Jabil Test 7.17.01, the leading zeroes are included and the hash code will match the hash code in the report writers.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$FileName\n\nString\n\nThe name of the file for which to generate a hash\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Hash\n\nString\n\nA string of hexadecimal characters representing the hash of the file\n\n\n\n\n\nExample:\n\n\n\n\n\n// Get the filename of this script (the hash will match the report writer).\n\n$fileName = $RESERVED_CurrentScriptFile;\n\n\n\n\n\n// Get the hash code.\n\n$Hash = GenerateFileHash($fileName);\n\n\n\n\n\nExcelCloseFile\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ExcelCloseFile": {
  "prefix": "ExcelCloseFile",
  "body": [
   "ExcelCloseFile($$ExcelObject);"
  ],
  "description": "\n\nThis function closes the Microsoft Excel file and releases the resources.\n\nNote: The Jabil Test Microsoft Excel file manipulation functions rely on the object model exposed via COM by the Microsoft Office suite. In order to use these functions, Microsoft Office must be installed on the PC running Jabil Test.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ExcelObject\n\nObject\n\nA handle to the Excel workbook opened by the ExcelOpenFile function.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExcelGetCell\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ExcelGetCell": {
  "prefix": "ExcelGetCell",
  "body": [
   "$$Value=ExcelGetCell($$ExcelObject,$$WorksheetNumber,$$Column,$$Row);Note:TheJabilTestMicrosoftExcelfilemanipulationfunctionsrelyontheobjectmodelexposedviaCOMbytheMicrosoftOfficesuite.Inordertousethesefunctions,MicrosoftOfficemustbeinstalledonthePCrunningJabilTest."
  ],
  "description": "\n\nThis function returns the contents of the cell specified by the $Column and $Row parameters on the worksheet specified by the $WorksheetNumber parameter. The contents of the cell are returned as a string variable.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ExcelObject\n\nObject\n\nA handle to the Excel workbook opened by the ExcelOpenFile function.\n\n\n\n$WorksheetNumber\n\nInteger\n\nThe number of the worksheet page to retrieve the cell. The first worksheet in the workbook starts at 1.\n\n\n\n$Column\n\nString\n\nThe column of the cell to return\n\n\n\n$Row\n\nInteger\n\nThe row number of the cell to return\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Value\n\nString\n\nThe text contents of the queried cell.\n\n\n\n\n\nExample:\n\n$Value = ExcelGetCell($ExcelObject,1,\"A\",5);\n\n\n\n\n\nExcelGetRange\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ExcelGetRange": {
  "prefix": "ExcelGetRange",
  "body": [
   "$$dataArray=ExcelGetRange($$excelHandle,$$worksheet,$$startColumn,$$startRow,$$endColumn,$$endRow);"
  ],
  "description": "\n\nThis function will return an array of data from the specified range of cells on the specified worksheet of the previously opened Excel file. The file needs to have been opened with the ExcelOpenFile function.\n\n\n\nRemarks:\n\n\u00b7 This function uses the Microsoft Office COM interface, so Microsoft Office must be loaded on the computer using this function.\n\n\u00b7 The data is always returned as a 2-D array, even if only one column is specified.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$excelHandle\n\nObject\n\nA reference to the Excel file that was previously opened.\n\n\n\n$worksheet\n\nInteger\n\nThe number of the worksheet to retrieve the data from. Worksheet numbers start at 1.\n\n\n\n$startColumn\n\nString\n\nThe leftmost column of the cells to return data from. Columns are listed by letter ('A', 'B', etc.)\n\n\n\n$startRow\n\nInteger\n\nThe topmost row of the cells to return data from.\n\n\n\n$endColumn\n\nString\n\nThe rightmost column of the cells to return data from. Columns are listed by letter ('A', 'B', etc.)\n\n\n\n$endRow\n\nInteger\n\nThe bottommost row of cells to return data from.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$dataArray\n\nArray\n\nA 2-D array of strings that contains the data from the specified cells.\n\n\n\n\n\nExample:\n\n// Open the Excel File.\n\n$excelFile = \"C:\\Files\\DataFile.xls\";\n\n$excelHandle = ExcelOpenFile($excelFile);\n\n\n\n\n\n// Return data from cells E5 to F20.\n\n$worksheet = 1;\n\n$startcolumn = \"E\";\n\n$startRow = 5;\n\n$endColumn = \"F\";\n\n$endRow = 20;\n\n$dataArray = ExcelGetRange($excelHandle, $worksheet, $startColumn, $startRow, $endColumn, $endRow);\n\n\n\n\n\nExcelOpenFile\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ExcelOpenFile": {
  "prefix": "ExcelOpenFile",
  "body": [
   "$$ExcelObject=ExcelOpenFile($$FileName);Note:TheJabilTestMicrosoftExcelfilemanipulationfunctionsrelyontheobjectmodelexposedviaCOMbytheMicrosoftOfficesuite.Inordertousethesefunctions,MicrosoftOfficemustbeinstalledonthePCrunningJabilTest."
  ],
  "description": "\n\nThis function opens a Microsoft Excel file for use.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$FileName\n\nString\n\nThe filepath and name of the Excel document to open.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ExcelObject\n\nObject\n\nA handle to the Excel workbook opened by the function.\n\n\n\n\n\nExample:\n\n$MyExcel = ExcelOpenFile(\"c:\\\\testfile.txt\");\n\n\n\n\n\nExcelPrintFile\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ExcelPrintFile": {
  "prefix": "ExcelPrintFile",
  "body": [
   "$$Status=ExcelPrintFile($$Excel,$$FirstPageNumber,$$LastPageNumber,$$PrinterName);"
  ],
  "description": "\n\n\n\nThis function permits sending an Excel document to the specified printer, as well as specifying a page range to be printed.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Excel\n\nObject\n\nAn excel file object that was created using the ExcelOpenFile command.\n\n\n\n$FirstPageNumber\n\nInteger\n\nThe first page number in the workbook to print\n\n\n\n$LastPageNumber\n\nInteger\n\nThe last page number in the workbook to print\n\n\n\n$PrinterName\n\nString\n\nThe name of the printer to which the Excel document should be printed.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Status\n\nBoolean\n\nA boolean value indicating whether or not the operation was successful.\n\n\n\n\n\nUsage Example:\n\n\n\n\n\n$ExcelObject = ExcelOpenFile(\"c:\\\\book1.xls\");\n\nSetFinalizeFunction(\"Cleanup\"):\n\nExcelPrintFile($ExcelObject,1,1,\"\\\\\\\\stpprt01\\\\RSV_A\");\n\n\n\n\n\nfunction Cleanup()\n\n{\n\nExcelCloseFile($ExcelObject);\n\nEnd;\n\n\n\n}\n\n\n\n\n\nExcelRunMacro\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ExcelRunMacro": {
  "prefix": "ExcelRunMacro",
  "body": [
   "ExcelRunMacro($$Excel,$$MacroName);"
  ],
  "description": "\n\n\n\nThis function will execute a macro in an excel spreadsheet. The macro must take no arguments, and any changes created to the document be applied immediately to the document in memory, but will not be permanently saved until the ExcelCloseFile function has been called.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Excel\n\nObject\n\nAn excel file object that was created using the ExcelOpenFile command.\n\n\n\n$MacroName\n\nString\n\nThe name of the macro to execute.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nUsage Example:\n\n\n\n\n\n$MyExcel = ExcelOpenFile(\"c:\\\\book1.xls\");\n\nSetFinalizeFunction(\"CleanUp\");\n\nExcelRunMacro($MyExcel,\"macro1\");\n\nEnd;\n\nfunction CleanUp()\n\n{\n\nExcelCloseFile($MyExcel);\n\nEnd;\n\n}\n\n\n\n\n\nExcelSearchForValue\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ExcelSearchForValue": {
  "prefix": "ExcelSearchForValue",
  "body": [
   "($$Found,$$Column,$$Row)=ExcelSearchForValue($$Excel,$$Worksheet,$$StartingColumn,$$EndingColumn,$$StartingRow,$$EndingRow,$$ValueToFind,$$MatchCase);"
  ],
  "description": "\n\n\n\nThis function will search the specified range of an excel file to find the location of a particular value. If the value is found, a boolean result indicating that the value was located is returned along with the column name, and row number of the cell that contained the value. If the value is not found inside of the specified search area, it will return a false result, along with a blank string for the $Column value and a 0 (zero) for the $Row return value.\n\n\n\n\n\nImportant Note:\n\nThe search value must be a literal cell value and can't be the result of a formula.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Excel\n\nObject\n\nAn excel file object that was created using the ExcelOpenFile command.\n\n\n\n$Worksheet\n\nInteger\n\nThe index of the worksheet to find, the first worksheet value starts at '1'.\n\n\n\n$StartingColumn\n\nString\n\nThe first column to include in the search region\n\n\n\n$EndingColumn\n\nString\n\nThe final column to include in the search region\n\n\n\n$StartingRow\n\nInteger\n\nThe first row to include in the search region.\n\n\n\n$EndingRow\n\nInteger\n\nThe final row to include in the search region.\n\n\n\n$ValueToFind\n\nString, Float, Integer,Boolean\n\nThe value to find in the spreadsheet.\n\n\n\n$MatchCase\n\nBoolean\n\nSpecifies whether or not a case sensitive search is done. If this variable is set to true, only exact case-matches will be returned.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Found\n\nBoolean\n\nA boolean value indicating whether or not the search string was located inside of the specified search area of the spreadsheet.\n\n\n\n$Column\n\nString\n\nThe column name in which the first match of the search value was located.\n\n\n\n$Row\n\nInteger\n\nThe row number in which the first match of the search value was located.\n\n\n\n\n\nUsage Example:\n\n$Excel = ExcelOpenFile(\"C:\\\\Agilent RF Tester.xls\");\n\n($Found,$Column,$Row) = ExcelSearchForValue($Excel,1,\"A\",\"G\",1,100,\"Labor\",\"FALSE\");\n\nUpdateStatus($Found);\n\nUpdateStatus($Column);\n\nUpdateStatus($Row);\n\nExcelCloseFile($Excel);\n\n\n\n\n\nExcelSetCell\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ExcelSetCell": {
  "prefix": "ExcelSetCell",
  "body": [
   "ExcelSetCell($$ExcelObject,$$WorksheetNumber,$$Column,$$Row,$$SetText);"
  ],
  "description": "\n\nThis function sets the contents of the cell specified by the $Column and $Row parameters on the worksheet specified by the $WorksheetNumber parameter. The content of the cell is in $SetText as a string variable.\n\nNote: The Jabil Test Microsoft Excel file manipulation functions rely on the object model exposed via COM by the Microsoft Office suite. In order to use these functions, Microsoft Office must be installed on the PC running Jabil Test.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ExcelObject\n\nObject\n\nA handle to the Excel workbook opened by the ExcelOpenFile function.\n\n\n\n$WorksheetNumber\n\nInteger\n\nThe number of the worksheet page for the cell. The first worksheet in the workbook starts at 1.\n\n\n\n$Column\n\nString\n\nThe column of the cell to change\n\n\n\n$Row\n\nInteger\n\nThe row number of the cell to change\n\n\n\n$SetText\n\nString\n\nThe new contents for the cell\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\nExcelSetCell($ExcelObject,1,\"A\",5, \"Jabil\");\n\n\n\n\n\nExcelSetRange\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ExcelSetRange": {
  "prefix": "ExcelSetRange",
  "body": [
   "ExcelSetRange($$excelHandle,$$worksheet,$$startColumn,$$startRow,$$endColumn,$$endRow,$$dataArray);"
  ],
  "description": "\n\nThis function will take an array of data and place it in the specified range of cells on the specified worksheet of the previously opened Excel file. The file needs to have been opened with the ExcelOpenFile function.\n\n\n\nRemarks:\n\n\u00b7 This function uses the Microsoft Office COM interface, so Microsoft Office must be loaded on the computer using this function.\n\n\u00b7 The data must be a 2-D array, even if only one column is specified.\n\n\u00b7 The size of the data must match the size of the selected area of cells on the spreadsheet.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$excelHandle\n\nObject\n\nA reference to the Excel file that was previously opened.\n\n\n\n$worksheet\n\nInteger\n\nThe number of the worksheet to send the data to. Worksheet numbers start at 1.\n\n\n\n$startColumn\n\nString\n\nThe leftmost column of the cells to send data to. Columns are listed by letter ('A', 'B', etc.)\n\n\n\n$startRow\n\nInteger\n\nThe topmost row of the cells to send data to.\n\n\n\n$endColumn\n\nString\n\nThe rightmost column of the cells to send data to. Columns are listed by letter ('A', 'B', etc.)\n\n\n\n$endRow\n\nInteger\n\nThe bottommost row of cells to send data to.\n\n\n\n$dataArray\n\nArray\n\nA 2-D numeric or string array of data to send to the specified range of cells.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n// Open the Excel File.\n\n$excelFile = \"C:\\Files\\DataFile.xls\";\n\n$excelHandle = ExcelOpenFile($excelFile);\n\n\n\n\n\n// Send data to cells E5 to F20.\n\n// Assumed: $dataArray has the correct size.\n\n$worksheet = 1;\n\n$startcolumn = \"E\";\n\n$startRow = 5;\n\n$endColumn = \"F\";\n\n$endRow = 20;\n\nExcelSetRange($excelHandle, $worksheet, $startColumn, $startRow, $endColumn, $endRow, $dataArray);\n\n\n\n\n\nCompressFile\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS CompressFile": {
  "prefix": "CompressFile",
  "body": [
   "$$success=CompressFile($$sourceFolder,$$destinationZip);"
  ],
  "description": "\n\nThis function will compress a folder or file and place the compressed ZIP file in the destination location.\n\n\n\n\n\nRemarks:\n\nThis function will always pass. The $success boolean will indicate whether to operation was successful.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$sourceFolder\n\nString\n\nThe path to the folder or file to be compressed.\n\n\n\n$destinationZip\n\nString\n\nThe location to save the compressed file to.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$success\n\nBoolean\n\nWhether the file was compressed successfully.\n\n\n\n\n\nExample:\n\n\n\n\n\n// Set source and destination variables.\n\n$source = \"C:\\\\Temp\\\\Folder_To_Compress\";\n\n$destination = \"C:\\\\Temp\\\\CompressedFolder.zip\";\n\n\n\n// Compress the folder.\n\n$success = CompressFile($source, $destination);\n\n\n\n\n\nExtractFile\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ExtractFile": {
  "prefix": "ExtractFile",
  "body": [
   "$$success=ExtractFile($$sourceZip,$$destinationFolder);"
  ],
  "description": "\n\nThis function will decompress a folder or file and place the files in the destination location.\n\n\n\n\n\nRemarks:\n\nThis function will always pass. The $success boolean will indicate whether to operation was successful.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$sourceZip\n\nString\n\nThe path to the zip file to decompress.\n\n\n\n$destinationFolder\n\nString\n\nThe location to save the decompressed files to.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$success\n\nBoolean\n\nWhether the files were decompressed successfully.\n\n\n\n\n\nExample:\n\n\n\n\n\n// Set source and destination variables.\n\n$source = \"C:\\\\Temp\\\\CompressedFolder.zip\";\n\n$destination = \"C:\\\\Temp\\\\Folder_To_DeCompress_To\";\n\n\n\n// Decompress the folder.\n\n$success = ExtractFile($source, $destination);\n\n\n\n\n\nCheckDirectoryExists\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS CheckDirectoryExists": {
  "prefix": "CheckDirectoryExists",
  "body": [
   "$$exists=CheckDirectoryExists($$pathName);"
  ],
  "description": "\n\nThis function returns a boolean value indicating whether or not the specified directory is present in the file system.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$pathName\n\nString\n\nThe path name to verify.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$exists\n\nBoolean\n\nSpecifies whether or not the directory is present on the file system.\n\n\n\n\n\nExample:\n\n\n\n\n\n// Check if a directory exists.\n\n$exists = CheckDirectoryExists(\"C:\\\\windows\");\n\nUpdateStatus($exists);\n\n\n\n$exists = CheckDirectoryExists(\"C:\\\\winnt\");\n\nUpdateStatus($exists);\n\n\n\n\n\nCheckFileExists\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS CheckFileExists": {
  "prefix": "CheckFileExists",
  "body": [
   "$$fileExists=CheckFileExists($$filePathAndName,$$action);"
  ],
  "description": "\n\nThis function checks to see if the file specified in the $filePathAndName argument exists in the file system. In the event that the file exists, the script returns the status specified in the $action argument.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$filePathAndName\n\nString\n\nThe file path and file name of the file. For example \"c:\\test\\testfile.txt\"\n\n\n\n$action\n\nString\n\nThe test status to return in the event that the file does exist. Valid values for the action argument are:\n\n\"PASS\"\n\n\"FAIL\"\n\n\"ABORT\"\n\n\"RETURNONLY\" = If specified, no action is taken, only the Boolean result is returned to the script.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$fileExists\n\nBoolean\n\nReturns true if the file exists, false in the event that the file does not exist.\n\n\n\n\n\nCheckFileInUse\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS CheckFileInUse": {
  "prefix": "CheckFileInUse",
  "body": [
   "$$inUse=CheckFileInUse($$fileName);"
  ],
  "description": "\n\nThis function checks if the specified file is locked because another process is using it. This function works for files in network, shared or local folders.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$fileName\n\nString\n\nThe file path/name. If no file path is specified, it's assumed that the file is located in the same directory as the JabilTest executable.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$inUse\n\nBoolean\n\nIndicated if the file is in use. A return of \"true\" indicates that the file is being used by another process.\n\n\n\n\n\nUsage Example:\n\n$fName = \"C:\\\\Temp\\\\File Info Test.txt\";\n\n\n\n\n\n// Loop until file is available\n\nLabel CheckLoop:\n\n$inUse = CheckFileInUse($fName);\n\n$strOut = \"File in Use = \" + $inUse;\n\nUpdateStatus($strOut);\n\n\n\n\n\nif ($inUse)\n\n{\n\nSleep(5);\n\ngoto CheckLoop;\n\n}\n\n\n\n\n\nUpdateStatus(\"\\r\\nFile is available.\");\n\n\n\n\n\nCreateDirectory\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS CreateDirectory": {
  "prefix": "CreateDirectory",
  "body": [
   "CreateDirectory($$PathName);"
  ],
  "description": "\n\n\n\nThis function creates the specified file path on the file system. If the directory is already present, or if the directory could not be created due to insufficient permissions, or a read-only file system, then the function returns a failure. If the directory is created successfully, the function will pass.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$PathName\n\nString\n\nThe path name to create\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nUsage Example:\n\n\n\n\n\n// Create a Directory\n\nCreateDirectory(\"c:\\\\mynewdirectory\\\\\");\n\n\n\n\n\nDirectoryCopy\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS DirectoryCopy": {
  "prefix": "DirectoryCopy",
  "body": [
   "DirectoryCopy($$sourceDir,$$destinationDir,$$overWrite,$$includeSubs);"
  ],
  "description": "\n\nThis function will copy the source directory and all of the files in it to the destination and create the destination directory if necessary. It can optionally overwrite files in the destination directory and can optionally include all subdirectories as well.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$sourceDir\n\nString\n\nThe path of the source directory.\n\n\n\n$destinationDir\n\nString\n\nThe path of the destination directory.\n\n\n\n$overWrite\n\nBoolean\n\nIf set to true, any files of the same names in the destination directory will be overwritten.\n\n\n\n$includeSubs\n\nBoolean\n\nIf set to true, all subdirectories of the main directory will also be copied.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n// Set up the directories to copy with all subdirectories as well.\n\n$srcDir = \"C:\\\\Temp\\\\Test Dir\";\n\n$destDir = \"C:\\\\Temp\\\\Backup\";\n\n$over = true;\n\n$subs = true;\n\n\n\n\n\nDirectoryCopy($srcDir, $destDir, $over, $subs);\n\n\n\n\n\nDirectoryDelete\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS DirectoryDelete": {
  "prefix": "DirectoryDelete",
  "body": [
   "DirectoryDelete($$directory,$$includeSubs);"
  ],
  "description": "\n\nThis function will delete the directory and all of the files in it and can optionally delete all subdirectories and their contents as well.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$directory\n\nString\n\nThe path of the directory to delete.\n\n\n\n$includeSubs\n\nBoolean\n\nIf set to true, all subdirectories and their contents will be deleted as well.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n// Set up the directory to delete with all subdirectories as well.\n\n$dir = \"C:\\\\Temp\\\\Test Dir\";\n\n$subs = true;\n\n\n\n\n\nDirectoryDelete($dir, $subs);\n\n\n\n\n\nFileBuildPath\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS FileBuildPath": {
  "prefix": "FileBuildPath",
  "body": [
   "$$combinedPath=FileBuildPath($$filePath1,$$filePath2);"
  ],
  "description": "\n\nThis function will combine two strings as a Windows path. The string supplied can include backslashes, or not. This function will also resolve relative path elements.\n\n\n\n\n\nNote: The backslash character is a delimiter for control characters, so to put a backslash into a string, two need to be added (example \"\\\\\").\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$filePath1\n\nString\n\nThe first part of the file path to return.\n\n\n\n$filePath2\n\nString\n\nThe second part of the file path to return.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$combinedPath\n\nString\n\nA string that includes the previous two file path parts combined with the appropriate path delimiter (\"\\\").\n\n\n\n\n\nExamples:\n\n\n\n\n\n// Set up the parts that we are going to combine.\n\n\n\n\n\n$path1 = \"C:\";\n\n$path2 = \"Temp\\\\\";\n\n$path3 = \"testfile.txt\";\n\n\n\n\n\n// Combine them, two parts at a time.\n\n\n\n\n\n$combine1 = FileBuildPath($path1, $path2); // Returns: \"C:\\\\Temp\\\\\"\n\n$fullPath = FileBuildPath($combine1, $path3); // Returns: \"C:\\\\Temp\\\\testfile.txt\"\n\n\n\n\n\n// Set up a path to demonstrate relative path resolution.\n\n\n\n\n\n$startPath = \"C:\\\\Temp\\\\SubFolder1\\\\Internal_Folder\\\\testfile.txt\";\n\n$newPath = \"..\\\\..\\\\..\\\\SubFolder2\\\\newTestFile.txt\"; // Back up 3 levels and add new path.\n\n\n\n\n\n// Now combine the two elements.\n\n\n\n\n\n$newPath = FileBuildPath($startPath, $newPath); // Returns: \"C:\\\\Temp\\\\SubFolder2\\\\newTestFile.txt\"\n\n\n\n\n\nFileCopy\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS FileCopy": {
  "prefix": "FileCopy",
  "body": [
   "FileCopy($$SourceFile,$$DestinationFile,$$Overwrite);"
  ],
  "description": "\n\nThis function copies the file located at the source file location to the location specified by the destination file. If a file already exists at the destination location and the $Overwrite argument is set to false, the test function will generate a failure.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$SourceFile\n\nString\n\nThe path to the source file\n\n\n\n$DestinationFile\n\nString\n\nThe desired path and filename for the destination file\n\n\n\n$Overwrite\n\nBoolean\n\nSpecifies whether or not you want to overwrite an existing file if a file with the name and path of the destination file already exists.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\nFileCopy(\"c:\\\\mysourcedir\\\\mysourcefile.txt\",\"c:\\\\mydestdir\\\\mydestfile.txt\",\"TRUE\");\n\n\n\n\n\nFileDelete\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS FileDelete": {
  "prefix": "FileDelete",
  "body": [
   "FileDelete($$FilePath);"
  ],
  "description": "\n\nThis function deletes the file specified by the $FilePath argument. In the event that the file doesn't exist, no action is taken. If the file can't be deleted for any reason, a failure is generated.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$FilePath\n\nString\n\nThe complete file path to the file you want deleted.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\nFileDelete(\"c:\\\\textfile.txt\");\n\n\n\n\n\nFileGetInfo\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS FileGetInfo": {
  "prefix": "FileGetInfo",
  "body": [
   "($$CreateDate,$$CreateTime,$$LastAccessDate,$$LastAccessTime,$$LastWriteDate,$$LastWriteTime,$$FileLength,$$Normal,$$ReadOnly,$$Hidden,$$Archive)=FileGetInfo($$FileName);"
  ],
  "description": "\n\nThis function retrieves the information concerning a given file from the file system. If the file is not present, the function returns a failure.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$FileName\n\nString\n\nThe file path/name. If no file path is specified, it's assumed that the file is located in the same directory as the JabilTest executable.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$CreateDate\n\nString\n\nThe creation date of the file.\n\n\n\n$CreateTime\n\nString\n\nThe creation time of the file.\n\n\n\n$LastAccessDate\n\nString\n\nThe date the file was last accessed.\n\n\n\n$LastAccessTime\n\nString\n\nThe time that the file was last accessed\n\n\n\n$LastWriteDate\n\nString\n\nThe date that the file was last written.\n\n\n\n$LastWriteTime\n\nString\n\nThe time that the file was last written\n\n\n\n$FileLength\n\nInteger\n\nThe number of bytes contained in the file.\n\n\n\n$Normal\n\nBoolean\n\nSpecifies if the Normal File Attribute is applied to the file.\n\n\n\n$ReadOnly\n\nBoolean\n\nSpecifies if the Read Only File Attribute is applied to the file.\n\n\n\n$Hidden\n\nBoolean\n\nSpecifies if the Hidden File Attribute is applied to the file.\n\n\n\n$Archive\n\nBoolean\n\nSpecifies if the Archive File Attribute is applied to the file.\n\n\n\n\n\nUsage Example:\n\n($CreateDate,$CreateTime,$AccessDate,$AccessTime,$WriteDate,$WriteTime,$Length,$Normal,$Hidden,$ReadOnly,$Archive) = FileGetInfo(\"jabiltest.exe\");\n\n\n\n\n\nFileSetAttribute\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS FileSetAttribute": {
  "prefix": "FileSetAttribute",
  "body": [
   "FileSetAttribute($$FileName,$$Attribute,$$Setting);"
  ],
  "description": "\n\nThis function sets or resets a specified attribute for a specified file in the system. If the file is not present, the function returns a failure.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$FileName\n\nString\n\nThe file path/name. If no file path is specified, it's assumed that the file is located in the same directory as the JabilTest executable.\n\n\n\n$Attribute\n\nString\n\nThe name of the attribute to set.\n\nValue: ReadOnly, Hidden, Archive\n\n\n\n$Setting\n\nBoolean\n\nThe setting for the attribute.\n\ntrue = set attribute (turn on)\n\nfalse = reset attribute (turn off)\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n\n\n\n\nFileSetAttribute(\"jabiltest.exe\", \"ReadOnly\", true);\n\n\n\n\n\nFileStripPath\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS FileStripPath": {
  "prefix": "FileStripPath",
  "body": [
   "($$pathPart1,$$pathPart2)=FileStripPath($$filePath);"
  ],
  "description": "\n\nThis function will remove the last part of a file path and return the two pieces. If there is no path delimiter (in Windows: \"\\\"), then the entire path will be returned as the first part and the second part will be blank.\n\n\n\n\n\nNote: The backslash character is a delimiter for control characters, so to put a backslash into a string, two need to be added (example \"\\\\\").\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$filePath\n\nString\n\nThe file path to have the last part stripped off of.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$pathPart1\n\nString\n\nThe first part of the path with the second part stripped off.\n\n\n\n$pathPart2\n\nString\n\nThe second part of the path.\n\n\n\n\n\nExample:\n\n\n\n\n\n// Set up the path that we are going to strip apart.\n\n\n\n\n\n$filePath = \"C:\\\\Temp\\\\testfile.txt\";\n\n\n\n\n\n// Strip them apart - one piece at a time.\n\n\n\n\n\n($firstPart, $pathPart3) = FileStripPath($filePath); // Returns: \"C:\\\\Temp\" and \"testfile.txt\"\n\n($pathPart1, $pathPart2) = FileStripPath($firstPart); // Returns: \"C:\\\\\" and \"Temp\\\\\"\n\n\n\n\n\nGetCurrentDirectory\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS GetCurrentDirectory": {
  "prefix": "GetCurrentDirectory",
  "body": [
   "$$Path=GetCurrentDirectory();"
  ],
  "description": "\n\n\n\n\n\nThis function returns the path name containing the currently running JabilTest.exe executable file.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Path\n\nString\n\nThe directory containing the current running executable file.\n\n\n\n\n\nUsage Example:\n\n\n\n\n\n// Get Current Working Directory\n\n$Dir = GetCurrentDirectory();\n\nUpdateStatus($Dir);\n\n\n\n\n\nGetDirectoriesInDirectory\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS GetDirectoriesInDirectory": {
  "prefix": "GetDirectoriesInDirectory",
  "body": [
   "($$DirectoryArray,$$DirectoryCount)=GetDirectoriesInDirectory($$DirectoryPath,$$SearchPattern);"
  ],
  "description": "\n\n\n\n\n\nThis function retrieves an array containing the directory names of each directory in the given directory path which match a given search string. The search string can contain wild cards for matching a particular pattern. If you would like to return all directories in the directory, simply use a '"
 }
,
 "JTS GetFilePathInfo": {
  "prefix": "GetFilePathInfo",
  "body": [
   "($$DirectoryName,$$FileExtension,$$FileName,$$FileNameWithoutExtension,$$FullPath,$$PathRoot,$$HasExtension,$$IsPathRooted)=GetFilePathInfo($$FilePath);"
  ],
  "description": "\n\n\n\n\n\nThis function retrieves the information concerning a given file path from the file system. If the file is not present, the function returns a failure.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$FilePath\n\nString\n\nA string that contains file for directory path information.file path and name.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$DirectoryName\n\nString\n\nThe directory information for the given path.\n\n\n\n$FileExtension\n\nString\n\nReturns the extension portion of the file in the given path.\n\n\n\n$FileName\n\nString\n\nReturns the file name and extension of the specified path string.\n\n\n\n$FileNameWithoutExtension\n\nString\n\nReturns the file name of the given path without the extension.\n\n\n\n$FullPath\n\nString\n\nReturns the absolute path for the specified path string.\n\n\n\n$PathRoot\n\nString\n\nReturns the root information of the given path.\n\n\n\n$HasExtension\n\nBoolean\n\nIndicates if the given path contains a file name with an extension\n\n\n\n$IsPathRooted\n\nBoolean\n\nIndicates if the given path contains absolute or relative path information.\n\n\n\n\n\nUsage Example:\n\n($DirectoryName,$FileExtension,$FileName,$FileNameWithoutExtension,$FullPath,$PathRoot,$HasExtension,$IsPathRooted) = GetFilePathInfo($FilePath);\n\n\n\n\n\nGetFilesInDirectory\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS GetFilesInDirectory": {
  "prefix": "GetFilesInDirectory",
  "body": [
   "($$FileArray,$$FileCount)=GetFilesInDirectory($$DirectoryPath,$$SearchPattern);"
  ],
  "description": "\n\n\n\n\n\nThis function retrieves an array containing the file names of each file in the given directory path which match a given search string. The search string can contain wild cards for matching a particular pattern. If you would like to return all files in the directory, simply use a '"
 }
,
 "JTS IniFile_DeleteKeyInSection": {
  "prefix": "IniFile_DeleteKeyInSection",
  "body": [
   "IniFile_DeleteKeyInSection($$iniPath,$$sectionName,$$keyName);"
  ],
  "description": "\n\nThis function will delete one key in one section of the specified INI file.\n\n\n\n\n\nRemarks:\n\nIf the file, section or key is not found, an error is returned.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$iniPath\n\nString\n\nThe path and file name of the INI file to modify.\n\n\n\n$sectionName\n\nString\n\nThe section to delete a key in.\n\n\n\n$keyName\n\nString\n\nThe key to delete.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n// Set up some variables to use.\n\n$iniPath = \"C:\\\\Test\\\\myProgram.ini\";\n\n$sectionName = \"Second Section\";\n\n$keyName = \"Key To Delete\";\n\n\n\n\n\nIniFile_DeleteKeyInSection($iniPath, $sectionName, $keyName);\n\n\n\n\n\nIniFile_DeleteSection\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS IniFile_DeleteSection": {
  "prefix": "IniFile_DeleteSection",
  "body": [
   "IniFile_DeleteSection($$iniPath,$$sectionName);"
  ],
  "description": "\n\nThis function will delete one section from the specified INI file.\n\n\n\n\n\nRemarks:\n\nIf the file or section is not found, an error is returned.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$iniPath\n\nString\n\nThe path and file name of the INI file to modify.\n\n\n\n$sectionName\n\nString\n\nThe section to delete.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n// Set up some variables to use.\n\n$iniPath = \"C:\\\\Test\\\\myProgram.ini\";\n\n$sectionName = \"Second Section\";\n\n\n\n\n\nIniFile_DeleteSection($iniPath, $sectionName);\n\n\n\n\n\nIniFile_ReadAllKeyNamesInSection\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS IniFile_ReadAllKeyNamesInSection": {
  "prefix": "IniFile_ReadAllKeyNamesInSection",
  "body": [
   "$$keyNames=IniFile_ReadAllKeyNamesInSection($$iniPath,$$sectionName);"
  ],
  "description": "\n\nThis function will return the names of all of the keys in the specified section of the INI file.\n\n\n\n\n\nRemarks:\n\nThe names returned are in a 1D array - even if there is only one key name returned.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$iniPath\n\nString\n\nThe path and file name of the INI file to read.\n\n\n\n$sectionName\n\nString\n\nThe name of the section in the INI file to read the key names from.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$keyNames\n\nString Array\n\nThe names of all of the keys in the specified section of the INI file.\n\n\n\n\n\nExample:\n\n// Set up some variables to use.\n\n$iniPath = \"C:\\\\Test\\\\myProgram.ini\";\n\n$sectionName = \"Second Section\";\n\n\n\n\n\n$keyNames = IniFile_ReadAllKeyNamesInSection($iniPath, $sectionName);\n\n\n\n\n\n// Now print all of the key names\n\n$numKeys = ArrayGetLength($keyNames);\n\n\n\n\n\nUpdateStatus(\"Key Names:\\n\");\n\n\n\n\n\n$lc = 0;\n\nwhile ($lc < $numKeys)\n\n{\n\n$keyName = Array1DGetValue($keyNames, $lc);\n\nUpdateStatus($keyName);\n\n$lc = $lc + 1;\n\n}\n\n\n\n\n\nIniFile_ReadAllSectionNames\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS IniFile_ReadAllSectionNames": {
  "prefix": "IniFile_ReadAllSectionNames",
  "body": [
   "$$sectionNames=IniFile_ReadAllSectionNames($$iniPath);"
  ],
  "description": "\n\nThis function will return the names of all of the sections in the specified INI file.\n\n\n\n\n\nRemarks:\n\nThe names returned are in a 1D array - even if there is only one section name returned.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$iniPath\n\nString\n\nThe path and file name of the INI file to read.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$sectionNames\n\nString Array\n\nThe names of all of the sections in the specified INI file.\n\n\n\n\n\nExample:\n\n// Set up some variables to use.\n\n$iniPath = \"C:\\\\Test\\\\myProgram.ini\";\n\n\n\n\n\n$sectNames = IniFile_ReadAllSectionNames($iniPath);\n\n\n\n\n\n// Now print all of the section names\n\n$numSects = ArrayGetLength($sectNames);\n\n\n\n\n\nUpdateStatus(\"Section Names:\\n\");\n\n\n\n\n\n$lc = 0;\n\nwhile ($lc < $numSects)\n\n{\n\n$sName = Array1DGetValue($sectNames, $lc);\n\nUpdateStatus($sName);\n\n$lc = $lc + 1;\n\n}\n\n\n\n\n\nIniFile_ReadKeyInSection\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS IniFile_ReadKeyInSection": {
  "prefix": "IniFile_ReadKeyInSection",
  "body": [
   "$$keyValue=IniFile_ReadKeyInSection($$iniPath,$$sectionName,$$keyName);"
  ],
  "description": "\n\nThis function will return the value from the key in the specified section of the specified INI file.\n\n\n\n\n\nRemarks:\n\nIf the file, section or key is not found, the function will fail the test.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$iniPath\n\nString\n\nThe path and file name of the INI file to read.\n\n\n\n$sectionName\n\nString\n\nThe name of the section to find the key in.\n\n\n\n$keyName\n\nString\n\nThe name of the key to return the value of.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$keyValue\n\nString\n\nThe value of the key that was read.\n\n\n\n\n\nExample:\n\n// Set up some variables to use.\n\n$iniPath = \"C:\\\\Test\\\\myProgram.ini\";\n\n$section = \"First Section\";\n\n$key = \"TheKeyToEverything\";\n\n\n\n\n\n$value = IniFile_ReadKeyInlSection($iniPath, $section, $key);\n\n\n\n\n\nIniFile_WriteKeyToSection\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS IniFile_WriteKeyToSection": {
  "prefix": "IniFile_WriteKeyToSection",
  "body": [
   "$$keyValue=IniFile_WriteKeyToSection($$iniPath,$$sectionName,$$keyName,$$keyValue);"
  ],
  "description": "\n\nThis function will write the value to the key in the specified section of the specified INI file.\n\n\n\n\n\nRemarks:\n\nIf the file, section and/or key is not found, the function will create them. This can be used to create an INI file.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$iniPath\n\nString\n\nThe path and file name of the INI file to write to.\n\n\n\n$sectionName\n\nString\n\nThe name of the section to find or create the key in.\n\n\n\n$keyName\n\nString\n\nThe name of the key to change the value of or to create.\n\n\n\n$keyValue\n\nString\n\nThe value to set the key to.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$keyValue\n\nString\n\nThe value of the key that was written.\n\n\n\n\n\nExample:\n\n// Set up some variables to use.\n\n$iniPath = \"C:\\\\Test\\\\myProgram.ini\";\n\n$section = \"Life Universe\";\n\n$key = \"TheKeyToEverything\";\n\n$value = \"42\";\n\n\n\n\n\n$valueOut = IniFile_WriteKeyTolSection($iniPath, $section, $key, $value);\n\n\n\n\n\nReadIniFile\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ReadIniFile": {
  "prefix": "ReadIniFile",
  "body": [
   "$$name=ReadIniFile($$Path,$$Section,$$Item);"
  ],
  "description": "\n\nThis function isprovided only for compatibility with 16-bit Windows-based applications. It is adviced to use XML instead. This Function uses the kernel32.dll.\n\nThis function returns the result $name of a reading to an INI file $Path .\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Path\n\nString\n\nThe path of where the ini file is located\n\n\n\n$Section\n\nString\n\nThe Section to look into\n\n\n\n$Item\n\nString\n\nThe Item in that section to look for\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Name\n\nString\n\nThe value of the found item\n\n\n\n\n\nExample:\n\n$checkValue = ReadIniFile(\"c:\\\\test.ini\",\"info\",\"name\");\n\n\n\n\n\nWriteIniFile\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS WriteIniFile": {
  "prefix": "WriteIniFile",
  "body": [
   "$$Name=WriteIniFile($$Path,$$Section,$$Item,$$Value);"
  ],
  "description": "\n\nThis function isprovided only for compatibility with 16-bit Windows-based applications. It is adviced to use XML instead.\n\nThis Function uses the kernel32.dll.This function writes the $value into the Ini File $Path beneath Section $Section and Item $Item .\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Path\n\nString\n\nThe path of where the ini file is or should be created\n\n\n\n$Section\n\nString\n\nThe Section to look for or to create\n\n\n\n$Item\n\nString\n\nThe Item in that section to look for or to create\n\n\n\n$Value\n\nString\n\nThe value to write into that section\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Name\n\nString\n\nThe value written into the ini file\n\n\n\n\n\nExample:\n\n$Name = WriteIniFile(\"c:\\\\test.ini\",\"section\",\"item\",\"something\");\n\n\n\n\n\nMicrosoftWord_Close\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS MicrosoftWord_Close": {
  "prefix": "MicrosoftWord_Close",
  "body": [
   "MicrosoftWord_Close($$file);"
  ],
  "description": "\n\nThis function closes the Microsoft Word Document, which was opened using the MicrosoftWord_OpenDocument function. If this function is not called before ending the test script, an instance of Microsoft Word will remain running on the computer.\n\n\n\n\n\nNote: In order to use these functions, the computer must have Microsoft Office 2003/07 installed.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$file\n\nObject\n\nFile Object which specifies the word document to be closed.\n\n\n\n\n\nExample:\n\n$file = MicrosoftWord_OpenDocument(\"C:\\\\Documents and Settings\\\\dantuh\\\\Desktop\\\\Word_Doc1.doc\",True);\n\nMicrosoftWord_Close($file);\n\n\n\n\n\nMicrosoftWord_FindAndReplace\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS MicrosoftWord_FindAndReplace": {
  "prefix": "MicrosoftWord_FindAndReplace",
  "body": [
   "MicrosoftWord_FindAndReplace($$file,$$textToFind,$$textToReplace);"
  ],
  "description": "\n\nThis function finds a particular string in a Microsoft Word Document previously opened using the MicrosoftWord_OpenDocument function and replaces it with the given string..\n\n\n\n\n\nNote: In order to use these functions, the computer must have Microsoft Office 2003/07 installed.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$file\n\nObject\n\nFile Object to access the File.\n\n\n\n$textToFind\n\nString\n\nSpecifies the string that needs to found\n\n\n\n$textToReplace\n\nString\n\nSpecifies the string that needs to be replaced with.\n\n\n\n\n\nExample:\n\n\n\n\n\n$file = MicrosoftWord_OpenDocument(\"C:\\\\Documents and Settings\\\\dantuh\\\\Desktop\\\\Word_Doc1.doc\",True);\n\nMicrosoftWord_FindAndReplace($file,\"John\",\"Peter\");\n\nMicrosoftWord_Close($file);\n\n\n\n\n\nMicrosoftWord_OpenDocument\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS MicrosoftWord_OpenDocument": {
  "prefix": "MicrosoftWord_OpenDocument",
  "body": [
   "$$file=MicrosoftWord_OpenDocument($$FileName,$$Visibility);"
  ],
  "description": "\n\nThis function opens up a Microsoft Word Document specified by the $FileName parameter. The file must already exist on the file system.\n\n\n\n\n\nNote: In order to use these functions, the computer must have Microsoft Office 2003/07 installed.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$FileName\n\nString\n\nSpecifies the Path to access the File.\n\n\n\n$Visibility\n\nBoolean\n\nSpecifies to show the File or Not.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$file\n\nObject\n\nThe File Object that was opened by the function.\n\n\n\n\n\nExample:\n\n\n\n\n\n$file = MicrosoftWord_OpenDocument(\"C:\\\\Documents and Settings\\\\dantuh\\\\Desktop\\\\Word_Doc1.doc\",True);\n\n\n\n\n\nMicrosoftWord_Close($file);\n\n\n\n\n\nMicrosoftWord_RunMacro\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS MicrosoftWord_RunMacro": {
  "prefix": "MicrosoftWord_RunMacro",
  "body": [
   "MicrosoftWord_RunMacro($$file,$$macro);"
  ],
  "description": "\n\nThis function runs an existing macro in a Microsoft Word Document previously opened using the MicrosoftWord_OpenDocument function.\n\n\n\n\n\nNote: In order to use these functions, the computer must have Microsoft Office 2003/07 installed.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$file\n\nObject\n\nFile Object to access the File.\n\n\n\n$macro\n\nString\n\nThe name of the macro to be run\n\n\n\n\n\nExample:\n\n\n\n\n\n$file = MicrosoftWord_OpenDocument(\"C:\\\\Documents and Settings\\\\dantuh\\\\Desktop\\\\Word_Doc1.doc\",True);\n\nMicrosoftWord_RunMacro($file,\"testMacro\");\n\nMicrosoftWord_Close($file);\n\n\n\n\n\nFileReadAllText\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS FileReadAllText": {
  "prefix": "FileReadAllText",
  "body": [
   "$$FileContents=FileReadAllText($$FileName);"
  ],
  "description": "\n\nThis function retrieves all the lines of text inside the given files, and returns it as a single string. If the file is not present, the function returns a failure.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$FileName\n\nString\n\nThe file path/name. If no file path is specified, it's assumed that the file is located in the same directory as the JabilTest executable.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$FileContents\n\nString\n\nThe entire text of the supplied file.\n\n\n\n\n\nUsage Example:\n\n\n\n\n\n$FileContents = FileReadAllText(\"c:\\\\M3_with_DPS_Abril_14.hex\");\n\nUpdateStatus($FileContents);\n\nEnd;\n\n\n\n\n\nFileReadClose\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS FileReadClose": {
  "prefix": "FileReadClose",
  "body": [
   "FileReadClose($$fileObject);"
  ],
  "description": "\n\nThis function closes the $fileObject on the local file system. A passing result is always returned in the event that a valid $fileObject has been passed to the function, otherwise a failure is generated.\n\n\n\nRemarks:\n\nThe file must already have been opened with FileReadOpen.\n\n\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$textFileObject\n\nObject\n\nThe file object that was previously opened using FileReadOpen.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n\n\n\n\nFileReadClose($myFile);\n\n\n\n\n\nFileReadLine\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS FileReadLine": {
  "prefix": "FileReadLine",
  "body": [
   "$$fileString=FileReadLine($$fileObject);"
  ],
  "description": "\n\nThis function reads the contents of the current file from the current pointer location up to the next newline or EOF character. This function always generates a passing result as long as the supplied $fileObject is a valid FileReader object. In the event that the file has reach EOF, an empty string is returned.\n\n\n\nRemarks:\n\nThe file must already have been opened with FileReadOpen.\n\n\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$fileObject\n\nObject\n\nThe file object that was previously opened using FileReadOpen.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$myString\n\nString\n\nThe contents of the file from the file pointers current location up to the next newline or EOF character.\n\n\n\n\n\nExample:\n\n\n\n\n\n$myString = FileReadLine($myFile);\n\n\n\n\n\nFileReadOpen\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS FileReadOpen": {
  "prefix": "FileReadOpen",
  "body": [
   "$$fileObject=FileReadOpen($$fileName);"
  ],
  "description": "\n\nThis function opens a file on the local testers file system for reading. In the event that the file can't be found or accessed, the function returns a failure. Otherwise, a pass result is returned to the executive.\n\n\n\nRemarks:\n\nIf the file is not found, the test will be failed.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$fileName\n\nString\n\nThe name and path of the file to be opened.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$fileObject\n\nObject\n\nThe returned variable is an Object of type 'FileReader'.\n\n\n\n\n\nExample:\n\n\n\n\n\n$fileName = \"c:\\\\TestFiles\\\\FileToSearch.txt\";\n\n\n\n$fileObj = FileReadOpen($fileName);\n\n\n\n\n\nFileSearchTextAndRead\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS FileSearchTextAndRead": {
  "prefix": "FileSearchTextAndRead",
  "body": [
   "($$lineNumber,$$lineText)=FileSearchTextAndRead($$textFileObject,$$textToFind);"
  ],
  "description": "\n\nThis function reads the specified text file a line at a time and searches each line for the specified text. when the text is found, the line number and the text line are returned.\n\n\n\nRemarks:\n\nThe file must already have been opened with FileReadOpen.\n\n\n\nIf the search text is not found in the text file, the test will be failed.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$textFileObject\n\nObject\n\nThe file object that was previously opened using FileReadOpen.\n\n\n\n$textToFind\n\nString\n\nThe text to search each line for.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$lineNumber\n\nInteger\n\nThe number of the line that the text was found in (first line is line 0).\n\n\n\n$lineText\n\nString\n\nThe line of text from the file that the search text was found in.\n\n\n\n\n\nExample:\n\n\n\n\n\n$fileName = \"c:\\\\TestFiles\\\\FileToSearch.txt\";\n\n$fileObj = FileReadOpen($fileName);\n\n\n\n$searchText = \"find this\";\n\n\n\n($lineNum, $lineText) = FileSearchTextAndRead($fileObj, $searchText);\n\n\n\n$outStr = \"Text was found on line \" + $lineNum;\n\nUpdateStatus($outStr);\n\n$outStr = \"The text of the line it was found in is: \" + $lineText;\n\nUpdateStatus($outStr);\n\n\n\nEnd;\n\n\n\n\n\nFileWrite\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS FileWrite": {
  "prefix": "FileWrite",
  "body": [
   "FileWrite($$fileObject,$$writeString);"
  ],
  "description": "\n\nThis function writes the contents of the $writeString argument to the current FileWriter object passed in as the first argument. Any character sequence of \"\\n\" in the $writeString parameter is converted to a new line character. In the event that the string is written successfully to the file, a passing result is returned, otherwise a failure result is generated.\n\n\n\nRemarks:\n\nThe file must already have been opened using the FileWriteOpen function.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$fileObject\n\nObject\n\nThe open FileWriter object.\n\n\n\n$writeString\n\nString\n\nThe string to be written to the FileWriter object.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n\n\n\n\n// Open and write to a file.\n\n$fileHandle = FileWriteOpen(\"C:\\\\temp\\\\myfile.txt\", \"NEW\");\n\n\n\nFileWrite($fileHandle, \"String goes here\\n\");\n\n\n\n\n\nFileWriteClose\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS FileWriteClose": {
  "prefix": "FileWriteClose",
  "body": [
   "FileWriteClose($$fileObject);"
  ],
  "description": "\n\nThis function closes the $fileObject on the local file system. A passing result is always returned in the event that a valid $fileObject has been passed to the function, otherwise a failure is generated.\n\n\n\nRemarks:\n\nThe file must already have been opened using the FileWriteOpen function.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$fileObject\n\nObject\n\nThe open FileWriter object.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n\n\n\n\n// Open and close a file.\n\n$fileHandle = FileWriteOpen(\"C:\\\\temp\\\\myfile.txt\", \"NEW\");\n\n\n\nFileWriteClose($fileHandle);\n\n\n\n\n\nFileWriteOpen\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS FileWriteOpen": {
  "prefix": "FileWriteOpen",
  "body": [
   "$$fileObject=FileWriteOpen($$fileName,$$writeMode);"
  ],
  "description": "\n\nThis function opens a file on the local tester's file system for writing or appending. In the event that the file can't be created or opened, the function returns a failure. Otherwise, a pass result is returned to the executive.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$fileName\n\nString\n\nThe name and path of the file to be opened.\n\n\n\n$writeMode\n\nString\n\nA switch to determine how the file should be opened for writing. The supported values are: NEW = creates or overwrites an existing file for writing.\n\nAPPEND = creates a new file, or opens an existing file while preserving its existing contents.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$fileObject\n\nObject\n\nThe returned variable is an Object of type \"FileWriter\".\n\n\n\n\n\nExample:\n\n\n\n\n\n// Open and close a file.\n\n$fileHandle = FileWriteOpen(\"C:\\\\temp\\\\myfile.txt\", \"NEW\");\n\n\n\n\n\nXMLReadConfig\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS XmlReadConfig": {
  "prefix": "XmlReadConfig",
  "body": [
   "$$value=XmlReadConfig($$filePath,$$PCName,$$projectName,$$diversityKey,$$parameter,$$updateStatus);"
  ],
  "description": "\n\nThis function reads a value from the XML config file. It is meant to be used as a generic config file.\n\nThere are sections for PCNAME, PROJECTNAME and DIVERSITY\n\nIn that way it is possible to run a project on more then one PC (PCNAME) and still have its own PC dedicated parameters\n\nIt is also possible to have different versions (DIVERSITY) of the project running , each with its own parameters.\n\nThe file can also be use to manage more projects within the same file (PROJECTNAME)\n\nSee the example file : XML Example\n\nThe XML file must be built up according to the following description:\n\nThe mandatory sections are PCNAME, PROJECTNAME, DIVERSITY.\n\nThey should be implemented as in the example, same order and syntax.\n\nWithin this DIVERSITY section, it is allowed to put whatever is accepted by XML syntax and is needed for your diversity.\n\nBe careful to use unique names for each keys as it is the first occurrence of a key that is returned.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$filePath\n\nString\n\nThe path + FileName\n\n\n\n$PCName\n\nString\n\nThe PCNAME or TesterID\n\n\n\n$projectName\n\nString\n\nThe ProjectName\n\n\n\n$diversityKey\n\nString\n\nThe Diversity Key\n\n\n\n$parameter\n\nString\n\nThe Parameter to be read out\n\n\n\n$updateStatus\n\nString\n\nUpdate of the Status Display \"0\" means NO, \"1\" means YES\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$value\n\nString/b>\n\nThe actual value read out\n\n\n\n\n\nExample:\n\n\n\n\n\n$filePath = \"c:\\\\scripts\\\\ruif.xml\";\n\n$pcName = \"MYPC1\";\n\n$projectName = \"MEDICAL RUIF\";\n\n$diversityKey = \"A\";\n\n$parameter = \"PMKey1\";\n\n$updateStatus = \"1\";\n\n\n\n$value = XmlReadConfig($filePath, $pcName, $projectName, $diversityKey, $parameter, $updateStatus);\n\n\n\n\n\niFactory_AbortWIP\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS iFactory_AbortWIP": {
  "prefix": "iFactory_AbortWIP",
  "body": [
   "($$routeIds,$$routeNames)=iFactory_AbortWIP($$iFactoryToken);"
  ],
  "description": "\n\nThis function will abort an already started WIP.\n\n\n\n\n\nRemarks:\n\nA connection to the API server must already have been established with iFactory_Connect.\n\nThe WIP must already have been started with iFactory_StartWIP.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$iFactoryToken\n\nObject\n\nThe object returned by the iFactory_StartWIP function.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$routeIds\n\nString Array\n\nThe list of queued route step IDs for the next steps of the aborted WIP.\n\n\n\n$routeNames\n\nString Array\n\nThe list of queued route step names for the next steps of the aborted WIP.\n\n\n\n\n\nExample:\n\n\n\n\n\n// Connect to the API and log in.\n\n$url = \"http://apiserver01:60200\";\n\n$userName = \"thisUser\";\n\n$password = \"abc123\";\n\n$iFToken = iFactory_Connect($url, $userName, $password);\n\n\n\n// Start a WIP.\n\n$serial = \"S00001\";\n\n$resource = \"TestMachine01\";\n\n$iFStarted = iFactory_StartWIP($iFToken, $serial, $resource);\n\n\n\n// Abort the WIP.\n\n($routeIds, $routeSteps) = iFactory_AbortWIP($iFStarted);\n\n\n\n// Print out the list of Route IDs and Route Step Names.\n\n$numSteps = ArrayGetLength($routeIds);\n\n$loopCount = 0;\n\nwhile($loopCount < $numSteps)\n\n{\n\n$oneId = Array1DGetValue($routeIds, $loopCount);\n\n$oneName = Array1DGetValue($routeNames, $loopCount);\n\n$outString = \"Step ID =\\t\" + $oneId + \"\\tStep Name =\\t\" + $oneName;\n\nUpdateStatus($outString);\n\n$loopCount = $loopCount + 1;\n\n\n\n}\n\n\n\n\n\niFactory_Close\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS iFactory_Close": {
  "prefix": "iFactory_Close",
  "body": [
   "iFactory_Close($$iFactoryToken);"
  ],
  "description": "\n\nThis function will close communication with the API server.\n\n\n\n\n\nRemarks:\n\nA connection to the API server must already have been established with iFactory_Connect.\n\nThe WIP may already have been started with iFactory_StartWIP.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$iFactoryToken\n\nObject\n\nThe object returned by the iFactory_StartWIP function or the iFactory_Connect function.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n\n\n\n\n// Connect to the API and log in.\n\n$url = \"http://apiserver01:60200\";\n\n$userName = \"thisUser\";\n\n$password = \"abc123\";\n\n$iFToken = iFactory_Connect($url, $userName, $password);\n\n\n\n// Close the connection.\n\niFactory_Close($iFToken);\n\n\n\n\n\niFactory_Connect\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS iFactory_Connect": {
  "prefix": "iFactory_Connect",
  "body": [
   "$$iFactoryToken=iFactory_Connect($$apiURL,$$userName,$$password);"
  ],
  "description": "\n\nThis function will connect to an iFactory StackTest API server and log in.\n\n\n\n\n\nRemarks:\n\nAn error is generated if the URL does not connect or the username and password fail.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$apiURL\n\nString\n\nThe URL to connect to the iFactory StackTest API.\n\n\n\n$userName\n\nString\n\nThe name of the user to log in.\n\n\n\n$password\n\nString\n\nThe user's password for logging in.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$iFactoryToken\n\nObject\n\nAn object that contains the security token. Passed this in to all succeeding iFactory functions for this user.\n\n\n\n\n\nExample:\n\n\n\n\n\n// Connect to the API and log in.\n\n$url = \"http://apiserver01:60200\";\n\n$namePrompt = \"Enter your User Name for login:\";\n\n$passPrompt = \"Enter your password:\";\n\n$userName = OperatorInputPrompt($namePrompt);\n\n$password = OperatorInputPasswordPrompt($namePrompt);\n\n\n\n$iFToken = iFactory_Connect($url, $userName, $password);\n\n\n\n\n\niFactory_FailWIP\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS iFactory_FailWIP": {
  "prefix": "iFactory_FailWIP",
  "body": [
   "($$routeIds,$$routeNames)=iFactory_FailWIP($$iFactoryToken,$$failLabel$$failMessage]);"
  ],
  "description": "\n\nThis function will insert a failure for an already started WIP and then completes the WIP.\n\n\n\n\n\nRemarks:\n\nA connection to the API server must already have been established with iFactory_Connect.\n\nThe WIP must already have been started with iFactory_StartWIP.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$iFactoryToken\n\nObject\n\nThe object returned by the iFactory_StartWIP function.\n\n\n\n$failLabel\n\nString\n\nThe failure label (or symptom label) for this failure.\n\n\n\n$failMessage\n\nString\n\n[Optional] The failure message for this failure.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$routeIds\n\nString Array\n\nThe list of queued route step IDs for the next steps of the failed WIP.\n\n\n\n$routeNames\n\nString Array\n\nThe list of queued route step names for the next steps of the failed WIP.\n\n\n\n\n\nExample:\n\n\n\n\n\n// Connect to the API and log in.\n\n$url = \"http://apiserver01:60200\";\n\n$userName = \"thisUser\";\n\n$password = \"abc123\";\n\n$iFToken = iFactory_Connect($url, $userName, $password);\n\n\n\n// Start a WIP.\n\n$serial = \"S00001\";\n\n$resource = \"TestMachine01\";\n\n$iFStarted = iFactory_StartWIP($iFToken, $serial, $resource);\n\n\n\n// Fail the WIP.\n\n$failLabel = \"It blew up.\";\n\n$failMessage = \"Not all pieces recovered.\";\n\n($routeIds, $routeSteps) = iFactory_FailWIP($iFStarted, $failLabel, $failMessage);\n\n\n\n// Print out the list of Route IDs and Route Step Names.\n\n$numSteps = ArrayGetLength($routeIds);\n\n$loopCount = 0;\n\nwhile($loopCount < $numSteps)\n\n{\n\n$oneId = Array1DGetValue($routeIds, $loopCount);\n\n$oneName = Array1DGetValue($routeNames, $loopCount);\n\n$outString = \"Step ID =\\t\" + $oneId + \"\\tStep Name =\\t\" + $oneName;\n\nUpdateStatus($outString);\n\n$loopCount = $loopCount + 1;\n\n\n\n}\n\n\n\n\n\niFactory_GetProductionOrderAttribute\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS iFactory_GetProductionOrderAttribute": {
  "prefix": "iFactory_GetProductionOrderAttribute",
  "body": [
   "$$poAttribute=iFactory_GetProductionOrderAttribute($$iFactoryToken,$$serialNumber,$$attribute$$customerId]);"
  ],
  "description": "\n\nThis function will return the value of the specified Production Order Attribute.\n\n\n\n\n\nRemarks:\n\nA connection to the API server must already have been established with the iFactory_Connect function.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$iFactoryToken\n\nObject\n\nThe object returned by the iFactory_Connect function.\n\n\n\n$serialNumber\n\nString\n\nThe serial number of the item to get the attribute for.\n\n\n\n$attribute\n\nString\n\nThe name of the attribute to get the value of.\n\n\n\n$customerId\n\nInteger\n\n[Optional] The ID of the customer.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$poAttribute\n\nString\n\nThe value of the specified purchase order attribute.\n\n\n\n\n\nExample:\n\n\n\n\n\n// Connect to the API and get an attribute.\n\n$url = \"http://apiserver01:60200\";\n\n$serialNum = \"S000001\";\n\n$attrib = \"ShipDate\";\n\n\n\n$attribValue = iFactory_GetProductionOrderAttribute($url, $serialNum, $attrib);\n\n\n\n// Print out the attribute value.\n\nUpdateStatus($attribValue);\n\n\n\n\n\niFactory_PassWIP\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS iFactory_PassWIP": {
  "prefix": "iFactory_PassWIP",
  "body": [
   "($$routeIds,$$routeNames)=iFactory_PassWIP($$iFactoryToken);"
  ],
  "description": "\n\nThis function will pass and complete an already started WIP.\n\n\n\n\n\nRemarks:\n\nA connection to the API server must already have been established with iFactory_Connect.\n\nThe WIP must already have been started with iFactory_StartWIP.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$iFactoryToken\n\nObject\n\nThe object returned by the iFactory_StartWIP function.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$routeIds\n\nString Array\n\nThe list of queued route step IDs for the next steps of the passed WIP.\n\n\n\n$routeNames\n\nString Array\n\nThe list of queued route step names for the next steps of the passed WIP.\n\n\n\n\n\nExample:\n\n\n\n\n\n// Connect to the API and log in.\n\n$url = \"http://apiserver01:60200\";\n\n$userName = \"thisUser\";\n\n$password = \"abc123\";\n\n$iFToken = iFactory_Connect($url, $userName, $password);\n\n\n\n// Start a WIP.\n\n$serial = \"S00001\";\n\n$resource = \"TestMachine01\";\n\n$iFStarted = iFactory_StartWIP($iFToken, $serial, $resource);\n\n\n\n// Pass the WIP.\n\n($routeIds, $routeSteps) = iFactory_PassWIP($iFStarted);\n\n\n\n// Print out the list of Route IDs and Route Step Names.\n\n$numSteps = ArrayGetLength($routeIds);\n\n$loopCount = 0;\n\nwhile($loopCount < $numSteps)\n\n{\n\n$oneId = Array1DGetValue($routeIds, $loopCount);\n\n$oneName = Array1DGetValue($routeNames, $loopCount);\n\n$outString = \"Step ID =\\t\" + $oneId + \"\\tStep Name =\\t\" + $oneName;\n\nUpdateStatus($outString);\n\n$loopCount = $loopCount + 1;\n\n\n\n}\n\n\n\n\n\niFactory_RetrieveWipGenealogyById\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS iFactory_RetrieveWipGenealogyById": {
  "prefix": "iFactory_RetrieveWipGenealogyById",
  "body": [
   "$$wipHistoryArray=iFactory_RetrieveWipGenealogyById($$iFactoryToken,$$wipId,$$maxLevel,$$serialized);"
  ],
  "description": "\n\nThis function returns an array of comma delimited strings for the selected WIPs history.\n\n\n\n\n\nRemarks:\n\nA connection to the API server must already have been established with the iFactory_Connect function.\n\nThe WIP ID can be obtained from the iFactory_RetrieveWipIds function.\n\nThe fields in the CSV strings for a history are (in order):\n\nAssembled Date\n\nAssembled Route Step\n\nCRD\n\nID\n\nManufacturer Part Number\n\nMaterial ID\n\nMaterial Name\n\nMaterial Plant Code\n\nOperator User Login\n\nParent ID\n\nPhoenix Material Type\n\nQuantity\n\nReturn Count\n\nSerialized Material ID\n\nSerial Number\n\nWIP ID.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$iFactoryToken\n\nObject\n\nThe object returned by the iFactory_Connect function.\n\n\n\n$wipId\n\nString\n\nThe ID of the WIP to get the history of.\n\n\n\n$maxLevel\n\nInteger\n\nThe maximum number of history lines to return. From 1 to 10.\n\n\n\n$serialized\n\nBoolean\n\nWhether to return history for only serialized materials.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$wipIdArray\n\nString Array\n\nThe array of CSV strings with the history data.\n\n\n\n\n\nExample:\n\n\n\n\n\n// Connect to the API and log in.\n\n$url = \"http://apiserver01:60200\";\n\n$userName = \"thisUser\";\n\n$password = \"abc123\";\n\n$iFToken = iFactory_Connect($url, $userName, $password);\n\n\n\n// Get the WIP IDs.\n\n$serial = \"S00001\";\n\n$wipArray = iFactory_RetrieveWipIds($iFToken, $serial);\n\n\n\n// Get the history for the first WIP ID.\n\n$firstWIP = Array1DGetValue($wipArray, 0);\n\n$maxLevel = 10;\n\n$serial = false;\n\n$histArray = iFactory_RetrieveWipGenealogyById(iFToken, $firstWIP, $maxLevel, $serial);\n\n\n\n\n\niFactory_RetrieveWipIds\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS iFactory_RetrieveWipIds": {
  "prefix": "iFactory_RetrieveWipIds",
  "body": [
   "$$wipIdArray=iFactory_RetrieveWipIds($$iFactoryToken,$$serialNumber$$customerName$$material$$plantCode]]]);"
  ],
  "description": "\n\nThis function returns an array of WIP IDs that are for the specified serial number and optionally, the customer name, material name and material plant code.\n\n\n\n\n\nRemarks:\n\nA connection to the API server must already have been established with the iFactory_Connect function.\n\nTo include any optional parameter, the optional parameters before it must be included. For example, to include $material, you must also include $customer. To include $plantCode, you must include $customer and $material.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$iFactoryToken\n\nObject\n\nThe object returned by the iFactory_Connect function.\n\n\n\n$serialNumber\n\nString\n\nThe serial number of the WIP to retrieve.\n\n\n\n$customer\n\nString\n\n[Optional] The name of the customer that this WIP belongs to.\n\n\n\n$material\n\nString\n\n[Optional] The name of the material for this WIP.\n\n\n\n$plantCode\n\nString\n\n[Optional] The material plant code for this WIP.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$wipIdArray\n\nArray\n\nThe list of WIP IDs for this serial number.\n\n\n\n\n\nExample:\n\n\n\n\n\n// Connect to the API and log in.\n\n$url = \"http://apiserver01:60200\";\n\n$userName = \"thisUser\";\n\n$password = \"abc123\";\n\n$iFToken = iFactory_Connect($url, $userName, $password);\n\n\n\n// Get the WIP IDs.\n\n$serial = \"S00001\";\n\n$wipArray = iFactory_RetrieveWipIds($iFToken, $serial);\n\n\n\n// Print out the number of WIPS found.\n\n$numWips = ArrayGetLength($wipArray);\n\n$outString = \"Found \" + $numWips + \"WIPs\";\n\nUpdateStatus($outString);\n\n\n\n\n\niFactory_StartWIP\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS iFactory_StartWIP": {
  "prefix": "iFactory_StartWIP",
  "body": [
   "$$wipStartedToken=iFactory_StartWIP($$iFactoryToken,$$serialNumber,$$resource$$customer$$material$$plantCode]]]);"
  ],
  "description": "\n\nThis function will start the WIP for the $resource in iFactory.\n\n\n\n\n\nRemarks:\n\nA connection to the API server must already have been established with the iFactory_Connect function.\n\nTo include any optional parameter, the optional parameters before it must be included. For example, to include $material, you must also include $customer. To include $plantCode, you must include $customer and $material.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$iFactoryToken\n\nObject\n\nThe object returned by the iFactory_Connect function.\n\n\n\n$serialNumber\n\nString\n\nThe serial number of the WIP to start.\n\n\n\n$resource\n\nString\n\nThe name of the resource that the WIP is being started for (this is usually the route step name).\n\n\n\n$customer\n\nString\n\n[Optional] The name of the customer that this WIP belongs to.\n\n\n\n$material\n\nString\n\n[Optional] The name of the material for this WIP.\n\n\n\n$plantCode\n\nString\n\n[Optional] The material plant code for this WIP.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$wipStartedToken\n\nObject\n\nAn object that will need to be passed to the iFactory_AbortWIP, iFactory_FailWIP, or iFactory_PassWIP functions.\n\n\n\n\n\nExample:\n\n\n\n\n\n// Connect to the API and log in.\n\n$url = \"http://apiserver01:60200\";\n\n$userName = \"thisUser\";\n\n$password = \"abc123\";\n\n$iFToken = iFactory_Connect($url, $userName, $password);\n\n\n\n// Start a WIP.\n\n$serial = \"S00001\";\n\n$resource = \"TestMachine01\";\n\n$iFStarted = iFactory_StartWIP($iFToken, $serial, $resource);\n\n\n\n\n\nImageGetBlueIntensity\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ImageGetBlueIntensity": {
  "prefix": "ImageGetBlueIntensity",
  "body": [
   "($$AverageValue,$$LowValue,$$HighValue)=ImageGetBlueIntensity($$FileName,$$RegionX,$$RegionY,$$Width,$$Height);"
  ],
  "description": "\n\nThis function calculates the intensity value of the given region of interest in the specified region. The upper left rectangle of the area of interest is defined by the point specified by the $RegionX,$RegionY arguments. The lower right corner of the region of interest is defined by the $Width,$Height arguments. The function returns the average, highest, and lowest pixel value intensity found in the region of interest for the specified color plane.\n\n\n\nRequirements:\n\n\n\nUsage Example:\n\n($Avg,$High,$Low) = ImageGetBlueIntensity(\"c:\\\\myFile.bmp\",400,500,35,100);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$FileName\n\nString\n\nThe filename and path of the image to analyze.\n\n\n\n$RegionX\n\nInteger\n\nThe upper left X coordinate of the region of interest.\n\n\n\n$RegionY\n\nInteger\n\nThe upper left Y coordinate of the region of interest.\n\n\n\n$Width\n\nInteger\n\nThe width in pixels of the region of interest.\n\n\n\n$Height\n\nInteger\n\nThe height in pixels of the region of interest.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AverageValue\n\nInteger\n\nThe average value of the pixels in the region of interest.\n\n\n\n$LowValue\n\nInteger\n\nThe lowest pixel value found in the region of interest.\n\n\n\n$HighValue\n\nInteger\n\nThe highest pixel value found in the region of interest.\n\n\n\n\n\nImageGetGreenIntensity\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ImageGetGreenIntensity": {
  "prefix": "ImageGetGreenIntensity",
  "body": [
   "($$AverageValue,$$LowValue,$$HighValue)=ImageGetGreenIntensity($$FileName,$$RegionX,$$RegionY,$$Width,$$Height);"
  ],
  "description": "\n\nThis function calculates the intensity value of the given region of interest in the specified region. The upper left rectangle of the area of interest is defined by the point specified by the $RegionX,$RegionY arguments. The lower right corner of the region of interest is defined by the $Width,$Height arguments. The function returns the average, highest, and lowest pixel value intensity found in the region of interest for the specified color plane.\n\n\n\nRequirements:\n\n\n\nUsage Example:\n\n($Avg,$High,$Low) = ImageGetGreenIntensity(\"c:\\\\myFile.bmp\",400,500,35,100);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$FileName\n\nString\n\nThe filename and path of the image to analyze.\n\n\n\n$RegionX\n\nInteger\n\nThe upper left X coordinate of the region of interest.\n\n\n\n$RegionY\n\nInteger\n\nThe upper left Y coordinate of the region of interest.\n\n\n\n$Width\n\nInteger\n\nThe width in pixels of the region of interest.\n\n\n\n$Height\n\nInteger\n\nThe height in pixels of the region of interest.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AverageValue\n\nInteger\n\nThe average value of the pixels in the region of interest.\n\n\n\n$LowValue\n\nInteger\n\nThe lowest pixel value found in the region of interest.\n\n\n\n$HighValue\n\nInteger\n\nThe highest pixel value found in the region of interest.\n\n\n\n\n\nImageGetMonoIntensity\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ImageGetMonoIntensity": {
  "prefix": "ImageGetMonoIntensity",
  "body": [
   "($$AverageValue,$$LowValue,$$HighValue)=ImageGetMonoIntensity($$FileName,$$RegionX,$$RegionY,$$Width,$$Height);"
  ],
  "description": "\n\nThis function calculates the intensity value of the given region of interest in the specified region. The upper left rectangle of the area of interest is defined by the point specified by the $RegionX,$RegionY arguments. The lower right corner of the region of interest is defined by the $Width,$Height arguments. The function returns the average, highest, and lowest pixel value intensity found in the region of interest for the specified color plane.\n\n\n\nRequirements:\n\n\n\nUsage Example:\n\n($Avg,$High,$Low) = ImageGetMonoIntensity(\"c:\\\\myFile.bmp\",400,500,35,100);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$FileName\n\nString\n\nThe filename and path of the image to analyze.\n\n\n\n$RegionX\n\nInteger\n\nThe upper left X coordinate of the region of interest.\n\n\n\n$RegionY\n\nInteger\n\nThe upper left Y coordinate of the region of interest.\n\n\n\n$Width\n\nInteger\n\nThe width in pixels of the region of interest.\n\n\n\n$Height\n\nInteger\n\nThe height in pixels of the region of interest.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AverageValue\n\nInteger\n\nThe average value of the pixels in the region of interest.\n\n\n\n$LowValue\n\nInteger\n\nThe lowest pixel value found in the region of interest.\n\n\n\n$HighValue\n\nInteger\n\nThe highest pixel value found in the region of interest.\n\n\n\n\n\nImageGetPixelFormat\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ImageGetPixelFormat": {
  "prefix": "ImageGetPixelFormat",
  "body": [
   "$$PixelFormat=ImageGetPixelFormat($$FileName);"
  ],
  "description": "\n\n\n\nThis function returns a string containing the pixel format of the image including color space information, and bit depth per pixel.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$FileName\n\nString\n\nThe filename and path of the image to analyze.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$PixelFormat\n\nString\n\nA string containing the pixel format of the image specifying the color space and the number of bits per pixel. (ex. \"RGB24BPP\")\n\n\n\n\n\nUsage Example:\n\n\n\n\n\n$PixelFormat = ImageGetPixelFormat(\"c:\\\\ocrimage.jpg\");\n\nUpdateStatus($PixelFormat);\n\n\n\n\n\nImageGetRedIntensity\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ImageGetRedIntensity": {
  "prefix": "ImageGetRedIntensity",
  "body": [
   "($$AverageValue,$$LowValue,$$HighValue)=ImageGetRedIntensity($$FileName,$$RegionX,$$RegionY,$$Width,$$Height);"
  ],
  "description": "\n\nThis function calculates the intensity value of the given region of interest in the specified region. The upper left rectangle of the area of interest is defined by the point specified by the $RegionX,$RegionY arguments. The lower right corner of the region of interest is defined by the $Width,$Height arguments. The function returns the average, highest, and lowest pixel value intensity found in the region of interest for the specified color plane.\n\n\n\nRequirements:\n\n\n\nUsage Example:\n\n($Avg,$High,$Low) = ImageGetRedIntensity(\"c:\\\\myFile.bmp\",400,500,35,100);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$FileName\n\nString\n\nThe filename and path of the image to analyze.\n\n\n\n$RegionX\n\nInteger\n\nThe upper left X coordinate of the region of interest.\n\n\n\n$RegionY\n\nInteger\n\nThe upper left Y coordinate of the region of interest.\n\n\n\n$Width\n\nInteger\n\nThe width in pixels of the region of interest.\n\n\n\n$Height\n\nInteger\n\nThe height in pixels of the region of interest.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AverageValue\n\nInteger\n\nThe average value of the pixels in the region of interest.\n\n\n\n$LowValue\n\nInteger\n\nThe lowest pixel value found in the region of interest.\n\n\n\n$HighValue\n\nInteger\n\nThe highest pixel value found in the region of interest.\n\n\n\n\n\nImageGetResolution\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ImageGetResolution": {
  "prefix": "ImageGetResolution",
  "body": [
   "($$XResolution,$$YResolution)=ImageGetResolution($$FileName);"
  ],
  "description": "\n\n\n\nThis function returns the horizontal and vertical resolution of the image expressed in Pixels Per Inch.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$FileName\n\nString\n\nThe filename and path of the image to analyze.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$XResolution\n\nFloat\n\nThe horizontal resolution of the image in pixels per inch.\n\n\n\n$YResolution\n\nFloat\n\nThe vertical resolution of the image in pixels per inch.\n\n\n\n\n\nUsage Example:\n\n($XResolution,$YResolution)=ImageGetResolution(\"c:\\\\ocrimage.jpg\");\n\nUpdateStatus($XResolution);\n\nUpdateStatus($YResolution);\n\n\n\n\n\nImageGetSize\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ImageGetSize": {
  "prefix": "ImageGetSize",
  "body": [
   "($$Width,$$Height)=ImageGetSize($$FileName);"
  ],
  "description": "\n\n\n\nThis function returns the width and height of an image in pixels.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$FileName\n\nString\n\nThe filename and path of the image to analyze.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Width\n\nInteger\n\nThe width of the image in pixels\n\n\n\n$Height\n\nInteger\n\nThe height of the image in pixels\n\n\n\n\n\nUsage Example:\n\n($XSize,$YSize)=ImageGetSize(\"c:\\\\ocrimage.jpg\");\n\nUpdateStatus($XSize);\n\nUpdateStatus($YSize);\n\n\n\n\n\nFastBitmap_CountPixelsInHSVRange\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS FastBitmap_CountPixelsInHSVRange": {
  "prefix": "FastBitmap_CountPixelsInHSVRange",
  "body": [
   "$$PixelCount=FastBitmap_CountPixelsInHSVRange($$Image,$$Hmin,$$Smin,$$Vmin,$$Hmax,$$Smax,$$Vmax,$$PixelList,$$ShowDebugImage);"
  ],
  "description": "\n\n\n\n\n\nThis function counts pixels of a bitmap object based on HSV values. If a pixel's HSV value falls within the high and low limits specified for all three values (Hue, Saturation and Value), the pixel is included in the total pixel count that is returned.\n\n\n\n\n\nThis function requires a pixel list object be provided as an input parameter. A pixel list can be thought of as an advanced ROI description. It contains a list of pixels in the image where you are interested in performing analysis. It can be as simple as a single rectangular or circle ROI description, or a combination of numerous rectangular or circle areas in the image. A pixel list can be created using the following functions:\n\nFastBitmap_GetPixelListFromCircleRadius\n\nFastBitmap_GetPixelListFromRectangle\n\nFastBitmap_CreateSupersetFromPixelLists\n\n\n\n\n\nThis function is useful for calculating area, coverage, and distribution of specific colors within an image.\n\n\n\n\n\nThe image below is a flattened representation of the HSV color space. For more information regarding color space please visit: http://en.wikipedia.org/wiki/HSL_and_HSV\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Image\n\nObject\n\nA bitmap image object.\n\n\n\n$Hmin\n\nInteger\n\nThe lower limit of Hue for pixel color comparison. Note: Since Hue is a cylindrical-coordinate and could wrap around the zero value, if the lower limit for Hue is greater than the higher limit, the function will work on the assumption that the user wants to select Hue values that cross the zero value. The range of values for Hue is 0-360 however, the 360 value is never realized since 360 would equal zero. The actual range of Hue values is [0,360).\n\n\n\n$Smin\n\nInteger\n\nThe lower limit of Saturation for pixel color comparison. The range of Saturation values is [0,100].\n\n\n\n$Vmin\n\nInteger\n\nThe lower limit of Value for pixel color comparison. The range of Value values is [0,100].\n\n\n\n$Hmax\n\nInteger\n\nThe upper limit of Hue for pixel color comparison. See note above regarding wrap.\n\n\n\n$Smax\n\nInteger\n\nThe upper limit of Saturation for pixel color comparison. The range of Saturation values is [0,100].\n\n\n\n$Vmax\n\nInteger\n\nThe upper limit of Value for pixel color comparison. The range of Value values is [0,100].\n\n\n\n$PixelList\n\nObject\n\nA list object that contains pixels of interest. This list is created using other FastBitmap functions (see explanation above).\n\n\n\n$ShowDebugImage\n\nBoolean\n\nSpecifies whether to show the debug image. The pixels that meet the HSV input range requirements will be filled gray. [TRUE,FALSE]\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$PixelCount\n\nInteger\n\nThe number of pixels found within the pixel list that match the input HSV color range\n\n\n\n\n\nUsage Example:\n\n\n\n\n\n//Load image\n\n$Image = FastBitmap_LoadImageFromFile(\"C:\\\\JabilTestScripts\\\\Jellyfish.jpg\");\n\n// Display original image\n\nFastBitmap_DisplayImage($Image);\n\n// Fill pixels with black (HSV = 0,0,0) based on Hue to eliminate colors other than redish orange\n\n$FBResultImage = FastBitmap_FillByHSV($Image,71,249,0,100,0,100,0,0,0);\n\n// Fill pixels with black (HSV = 0,0,0) to eliminate lower saturation levels\n\n$FBResultImage = FastBitmap_FillByHSV($FBResultImage,0,360,0,40,0,100,0,0,0);\n\n// Display and save results of 2nd fill\n\nFastBitmap_DisplayImage($FBResultImage);\n\nFastBitmap_SaveImageToFile($FBResultImage,\"C:\\\\JabilTestScripts\\\\Jellyfish2ndFill.jpg\",\"JPEG\");\n\n// create pixel list for area to count pixels\n\n$PixelList1 = FastBitmap_GetPixelListFromRectangle(50,100,150,100);\n\n$PixelCount = FastBitmap_CountPixelsInHSVRange($FBResultImage,0,1,1,360,100,100,$PixelList1,true);\n\nFastBitmap_DisposeImage($Image);\n\nFastBitmap_DisposeImage($FBResultImage);\n\nEnd;\n\nImage after 2nd fill\n\n\n\nDebug image from FastBitmap_CountPixelsInHSVRange\n\n\n\nThe debug image indicates which pixels in the pixel list that were found to be in range by filling those pixels with grey.\n\n\n\n\n\nThe result is a count of pixels that meet all of the minimum and maximum HSV parameters specified. Using the original pixel count from the FastBitmap_GetPixelListFromRectangle (15251) and the count from FastBitmap_GetPixelsInHSVRange, you can see that 7625 out of 15251 pixels were within the HSV parameters.\n\nFastBitmap_GetPixelListFromRectangle: Pixel Count [15251]\n\nFastBitmap_CountPixelsInHSVRange: Pixel Count [7625]\n\n\n\n\n\nImportant Note:\n\nThe FastBitmap Class is faster than standard bitmap pixel operations but slower than the OpenCV library functions. OpenCV functions should be your first choice for speed if an equivalent function is available.\n\n\n\n\n\nThe FastBitmap Class works on standard Bitmap image object within JabilTest. OpenCV image objects have a different structure. To use an image processed by the FastBitmap class with an OpenCV function, you must open the image using an OpenCV function in order to obtain the correct structure.\n\n\n\n\n\nFastBitmap_CreateSupersetFromPixelLists\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS FastBitmap_CreateSupersetFromPixelLists": {
  "prefix": "FastBitmap_CreateSupersetFromPixelLists",
  "body": [
   "($$SupersetPixelList,$$SupersetPixelCount)=FastBitmap_CreateSupersetFromPixelLists($$PixelList1,$$PixelList2);"
  ],
  "description": "\n\n\n\n\n\nThis function takes in two pixel list objects and combines them to create a single superset of pixels returned in a single pixel list object. The function also returns the count of pixels contained in this new superset pixel list object.\n\n\n\n\n\nThis function requires a pixel list object be provided as an input parameter. A pixel list can be thought of as an enhanced ROI description. It contains a list of pixels in the image where you are interested in performing analysis. It can be as simple as a single rectangular or circle ROI description, or a combination of numerous rectangular or circle areas in the image. A pixel list can be created using the following functions:\n\nFastBitmap_GetPixelListFromCircleRadius\n\nFastBitmap_GetPixelListFromRectangle\n\nFastBitmap_CreateSupersetFromPixelLists\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$PixelList1\n\nObject\n\nA list object that contains pixels of interest. This list is created using other FastBitmap functions (see explanation above).\n\n\n\n$PixelList2\n\nObject\n\nA list object that contains pixels of interest. This list is created using other FastBitmap functions (see explanation above).\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$SupersetPixelList\n\nObject\n\nA superset list of pixels resulting from the combination of two other pixel lists.\n\n\n\n$SupersetPixelCount\n\nInteger\n\nThe number of pixels contained in the newly created pixel list.\n\n\n\n\n\nThe pixel list object returned from this function can in turn be passed back into it with another function call to create a superset of a superset. This can be repeated until all pixel lists (ROIs) have been combined together.\n\n\n\n\n\nUsage Example:\n\n\n\n\n\n//Load image\n\n$Image = FastBitmap_LoadImageFromFile(\"C:\\\\JabilTestScripts\\\\Jellyfish.jpg\");\n\n// create a pixel list from a rectangle\n\n$PixelList1 = FastBitmap_GetPixelListFromCircleRadius(100,100,50);\n\n// create a pixel list from a rectangle\n\n$PixelList2 = FastBitmap_GetPixelListFromCircleRadius(150,100,50);\n\n// create a superset using $PixelList1 and $PixelList2\n\n$PixelSuperSet = FastBitmap_CreateSupersetFromPixelLists($PixelList1,$PixelList2);\n\n// Display Pixel super set list by filling pixels in image with green (HSV = 120,100,100)\n\n$FBResultImage = FastBitmap_FillPixelListByHSV($Image,$PixelSuperSet,true,120,100,100);\n\n// display and save image\n\nFastBitmap_DisplayImage($FBResultImage);\n\nFastBitmap_SaveImageToFile($FBResultImage,\"C:\\\\JabilTestScripts\\\\JellyfishPixelSuperSet.jpg\",\"JPEG\");\n\n// dispose of images\n\nFastBitmap_DisposeImage($Image);\n\nFastBitmap_DisposeImage($FBResultImage);\n\nOriginal image\n\n\n\nImage with superset filled\n\n\n\n\n\nImportant Note:\n\nThe FastBitmap Class is faster than standard bitmap pixel operations but slower than the OpenCV library functions. OpenCV functions should be your first choice for speed if an equivalent function is available.\n\n\n\n\n\nThe FastBitmap Class works on standard Bitmap image object within JabilTest. OpenCV image objects have a different structure. To use an image processed by the FastBitmap class with an OpenCV function, you must open the image using an OpenCV function in order to obtain the correct structure.\n\n\n\n\n\nFastBitmap_DisplayImage\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS FastBitmap_DisplayImage": {
  "prefix": "FastBitmap_DisplayImage",
  "body": [
   "FastBitmap_DisplayImage($$Image);"
  ],
  "description": "\n\nThis function will open a diagnostic and debug window displaying the Bitmap image passed to the function. The $Image parameter must be a Bitmap image object. Note: This function is not compatible with OpenCV image types.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Image\n\nObject\n\nA Bitmap image object.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nUsage Example:\n\n\n\n\n\n$FBImage = FastBitmap_LoadImageFromFile(\"c:\\\\myBitmap.bmp\");\n\nFastBitmap_DisplayImage($FBImage);\n\nFastBitmap_DisposeImage($FBImage);\n\n\n\n\n\nImportant Note:\n\nThe FastBitmap Class is faster than standard bitmap pixel operations but slower than the OpenCV library functions. OpenCV functions should be your first choice for speed if an equivalent function is available.\n\n\n\n\n\nThe FastBitmap Class works on standard Bitmap image object within JabilTest. OpenCV image objects have a different structure. To use an image processed by the FastBitmap class with an OpenCV function, you must open the image using an OpenCV function in order to obtain the correct structure.\n\n\n\n\n\nFastBitmap_DisposeImage\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS FastBitmap_DisposeImage": {
  "prefix": "FastBitmap_DisposeImage",
  "body": [
   "FastBitmap_DisposeImage($$Image);"
  ],
  "description": "\n\n\n\n\n\nThis function will dispose of the memory resources used to hold the Image object.\n\n\n\n\n\nThis function should be used to clean up any FastBitmap Image resources after they are no longer used in the test script.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Image\n\nObject\n\nAn Bitmap image object of any resolution, format, or color depth\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nUsage Example:\n\n\n\n\n\nFastBitmap_DisposeImage($MyImage); // Removes $MyImage from Memory...\n\n\n\n\n\nImportant Note:\n\nThe FastBitmap Class is faster than standard bitmap pixel operations but slower than the OpenCV library functions. OpenCV functions should be your first choice for speed if an equivalent function is available.\n\n\n\n\n\nThe FastBitmap Class works on standard Bitmap image object within JabilTest. OpenCV image objects have a different structure. To use an image processed by the FastBitmap class with an OpenCV function, you must open the image using an OpenCV function in order to obtain the correct structure.\n\n\n\n\n\nFastBitmap_DumpImageToCSV\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS FastBitmap_DumpImageToCSV": {
  "prefix": "FastBitmap_DumpImageToCSV",
  "body": [
   "FastBitmap_DumpImageToCSV($$Image,$$CSVFileName);"
  ],
  "description": "\n\n\n\n\n\nThis function is useful for offline image pixel analysis for color scale and distribution. It can be used to analyze the RGB and HSV values for every pixel in an image to get a better understanding of the image color space for use with other HSV and RGB functions.\n\n\n\n\n\nThis function takes an image bitmap object and writes a .csv file with one line per pixel containing the following information:\n\n\"Name,PixelX,PixelY,R,G,B,Hue,Saturation,Value\"\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Image\n\nObject\n\nA bitmap image object.\n\n\n\n$CSVFileName\n\nString\n\nThe save destination filename and path.\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nUsage Example:\n\n\n\n\n\nFastBitmap_DumpImageToCSV($FBImage, \"C:\\\\PixelColorValues.csv\");\n\n\n\n\n\nImportant Note:\n\nThe FastBitmap Class is faster than standard bitmap pixel operations but slower than the OpenCV library functions. OpenCV functions should be your first choice for speed if an equivalent function is available.\n\n\n\n\n\nThe FastBitmap Class works on standard Bitmap image object within JabilTest. OpenCV image objects have a different structure. To use an image processed by the FastBitmap class with an OpenCV function, you must open the image using an OpenCV function in order to obtain the correct structure.\n\n\n\n\n\nFastBitmap_BinarizeOnHSV\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS FastBitmap_FillByHSV": {
  "prefix": "FastBitmap_FillByHSV",
  "body": [
   "$$FBResultImage=FastBitmap_FillByHSV($$FBImage,$$Hmin,$$Hmax,$$Smin,$$Smax,$$Hmin,$$Hmax,$$Hfill,$$Sfill,$$Vfill);"
  ],
  "description": "\n\nThis function fills a bitmap object based on HSV values. If a pixel's HSV value falls within the high and low limits specified for all three values (Hue, Saturation and Value), the pixel's color is changed to the HSV value specified by the pixel fill parameters.\n\n\n\n\n\nThis function is useful for segmenting an image based on HSV in order to eliminate background clutter and improve image or edge pattern matching probability.\n\n\n\n\n\nThe image below is a flattened representation of the HSV color space. For more information regarding color space please visit: http://en.wikipedia.org/wiki/HSL_and_HSV\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$FBImage\n\nObject\n\nA Bitmap Image object.\n\n\n\n$Hmin\n\nInteger\n\nThe lower limit of Hue for pixel color comparison. Note: Since Hue is a cylindrical-coordinate and could wrap around the zero value, if the lower limit for Hue is greater than the higher limit, the function will work on the assumption that the user wants to select Hue values that cross the zero value. The range of values for Hue is 0-360 however, the 360 value is never realized since 360 would equal zero. The actual range of Hue values is [0,360).\n\n\n\n$Hmax\n\nInteger\n\nThe upper limit of Hue for pixel color comparison. See note above regarding wrap.\n\n\n\n$Smin\n\nInteger\n\nThe lower limit of Saturation for pixel color comparison. The range of Saturation values is [0,100].\n\n\n\n$Smax\n\nInteger\n\nThe upper limit of Saturation for pixel color comparison. The range of Saturation values is [0,100].\n\n\n\n$Vmin\n\nInteger\n\nThe lower limit of Value for pixel color comparison. The range of Value values is [0,100].\n\n\n\n$Vmax\n\nInteger\n\nThe upper limit of Value for pixel color comparison. The range of Value values is [0,100].\n\n\n\n$Hfill\n\nInteger\n\nPixels within all three criteria of Hue, Saturation and Value will be set to this Hue value. Hue range is [0,360).\n\n\n\n$Sfill\n\nInteger\n\nPixels within all three criteria of Hue, Saturation and Value will be set to this Saturation value. Saturation range is [0,100].\n\n\n\n$Vfill\n\nInteger\n\nPixels within all three criteria of Hue, Saturation and Value will be set to this Value. Value range is [0,100].\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$FBResultImage\n\nObject\n\nA Bitmap Image object.\n\n\n\n\n\nUsage Example:\n\n//Load image\n\n$Image = FastBitmap_LoadImageFromFile(\"C:\\\\JabilTestScripts\\\\Jellyfish.jpg\");\n\n// Display original image\n\nFastBitmap_DisplayImage($Image);\n\n// Fill pixels with black (HSV = 0,0,0) based on Hue to eliminate colors other than redish orange\n\n$FBResultImage = FastBitmap_FillByHSV($Image,71,249,0,100,0,100,0,0,0);\n\n// Display and save results of 1st fill\n\nFastBitmap_DisplayImage($FBResultImage);\n\nFastBitmap_SaveImageToFile($FBResultImage,\"C:\\\\JabilTestScripts\\\\Jellyfish1stFill.jpg\",\"JPEG\");\n\n// Fill pixels with black (HSV = 0,0,0) to eliminate lower saturation levels\n\n$FBResultImage = FastBitmap_FillByHSV($FBResultImage,0,360,0,40,0,100,0,0,0);\n\n// Display and save results of 2nd fill\n\nFastBitmap_DisplayImage($FBResultImage);\n\nFastBitmap_SaveImageToFile($FBResultImage,\"C:\\\\JabilTestScripts\\\\Jellyfish2ndFill.jpg\",\"JPEG\");\n\n// Dispose and quit\n\nFastBitmap_DisposeImage($Image);\n\nFastBitmap_DisposeImage($FBResultImage);\n\nEnd;\n\n\n\n\n\nOriginal Image\n\n\n\nAfter 1st FastBitmap_FillByHSV\n\n\n\nAfter 2nd FastBitmap_FillByHSV\n\n\n\n\n\nImportant Note:\n\nThe FastBitmap Class is faster than standard bitmap pixel operations but slower than the OpenCV library functions. OpenCV functions should be your first choice for speed if an equivalent function is available.\n\n\n\n\n\nThe FastBitmap Class works on standard Bitmap image object within JabilTest. OpenCV image objects have a different structure. To use an image processed by the FastBitmap class with an OpenCV function, you must open the image using an OpenCV function in order to obtain the correct structure.\n\n\n\n\n\nFastBitmap_FillByPixelList\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS FastBitmap_FillPixelListByHSV": {
  "prefix": "FastBitmap_FillPixelListByHSV",
  "body": [
   "$$FilledImage=FastBitmap_FillPixelListByHSV($$Image,$$PixelList,$$FillList,$$Hfill,$$Sfill,$$Vfill);"
  ],
  "description": "\n\n\n\n\n\nThis function performs a HSV color fill on a bitmap image object. The user specifies the HSV values to use for the color fill. The color fill pixel area is specified using the two input parameters: $PixelList and $FillList.\n\n\n\n\n\n$PixelList: This function requires a pixel list object be provided as an input parameter. A pixel list can be thought of as an advanced ROI description. It contains a list of pixels in the image where you are interested in performing analysis. It can be as simple as a single rectangular or circle ROI description, or a combination of numerous rectangular or circle areas in the image. A pixel list can be created using the following functions:\n\nFastBitmap_GetPixelListFromCircleRadius\n\nFastBitmap_GetPixelListFromRectangle\n\nFastBitmap_CreateSupersetFromPixelLists\n\n\n\n\n\n$FillList: This is a boolean value used to specify whether to color fill only the pixels contained in the input pixel list or color fill all of the pixels not contained in the pixel list.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Image\n\nObject\n\nA bitmap image object.\n\n\n\n$PixelList\n\nObject\n\nA list object that contains pixels of interest. This list is created using other FastBitmap functions (see explanation above).\n\n\n\n$FillList\n\nBoolean\n\nA boolean value indicating which portion of the image to fill with the input HSV values\n\nTRUE: Fill only the pixels contained in the pixel list with the input HSV values. Useful in masking specific features/areas in the image.\n\nFALSE: Fill only the pixels not contained in the pixel list with the input HSV values. Useful in masking out background noise to uniform color.\n\n\n\n$Hfill\n\nInteger\n\nThe Hue value that will be used to fill the pixels based on the boolean value. Hue range is [0,360].\n\n\n\n$Sfill\n\nInteger\n\nThe Saturation value that will be used to fill the pixels based on the boolean value. Saturation range is [0,100].\n\n\n\n$Vfill\n\nInteger\n\nThe Value that will be used to fill the pixels based on the boolean value. Value range is [0,100].\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$FilledImage\n\nObject\n\nA bitmap image object that has been updated with HSV color fill based on the input parameters.\n\n\n\n\n\nUsage Example:\n\n\n\n\n\n//Load image\n\n$Image = FastBitmap_LoadImageFromFile(\"C:\\\\JabilTestScripts\\\\Jellyfish.jpg\");\n\n// create a pixel list from a rectangle\n\n$PixelList1 = FastBitmap_GetPixelListFromRectangle(100,200,100,100);\n\n// Display Pixel list by filling pixels in image with green (HSV = 120,100,100)\n\n$FBResultImage = FastBitmap_FillPixelListByHSV($Image,$PixelList1,true,120,100,100);\n\n// display and save image\n\nFastBitmap_DisplayImage($FBResultImage);\n\nFastBitmap_SaveImageToFile($FBResultImage,\"C:\\\\JabilTestScripts\\\\JellyfishPixelListRect.jpg\",\"JPEG\");\n\n// dispose of images\n\nFastBitmap_DisposeImage($Image);\n\nFastBitmap_DisposeImage($FBResultImage);\n\nEnd;\n\nOriginal Image\n\n\n\nImage with pixel list Filled\n\n\n\n\n\nImportant Note:\n\nThe FastBitmap Class is faster than standard bitmap pixel operations but slower than the OpenCV library functions. OpenCV functions should be your first choice for speed if an equivalent function is available.\n\n\n\n\n\nThe FastBitmap Class works on standard Bitmap image object within JabilTest. OpenCV image objects have a different structure. To use an image processed by the FastBitmap class with an OpenCV function, you must open the image using an OpenCV function in order to obtain the correct structure.\n\n\n\n\n\nFastBitmap_GetConnectedComponents\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS FastBitmap_GetConnectedComponents": {
  "prefix": "FastBitmap_GetConnectedComponents",
  "body": [
   "($$ConnectedComponentList,$$ConnectedComponentImage)=FastBitmap_GetConnectedComponents($$Image,$$Hbackground,$$Sbackground,$$Vbackground,$$MinimumSize,$$ReturnConnectedImage);"
  ],
  "description": "\n\n\n\n\n\nThis function analyzes a bitmap image object to determine all of the unique components within the image. This function is a prerequisite to running the FastBitmap_TestConnectedPixels function.\n\n\n\n\n\nFor better performance and less component noise from unwanted regions or colors, you can use the FastBitmap_FillByHSV and FastBitmap_FillPixelListByHSV functions to create a consistent background color (can be specified with the input parameters) for omission to allow more robust component identification and labeling.\n\n\n\n\n\nSmaller features can be filtered out using the $MinimumSize input field.\n\n\n\n\n\nThe function returns a connected component list (described below) and an image that is determined based on the boolean input value.\n\n\n\n\n\nFor more information regarding this type of blob extraction please review the information in the following link: http://en.wikipedia.org/wiki/Connected-component_labeling\n\n\n\n\n\nThis implementation uses 8 way connectivity.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Image\n\nObject\n\nA bitmap image object.\n\n\n\n$Hbackground\n\nInteger\n\nThe Hue of the image background.\n\n\n\n$Sbackground\n\nInteger\n\nThe Saturation of the image background.\n\n\n\n$Vbackground\n\nInteger\n\nThe Value of the image background.\n\n\n\n$MinimumSize\n\nInteger\n\nSpecifies the minimum feature size (# of pixels) to include in connected component analysis. Features smaller than the specified pixel count count will be excluded.\n\n\n\n$ReturnConnectedImage\n\nBoolean\n\nA boolean value indicating which image to return to the $ConnectedComponentImage return parameter\n\nTRUE: Create and return the connected component color image. Creating the connected component color image can have time impacts depending on the number of components in the image.\n\nFALSE: Return the unmodified original $Image that was passed into the function.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ConnectedComponentList\n\nObject\n\nA list that contains a unique index for each separate component in the image. Each unique component index has a list of all the pixels that make up that particular component. This object list is needed to test for connectivity between ROIs using the FastBitmap_TestConnectedPixels function.\n\n\n\n$ConnectedComponentImage\n\nObject\n\nA bitmap image object. Depending on the boolean setting, either the original image that was passed into the function, or a newly created connected component color image. If the $ConnectedComponentImage boolean setting was TRUE, the HSV value of the each connected component is modified to illustrate each unique component. The intent of this output is to provide debug information.\n\n\n\n\n\nUsage Example:\n\n\n\n\n\n//Load image\n\n$Image = FastBitmap_LoadImageFromFile(\"C:\\\\JabilTestScripts\\\\Jellyfish.jpg\");\n\n// Display original image\n\nFastBitmap_DisplayImage($Image);\n\n// Fill pixels with black (HSV = 0,0,0) based on Hue to eliminate colors other than redish orange\n\n$FBResultImage = FastBitmap_FillByHSV($Image,71,249,0,100,0,100,0,0,0);\n\n// Fill pixels with black (HSV = 0,0,0) to eliminate lower saturation levels\n\n$FBResultImage = FastBitmap_FillByHSV($FBResultImage,0,360,0,40,0,100,0,0,0);\n\n// Display and save results of 2nd fill\n\nFastBitmap_DisplayImage($FBResultImage);\n\nFastBitmap_SaveImageToFile($FBResultImage,\"C:\\\\JabilTestScripts\\\\Jellyfish2ndFill.jpg\",\"JPEG\");\n\n// Generate Connectect Component List\n\n($ConnectedComponentList, $ResultImage) = FastBitmap_GetConnectedComponents($FBResultImage,0,0,0,50,true);\n\n// display and save debug output image\n\nFastBitmap_DisplayImage($ResultImage);\n\nFastBitmap_SaveImageToFile($ResultImage,\"C:\\\\JabilTestScripts\\\\JellyfishConnectedComponent.jpg\",\"JPEG\");\n\n// dispose of images\n\nFastBitmap_DisposeImage($Image);\n\nFastBitmap_DisposeImage($FBResultImage);\n\nFastBitmap_DisposeImage($ResultImage);\n\nEnd;\n\nOriginal Image\n\n\n\nImage after 2nd fill by HSV\n\n\n\nDebug image output of Connected Component\n\n\n\n\n\nImportant Note:\n\nThe FastBitmap Class is faster than standard bitmap pixel operations but slower than the OpenCV library functions. OpenCV functions should be your first choice for speed if an equivalent function is available.\n\n\n\n\n\nThe FastBitmap Class works on standard Bitmap image object within JabilTest. OpenCV image objects have a different structure. To use an image processed by the FastBitmap class with an OpenCV function, you must open the image using an OpenCV function in order to obtain the correct structure.\n\n\n\n\n\nFastBitmap_GetPixelListFromCircleRadius\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS FastBitmap_GetPixelListFromCircleRadius": {
  "prefix": "FastBitmap_GetPixelListFromCircleRadius",
  "body": [
   "($$PixelList,$$PixelCount)=FastBitmap_GetPixelListFromCircleRadius($$CenterX,$$CenterY,$$Radius);"
  ],
  "description": "\n\n\n\n\n\nThis function creates a pixel list object that can be used as input parameters for the following FastBitmap functions:\n\nFastBitmap_CreateSupersetFromPixelLists\n\nFastBitmap_FillPixelListByHSV\n\nFastBitmap_CountPixelsInHSVRange\n\nFastBitmap_TestConnectedPixels\n\n\n\n\n\nThe pixel list object that is created is simply a list of pixels that are contained within the user specified circular region of interest. The user supplies the center X/Y coordinate and radius of a circle ROI in terms of image pixels values and the function returns a list of pixels and number of pixels contained within that specified region.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$CenterX\n\nInteger\n\nX-coordinate value (image pixel) of the center of the circle of interest. [must be >= 0]\n\n\n\n$CenterY\n\nInteger\n\nY-coordinate value (image pixel) of the center of the circle of interest. [must be >= 0]\n\n\n\n$Radius\n\nInteger\n\nThe radius of the circle of interest, specified in pixels. [must be > 0]\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$PixelList\n\nObject\n\nA list of pixels that are contained within the specified circular region\n\n\n\n$PixelCount\n\nInteger\n\nThe number of pixels contained in the list/circle\n\n\n\n\n\nUsage Example:\n\n\n\n\n\n//Load image\n\n$Image = FastBitmap_LoadImageFromFile(\"C:\\\\JabilTestScripts\\\\Jellyfish.jpg\");\n\n// create a pixel list from a circle\n\n$PixelList1 = FastBitmap_GetPixelListFromCircleRadius(100,100,50);\n\n// Display Pixel list by filling pixels in image with green (HSV = 120,100,100)\n\n$FBResultImage = FastBitmap_FillPixelListByHSV($Image,$PixelList1,true,120,100,100);\n\n// display and save image\n\nFastBitmap_DisplayImage($FBResultImage);\n\nFastBitmap_SaveImageToFile($FBResultImage,\"C:\\\\JabilTestScripts\\\\JellyfishPixelListCircle.jpg\",\"JPEG\");\n\n// dispose of images\n\nFastBitmap_DisposeImage($Image);\n\nFastBitmap_DisposeImage($FBResultImage);\n\nOriginal Image\n\n\n\nImage with pixel list Filled\n\n\n\n\n\nImportant Note:\n\nThe FastBitmap Class is faster than standard bitmap pixel operations but slower than the OpenCV library functions. OpenCV functions should be your first choice for speed if an equivalent function is available.\n\n\n\n\n\nThe FastBitmap Class works on standard Bitmap image object within JabilTest. OpenCV image objects have a different structure. To use an image processed by the FastBitmap class with an OpenCV function, you must open the image using an OpenCV function in order to obtain the correct structure.\n\n\n\n\n\nFastBitmap_GetPixelListFromRectangle\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS FastBitmap_GetPixelListFromRectangle": {
  "prefix": "FastBitmap_GetPixelListFromRectangle",
  "body": [
   "($$PixelList,$$PixelCount)=FastBitmap_GetPixelListFromRectangle($$X1,$$Y1,$$Height,$$Width);"
  ],
  "description": "\n\n\n\n\n\nThis function creates a pixel list object that can be used as input parameters for the following FastBitmap functions:\n\nFastBitmap_CreateSupersetFromPixelLists\n\nFastBitmap_FillPixelListByHSV\n\nFastBitmap_CountPixelsInHSVRange\n\nFastBitmap_TestConnectedPixels\n\n\n\n\n\nThe pixel list object that is created is simply a list of pixels that are contained within the user specified rectangular region of interest. The user supplies the upper left X/Y coordinate, height, and width of the rectangle ROI in terms of image pixels values and the function returns a list of pixels and number of pixels contained within that specified region.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$X1\n\nInteger\n\nX-coordinate value (image pixel) of the upper left corner of the rectangle of interest. [must be >= 0]\n\n\n\n$Y1\n\nInteger\n\nY-coordinate value (image pixel) of the upper left corner of the rectangle of interest. [must be >= 0]\n\n\n\n$Height\n\nInteger\n\nHeight of the rectangle, in pixels. [must be > 0]\n\n\n\n$Width\n\nInteger\n\nWidth of the rectangle, in pixels. [must be > 0]\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$PixelList\n\nObject\n\nA list of pixels that are contained within the specified rectangular region\n\n\n\n$PixelCount\n\nObject\n\nThe number of pixels contained in the list/rectangle\n\n\n\n\n\nUsage Example:\n\n\n\n\n\n//Load image\n\n$Image = FastBitmap_LoadImageFromFile(\"C:\\\\JabilTestScripts\\\\Jellyfish.jpg\");\n\n// create a pixel list from a rectangle\n\n$PixelList1 = FastBitmap_GetPixelListFromRectangle(100,200,100,100);\n\n// Display Pixel list by filling pixels in image with green (HSV = 120,100,100)\n\n$FBResultImage = FastBitmap_FillPixelListByHSV($Image,$PixelList1,true,120,100,100);\n\n// display and save image\n\nFastBitmap_DisplayImage($FBResultImage);\n\nFastBitmap_SaveImageToFile($FBResultImage,\"C:\\\\JabilTestScripts\\\\JellyfishPixelListRect.jpg\",\"JPEG\");\n\n// dispose of images\n\nFastBitmap_DisposeImage($Image);\n\nFastBitmap_DisposeImage($FBResultImage);\n\nEnd;\n\nOriginal Image\n\n\n\nImage with pixel list Filled\n\n\n\n\n\nImportant Note:\n\nThe FastBitmap Class is faster than standard bitmap pixel operations but slower than the OpenCV library functions. OpenCV functions should be your first choice for speed if an equivalent function is available.\n\n\n\n\n\nThe FastBitmap Class works on standard Bitmap image object within JabilTest. OpenCV image objects have a different structure. To use an image processed by the FastBitmap class with an OpenCV function, you must open the image using an OpenCV function in order to obtain the correct structure.\n\n\n\n\n\nFastBitamp_LoadImageFromFile\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS FastBitmap_LoadImageFromFile": {
  "prefix": "FastBitmap_LoadImageFromFile",
  "body": [
   "$$Image=FastBitmap_LoadImageFromFile($$Filename);"
  ],
  "description": "\n\n\n\n\n\nThis function opens a bitmap image stored on the local computer and creates a bitmap object.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Filename\n\nString\n\nThe filename and path of the image to be loaded into an Bitmap image object.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Image\n\nObject\n\nA Bitmap Image object. This image object is not compatible with OpenCV functions.\n\n\n\n\n\nUsage Example:\n\n$Image = FastBitmap_LoadImageFromFile(\"c:\\\\MyBitmap.bmp\");\n\n\n\n\n\nImportant Note:\n\nThe FastBitmap Class is faster than standard bitmap pixel operations but slower than the OpenCV library functions. OpenCV functions should be your first choice for speed if an equivalent function is available.\n\n\n\n\n\nThe FastBitmap Class works on standard Bitmap image object within JabilTest. OpenCV image objects have a different structure. To use an image processed by the FastBitmap class with an OpenCV function, you must open the image using an OpenCV function in order to obtain the correct structure.\n\n\n\n\n\nFastBitmap_SaveImageAsBitmap\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS FastBitmap_SaveImageToFile": {
  "prefix": "FastBitmap_SaveImageToFile",
  "body": [
   "FastBitmap_SaveImageToFile($$Image,$$FileName,$$ImageType);"
  ],
  "description": "\n\nThis functions saves an image as the image type specified.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Image\n\nObject\n\nAn Image object of any format or color depth.\n\n\n\n$FileName\n\nString\n\nThe save destination filename and path.\n\n\n\n$ImageType\n\nString\n\nThe desired image type from the following list: \"BMP\",\"EMF\",\"EXIF\",\"GIF\",\"ICON\",\"JPEG\",\"PNG\",\"TIFF\",\"WMF\"\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nUsage Example:\n\n\n\n\n\nFastBitmap_SaveImageToFile($Image,\"c:\\\\MyBitmap.bmp\",\"BMP\");\n\n\n\n\n\nImportant Note:\n\nThe FastBitmap Class is faster than standard bitmap pixel operations but slower than the OpenCV library functions. OpenCV functions should be your first choice for speed if an equivalent function is available.\n\n\n\n\n\nThe FastBitmap Class works on standard Bitmap image object within JabilTest. OpenCV image objects have a different structure. To use an image processed by the FastBitmap class with an OpenCV function, you must open the image using an OpenCV function in order to obtain the correct structure.\n\n\n\n\n\nFastBitmap_TestConnectedPixels\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS FastBitmap_TestConnectedPixels": {
  "prefix": "FastBitmap_TestConnectedPixels",
  "body": [
   "$$ConnectionCount=FastBitmap_TestConnectedPixels($$PixelList1,$$PixelList2,$$ConnectedComponentList);"
  ],
  "description": "\n\n\n\n\n\nThis function tests for connectivity between two specified ROIs (passed in and described as pixel list objects) within an image.\n\n\n\n\n\nThis function requires two pixel list objects be provided as input parameters. Each pixel list can be thought of as an enhanced ROI description. It contains a list of pixels in the image where you are interested in performing the connection analysis. It can be as simple as a single rectangular or circle ROI description, or a combination of numerous rectangular or circle areas in the image built using the superset function. A pixel list can be created using the following functions:\n\nFastBitmap_GetPixelListFromCircleRadius\n\nFastBitmap_GetPixelListFromRectangle\n\nFastBitmap_CreateSupersetFromPixelLists\n\n\n\n\n\nThis function requires a connected component object list ($ConnectedComponentList) which is created using the FastBitmap_GetConnectedComponents function. The connected component object list contains a pixel list for each unique component that was found in the image. Each unique component was assigned an index ID.\n\n\n\n\n\nThis function determines all of the component index IDs contained in $PixelList1 and all of the component index IDs contained in $PixelList2. Any common component index IDs shared between $PixelList1 and $PixelList2 represents a connection between them. Using this method, the function counts the shared component index IDs and returns that as the connection count number.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$PixelList1\n\nObject\n\nA list object that contains pixels of interest. This list is created using other FastBitmap functions (see explanation above).\n\n\n\n$PixelList2\n\nObject\n\nA list object that contains pixels of interest. This list is created using other FastBitmap functions (see explanation above).\n\n\n\n$ConnectedComponentList\n\nObject\n\nThe connected component object list created using the FastBitmap_GetConnectedComponents function. (see function description for more information)\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ConnectionCount\n\nInteger\n\nReturns the count of connections between the pixel lists provided.\n\n\n\n\n\nUsage Example:\n\n\n\n\n\n//Load image\n\n$Image = FastBitmap_LoadImageFromFile(\"C:\\\\JabilTestScripts\\\\Jellyfish.jpg\");\n\n// Display original image\n\nFastBitmap_DisplayImage($Image);\n\n// Fill pixels with black (HSV = 0,0,0) based on Hue to eliminate colors other than redish orange\n\n$FBResultImage = FastBitmap_FillByHSV($Image,71,249,0,100,0,100,0,0,0);\n\n// Fill pixels with black (HSV = 0,0,0) to eliminate lower saturation levels\n\n$FBResultImage = FastBitmap_FillByHSV($FBResultImage,0,360,0,40,0,100,0,0,0);\n\n// Display and save results of 2nd fill\n\nFastBitmap_DisplayImage($FBResultImage);\n\nFastBitmap_SaveImageToFile($FBResultImage,\"C:\\\\JabilTestScripts\\\\Jellyfish2ndFill.jpg\",\"JPEG\");\n\n// Generate Connectect Component List\n\n($ConnectedComponentList, $ConnectedComponentDebugImage) = FastBitmap_GetConnectedComponents($FBResultImage,0,0,0,50,true);\n\n// display and save debug output image\n\nFastBitmap_DisplayImage($ConnectedComponentDebugImage);\n\nFastBitmap_SaveImageToFile($ConnectedComponentDebugImage,\"C:\\\\JabilTestScripts\\\\JellyfishConnectedComponentDebugImage.jpg\",\"JPEG\");\n\n// create pixel lists to check for connectivity\n\n$PixelList1 = FastBitmap_GetPixelListFromRectangle(100,200,100,100);\n\n$PixelList2 = FastBitmap_GetPixelListFromCircleRadius(450,100,50);\n\n// create image using debug output of FastBitmap_GetConnectedComponents to display pixel list area\n\n$DebugImageWithPixelListFill = FastBitmap_FillPixelListByHSV($ConnectedComponentDebugImage,$PixelList1,true,120,100,100);\n\n$DebugImageWithPixelListFill = FastBitmap_FillPixelListByHSV($DebugImageWithPixelListFill,$PixelList2,true,120,100,100);\n\n// display and save debug output image\n\nFastBitmap_DisplayImage($DebugImageWithPixelListFill);\n\nFastBitmap_SaveImageToFile($DebugImageWithPixelListFill,\"C:\\\\JabilTestScripts\\\\JellyfishConnectedComponentResultWithPixelListFill.jpg\",\"JPEG\");\n\n// Check for pixel continutity between the two pixel lists using connected component list\n\n$Connections = FastBitmap_TestConnectedPixels($PixelList1,$PixelList2,$ConnectedComponentList);\n\n// dispose of images\n\nFastBitmap_DisposeImage($Image);\n\nFastBitmap_DisposeImage($FBResultImage);\n\nFastBitmap_DisposeImage($ConnectedComponentDebugImage);\n\nFastBitmap_DisposeImage($DebugImageWithPixelListFill);\n\nEnd;\n\nSegmented image after 2nd fill\n\n\n\nDebug image after connected component labeling\n\n\n\nDebug image after connected component labeling showing pixel areas being tested for connectivity\n\n\n\n\n\nThe result is a connection count of one since there is one common connected component intersecting the two tested pixel areas.\n\nFastBitmap_TestConnectedPixels: Connection Count [1]\n\n\n\n\n\nImportant Note:\n\nThe FastBitmap Class is faster than standard bitmap pixel operations but slower than the OpenCV library functions. OpenCV functions should be your first choice for speed if an equivalent function is available.\n\n\n\n\n\nThe FastBitmap Class works on standard Bitmap image object within JabilTest. OpenCV image objects have a different structure. To use an image processed by the FastBitmap class with an OpenCV function, you must open the image using an OpenCV function in order to obtain the correct structure.\n\n\n\n\n\nImageResize\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ImageResize": {
  "prefix": "ImageResize",
  "body": [
   "ImageResize($$FileName,$$Scaling,$$DestinationFileName);"
  ],
  "description": "\n\nThis function scales the supplied image file to the percentage specified, and saves it in the destination filename location. A scaling percentage less than 100% reduces the image size, and a scaling percentage greater than 100% increases the image size.\n\n\n\nRequirements:\n\n\n\nUsage Example:\n\nImageResize(\"c:\\\\myImage.bmp\",150,\"c:\\\\myImage2.bmp\");\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$FileName\n\nString\n\nThe filename and path of the image to transform.\n\n\n\n$ScalingPercentage\n\nInteger\n\nThe percentage to scale the image.\n\n\n\n$DestinationFile\n\nString\n\nThe filename and path of the destination image.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nImageRotate\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ImageRotate": {
  "prefix": "ImageRotate",
  "body": [
   "ImageRotate($$FileName,$$RotationType,$$DestinationFileName);"
  ],
  "description": "\n\nThis function rotates and flips the supplied image, and saves it in the location specified by the destination file name.\n\nRequirements:\n\n\n\nUsage Example:\n\nImageRotate(\"c:\\\\myFile.bmp\",\"Rotate180FlipNone\",\"c:\\\\myNewFile.bmp\");\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$FileName\n\nString\n\nThe filename and path of the image to transform.\n\n\n\n$RotationType\n\nString\n\nThe type of rotation and flip transform to apply to the image. Supported transformation types are:\n\n\u00b7 \"Rotate180FlipNone\"\n\n\u00b7 \"Rotate180FlipX\"\n\n\u00b7 \"Rotate180FlipY\"\n\n\u00b7 \"Rotate180FlipXY\"\n\n\u00b7 \"Rotate90FlipNone\"\n\n\u00b7 \"Rotate90FlipX\"\n\n\u00b7 \"Rotate90FlipY\"\n\n\u00b7 \"Rotate90FlipXY\"\n\n\u00b7 \"Rotate270FlipNone\"\n\n\u00b7 \"Rotate270FlipX\"\n\n\u00b7 \"Rotate270FlipY\"\n\n\u00b7 \"Rotate270FlipXY\"\n\n\n\n$DestinationFile\n\nString\n\nThe filename and path of the destination image.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nMSOffice2007_OCRImage\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS MSOffice2007_OCRImage": {
  "prefix": "MSOffice2007_OCRImage",
  "body": [
   "($$Text,$$NumWords,$$NumChars,$$NumFonts)=MSOffice2007_OCRImage($$ImageName,$$Language,$$OrientImage,$$StraightenImage);"
  ],
  "description": "\n\nThis function uses the Microsoft Office 2007 Document Imaging Library to convert any text found in an image file into a string. This function will automatically convert the image type into the necessary format, and will also align the image automatically.\n\n\n\nRequirements:\n\nThis function requires Microsoft Office 2007 to be installed on the test machine in order to use this function.\n\n\n\nNote:\n\nThis function has been deprecated and may not be included in future versions of Jabil Test. Use OpenCV_PerformOCR for OCR functions.\n\n\n\nUsage Example:\n\n($Text,$NumWords,$NumChars,$NumFonts) = MSOffice2007_OCRImage(\"c:\\\\image0.tif\",\"English\",\"TRUE\",\"TRUE\");\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ImageName\n\nString\n\nThe file path and name of the image to be analyzed.\n\n\n\n$Language\n\nString\n\nThe language of the document to be analyzed. This function supports the following languages:\n\n\u00b7 \"ENGLISH\"\n\n\u00b7 \"CHINESE SIMPLIFIED\"\n\n\u00b7 \"CHINESE TRADITIONAL\"\n\n\u00b7 \"CZECH\"\n\n\u00b7 \"DANISH\"\n\n\u00b7 \"DUTCH\"\n\n\u00b7 \"ENGLISH\"\n\n\u00b7 \"FINNISH\"\n\n\u00b7 \"FRENCH\"\n\n\u00b7 \"GERMAN\"\n\n\u00b7 \"GREEK\"\n\n\u00b7 \"HUNGARIAN\"\n\n\u00b7 \"ITALIAN\"\n\n\u00b7 \"JAPANESE\"\n\n\u00b7 \"KOREAN\"\n\n\u00b7 \"NORWEGIAN\"\n\n\u00b7 \"POLISH\"\n\n\u00b7 \"PORTUGUESE\"\n\n\u00b7 \"RUSSIAN\"\n\n\u00b7 \"SPANISH\"\n\n\u00b7 \"SWEDISH\"\n\n\u00b7 \"SYSDEFAULT\"\n\n\u00b7 \"TURKISH\"\n\n\n\n\n\n$OrientImage\n\nBoolean\n\nThis boolean flag determines whether or not the OCR Engine should orient the image before running the OCR function. Note: The orientation algorithm used on the image is dependant on the language selected.\n\n\n\n$StraightenImage\n\nBoolean\n\nThis boolean flag determines whether or not the OCR engine should attempt to straighten the image before running the OCR function.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Text\n\nString\n\nThe complete text read from the image including any formatting such as new lines, spaces, tabs, etc\n\n\n\n$NumWords\n\nInteger\n\nThe number of words recognized in the image file\n\n\n\n$NumChars\n\nInteger\n\nThe number of characters recognized in the image file excluding whitespace\n\n\n\n$NumFonts\n\nInteger\n\nThe number of different fonts that were encountered in the image file.\n\n\n\n\n\nHexLimitTest\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS HexLimitTest": {
  "prefix": "HexLimitTest",
  "body": [
   "HexLimitTest($$compareValue,$$lowerLimit,$$upperLimit);"
  ],
  "description": "\n\nCompares the comparison value in a hexadecimal string to an upper and lower limit. If the Comparison value falls between (or is equal to) the supplied limits, the test passes. Otherwise, the test produces a failure.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$compareValue\n\nString\n\nThe hexadecimal string representing the value to be evaluated against the supplied limits.\n\n\n\n$lowerLimit\n\nString\n\nThe hexadecimal string representing the lower comparison limit.\n\n\n\n$upperLimit\n\nString\n\nThe hexadecimal string representing the upper comparison limit.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone.\n\n\n\n\n\nExample:\n\n// Set up the value and the limits to test it against.\n\n$compareValue = \"34AB\";\n\n$lowerLimit = \"300A\";\n\n$upperLimit = \"3FFF\";\n\n\n\n\n\n// Compare the numbers (this one will pass).\n\nHexLimitTest($compareValue, $lowerLimit, $upperLimit);\n\n\n\n\n\nHexLimitTestBool\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS HexLimitTestBool": {
  "prefix": "HexLimitTestBool",
  "body": [
   "$$inLimits=HexLimitTestBool($$compareValue,$$lowerLimit,$$upperLimit);"
  ],
  "description": "\n\nCompares the comparison value in a hexadecimal string to an upper and lower limit. If the Comparison value falls between (or is equal to) the supplied limits, the test returns TRUE, else the test returns FALSE.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$compareValue\n\nString\n\nThe hexadecimal string representing the value to be evaluated against the supplied limits.\n\n\n\n$lowerLimit\n\nString\n\nThe hexadecimal string representing the lower comparison limit.\n\n\n\n$upperLimit\n\nString\n\nThe hexadecimal string representing the upper comparison limit.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$inLimits\n\nBoolean\n\nReturns true if the comparison value is between the limits and false if the value is outside of the limits.\n\n\n\n\n\nExample:\n\n// Set up the value and the limits to test it against.\n\n$compareValue = \"34AB\";\n\n$lowerLimit = \"300A\";\n\n$upperLimit = \"3FFF\";\n\n\n\n\n\n// Compare the numbers (this one will pass).\n\n$inLimits = HexLimitTestBool($compareValue, $lowerLimit, $upperLimit);\n\n\n\n\n\nNumericLimitTest\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NumericLimitTest": {
  "prefix": "NumericLimitTest",
  "body": [
   "NumericLimitTest($$compareValue,$$lowerLimit,$$upperLimit);"
  ],
  "description": "\n\nCompares the floating point comparison value to an upper and lower limit. If the Comparison value falls between (or is equal to) the supplied limits, the test passes. Otherwise, the test produces a failure. This function is compatible with all numeric values.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$compareValue\n\nFloat\n\nThe value to be evaluated against the supplied limits.\n\n\n\n$lowerLimit\n\nFloat\n\nThe lower comparison limit.\n\n\n\n$upperLimit\n\nFloat\n\nThe upper comparison limit.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone.\n\n\n\n\n\nExample:\n\n// Set up the value and the limits to test it against.\n\n$compareValue = 986;\n\n$lowerLimit = 600;\n\n$upperLimit = 1200;\n\n\n\n\n\n// Compare the numbers (this one will pass).\n\nNumericLimitTest($compareValue, $lowerLimit, $upperLimit);\n\n\n\n\n\nNumericLimitTestBool\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS NumericLimitTestBool": {
  "prefix": "NumericLimitTestBool",
  "body": [
   "$$inLimits=NumericLimitTestBool($$compareValue,$$lowerLimit,$$upperLimit);"
  ],
  "description": "\n\nCompares the floating point comparison value to an upper and lower limit. If the Comparison value falls between (or is equal to) the supplied limits, the test returns TRUE, else the test returns FALSE.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$compareValue\n\nFloat\n\nThe value to be evaluated against the supplied limits.\n\n\n\n$lowerLimit\n\nFloat\n\nThe lower comparison limit.\n\n\n\n$upperLimit\n\nFloat\n\nThe upper comparison limit.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$inLimits\n\nBoolean\n\nReturns true if the comparison value is between the limits and false if the value is outside of the limits.\n\n\n\n\n\nExample:\n\n// Set up the value and the limits to test it against.\n\n$compareValue = 986;\n\n$lowerLimit = 600;\n\n$upperLimit = 1200;\n\n\n\n\n\n// Compare the numbers (this one will pass).\n\n$inLimits = NumericLimitTestBool($compareValue, $lowerLimit, $upperLimit);\n\n\n\n\n\nOpenCV_ScanBarCode\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OpenCV_ScanBarCode": {
  "prefix": "OpenCV_ScanBarCode",
  "body": [
   "($$Success,$$Count,$$Type,$$Contents)=OpenCV_ScanBarCode($$Image);"
  ],
  "description": "\n\nThis functions receives an OpenCV image object and scans the image for a bar code. This function will return three parameters indicating whether a bar code was found and if so, the type and contents of the bar code. If more than one bar code is found in the image, the type and content variables will be delimited by a colon.\n\n\n\n\n\nImportant Note:\n\nAny cameras or other video input devices opened with the OpenCV_OpenCamera function must be closed with the OpenCV_CloseCamera function to prevent resource leaks.\n\n\n\nRequirements:\n\nThese functions use the Open-Source OpenCV computer vision library from Intel, and therefore will offer the maximum performance when running on Intel Processors due to low-level optimizations for the Intel architecture. Any camera or input device that Windows recognizes as an imaging device should be compatible with these functions.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Image\n\nObject\n\nAn OpenCV Image Structure that has been loaded from an existing file or camera capture.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Success\n\nBoolean\n\nIndicating whether bar code could be analyzed\n\n\n\n$Count\n\nInteger\n\nNumber of Bar Codes Found\n\n\n\n$Type\n\nString\n\nBar code type (Colon : Delimited if more than one bar code is found)\n\n\n\n$Contents\n\nString\n\nBar code contents (Colon : Delimited if more than one bar code is found)\n\n\n\n\n\nUsage Example:\n\n($Success,$Count,$Type,$Contents) = OpenCV_ScanBarCode($Image);\n\n\n\n\n\nOpenCV_ScanBarCodeWithROI\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OpenCV_ScanBarCodeWithROI": {
  "prefix": "OpenCV_ScanBarCodeWithROI",
  "body": [
   "($$Success,$$Count,$$Type,$$Contents)=OpenCV_ScanBarCodeWithROI($$Image,$$X,$$Y,$$Width,$$Height);"
  ],
  "description": "\n\nThis functions receives an OpenCV image object and scans the specified region of interest for a bar code. This function will return three parameters indicating whether a bar code was found with the region of interest and if so, the type and contents of the bar code. If more than one bar code is found in the image, the type and content variables will be delimited by a colon.\n\n\n\n\n\nNote: If the region of interest exceeds the bounds of the image, the region of interest will be modified to obtain the image's original bounds.\n\n\n\n\n\nImportant Note:\n\nAny cameras or other video input devices opened with the OpenCV_OpenCamera function must be closed with the OpenCV_CloseCamera function to prevent resource leaks.\n\n\n\nRequirements:\n\nThese functions use the Open-Source OpenCV computer vision library from Intel, and therefore will offer the maximum performance when running on Intel Processors due to low-level optimizations for the Intel architecture. Any camera or input device that Windows recognizes as an imaging device should be compatible with these functions.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Image\n\nObject\n\nAn OpenCV Image Structure that has been loaded from an existing file or camera capture.\n\n\n\n$X\n\nInteger\n\nUpper left X coordinate of the region of interest.\n\n\n\n$Y\n\nInteger\n\nUpper left Y coordinate of the region of interest.\n\n\n\n$Width\n\nInteger\n\nThe width of the region of interest.\n\n\n\n$Height\n\nInteger\n\nThe height of the region of interest.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Success\n\nBoolean\n\nIndicating whether bar code could be analyzed\n\n\n\n$Count\n\nInteger\n\nNumber of bar codes found.\n\n\n\n$Type\n\nString\n\nBar code type (Colon : Delimited if more than one bar code is found)\n\n\n\n$Contents\n\nString\n\nBar code contents (Colon : Delimited if more than one bar code is found)\n\n\n\n\n\nUsage Example:\n\n($Success, $Count, $Type, $Contents) = OpenCV_ScanBarCodeWithROI($Image, 20, 20, 100, 100);\n\n\n\n\n\nOpenCV_AsynShowCameraOutputInWindow\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OpenCV_AsynShowCamerOutputInWindow": {
  "prefix": "OpenCV_AsynShowCamerOutputInWindow",
  "body": [
   "$$handle=OpenCV_AsynShowCamerOutputInWindow($$cameraObj,$$width,$$height);"
  ],
  "description": "\n\nThis function will open an asynchronous window and show the output from the specified camera.\n\n\n\n\n\nRemarks:\n\nThe camera must have previously opened using OpenCV_OpenCamera.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$cameraObj\n\nObject\n\nThe camera object\n\n\n\n$width\n\nInteger\n\nThe width of the window to open.\n\n\n\n$height\n\nInteger\n\nThe height of the window to open.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$handle\n\nObject\n\nThe handle of the window that was opened\n\n\n\n\n\nExample:\n\n$camera = OpenCV_OpenCamera(0);\n\n\n\n\n\n$handle = OpenCV_AsynShowCameraOutputInWindow($camera, 1024, 768);\n\n\n\n\n\nOpenCV_CloseAsynWindow\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OpenCV_CloseAsynWindow": {
  "prefix": "OpenCV_CloseAsynWindow",
  "body": [
   "OpenCV_CloseAsynWindow($$handle);"
  ],
  "description": "\n\nThis function is used to close an asynchronous window opened with OpenCV_AsynShowCameraOutputInWindow.\n\n\n\n\n\nRemarks:\n\nThese functions use the Open-Source OpenCV computer vision library from Intel, and therefore will offer the maximum performance when running on Intel Processors due to low-level optimizations for the Intel architecture.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$handle\n\nObject\n\nThe handle to asynchronous window.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n$camera = OpenCV_OpenCamera(0);\n\n$handle = OpenCV_AsynShowCameraOutputInWindow($camera, 1024, 768);\n\n\n\n\n\nOpenCV_CloseAsynWindow($handle);\n\n\n\n\n\nOpenCV_CloseCamera\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OpenCV_CloseCamera": {
  "prefix": "OpenCV_CloseCamera",
  "body": [
   "OpenCV_CloseCamera($$Camera);"
  ],
  "description": "\n\nThis function closes an imaging device that has been opened using the OpenCV_OpenCamera function and disposes of its resources. After a Camera has been closed, it must be re-opened to begin using it again.\n\n\n\n\n\nImportant Note:\n\nAny cameras or other video input devices opened with the OpenCV_OpenCamera function must be closed with the OpenCV_CloseCamera function to prevent resource leaks.\n\n\n\nRequirements:\n\nThese functions use the Open-Source OpenCV computer vision library from Intel, and therefore will offer the maximum performance when running on Intel Processors due to low-level optimizations for the Intel architecture. Any camera or input device that Windows recognizes as an imaging device should be compatible with these functions.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Camera\n\nObject\n\nA handle to the camera or imaging device to be closed. This handle should have been created using the OpenCV_OpenCamera function.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nUsage Example:\n\n\n\n\n\n$Camera = OpenCV_OpenCamera(0);\n\nSetFinalizeFunction(\"Cleanup\");\n\nEnd;\n\n\n\n\n\nfunction Cleanup()\n\n{\n\nOpenCV_CloseCamera($Camera);\n\nEnd;\n\n}\n\n\n\n\n\nOpenCV_GetCameraProperties\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OpenCV_GetCameraProperties": {
  "prefix": "OpenCV_GetCameraProperties",
  "body": [
   "($$Width,$$Height,$$FramesPerSecond,$$Format,$$Brightness,$$Contrast)=OpenCV_GetCameraProperties($$Camera);"
  ],
  "description": "\n\nThis function returns the current configuration properties for the specified camera object.\n\n\n\nRequirements:\n\nThese functions use the Open-Source OpenCV computer vision library from Intel, and therefore will offer the maximum performance when running on Intel Processors due to low-level optimizations for the Intel architecture. Any camera or input device that Windows recognizes as an imaging device should be compatible with these functions.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Camera\n\nObject\n\nThe handle of the Imaging Object to retrieve its currently configured properties\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Width\n\nFloat\n\nThe width of the camera capture image\n\n\n\n$Height\n\nFloat\n\nThe height of the camera capture image\n\n\n\n$FramesPerSecond\n\nFloat\n\nThe average frames per second set for the camera (0 usually indicates maximum frames per second is configured, but this is hardware dependent)\n\n\n\n$Format\n\nInteger\n\nAn integer representing an enumeration of the format of the camera (RGB, Bits Depth, etc)\n\n\n\n$Brightness\n\nFloat\n\nThe current brightness gain value set for the camera. This is an offset value to adjust the cameras overall sensitivity. The default value is 0.\n\n\n\n$Contrast\n\nFloat\n\nThe current contrast gain value set for the camera. This is an offset value to adjust the cameras overall contrast sensitivity. The default value is 0.\n\n\n\n\n\nUsage Example:\n\n\n\n\n\n($Width,$Height,$FramesPerSecond,$Format,$Brightness,$Contrast) = OpenCV_GetCameraProperties($Camera);\n\nUpdateStatus($Width);\n\nUpdateStatus($Height);\n\nUpdateStatus($FramesPerSecond);\n\nUpdateStatus($Format);\n\nUpdateStatus($Brightness);\n\nUpdateStatus($Contrast);\n\n\n\n\n\nOpenCV_OpenCamera\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OpenCV_OpenCamera": {
  "prefix": "OpenCV_OpenCamera",
  "body": [
   "$$Camera=OpenCV_OpenCamera($$CameraIndex);"
  ],
  "description": "\n\nThis function opens a supported camera device (USB, Firewire, Gig-E, etc) for image capture. The camera is specified by an integer index, starting at 0. If only a single camera is available, it is always camera index 0.\n\n\n\n\n\nOpening the camera reserves it for use, but does not begin the image acquisition process.\n\n\n\n\n\nImportant Note:\n\nAny cameras or other video input devices opened with the OpenCV_OpenCamera function must be closed with the OpenCV_CloseCamera function to prevent resource leaks.\n\n\n\nRequirements:\n\nThese functions use the Open-Source OpenCV computer vision library from Intel, and therefore will offer the maximum performance when running on Intel Processors due to low-level optimizations for the Intel architecture. Any camera or input device that Windows recognizes as an imaging device should be compatible with these functions.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$CameraIndex\n\nInteger\n\nThe index of the camera to reserve for use.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Camera\n\nObject\n\nA handle to the imaging device.\n\n\n\n\n\nUsage Example:\n\n$Camera = OpenCV_OpenCamera(0);\n\n\n\n\n\nOpenCV_OpenDevicePropertiesWindow\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OpenCV_OpenDevicePropertiesWindow": {
  "prefix": "OpenCV_OpenDevicePropertiesWindow",
  "body": [
   "OpenCV_OpenDevicePropertiesWindow($$captureDeviceIndex);"
  ],
  "description": "\n\nLaunches the default system properties windows for the video capture device specified.\n\n\n\n\n\nNote: The property window is non-blocking; the test script will continue executing after the window is displayed. This allows adjustments to be made in real-time in conjunction with a camera output display function (such as OpenCV_ShowCameraOutputInWindow).\n\n\n\n\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$captureDeviceIndex\n\nInteger\n\nVideo capture device index. This is 0 if only one device is present on the system.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n--\n\n\n\n\n\nExample:\n\nOpenCV_OpenDevicePropertiesWindow(0); //opens properties windows\n\nOpenCV_ShowCameraOutputInWindow($Camera); //opens camera display window, pauses script\n\n\n\n\n\nOpenCV_QueryFrame\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OpenCV_QueryFrame": {
  "prefix": "OpenCV_QueryFrame",
  "body": [
   "$$Image=OpenCV_QueryFrame($$Camera);"
  ],
  "description": "\n\nThis function captures a single 24 bit color image from the imaging device specified by the $Camera argument at it's native resolution, and returns it as $Image. If the camera is configured for a different imaging format or color depth, the image is converted into a 24 Bit RGB image structure.\n\n\n\n\n\nThe imaging hardware must first be opened using the OpenCV_OpenCamera function before calling this function.\n\n\n\n\n\nNote: In order to return the current view, this function performs a double query each time. Looped queries that are concerned with performance should use the OpenCV_QueryFrameFast() function instead. However, be aware that functions returns the previously queried frame, not the expected frame being currently queried, so an extra call is required to return the final frame desired.\n\n\n\nRequirements:\n\n\n\n\n\nThese functions use the Open-Source OpenCV computer vision library from Intel, and therefore will offer the maximum performance when running on Intel Processors due to low-level optimizations for the Intel architecture. Any camera or input device that Windows recognizes as an imaging device should be compatible with these functions.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Camera\n\nObject\n\nThe handle of the Imaging Object to retrieve its currently configured properties\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Image\n\nObject\n\nReturns a 24-Bit RGB Image object that represents the current camera view.\n\n\n\n\n\nUsage Example:\n\n\n\n\n\n$Camera = OpenCV_OpenCamera(0);\n\n$Image = OpenCV_QueryFrame($Camera);\n\nOpenCV_CloseCamera($Camera);\n\n\n\n\n\nOpenCV_QueryFrameFast\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OpenCV_QueryFrameFast": {
  "prefix": "OpenCV_QueryFrameFast",
  "body": [
   "$$Image=OpenCV_QueryFrameFast($$Camera);"
  ],
  "description": "\n\nThis function captures a single 24 bit color image from the imaging device specified by the $Camera argument at it's native resolution. If the camera is configured for a different imaging format or color depth, the image is converted into a 24 Bit RGB image structure.\n\n\n\n\n\nThe imaging hardware must first be opened using the OpenCV_OpenCamera function before calling this function.\n\n\n\n\n\nNote: The image returned by this function is always the LAST frame that was queried! E.g., the first time this function is called, the return parameter $Image will be the frame stored when the camera was initialized with OpenCV_OpenCamera(). The seconds time it is called, $Image will be the frame stored during the first call to OpenCV_QueryFrameFast(). The third call will return the frame queried in the seconds call, etc.\n\n\n\n\n\nTo return a frame that shows the current view every time, use the OpenCV_QueryFrame() function. Be aware that function runs at half the speed of this function.\n\n\n\nRequirements:\n\n\n\n\n\nThese functions use the Open-Source OpenCV computer vision library from Intel, and therefore will offer the maximum performance when running on Intel Processors due to low-level optimizations for the Intel architecture. Any camera or input device that Windows recognizes as an imaging device should be compatible with these functions.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Camera\n\nObject\n\nThe handle of the Imaging Object to retrieve its currently configured properties\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Image\n\nObject\n\nReturns a 24-Bit RGB Image object. Note this is not the current camera view, but the frame from the last query.\n\n\n\n\n\nUsage Example:\n\n\n\n\n\n$Camera = OpenCV_OpenCamera(0);\n\n$Image = OpenCV_QueryFrameFast($Camera); //returns frame captured when camera initialized\n\n$Image = OpenCV_QueryFrameFast($Camera); //returns frame captrued by last query call\n\nOpenCV_CloseCamera($Camera);\n\n\n\n\n\nOpenCV_QueryFrameWithAveraging\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OpenCV_QueryFrameWithAveraging": {
  "prefix": "OpenCV_QueryFrameWithAveraging",
  "body": [
   "$$Image=OpenCV_QueryFrameWithAveraging($$Camera,$$NumberOfFrames);"
  ],
  "description": "\n\nThis function captures a series of 24 bit color image from the imaging device specified by the $Camera argument at it's currently configured resolution. If the camera is configured for a different imaging format or color depth, the image is converted into a 24 Bit RGB image structure.\n\n\n\n\n\nThe camera captures several frames (specified by the $NumberOfFrames) argument and then does a non-weighted averaging on the frames to create a composite image of all the captured images.\n\nThis image averaging is useful for removing \"noise\" and color banding from lower cost imaging devices such as USB webcams.\n\n\n\n\n\nThe imaging hardware must first be opened using the OpenCV_OpenCamera function before calling this function.\n\n\n\n\n\nNote:\n\nIn order to effectively make use of this function, there can be no movement in the frame due to the imaging process, or the result will be a blurred or \"ghosted\" image.\n\n\n\n\n\nNote: This function was developed in Visual C++ 2008 and require the latest version of the Microsoft Visual C++ runtime which can be downloaded from Microsoft.\n\n\n\n\n\nRequirements:\n\n\n\n\n\nThese functions use the Open-Source OpenCV computer vision library from Intel, and therefore will offer the maximum performance when running on Intel Processors due to low-level optimizations for the Intel architecture. Any camera or input device that Windows recognizes as an imaging device should be compatible with these functions.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Camera\n\nObject\n\nThe handle of the Imaging Object to retrieve its currently configured properties\n\n\n\n$NumberOfFrames\n\nInteger\n\nThe number of frames which should be averaged together in order to create the final noise-free composite image.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Image\n\nObject\n\nReturns a 24-Bit RGB Image object.\n\n\n\n\n\nUsage Example:\n\n\n\n\n\n$Camera = OpenCV_OpenCamera(0);\n\n$Image = OpenCV_QueryFrameWithAveraging($Camera,5);\n\nOpenCV_CloseCamera($Camera);\n\n\n\n\n\nOpenCV_QueryGrayFrame\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OpenCV_QueryGrayFrame": {
  "prefix": "OpenCV_QueryGrayFrame",
  "body": [
   "$$Image=OpenCV_QueryGrayFrame($$Camera);"
  ],
  "description": "\n\nThis function captures a single 8 bit grayscale image from the imaging device specified by the $Camera argument at it's native resolution. If the camera is configured for a different imaging format or color depth, the image is converted into a 8 Bit grayscale image structure.\n\n\n\n\n\nThe imaging hardware must first be opened using the OpenCV_OpenCamera function before calling this function.\n\n\n\n\n\nThis is a convenient function to use for image acquisition since many of the analysis and transformation algorithms are designed to work on gray-scale images for improved performance.\n\n\n\nRequirements:\n\n\n\n\n\nThese functions use the Open-Source OpenCV computer vision library from Intel, and therefore will offer the maximum performance when running on Intel Processors due to low-level optimizations for the Intel architecture. Any camera or input device that Windows recognizes as an imaging device should be compatible with these functions.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Camera\n\nObject\n\nThe handle of the Imaging Object to retrieve its currently configured properties\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Image\n\nObject\n\nReturns an 8 Bit grayscale image object.\n\n\n\n\n\nUsage Example:\n\n\n\n\n\n$Camera = OpenCV_OpenCamera(0);\n\n$Image = OpenCV_QueryGrayFrame($Camera);\n\nOpenCV_CloseCamera($Camera);\n\n\n\n\n\nOpenCV_RecordVideo\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OpenCV_RecordVideo": {
  "prefix": "OpenCV_RecordVideo",
  "body": [
   "OpenCV_RecordVideo($$Camera,$$Duration,$$FPS,$$CodecString,$$UseColor,$$FileName);"
  ],
  "description": "\n\nThis function can be used to record a video file from an OpenCV Capture device, and store it to a file using the specified video encoding codec. The $FPS parameters specifies the desired frames per second for the video. If the specified frames per second exceeds the capabilities of the capture device, the maximum FPS of the capture device will be used.\n\n\n\n\n\nThe $CodecString specifies the desired video encoder to use for recording the video. The Codec is specified using a four character string as defined the the Four CC standard. (For more information, see www.fourcc.org). The most common codec codes are shown below... if you would like a listing of the installed codecs on your system, and to be able to manually choose the codec to use for video recording, use the value of '0000' in this parameter and an options dialog will be displayed when the function runs with all the codecs installed, and adjustable parameters that can be selected before video recording begins.\n\n\n\n\n\nThe $UseColor parameter specifies whether to record the video using color, or else in grayscale.\n\nFinally, the $FileName specifies the destination file name for the output file. If there is an existing file at this location, it will be overwritten with the new file.\n\n\n\n\n\nRemarks:\n\nAny camera or input device that Windows recognizes as an imaging device should be compatible with these functions.\n\nThis function uses the OpenCV and EMGU CV libraries version 3.3.0.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Camera\n\nObject\n\nThe handle of the Imaging Object to use for video capture.\n\n\n\n$Duration\n\nInteger\n\nThe number of seconds of video to record\n\n\n\n$FPS\n\nInteger\n\nThe desired number of frames per second for the captured video.\n\n\n\n$CodecString\n\nString\n\nThe four character FourCC code for the video codec. See the fourcc.org website for additional information. Some common codecs used are:\n\n\"PIM1\" = MPEG-1\n\n\"MJPG\" = Motion JPEG\n\n\"DIB \" = RGB AVI Files\n\n\"IYUV\" = Uncompressed YUV, 4:2;) chroma\n\nsubsampled video.\n\n\"0000\" = Manually Select the Codec to use\n\n\n\n$UseColor\n\nBoolean\n\nSpecifies whether or not to use color for the recorded video file.\n\n\n\n$FileName\n\nString\n\nThe output file name for the recorded video file.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nUsage Example:\n\n\n\n\n\nOpenCV_RecordVideo($Camera, 10, 30, \"IYUV\", true, \"mytestfile.avi\");\n\n\n\n\n\nOpenCV_SetCameraBrightness\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OpenCV_SetCameraBrightness": {
  "prefix": "OpenCV_SetCameraBrightness",
  "body": [
   "OpenCV_SetCameraBrightness($$Camera,$$brightness);"
  ],
  "description": "\n\nThis function sets the brightness for the selected camera.\n\n\n\n\n\nRemarks:\n\nThis function uses the OpenCV and EMGU CV libraries version 3.3.0.\n\nCommunication with the camera must previously been opened with OpenCV_OpenCamera.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Camera\n\nObject\n\nA previously opened connection to a camera.\n\n\n\n$brightness\n\nInteger\n\nThe new brightness setting for the camera (0 to 255).\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n\n\n\n\n// Set the camera brightness.\n\n$camNumber = 0;\n\n$camHandle = OpenCV_OpenCamera($camNumber);\n\n\n\n$bright = 115;\n\n\n\nOpenCV_SetCameraBrightness($camHandle, $bright);\n\n\n\n\n\nOpenCV_SetCameraContrast\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OpenCV_SetCameraContrast": {
  "prefix": "OpenCV_SetCameraContrast",
  "body": [
   "OpenCV_SetCameraContrast($$Camera,$$contrast);"
  ],
  "description": "\n\nThis function sets the contrast for the selected camera.\n\n\n\n\n\nRemarks:\n\nThis function uses the OpenCV and EMGU CV libraries version 3.3.0.\n\nCommunication with the camera must previously been opened with OpenCV_OpenCamera.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Camera\n\nObject\n\nA previously opened connection to a camera.\n\n\n\n$contrast\n\nInteger\n\nThe new contrast setting for the camera (0 to 255).\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n\n\n\n\n// Set the camera contrast.\n\n$camNumber = 0;\n\n$camHandle = OpenCV_OpenCamera($camNumber);\n\n\n\n$contrast = 115;\n\n\n\nOpenCV_SetCameraBrightness($camHandle, $contrast);\n\n\n\n\n\nOpenCV_SetCameraControlProperty\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OpenCV_SetCameraControlProperty": {
  "prefix": "OpenCV_SetCameraControlProperty",
  "body": [
   "OpenCV_SetCameraControlProperty($$captureDeviceIndex,$$propertyName,$$propertyValue);"
  ],
  "description": "\n\nSets video capture device properties using the DirectShow API. These properties relate to control of the camera itself.\n\n\n\n\n\nNote: Values outside of the allowable range of a property will cause a failure that reports the valid range, but invalid values within the acceptable range will often be ignored without causing a failure.\n\n\n\n\n\ne.g., the allowable range for ZOOM is 1-10, but only 1X, 5X, and 10X are valid zoom levels. Entering a value of \"2\" will return a pass status for the function, but leave the zoom level unchanged.\n\n\n\n\n\nValid values and behavior depend on the specific camera drivers. You can often use OpenCV_OpenDevicePropertiesWindow() to inspect valid values for the different properties.\n\n\n\n\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$captureDeviceIndex\n\nInteger\n\nVideo capture device index. This is 0 if only one device is present on the system.\n\n\n\n$propertyName\n\nString\n\nName of the property to set. Valid properties are:\n\n\u00b7 \"EXPOSURE\"\n\n\u00b7 \"FOCUS\"\n\n\u00b7 \"IRIS\"\n\n\u00b7 \"PAN\"\n\n\u00b7 \"ROLL\"\n\n\u00b7 \"TILT\"\n\n\u00b7 \"ZOOM\"\n\n\n\n$propertyValue\n\nString\n\nValue to set property to. Use \"DEFAULT\" to reset the value, \"AUTO\" to allow the device to automatically adjust the property (if supported), or enter a numeric value to manually set it. The value must be in the allowable range for the property or the function will fail.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n--\n\n\n\n\n\nExample:\n\nOpenCV_SetCameraControlProperty(0, \"FOCUS\", \"AUTO\"); //autoset value\n\nOpenCV_SetCameraControlProperty(0, \"EXPOSURE\", \"DEFAULT\"); //default value\n\nOpenCV_SetCameraControlProperty(0, \"ZOOM\", \"2\"); //manual value\n\n\n\n\n\nOpenCV_SetCameraResolution\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OpenCV_SetCameraResolution": {
  "prefix": "OpenCV_SetCameraResolution",
  "body": [
   "OpenCV_SetCameraResolution($$CameraIndex,$$Width,$$Height);"
  ],
  "description": "\n\nThis function sets the resolution (width x height) for the specified camera object. If the requested camera resolution exceeds the capabilities of the hardware, then the resolution will be set to the maximum value allowed by the camera.\n\n\n\n\n\nNote: You will need to refer to the documentation that is provided by your camera manufacturer for a list of supported resolutions. Also the driver for the camera must be directShow compatible in order to set the resolution of the camera via this function.\n\n\n\n\n\nRequirements:\n\nThese functions use the Open-Source OpenCV computer vision library from Intel, and therefore will offer the maximum performance when running on Intel Processors due to low-level optimizations for the Intel architecture. Any camera or input device that Windows recognizes as an imaging device should be compatible with these functions.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Camera\n\nObject\n\nThe handle of the imaging device returned from the OpenCV_OpenCamera function.\n\n\n\n$Width\n\nInteger\n\nThe Width (pixels) value to set the camera resolution.\n\n\n\n$Height\n\nInteger\n\nThe Height (pixels) value to set the camera resolution.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nnone\n\n\n\n\n\nUsage Example:\n\nOpenCV_SetCameraResolution($Camera,640,480);\n\n\n\n\n\nOpenCV_SetVideoProcAmpProperty\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OpenCV_SetVideoProcAmpProperty": {
  "prefix": "OpenCV_SetVideoProcAmpProperty",
  "body": [
   "OpenCV_SetVideoProcAmpProperty($$captureDeviceIndex,$$propertyName,$$propertyValue);"
  ],
  "description": "\n\nSets video capture device properties using the DirectShow API. These properties relate to the video processing amplifier of the device.\n\n\n\n\n\nNote: Values outside of the allowable range of a property will cause a failure that reports the valid range, but invalid values within the acceptable range will often be ignored without causing a failure.\n\n\n\n\n\ne.g., the allowable range for BRIGHTNESS is 0-255, but only multiples of 5 are valid brightness levels. Entering a value of \"9\" will return a pass status for the function, but leave the brightness level unchanged.\n\n\n\n\n\nValid values and behavior depend on the specific camera drivers. You can often use OpenCV_OpenDevicePropertiesWindow() to inspect valid values for the different properties.\n\n\n\n\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$captureDeviceIndex\n\nInteger\n\nVideo capture device index. This is 0 if only one device is present on the system.\n\n\n\n$propertyName\n\nString\n\nName of the property to set. Valid properties are:\n\n\u00b7 \"BACKLIGHTCOMPENSATION\"\n\n\u00b7 \"BRIGHTNESS\"\n\n\u00b7 \"COLORENABLE\"\n\n\u00b7 \"CONTRAST\"\n\n\u00b7 \"GAIN\"\n\n\u00b7 \"GAMMA\"\n\n\u00b7 \"HUE\"\n\n\u00b7 \"SATURATION\"\n\n\u00b7 \"SHARPNESS\"\n\n\u00b7 \"WHITEBALANCE\"\n\n\n\n$propertyValue\n\nString\n\nValue to set property to. Use \"DEFAULT\" to reset the value, \"AUTO\" to allow the device to automatically adjust the property (if supported), or enter a numeric value to manually set it. The value must be in the allowable range for the property or the function will fail.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n--\n\n\n\n\n\nExample:\n\nOpenCV_SetVideoProcAmpProperty(0, \"WHITEBALANCE\", \"AUTO\"); //autoset value\n\nOpenCV_SetVideoProcAmpProperty(0, \"SATURATION\", \"DEFAULT\"); //default value\n\nOpenCV_SetVideoProcAmpProperty(0, \"HUE\", 0); //manual value\n\n\n\n\n\nOpenCV_ShowCameraOutputInWindow\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OpenCV_ShowCameraOutputInWindow": {
  "prefix": "OpenCV_ShowCameraOutputInWindow",
  "body": [
   "OpenCV_ShowCameraOutputInWindow($$Camera);"
  ],
  "description": "\n\nShows the output of the camera in a pop-up window.\n\n\n\n\n\nNote: Script execution blocks until the output window is closed.\n\n\n\n\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Camera\n\nObject\n\nA handle to the camera or imaging device to be closed. This handle should have been created using the OpenCV_OpenCamera function.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n--\n\n\n\n\n\nExample:\n\nOpenCV_OpenDevicePropertiesWindow(0); //opens properties windows\n\nOpenCV_ShowCameraOutputInWindow($Camera); //opens camera display window, pauses script\n\n\n\n\n\nOpenCV_CalculatePixelDistance\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OpenCV_CalculatePixelDistance": {
  "prefix": "OpenCV_CalculatePixelDistance",
  "body": [
   "$$Distance=OpenCV_CalculatePixelDistance($$X1,$$Y1,$$X2,$$Y2);"
  ],
  "description": "\n\nThis function calculates the distance between two pixels\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$X1\n\nInteger\n\nX coordinate of the first pixel\n\n\n\n$Y1\n\nInteger\n\nY coordinate of the first pixel\n\n\n\n$X2\n\nInteger\n\nX coordinate of the second pixel\n\n\n\n$Y2\n\nInteger\n\nY coordinate of the second pixel\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Distance\n\nFloat\n\nThe distance between the two pixels\n\n\n\n\n\nUsage Example:\n\n\n\n\n\n$Distance = OpenCV_CalculatePixelDistance(10,10,20,20);\n\n\n\n\n\nOpenCV_CalculatePointAngle\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OpenCV_CalculatePointAngle": {
  "prefix": "OpenCV_CalculatePointAngle",
  "body": [
   "$$angle=OpenCV_CalculatePointAngle($$x1,$$y1,$$x2,$$y2,$$axis);"
  ],
  "description": "\n\nThis function calculates and returns the angle (in degrees) of a line specified by two end-points and a specified axis.\n\n\n\n\n\nRemarks:\n\nThis function uses the OpenCV and EMGU CV libraries version 3.3.0.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$x1\n\nInteger\n\nThe X coordinate of the first point.\n\n\n\n$y1\n\nInteger\n\nThe Y coordinate of the first point.\n\n\n\n$x2\n\nInteger\n\nThe X coordinate of the second point.\n\n\n\n$y2\n\nInteger\n\nThe Y coordinate of the second point.\n\n\n\n$axis\n\nString\n\nThe axis to calculate the angle from. Must be \"Horz\" or \"Vert\".\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$angle\n\nFloat\n\nThe angle of the line from the specified axis.\n\n\n\n\n\nExample:\n\n\n\n\n\n// Find the angle of the line from the X-axis.\n\n$x1 = 10;\n\n$y1 = 20;\n\n$x2 = 100;\n\n$y2 = 115;\n\n$axis = \"Horz\";\n\n\n\n$angle = OpenCV_CalculatePointAngle($x1, $y1, $x2, $y2, $axis);\n\n\n\n\n\nOpenCV_CannyEdgeDetectGrayscale\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OpenCV_CannyEdgeDetectGrayscale": {
  "prefix": "OpenCV_CannyEdgeDetectGrayscale",
  "body": [
   "$$newImage=OpenCV_CannyEdgeDetectGrayscale($$Image,$$Threshold,$$LinkingThreshold);"
  ],
  "description": "\n\nThis function takes an OpenCV image of any resolution and color depth and converts it to an 8-bit grayscale image before applying a Canny Edge Detection algorithm on the image.\n\nThe canny edge detection algorithm attempts to find candidate pixels representing potential edges (regions of high contrast transition) and assembles them into contours.\n\n\n\n\n\nThe returned image will be a gray scale (binary) image showing the edges detected in the original image. This can be a useful transform to apply before using subsequent pattern matching, or measurement algorithms.\n\nThe threshold parameter specifies the minimum threshold for a pixel gradient to be determined to be an edge within the image. The maximum parameter specifies the maximum color gradient for a given pixel to be considered an edge within the image.\n\n\n\n\n\nCanny recommends a high:low hysterisis threshold ratios of 5:1 and 3:2 respective.\n\n\n\n\n\nRequirements:\n\nThese functions use the Open-Source OpenCV computer vision library from Intel, and therefore will offer the maximum performance when running on Intel Processors due to low-level optimizations for the Intel architecture. Any camera or input device that Windows recognizes as an imaging device should be compatible with these functions.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Image\n\nObject\n\nAn OpenCV Image Structure that has been loaded from an existing file or camera capture.\n\n\n\n$Threshold\n\nFloat\n\nThe pixel threshold value for it's gradient value to be considered as an edge in the image\n\n\n\n$LinkingThreshold\n\nFloat\n\nThe minimum threshold value for a pixel-to-pixel neighboring threshold for two pixels to be considered as part of a common contour.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$newImage\n\nObject\n\nAn OpenCV Image Grayscale Structure which can be used with the other OpenCV functions in this library.\n\n\n\n\n\nUsage Example:\n\n$newImage= OpenCV_CannyEdgeDetectGrayscale($Image,100,60);\n\n\n\n\n\nExample Photos\n\nOriginal Image\n\n\n\n\n\nEdge Detect with Pixel Threshold of 100 and linking neighbor threshold of 60:\n\n\n\n\n\nOpenCV_CompareImges\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OpenCV_CompareImages": {
  "prefix": "OpenCV_CompareImages",
  "body": [
   "$$UnmatchedPixels=OpenCV_CompareImages($$Image1,$$Image2);"
  ],
  "description": "\n\nThis function performs a pixel by pixel comparison of two input images and returns the resulting percentage of matched pixels. No normalization is done on the images before comparison.\n\n\n\n\n\nThe formula is essentially: number of matching pixels/number of total pixels.\n\n\n\n\n\nA pixel must be a perfect match to be considered a valid match, there is no tolerance function.\n\n\n\n\n\nNote: This function was developed in Visual C++ 2008 and require the latest version of the Microsoft Visual C++ runtime which can be downloaded from Microsoft.\n\n\n\n\n\nRequirements:\n\nThese functions use the Open-Source OpenCV computer vision library from Intel, and therefore will offer the maximum performance when running on Intel Processors due to low-level optimizations for the Intel architecture. Any camera or input device that Windows recognizes as an imaging device should be compatible with these functions.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Image1\n\nObject\n\nThe OpenCV image object for comparison\n\n\n\n$Image2\n\nObject\n\nThe second OpenCV image object for comparison\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$MatchedPixelPercent\n\nFloat\n\nThe percentage matched pixels related to whole image returned as a number from 0 to 1.\n\n\n\n\n\nUsage Example:\n\n$Scene1 = OpenCV_LoadImageFromFile(\"c:\\\\scene1.jpg\");\n\n$Scene2 = OpenCV_LoadBitmapObject($image);\n\n$MatchedPixelPercent = OpenCV_CompareImages($Scene1,$Scene2);\n\n\n\n\n\nOpenCV_CompareImagesWithTolerance\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OpenCV_CompareImagesWithTolerance": {
  "prefix": "OpenCV_CompareImagesWithTolerance",
  "body": [
   "$$UnmatchedPixels=OpenCV_CompareImagesWithTolerance($$Image1,$$Image2,$$RTolerance,$$GTolerance,$$BTolerance);"
  ],
  "description": "\n\nThis function performs a pixel by pixel comparison of two input images and returns the resulting percentage of matched pixels. No normalization is done on the images before comparison.\n\n\n\n\n\nThe comparison is done in the RGB color space with 8 bits per pixel of color information.\n\n\n\n\n\nThe formula is essentially: number of matching pixels/number of total pixels.\n\n\n\n\n\nUnlike the OpenCV_CompareImages function this function allows specifying an integer tolerance for each color value. Each tolerance is the absolute value of the difference allowed in a pixels color value for each channel before it is considered a failed match. This makes this function useful to compare video images that have been digitally compressed and suffer from macro-blocking or other types of fixed-contrast stepped distortions.\n\n\n\n\n\nNote: This function was developed in Visual C++ 2008 and require the latest version of the Microsoft Visual C++ runtime which can be downloaded from Microsoft.\n\n\n\n\n\nRequirements:\n\nThese functions use the Open-Source OpenCV computer vision library from Intel, and therefore will offer the maximum performance when running on Intel Processors due to low-level optimizations for the Intel architecture. Any camera or input device that Windows recognizes as an imaging device should be compatible with these functions.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Image1\n\nObject\n\nThe OpenCV image object for comparison\n\n\n\n$Image2\n\nObject\n\nThe second OpenCV image object for comparison\n\n\n\n$RTolerance\n\nInteger\n\nThe integer tolerance for the absolute value of the difference in a pixels color value before it is considered a mismatch.\n\n\n\n$GTolerance\n\nInteger\n\nThe integer tolerance for the absolute value of the difference in a pixels color value before it is considered a mismatch.\n\n\n\n$BTolerance\n\nInteger\n\nThe integer tolerance for the absolute value of the difference in a pixels color value before it is considered a mismatch.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$MatchedPixelPercent\n\nFloat\n\nThe percentage matched pixels related to whole image returned as a number from 0 to 1.\n\n\n\n\n\nUsage Example:\n\n$Scene1 = OpenCV_LoadImageFromFile(\"c:\\\\scene1.jpg\");\n\n$Scene2 = OpenCV_LoadBitmapObject($image);\n\n$MatchedPixelPercent = OpenCV_CompareImagesWithTolerance($Scene1,$Scene2,1,1,4);\n\n\n\n\n\nOpenCV_CountHorizontalEdges\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OpenCV_CountHorizontalEdges": {
  "prefix": "OpenCV_CountHorizontalEdges",
  "body": [
   "$$edges=OpenCV_CountHorizontalEdges($$Image,$$YCoordinate,$$X1Coordinate,$$X2Coordinate,$$RGB);"
  ],
  "description": "\n\nCounts the number of edges found in the horizontal line at Y coordinate and between X1 and X2. The RGB threshold is used to trigger to set the point in which an edge is considered valid as such.\n\nNote:\n\nThis function works best with the output of an edge detection algorithm such as OpenCV_CannyEdgeDetectGrayscale().\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Image\n\nObject\n\nThe image object to work with.\n\n\n\n$YCoordinate\n\nInteger\n\nThe vertical position of the line that will be checked.\n\n\n\n$X1Coordinate\n\nInteger\n\nThe starting X position of the line.\n\n\n\n$X2Coordinate\n\nInteger\n\nThe ending X position of the line.\n\n\n\n$RGB\n\nString\n\nRGB Edge Threshold trigger. This is a comma spearated string of R, G and B values (0 - 255).\n\n\n\n\n\nReturn arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$edges\n\nInteger\n\nThe number of edges that were detected.\n\n\n\n\n\nExample:\n\n\n\n\n\n$edges = OpenCV_CountHorizontalEdges ($Image, 100, 1, 639, \u201d20,20,20\u201d);\n\n\n\n\n\nOpenCV_CountPixelsInHSVRange\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OpenCV_CountPixelsInHSVRange": {
  "prefix": "OpenCV_CountPixelsInHSVRange",
  "body": [
   "$$PixelCount=OpenCV_CountPixelsInHSVRange($$Image,$$MinH,$$MinS,$$MinV,$$MaxH,$$MaxS,$$MaxV,$$X1,$$Y1,$$X2,$$Y2,$$ShowDebugImage);"
  ],
  "description": "\n\nThis function counts the number of pixels in a given image that fall between a range of HSV values in the hue, saturation, and value color space.\n\n\n\n\n\nIf a pixel falls within the minimum and maximum boundaries for each color and intensity parameter, it is added to the summation.\n\n\n\n\n\nThe $X1,$Y1, $X2, $Y2 parameters are used to express the region of interest for the calculation, with $X1, $Y1 setting the upper left corner of the region of interest, and $X2, $Y2 specifying the lower right corner of the region of interest.\n\n\n\n\n\nIf $ShowDebugImage is set to true, the test will pause and show a colored region showing the pixels that were included in the summation, vs the pixels which were excluded for falling outside the threshold range. The debug image shows the region of interest inside of a white rectangle, and all valid pixels within the threshold values are displayed in blue.\n\n\n\n\n\nRequirements:\n\nThese functions use the Open-Source OpenCV computer vision library from Intel, and therefore will offer the maximum performance when running on Intel Processors due to low-level optimizations for the Intel architecture. Any camera or input device that Windows recognizes as an imaging device should be compatible with these functions.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Image\n\nObject\n\nAn OpenCV Image Structure that has been loaded from an existing file or camera capture.\n\n\n\n$MinH\n\nFloat\n\nThe minimum Hue Value of the pixel threshold. (Values 0 to 360) Note: Since Hue is a cylindrical-coordinate and could wrap around the zero value, if the lower limit for Hue is greater than the higher limit, the function will work on the assumption that the user wants to select Hue values that cross the zero value.\n\n\n\n$MinS\n\nFloat\n\nThe minimum Saturation Value of the pixel threshold. (Values 0 to 100)\n\n\n\n$MinV\n\nFloat\n\nThe minimum ' Value' Value of the pixel threshold. (Values 0 to 100)\n\n\n\n$MaxH\n\nFloat\n\nThe maximum Hue Value of the pixel threshold. (Values 0 to 360)\n\n\n\n$MaxS\n\nFloat\n\nThe maximum Saturation Value of the pixel threshold. (Values 0 to 100)\n\n\n\n$MaxV\n\nFloat\n\nThe maximum ' Value' Value of the pixel threshold. (Values 0 to 100)\n\n\n\n$X1\n\nInteger\n\nUpper Left X coordinate of the region of interest\n\n\n\n$Y1\n\nInteger\n\nUpper Left Y coordinate of the region of interest\n\n\n\n$X2\n\nInteger\n\nLower Right X coordinate of the region of interest\n\n\n\n$Y2\n\nInteger\n\nLower Right Y coordinate of the region of interest\n\n\n\n$ShowDebugImage\n\nBoolean\n\nSpecifies whether or not the test executive will pause to show a debug image of the analyzed image. See example below.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$PixelCount\n\nInteger\n\nThe number of pixels found matching the requested color matching criteria\n\n\n\n\n\nUsage Example:\n\n\n\n\n\n$BadCount = OpenCV_CountPixelsInHSVRange($BadImage,0,0,0,25,100,100,429,341,768,470,true);\n\n\n\n\n\nOriginal Image:\n\n\n\n\n\nDebug Image:\n\n\n\n\n\nOpenCV_CountPixelsInHSVRangeReturnImage\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OpenCV_CountPixelsInHSVRangeReturnImage": {
  "prefix": "OpenCV_CountPixelsInHSVRangeReturnImage",
  "body": [
   "($$PixelCount,$$MatchImage)=OpenCV_CountPixelsInHSVRangeReturnImage($$Image,$$MinH,$$MinS,$$MinV,$$MaxH,$$MaxS,$$MaxV,$$X1,$$Y1,$$X2,$$Y2);"
  ],
  "description": "\n\nThis function counts the number of pixels in a given image that fall between a range of HSV values in the hue, saturation, and value color space.\n\n\n\n\n\nIf a pixel falls within the minimum and maximum boundaries for each color and intensity parameter, it is added to the summation.\n\n\n\n\n\nThe $X1,$Y1, $X2, $Y2 parameters are used to express the region of interest for the calculation, with $X1, $Y1 setting the upper left corner of the region of interest, and $X2, $Y2 specifying the lower right corner of the region of interest.\n\n\n\n\n\nThe function returns a handle to an OpenCV image object which shows the matching pixels highlighted in blue, as well as the number of pixels that matched the search criteria.\n\n\n\n\n\nRequirements:\n\nThese functions use the Open-Source OpenCV computer vision library from Intel, and therefore will offer the maximum performance when running on Intel Processors due to low-level optimizations for the Intel architecture. Any camera or input device that Windows recognizes as an imaging device should be compatible with these functions.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Image\n\nObject\n\nAn OpenCV Image Structure that has been loaded from an existing file or camera capture.\n\n\n\n$MinH\n\nFloat\n\nThe minimum Hue Value of the pixel threshold. (Values 0 to 360) Note: Since Hue is a cylindrical-coordinate and could wrap around the zero value, if the lower limit for Hue is greater than the higher limit, the function will work on the assumption that the user wants to select Hue values that cross the zero value.\n\n\n\n$MinS\n\nFloat\n\nThe minimum Saturation Value of the pixel threshold. (Values 0 to 100)\n\n\n\n$MinV\n\nFloat\n\nThe minimum ' Value' Value of the pixel threshold. (Values 0 to 100)\n\n\n\n$MaxH\n\nFloat\n\nThe maximum Hue Value of the pixel threshold. (Values 0 to 360)\n\n\n\n$MaxS\n\nFloat\n\nThe maximum Saturation Value of the pixel threshold. (Values 0 to 100)\n\n\n\n$MaxV\n\nFloat\n\nThe maximum ' Value' Value of the pixel threshold. (Values 0 to 100)\n\n\n\n$X1\n\nInteger\n\nUpper Left X coordinate of the region of interest\n\n\n\n$Y1\n\nInteger\n\nUpper Left Y coordinate of the region of interest\n\n\n\n$X2\n\nInteger\n\nLower Right X coordinate of the region of interest\n\n\n\n$Y2\n\nInteger\n\nLower Right Y coordinate of the region of interest\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$PixelCount\n\nInteger\n\nThe number of pixels matching the input color criteria.\n\n\n\n$MatchImage\n\nObject\n\nAn OpenCV Image Structure which can be used with the other OpenCV functions in this library. This image will be a copy of the input image, with the matched pixels indicated in blue.\n\n\n\n\n\nUsage Example:\n\n\n\n\n\n($BadCount,MatchImage) = OpenCV_CountPixelsInHSVRangeReturnImage($BadImage,0,0,0,25,100,100,429,341,768,470);\n\n\n\n\n\nOriginal Image:\n\n\n\n\n\nMatch Image:\n\n\n\n\n\nOpenCV_CountVerticalEdges\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OpenCV_CountVerticalEdges": {
  "prefix": "OpenCV_CountVerticalEdges",
  "body": [
   "$$edges=OpenCV_CountVerticalEdges($$Image,$$YCoordinate,$$X1Coordinate,$$X2Coordinate,$$RGB);"
  ],
  "description": "\n\nCounts the number of edges found in the vertical line at X coordinate and between Y1 and Y2. The RGB threshold is used to trigger to set the point in which an edge is considered valid as such.\n\nNote:\n\nThis function works best with the output of an edge detection algorithm such as OpenCV_CannyEdgeDetectGrayscale().\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Image\n\nObject\n\nThe image object to work with.\n\n\n\n$XCoordinate\n\nInteger\n\nThe horizontal position of the line that will be checked.\n\n\n\n$Y1Coordinate\n\nInteger\n\nThe starting Y position of the line.\n\n\n\n$Y2Coordinate\n\nInteger\n\nThe ending Y position of the line.\n\n\n\n$RGB\n\nString\n\nRGB Edge Threshold trigger. This is a comma spearated string of R, G and B values (0 - 255).\n\n\n\n\n\nReturn arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$edges\n\nInteger\n\nThe number of edges that were detected.\n\n\n\n\n\nExample:\n\n\n\n\n\n$edges = OpenCV_CountVerticalEdges ($Image, 100, 1, 479, \u201d20,20,20\u201d);\n\n\n\n\n\nOpenCV_ExtractLEDInfo\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OpenCV_ExtractLEDInfo": {
  "prefix": "OpenCV_ExtractLEDInfo",
  "body": [
   "($$X1,$$Y1,$$X2,$$Y2)=OpenCV_ExtractLEDInfo($$Image,$$X1,$$Y1,$$X2,$$Y2,$$RGB);"
  ],
  "description": "\n\nExtract the coordinates of an LED inside an area. If no LED is found the function fails. The RGB threshold is used to detect the black area or the minimum color to consider the existence of an LED. Parameters:\n\n\n\nName\n\nType\n\nDescription\n\n\n\n$Image\n\nObject\n\n\n\n\n\n$X1\n\nInteger\n\n\n\n\n\n$Y1\n\nInteger\n\n\n\n\n\n$X2\n\nInteger\n\n\n\n\n\n$Y2\n\nInteger\n\n\n\n\n\n$RGB\n\nString\n\nRGB Threshold . This is a comma-separated string of R, B, and G values (0-255).\n\n\n\n\n\nReturns:\n\n\n\nName\n\nType\n\nDescription\n\n\n\nX1,Y1,X2,Y2\n\nIntegers\n\nThe coordinates of the LED\n\n\n\n\n\nExample:\n\n\n\n\n\n($X1,$Y1,$X2,$Y2) = OpenCV_ExtractLEDInfo($Image,10,10,50,50,\u201d50,50,50\u201d);\n\n\n\n\n\nOpenCV_GetColorIntensity\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OpenCV_GetHorizontalEdge($Image,$YCoord,$Xleft,$Xright,$RGBThreshold,$EdgeNum,$Direction);DescriptionScansasinglehorizontallinetofindallpointsonthelinethathaveRed,GreenandBluevaluesaboveaspecifiedlevel.Theseareconsiderededges.ReturnstheXcoordinateofthespecifiededgenumberfound.Eg.edgenumber3.Notes:Ifanedgeisnotfound,thefunctionreturns-1.Requirements:ThesefunctionsusetheOpen-SourceOpenCVcomputervisionlibraryfromIntel,andthereforewillofferthemaximumperformancewhenrunningonIntelProcessorsduetolow-leveloptimizationsfortheIntelarchitecture.AnycameraorinputdevicethatWindowsrecognizesasanimagingdeviceshouldbecompatiblewiththesefunctions.FunctionargumentsParameterVariableTypeDescription$ImageObjectAnOpenCVimageobjectofanyresolution,format,orcolordepth$YCoordIntegerTheverticalcoordinateofthehorizontallinethatwillbescanned$XleftIntegerTheleft-mostXcoordinateofthehorizontallinethatwillbescanned$XrightIntegerTheright-mostXcoordinateofthehorizontallinethatwillbescanned$RGBThresholdStringCommadelimitedstringlistingtheRed,GreenandBlueThresholdlevelsforfindinganedge$EdgeNumIntegerThenumberoftheedgetoreturn$DirectionStringThedirectiontoscanValue:\u00b7\"LEFT2RIGHT\"\u00b7\"RIGHT2LEFT\"ReturnparametersParameterVariableTypeDescription$XCoordIntegerTheXCoordinateofthespecifiededge.Returns-1ifnoedgeswerefound.Example://Scanahorizontallineatverticalcoordinate190fromX=20toX=125foredgeswhereRedlevel>150.$YCoord=190;$Xleft=20;$XRight=125;$RGDThreshold=\"150,0,0\";//GreenandBluelevelssetto0.WearelookingatRededges.$EdgeNum=3;//Returnthethirdedge.$Direction=\"LEFT2RIGHT\";$XCoord=OpenCV_GetHorizontalEdge($Image,$YCoord,$Xleft,$Xright,$RGBThreshold,$EdgeNum,$Direction);OpenCV_GetHorzLine2PointContourPreviousTopNext***OpenCV_GetHorzLine2PointContourGetstwopointsofacontourinanimage.Thisfunctionisusefultodetectifanobjecthasarotationfromthepositionweareexpecting.Withthecoordinatesfromthetwopointswecancalculatethedegreesnecessarytoleavetheimageinthecorrectangle.Parameters:ImageObjectX1IntegerY1IntegerX2IntegerY2IntegerRGBThresholdStringDirectionString(\u201cLEFT2RIGHT\u201d,\u201cRIGHT2LEFT\u201d)Returns:X,Y,X1,Y1IntegerExample:($X,$Y,$X1,$Y1)=OpenCV_GetHorzLine2PointContour($Image,10,10,400,400,\u201d50,50,50\u201d,\u201dLEFT2RIGHT\u201d);OpenCV_GetHoughCirclesPreviousTopNext***OpenCV_GetHoughCirclesUsage:($numCircles,$centerX,$centerY,$radii)=OpenCV_GetHoughCircles": {
  "prefix": "OpenCV_GetHorizontalEdge($Image,$YCoord,$Xleft,$Xright,$RGBThreshold,$EdgeNum,$Direction);DescriptionScansasinglehorizontallinetofindallpointsonthelinethathaveRed,GreenandBluevaluesaboveaspecifiedlevel.Theseareconsiderededges.ReturnstheXcoordinateofthespecifiededgenumberfound.Eg.edgenumber3.Notes:Ifanedgeisnotfound,thefunctionreturns-1.Requirements:ThesefunctionsusetheOpen-SourceOpenCVcomputervisionlibraryfromIntel,andthereforewillofferthemaximumperformancewhenrunningonIntelProcessorsduetolow-leveloptimizationsfortheIntelarchitecture.AnycameraorinputdevicethatWindowsrecognizesasanimagingdeviceshouldbecompatiblewiththesefunctions.FunctionargumentsParameterVariableTypeDescription$ImageObjectAnOpenCVimageobjectofanyresolution,format,orcolordepth$YCoordIntegerTheverticalcoordinateofthehorizontallinethatwillbescanned$XleftIntegerTheleft-mostXcoordinateofthehorizontallinethatwillbescanned$XrightIntegerTheright-mostXcoordinateofthehorizontallinethatwillbescanned$RGBThresholdStringCommadelimitedstringlistingtheRed,GreenandBlueThresholdlevelsforfindinganedge$EdgeNumIntegerThenumberoftheedgetoreturn$DirectionStringThedirectiontoscanValue:\u00b7\"LEFT2RIGHT\"\u00b7\"RIGHT2LEFT\"ReturnparametersParameterVariableTypeDescription$XCoordIntegerTheXCoordinateofthespecifiededge.Returns-1ifnoedgeswerefound.Example://Scanahorizontallineatverticalcoordinate190fromX=20toX=125foredgeswhereRedlevel>150.$YCoord=190;$Xleft=20;$XRight=125;$RGDThreshold=\"150,0,0\";//GreenandBluelevelssetto0.WearelookingatRededges.$EdgeNum=3;//Returnthethirdedge.$Direction=\"LEFT2RIGHT\";$XCoord=OpenCV_GetHorizontalEdge($Image,$YCoord,$Xleft,$Xright,$RGBThreshold,$EdgeNum,$Direction);OpenCV_GetHorzLine2PointContourPreviousTopNext***OpenCV_GetHorzLine2PointContourGetstwopointsofacontourinanimage.Thisfunctionisusefultodetectifanobjecthasarotationfromthepositionweareexpecting.Withthecoordinatesfromthetwopointswecancalculatethedegreesnecessarytoleavetheimageinthecorrectangle.Parameters:ImageObjectX1IntegerY1IntegerX2IntegerY2IntegerRGBThresholdStringDirectionString(\u201cLEFT2RIGHT\u201d,\u201cRIGHT2LEFT\u201d)Returns:X,Y,X1,Y1IntegerExample:($X,$Y,$X1,$Y1)=OpenCV_GetHorzLine2PointContour($Image,10,10,400,400,\u201d50,50,50\u201d,\u201dLEFT2RIGHT\u201d);OpenCV_GetHoughCirclesPreviousTopNext***OpenCV_GetHoughCirclesUsage:($numCircles,$centerX,$centerY,$radii)=OpenCV_GetHoughCircles",
  "body": [
   "$$XCoord=OpenCV_GetHorizontalEdge($$Image,$$YCoord,$$Xleft,$$Xright,$$RGBThreshold,$$EdgeNum,$$Direction);DescriptionScansasinglehorizontallinetofindallpointsonthelinethathaveRed,GreenandBluevaluesaboveaspecifiedlevel.Theseareconsiderededges.ReturnstheXcoordinateofthespecifiededgenumberfound.Eg.edgenumber3.Notes:Ifanedgeisnotfound,thefunctionreturns-1.Requirements:ThesefunctionsusetheOpen-SourceOpenCVcomputervisionlibraryfromIntel,andthereforewillofferthemaximumperformancewhenrunningonIntelProcessorsduetolow-leveloptimizationsfortheIntelarchitecture.AnycameraorinputdevicethatWindowsrecognizesasanimagingdeviceshouldbecompatiblewiththesefunctions.FunctionargumentsParameterVariableTypeDescription$$ImageObjectAnOpenCVimageobjectofanyresolution,format,orcolordepth$$YCoordIntegerTheverticalcoordinateofthehorizontallinethatwillbescanned$$XleftIntegerTheleft-mostXcoordinateofthehorizontallinethatwillbescanned$$XrightIntegerTheright-mostXcoordinateofthehorizontallinethatwillbescanned$$RGBThresholdStringCommadelimitedstringlistingtheRed,GreenandBlueThresholdlevelsforfindinganedge$$EdgeNumIntegerThenumberoftheedgetoreturn$$DirectionStringThedirectiontoscanValue:\u00b7\"LEFT2RIGHT\"\u00b7\"RIGHT2LEFT\"ReturnparametersParameterVariableTypeDescription$$XCoordIntegerTheXCoordinateofthespecifiededge.Returns-1ifnoedgeswerefound.Example://Scanahorizontallineatverticalcoordinate190fromX=20toX=125foredgeswhereRedlevel>150.$$YCoord=190;$$Xleft=20;$$XRight=125;$$RGDThreshold=\"150,0,0\";//GreenandBluelevelssetto0.WearelookingatRededges.$$EdgeNum=3;//Returnthethirdedge.$$Direction=\"LEFT2RIGHT\";$$XCoord=OpenCV_GetHorizontalEdge($$Image,$$YCoord,$$Xleft,$$Xright,$$RGBThreshold,$$EdgeNum,$$Direction);OpenCV_GetHorzLine2PointContourPreviousTopNext***OpenCV_GetHorzLine2PointContourGetstwopointsofacontourinanimage.Thisfunctionisusefultodetectifanobjecthasarotationfromthepositionweareexpecting.Withthecoordinatesfromthetwopointswecancalculatethedegreesnecessarytoleavetheimageinthecorrectangle.Parameters:ImageObjectX1IntegerY1IntegerX2IntegerY2IntegerRGBThresholdStringDirectionString(\u201cLEFT2RIGHT\u201d,\u201cRIGHT2LEFT\u201d)Returns:X,Y,X1,Y1IntegerExample:($$X,$$Y,$$X1,$$Y1)=OpenCV_GetHorzLine2PointContour($$Image,10,10,400,400,\u201d50,50,50\u201d,\u201dLEFT2RIGHT\u201d);OpenCV_GetHoughCirclesPreviousTopNext***OpenCV_GetHoughCirclesUsage:($$numCircles,$$centerX,$$centerY,$$radii)=OpenCV_GetHoughCircles($$image,$$cannyThresh,$$accumThresh,$$accumResol,$$minDist,$$minR,$$maxR);"
  ],
  "description": "\n\nThis function performs a canny edge detect on a grayscale image then performs a circle detection using the Hough algorithm.\n\n\n\n\n\nRemarks:\n\nFor more information about the Hough Circles method, see: http://docs.opencv.org/doc/tutorials/imgproc/imgtrans/hough_circle/hough_circle.html\n\nand: http://www.emgu.com/wiki/files/1.4.0.0/html/6f78c3d8-fb1a-5983-2862-549c49019d49.htm\n\n\n\n\n\nThese functions use the Open-Source OpenCV computer vision library from Intel, and therefore will offer the maximum performance when running on Intel Processors due to low-level optimizations for the Intel architecture.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$image\n\nObject\n\nThe grayscale image to perform the Circle Detection on.\n\n\n\n$cannyThresh\n\nInteger\n\nThe higher threshold of the two passed to Canny edge detector (the lower one will be half this number).\n\n\n\n$accumThresh\n\nInteger\n\nAccumulator threshold at the center detection stage. The smaller it is, the more false circles may be detected. Circles, corresponding to the larger accumulator values, will be returned first.\n\n\n\n$accumResol\n\nInteger\n\nResolution of the accumulator used to detect centers of the circles. For example, if it is 1, the accumulator will have the same resolution as the input image, if it is 2 - accumulator will have half the width and height, etc.\n\n\n\n$minDist\n\nInteger\n\nMinimum distance between centers of the detected circles. If the parameter is too small, multiple neighbor circles may be falsely detected in addition to a true one. If it is too large, some circles may be missed.\n\n\n\n$minR\n\nInteger\n\nMinimum radius of the circles to search for.\n\n\n\n$maxR\n\nInteger\n\nMaximum radius of the circles to search for.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$numCircles\n\nInteger\n\nThe number of circles found in the image.\n\n\n\n$centerX\n\nArray\n\nAn array of Floats that contains the X coordinates of the centers of all of the circles found.\n\n\n\n$centerY\n\nArray\n\nAn array of Floats that contains the Y coordinates of the centers of all of the circles found.\n\n\n\n$radii\n\nArray\n\nAn array of Floats that contains the radii of all of the circles found.\n\n\n\n\n\nExample:\n\n// Assumed: $image is already loaded with grayscale image.\n\n$cannyThresh = 120;\n\n$accumThresh = 85;\n\n$accumResol = 1;\n\n$minDist = 80;\n\n$minR = 50;\n\n$maxR = 450;\n\n($numCircles, $centerX, $centerY, $radii) = OpenCV_GetHoughCircles($image, $cannyThresh, $accumThresh, $accumResol, $minDist, $minR, $maxR);\n\n\n\n\n\nOpenCV_GetHoughLines\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OpenCV_GetHoughLines": {
  "prefix": "OpenCV_GetHoughLines",
  "body": [
   "($$numLines,$$startX,$$startY,$$endX,$$endY)=OpenCV_GetHoughLines($$image,$$cannyThresh,$$cannyLink,$$distResol,$$angleResol,$$accumThresh,$$minWidth,$$maxGap);"
  ],
  "description": "\n\nThis function performs a canny edge detect on a grayscale image then performs a line detection using the Hough algorithm.\n\n\n\n\n\nRemarks:\n\nFor more information about the Hough Lines method, see: http://docs.opencv.org/doc/tutorials/imgproc/imgtrans/hough_lines/hough_lines.html\n\nand: http://www.emgu.com/wiki/files/2.3.0/document/html/8cafb14d-e65f-aff1-892f-25376a208bdb.htm\n\n\n\n\n\nThese functions use the Open-Source OpenCV computer vision library from Intel, and therefore will offer the maximum performance when running on Intel Processors due to low-level optimizations for the Intel architecture.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$image\n\nObject\n\nThe grayscale image to perform the Circle Detection on.\n\n\n\n$cannyThresh\n\nFloat\n\nThe higher threshold of the two passed to Canny edge detector.\n\n\n\n$cannyLink\n\nFloat\n\nThe minimum threshold value for a pixel-to-pixel neighboring threshold for two pixels to be considered as part of a common contour.\n\n\n\n$distResol\n\nFloat\n\nDistance resolution in pixel-related units.\n\n\n\n$angleResol\n\nFloat\n\nAngle resolution in radians.\n\n\n\n$accumThresh\n\nInteger\n\nA line is returned if the corresponding accumulator value is greater than the threshold.\n\n\n\n$minWidth\n\nInteger\n\nMinimum width of a line in pixels.\n\n\n\n$maxGap\n\nInteger\n\nThe maximum gap between lines for it to be considered one line.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$numLines\n\nInteger\n\nThe number of lines found in the image.\n\n\n\n$startX\n\nArray\n\nAn array of Floats that contains the X coordinates of the starts of all of the lines found.\n\n\n\n$startY\n\nArray\n\nAn array of Floats that contains the Y coordinates of the starts of all of the lines found.\n\n\n\n$endX\n\nArray\n\nAn array of Floats that contains the X coordinates of the ends of all of the lines found.\n\n\n\n$endY\n\nArray\n\nAn array of Floats that contains the Y coordinates of the ends of all of the lines found.\n\n\n\n\n\nExample:\n\n// Assumed: $image is already loaded with grayscale image.\n\n$cannyThresh = 150;\n\n$cannyLink = 60;\n\n$distResol = 2;\n\n$angleResol = 0.0698131; // PI / 45.\n\n$accumThresh = 100;\n\n$minWidth = 3;\n\n$maxGap = 7;\n\n($numLines, $startX, $startY, $endX, $endY) = OpenCV_GetHoughLines($image, $cannyThresh, $cannyLink, $distResol, $angleResol, $accumThresh, $minWidth, $maxGap);\n\n\n\n\n\nOpenCV_GetHueColorArea\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OpenCV_GetImageChannelCount": {
  "prefix": "OpenCV_GetImageChannelCount",
  "body": [
   "$$ChannelCount=OpenCV_GetImageChannelCount($$Image);"
  ],
  "description": "\n\n\n\n\n\nThis function returns the number of color channels in the specified OpenCV image structure.\n\nFor example, an RGB image will contain 3 color channels, and an RGBA (w/ Alpha Channel) image will contain 4 color channels.\n\nA grayscale image will contain a single color channel.\n\n\n\n\n\nRequirements:\n\nThese functions use the Open-Source OpenCV computer vision library from Intel, and therefore will offer the maximum performance when running on Intel Processors due to low-level optimizations for the Intel architecture. Any camera or input device that Windows recognizes as an imaging device should be compatible with these functions.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Image\n\nObject\n\nAn OpenCV image object of any resolution, format, or color depth\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ChannelCount\n\nInteger\n\nThe number of color channels that exist in the supplied OpenCV image.\n\n\n\n\n\nUsage Example:\n\n\n\n\n\n$Image = OpenCV_LoadImageFromFile(\"c:\\\\a.png\");\n\n$ChannelCount = OpenCV_GetImageChannelCount($Image);\n\n\n\n\n\nOpenCV_GetImageSize\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OpenCV_GetImageSize": {
  "prefix": "OpenCV_GetImageSize",
  "body": [
   "($$Width,$$Height)=OpenCV_GetImageSize($$Image);"
  ],
  "description": "\n\nThis function returns the width and height of the supplied OpenCV image structure in pixels.\n\n\n\n\n\nRequirements:\n\nThese functions use the Open-Source OpenCV computer vision library from Intel, and therefore will offer the maximum performance when running on Intel Processors due to low-level optimizations for the Intel architecture. Any camera or input device that Windows recognizes as an imaging device should be compatible with these functions.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Image\n\nObject\n\nAn OpenCV image object of any resolution, format, or color depth\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Width\n\nInteger\n\nThe number of pixels contained in the x axis of the image\n\n\n\n$Height\n\nInteger\n\nThe number of pixels contained in the y axis of the image.\n\n\n\n\n\nUsage Example:\n\n\n\n\n\n$Image = OpenCV_LoadImageFromFile(\"c:\\\\a.png\");\n\n($Width,$Height) = OpenCV_GetImageSize($Image);\n\nUpdateStatus($Width);\n\nUpdateStatus($Height);\n\n\n\n\n\nOpenCV_GetMonoIntensity\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OpenCV_GetMonoIntensity": {
  "prefix": "OpenCV_GetMonoIntensity",
  "body": [
   "($$Intensity,$$StdDev)=OpenCV_GetMonoIntensity($$Image,$$RoiUpperLeftX,$$RoiUpperLeftY,$$RoiWidth,$$RoiHeight);"
  ],
  "description": "\n\nThis function returns the grayscale intensity of the supplied region of interest, and the standard deviation of the pixel values in that region. If the image passed into the function is a color image of any format, it will be automatically converted to a grayscale image before the analysis is performed.\n\nIf the requested region of interest is outside of the maximum bounds of the image, the functon will automatically return a failing test result.\n\n\n\nRequirements:\n\nThese functions use the Open-Source OpenCV computer vision library from Intel, and therefore will offer the maximum performance when running on Intel Processors due to low-level optimizations for the Intel architecture. Any camera or input device that Windows recognizes as an imaging device should be compatible with these functions.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Image\n\nObject\n\nAn OpenCV Image Object\n\n\n\n$RoiUpperLeftX\n\nInteger\n\nThe x-coordinate of the upper left corner of the region of interest to be analyzed for intensity.\n\n\n\n$RoiUpperLeftY\n\nInteger\n\nThe y-coordinate of the upper left corner of the region of interest to be analyzed for intensity\n\n\n\n$RoiWidth\n\nInteger\n\nThe width of the region of interest specified in pixels (X-axis)\n\n\n\n$RoiHeight\n\nInteger\n\nThe height of the region of interest specified in pixels (Y-axis)\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Intensity\n\nFloat\n\nThe 256 bit average intensity of the image in the region of interest (0=Black, 255=white)\n\n\n\n$StdDev\n\nFloat\n\nThe standard deviation of the pixel values in the given region of interest specified in the image\n\n\n\n\n\nUsage Example:\n\n\n\n\n\n$Image = OpenCV_LoadImageFromFile(\"c:\\\\test.png\");\n\n($Intensity,$StdDev) = OpenCV_GetMonoIntensity($Image,40,40,20,20);\n\nUpdateStatus($Intensity);\n\nUpdateStatus($StdDev);\n\n\n\n\n\nOpenCV_GetMonoMinMaxIntensityInROI\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OpenCV_GetMonoMinMaxIntensityInROI": {
  "prefix": "OpenCV_GetMonoMinMaxIntensityInROI",
  "body": [
   "($$minX,$$minY,$$minValue,$$maxX,$$maxY,$$maxValue)=OpenCV_GetMonoMinMaxIntensityInROI($$Image,$$UpperX,$$UpperY,$$Width,$$Height);"
  ],
  "description": "\n\nThis function takes an OpenCV image, the upper left coordinates & width and height of the region of interest. It returns the gray-scale maximum and minimum pixel values within that region along with their pixel coordinates.\n\n\n\n\n\nThe function will display the following:\n\n\u00b7 The amount of maximum and minimum locations found\n\n\u00b7 The maximum and minimum pixel values found within the region of interest.\n\n\u00b7 The coordinates of the first maximum value found\n\n\u00b7 The coordinates of the first minimum value found\n\n\n\n\n\nNote: If the image passed into the function is a color image of any format, it will be automatically converted to a gray-scale image before the analysis is performed.\n\nNote: If the requested region of interest is outside of the maximum bounds of the image, the function will automatically return a failing test result.\n\n\n\n\n\nRequirements:\n\nThese functions use the Open-Source OpenCV computer vision library from Intel, and therefore will offer the maximum performance when running on Intel Processors due to low-level optimizations for the Intel architecture. Any camera or input device that Windows recognizes as an imaging device should be compatible with these functions.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Image\n\nObject\n\nAn OpenCV Image Structure that has been loaded from an existing file or camera capture.\n\n\n\n$UpperX\n\nInteger\n\nUpper left X coordinate of the ROI\n\n\n\n$UpperY\n\nInteger\n\nUpper left Y coordinate of the ROI\n\n\n\n$Width\n\nInteger\n\nROI Width (Pixels)\n\n\n\n$Height\n\nInteger\n\nROI Height (Pixels)\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$minX\n\nInteger\n\nX coordinate of the first minimum pixel value location\n\n\n\n$minY\n\nInteger\n\nY coordinate of the first minimum pixel value location\n\n\n\n$minValue\n\nFloat\n\nPixel value of the first minim pixel located\n\n\n\n$maxX\n\nInteger\n\nX coordinate of the first maximum pixel value location\n\n\n\n$maxY\n\nInteger\n\nY coordinate of the first maximum pixel value location\n\n\n\n$maxValue\n\nFloat\n\nPixel value of the first maximum pixel value located\n\n\n\n\n\nUsage Example:\n\n($minx,$miny,$minv,$maxx,$maxy,$maxv) = OpenCV_GetMonoMinMaxIntensityInROI($Image,20,20,100,100);\n\n\n\n\n\nOpenCV_GetVertLine2PointContour\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OpenCV_GetVerticalEdge($Image,$XCoord,$Ytop,$Ybottom,$RGBThreshold,$EdgeNum,$Direction);DescriptionScansasingleverticallinetofindallpointsonthelinethathaveRed,GreenandBluevaluesaboveaspecifiedlevel.Theseareconsiderededges.ReturnstheYcoordinateofthespecifiededgenumberfound.Eg.edgenumber3.Notes:Ifanedgeisnotfound,thefunctionreturns-1.Requirements:ThesefunctionsusetheOpen-SourceOpenCVcomputervisionlibraryfromIntel,andthereforewillofferthemaximumperformancewhenrunningonIntelProcessorsduetolow-leveloptimizationsfortheIntelarchitecture.AnycameraorinputdevicethatWindowsrecognizesasanimagingdeviceshouldbecompatiblewiththesefunctions.FunctionargumentsParameterVariableTypeDescription$ImageObjectAnOpenCVimageobjectofanyresolution,format,orcolordepth$XCoordIntegerThehorizontalcoordinateoftheverticallinethatwillbescanned$YtopIntegerThetop-mostYcoordinateoftheverticallinethatwillbescanned$YbottomIntegerThebottom-mostYcoordinateoftheverticallinethatwillbescanned$RGBThresholdStringCommadelimitedstringlistingtheRed,GreenandBlueThresholdlevelsforfindinganedge$EdgeNumIntegerThenumberoftheedgetoreturn$DirectionStringThedirectiontoscanValue:\u00b7\"TOP2BOTTOM\"\u00b7\"BOTTOM2TOP\"\u00b7\"UP2BOTTOM\"(deprecated)\u00b7\"BOTTOM2UP\"(deprecated)ReturnparametersParameterVariableTypeDescription$YCoordIntegerTheYCoordinateofthespecifiededge.Returns-1ifnoedgeswerefound.Example://Scanaverticallineathorizontalcoordinate190fromY=20toY=125foredgeswhereRedlevel>150.$XCoord=190;$Ytop=20;$Ybottom=125;$RGDThreshold=\"150,0,0\";//GreenandBluelevelssetto0.WearelookingatRededges.$EdgeNum=3;//Returnthethirdedge.$Direction=\"TOP2BOTTOM\";$XCoord=OpenCV_GetVerticalEdge($Image,$XCoord,$Ytop,$Ybottom,$RGBThreshold,$EdgeNum,$Direction);OpenCV_ManualCompareImagesPreviousTopNext***OpenCV_ManualCompareImagesUsage:$cReturn=OpenCV_ManualCompareImages": {
  "prefix": "OpenCV_GetVerticalEdge($Image,$XCoord,$Ytop,$Ybottom,$RGBThreshold,$EdgeNum,$Direction);DescriptionScansasingleverticallinetofindallpointsonthelinethathaveRed,GreenandBluevaluesaboveaspecifiedlevel.Theseareconsiderededges.ReturnstheYcoordinateofthespecifiededgenumberfound.Eg.edgenumber3.Notes:Ifanedgeisnotfound,thefunctionreturns-1.Requirements:ThesefunctionsusetheOpen-SourceOpenCVcomputervisionlibraryfromIntel,andthereforewillofferthemaximumperformancewhenrunningonIntelProcessorsduetolow-leveloptimizationsfortheIntelarchitecture.AnycameraorinputdevicethatWindowsrecognizesasanimagingdeviceshouldbecompatiblewiththesefunctions.FunctionargumentsParameterVariableTypeDescription$ImageObjectAnOpenCVimageobjectofanyresolution,format,orcolordepth$XCoordIntegerThehorizontalcoordinateoftheverticallinethatwillbescanned$YtopIntegerThetop-mostYcoordinateoftheverticallinethatwillbescanned$YbottomIntegerThebottom-mostYcoordinateoftheverticallinethatwillbescanned$RGBThresholdStringCommadelimitedstringlistingtheRed,GreenandBlueThresholdlevelsforfindinganedge$EdgeNumIntegerThenumberoftheedgetoreturn$DirectionStringThedirectiontoscanValue:\u00b7\"TOP2BOTTOM\"\u00b7\"BOTTOM2TOP\"\u00b7\"UP2BOTTOM\"(deprecated)\u00b7\"BOTTOM2UP\"(deprecated)ReturnparametersParameterVariableTypeDescription$YCoordIntegerTheYCoordinateofthespecifiededge.Returns-1ifnoedgeswerefound.Example://Scanaverticallineathorizontalcoordinate190fromY=20toY=125foredgeswhereRedlevel>150.$XCoord=190;$Ytop=20;$Ybottom=125;$RGDThreshold=\"150,0,0\";//GreenandBluelevelssetto0.WearelookingatRededges.$EdgeNum=3;//Returnthethirdedge.$Direction=\"TOP2BOTTOM\";$XCoord=OpenCV_GetVerticalEdge($Image,$XCoord,$Ytop,$Ybottom,$RGBThreshold,$EdgeNum,$Direction);OpenCV_ManualCompareImagesPreviousTopNext***OpenCV_ManualCompareImagesUsage:$cReturn=OpenCV_ManualCompareImages",
  "body": [
   "$$YCoord=OpenCV_GetVerticalEdge($$Image,$$XCoord,$$Ytop,$$Ybottom,$$RGBThreshold,$$EdgeNum,$$Direction);DescriptionScansasingleverticallinetofindallpointsonthelinethathaveRed,GreenandBluevaluesaboveaspecifiedlevel.Theseareconsiderededges.ReturnstheYcoordinateofthespecifiededgenumberfound.Eg.edgenumber3.Notes:Ifanedgeisnotfound,thefunctionreturns-1.Requirements:ThesefunctionsusetheOpen-SourceOpenCVcomputervisionlibraryfromIntel,andthereforewillofferthemaximumperformancewhenrunningonIntelProcessorsduetolow-leveloptimizationsfortheIntelarchitecture.AnycameraorinputdevicethatWindowsrecognizesasanimagingdeviceshouldbecompatiblewiththesefunctions.FunctionargumentsParameterVariableTypeDescription$$ImageObjectAnOpenCVimageobjectofanyresolution,format,orcolordepth$$XCoordIntegerThehorizontalcoordinateoftheverticallinethatwillbescanned$$YtopIntegerThetop-mostYcoordinateoftheverticallinethatwillbescanned$$YbottomIntegerThebottom-mostYcoordinateoftheverticallinethatwillbescanned$$RGBThresholdStringCommadelimitedstringlistingtheRed,GreenandBlueThresholdlevelsforfindinganedge$$EdgeNumIntegerThenumberoftheedgetoreturn$$DirectionStringThedirectiontoscanValue:\u00b7\"TOP2BOTTOM\"\u00b7\"BOTTOM2TOP\"\u00b7\"UP2BOTTOM\"(deprecated)\u00b7\"BOTTOM2UP\"(deprecated)ReturnparametersParameterVariableTypeDescription$$YCoordIntegerTheYCoordinateofthespecifiededge.Returns-1ifnoedgeswerefound.Example://Scanaverticallineathorizontalcoordinate190fromY=20toY=125foredgeswhereRedlevel>150.$$XCoord=190;$$Ytop=20;$$Ybottom=125;$$RGDThreshold=\"150,0,0\";//GreenandBluelevelssetto0.WearelookingatRededges.$$EdgeNum=3;//Returnthethirdedge.$$Direction=\"TOP2BOTTOM\";$$XCoord=OpenCV_GetVerticalEdge($$Image,$$XCoord,$$Ytop,$$Ybottom,$$RGBThreshold,$$EdgeNum,$$Direction);OpenCV_ManualCompareImagesPreviousTopNext***OpenCV_ManualCompareImagesUsage:$$cReturn=OpenCV_ManualCompareImages($$title,$$image1,$$image2);"
  ],
  "description": "\n\nThis function opens a form to show the two images side by side. The user can then select whether the images pass or fail.\n\n\n\n\n\nRemarks:\n\nThis function will not fail the test when the user selects the FAIL button, but will return the word \"FAIL\".\n\nThese functions use the Open-Source OpenCV computer vision library from Intel, and therefore will offer the maximum performance when running on Intel Processors due to low-level optimizations for the Intel architecture.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$title\n\nString\n\nThe title to put on screen above the images.\n\n\n\n$image1\n\nObject\n\nThe first image to show.\n\n\n\n$image2\n\nObject\n\nThe second image to show.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$cReturn\n\nString\n\nThe name of the button the user clicked on. Will be \"PASS\" or \"FAIL\" or empty if the user closed the window without clicking on a button.\n\n\n\n\n\nExample:\n\n$title = \"Confirm\";\n\n$cReturn = OpenCV_ManualCompareImages($title, $image1, $image2);\n\n\n\n\n\nif ($cReturn == \"FAIL\")\n\n{\n\nFail(\"The images did not match.\");\n\n}\n\n\n\n\n\nOpenCV_ManualCompareNonBlocking\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OpenCV_ManualCompareNonBlocking": {
  "prefix": "OpenCV_ManualCompareNonBlocking",
  "body": [
   "OpenCV_ManualCompareNonBlocking($$title,$$image1,$$image2);"
  ],
  "description": "\n\nThis function opens a form to show the two images side by side. The new form is opened on a separate thread so that it does not stop the script running.\n\n\n\n\n\nRemarks:\n\nThe user must close the form with the images manually by clicking on the Close button or clicking on the X in the top right of the window.\n\nThese functions use the Open-Source OpenCV computer vision library from Intel, and therefore will offer the maximum performance when running on Intel Processors due to low-level optimizations for the Intel architecture.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$title\n\nString\n\nThe title to display on the window.\n\n\n\n$image1\n\nObject\n\nThe first image to show.\n\n\n\n$image2\n\nObject\n\nThe second image to show.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\nOpenCV_ManualCompareNonBlocking($title, $image1, $image2);\n\n\n\n\n\nOpenCV_MatchTemplate\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OpenCV_MatchTemplate": {
  "prefix": "OpenCV_MatchTemplate",
  "body": [
   "($$Confidence,$$X,$$Y,$$ImageMatch)=OpenCV_MatchTemplate($$SearchImage,$$TemplateImage,$$MatchingAlgorithm,$$ShowDebug);"
  ],
  "description": "\n\nThis function performs a basic pattern matching algorithm which attempts to find the template image specified inside of the search image.\n\n\n\n\n\nThe template matching performed via this function \"slides\" the template image over the search image and computes a corresponding match confidence based on the matching algorithm specified in the function.\n\n\n\n\n\nThe different pattern matching algorithms supported by this function have all been normalized to compensate for colorspace differences caused by poor lighting control.\n\nThe \"Normalized Correlation Matching\" algorithm multiplicatively matches the template against an image so that a perfect match returns a very high confidence and poor matches will have a very low confidence, or 0.\n\nThe \"Normalized Correlation Coefficient Matching\" algorithm attempts to match a template relative to it's mean against the image relative to it's respective mean so that a perfect match will result in a value of 100%, and low matches will correspond a confidence of 50% which essentially means that there is no correlation between the matches (i.e. random alignments).\n\n\n\n\n\nFinally, the \"Normalized Square Difference Matching\" algorithm attempts to match the pattern by squaring the difference between the template and the patch of the image being search, where low values (i.e. small differences) yield higher confidence intervals.\n\n\n\n\n\nThe $ShowDebug parameter presents a modal dialog window which shows the operator both the search image, the best pattern match location of the template, and also the computed match image (the correlation or difference map depending on the algorithm chosen) which is useful for debugging when attempting to choose the most appropriate algorithm for a given template matching situation.\n\n\n\n\n\nEach algorithm will perform better or worse in different situations so it's recommended to try all three, but in general, the Normalized Correlation Coefficent Matching algorithm yields the best results in most situations.\n\n\n\n\n\nNote:\n\nThis function performs a simple template match operation on two images, therefore the template image and the source image must be of the same alignment and scale in order to create an effective match. If a more sophisticated (and more time-consuming) method is required, please see the SURF feature detection algorithm which provides a state of the art, scale and rotation invariant pattern matching solution.\n\n\n\n\n\nRequirements:\n\nThese functions use the Open-Source OpenCV computer vision library from Intel, and therefore will offer the maximum performance when running on Intel Processors due to low-level optimizations for the Intel architecture. Any camera or input device that Windows recognizes as an imaging device should be compatible with these functions.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$SearchImage\n\nObject\n\nThe OpenCV image object to search for the corresponding template\n\n\n\n$TemplateImage\n\nObject\n\nThe OpenCV image object to serve as a template for matching inside of the 'Search Image'\n\n\n\n$MatchingAlgorithm\n\nString\n\nThe desired matching algorithm to use during the template matching operation. Allowable values are:\n\n\u00b7 \"CCOEFF_NORMALIZED\" - Correlated Coefficient Matching Algorithm\n\n\u00b7 \"CCORR_NORMALIZED\" - Correlation Matching Algorithm\n\n\u00b7 \"SQDIFF_NORMALIZED\" - Square of Differences Matching Algorithm\n\n\n\n$ShowDebug\n\nBoolean\n\nShow debug image after match [TRUE,FALSE]\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Confidence\n\nFloat\n\nThe overall confidence interval of the match between the template and the source image.\n\n\n\n$X\n\nInteger\n\nThe X coordinate of the best matching location of the upper left hand corner of the template found in the source image.\n\n\n\n$Y\n\nInteger\n\nThe Y coordinate of the best matching location of the upper left hand corner of the template found in the source image.\n\n\n\n$Image\n\nObject\n\nAn OpenCV image structure showing the correlation of the matches between the template and the search image. The size of the image will be the same as the search image minus the dimensions of the template image. When using correlation matching algorithms, the overall brightness of a pixel inside of the match image indicates a high correlation (showing the best match). When using a differencing matching algorithm, the lowest intensity (dark region) indicates a more likely match.\n\n\n\n\n\nUsage Example:\n\n$SearchImage = OpenCV_LoadImageFromFile(\"c:\\\\folderview.png\");\n\n$TemplateImage = OpenCV_LoadImageFromFile(\"c:\\\\folder.png\");\n\n($Confidence,$X,$Y,$Image) = OpenCV_MatchTemplate($SearchImage,$TemplateImage,\"CCOEFF_NORMALIZED\",true);\n\nEnd;\n\n\n\n\n\nOpenCV_MatchTemplateWithROI\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OpenCV_MatchTemplateWithROI": {
  "prefix": "OpenCV_MatchTemplateWithROI",
  "body": [
   "($$Confidence,$$X,$$Y,$$ImageMatch)=OpenCV_MatchTemplateWithROI($$SearchImage,$$TemplateImage,$$MatchingAlgorithm,$$X,$$Y,$$Width,$$Height,$$ShowDebug);"
  ],
  "description": "\n\nThis function performs a basic pattern matching algorithm which attempts to find the template image inside of the specified region of interest within the search image.\n\n\n\n\n\nThe template matching performed via this function \"slides\" the template image over the region of interest in the search image and computes a corresponding match confidence based on the matching algorithm specified in the function.\n\n\n\n\n\nThe different pattern matching algorithms supported by this function have all been normalized to compensate for colorspace differences caused by poor lighting control.\n\nThe \"Normalized Correlation Matching\" algorithm multiplicatively matches the template against an image so that a perfect match returns a very high confidence and poor matches will have a very low confidence, or 0.\n\nThe \"Normalized Correlation Coefficient Matching\" algorithm attempts to match a template relative to it's mean against the image relative to it's respective mean so that a perfect match will result in a value of 100%, and low matches will correspond a confidence of 50% which essentially means that there is no correlation between the matches (i.e. random alignments).\n\n\n\n\n\nFinally, the \"Normalized Square Difference Matching\" algorithm attempts to match the pattern by squaring the difference between the template and the patch of the image being search, where low values (i.e. small differences) yield higher confidence intervals.\n\n\n\n\n\nThe $ShowDebug parameter presents a modal dialog window which shows the operator both the search image, the best pattern match location of the template, and also the computed match image (the correlation or difference map depending on the algorithm chosen) which is useful for debugging when attempting to choose the most appropriate algorithm for a given template matching situation.\n\n\n\n\n\nEach algorithm will perform better or worse in different situations so it's recommended to try all three, but in general, the Normalized Correlation Coefficent Matching algorithm yields the best results in most situations.\n\n\n\n\n\nNote:\n\nThis function performs a simple template match operation on two images, therefore the template image and the region of interest within the source image must be of the same alignment and scale in order to create an effective match. If a more sophisticated (and more time-consuming) method is required, please see the SURF feature detection algorithm which provides a state of the art, scale and rotation invariant pattern matching solution.\n\n\n\n\n\nRequirements:\n\nThese functions use the Open-Source OpenCV computer vision library from Intel, and therefore will offer the maximum performance when running on Intel Processors due to low-level optimizations for the Intel architecture. Any camera or input device that Windows recognizes as an imaging device should be compatible with these functions.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$SearchImage\n\nObject\n\nThe OpenCV image object to search for the corresponding template\n\n\n\n$TemplateImage\n\nObject\n\nThe OpenCV image object to serve as a template for matching inside of the 'Search Image'\n\n\n\n$MatchingAlgorithm\n\nString\n\nThe desired matching algorithm to use during the template matching operation. Allowable values are:\n\n\u00b7 \"CCOEFF_NORMALIZED\" - Correlated Coefficient Matching Algorithm\n\n\u00b7 \"CCORR_NORMALIZED\" - Correlation Matching Algorithm\n\n\u00b7 \"SQDIFF_NORMALIZED\" - Square of Differences Matching Algorithm\n\n\n\n$X\n\nInteger\n\nThe upper left X coordinate of the region of interest\n\n\n\n$Y\n\nInteger\n\nThe upper left Y coordinate of the region of interest\n\n\n\n$Width\n\nInteger\n\nThe width of the region of interest\n\n\n\n$Height\n\nInteger\n\nThe height of the region of interest\n\n\n\n$ShowDebug\n\nBoolean\n\nShow debug image after match [TRUE,FALSE]\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Confidence\n\nFloat\n\nThe overall confidence interval of the match between the template and the source image.\n\n\n\n$X\n\nInteger\n\nThe X coordinate of the best matching location of the upper left hand corner of the template found in the source image.\n\n\n\n$Y\n\nInteger\n\nThe Y coordinate of the best matching location of the upper left hand corner of the template found in the source image.\n\n\n\n$Image\n\nObject\n\nAn OpenCV image structure showing the correlation of the matches between the template and the search image. The size of the image will be the same as the search image minus the dimensions of the template image. When using correlation matching algorithms, the overall brightness of a pixel inside of the match image indicates a high correlation (showing the best match). When using a differencing matching algorithm, the lowest intensity (dark region) indicates a more likely match.\n\n\n\n\n\nUsage Example:\n\n$SearchImage = OpenCV_LoadImageFromFile(\"c:\\\\folderview.png\");\n\n$TemplateImage = OpenCV_LoadImageFromFile(\"c:\\\\folder.png\");\n\n($Confidence,$X,$Y,$Image) = OpenCV_MatchTemplateWithROI($SearchImage,$TemplateImage,\"CCOEFF_NORMALIZED\", 10,10,100,100,true);\n\nEnd;\n\n\n\n\n\nOpenCV_MatchTemplateWithRotation\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OpenCV_MatchTemplateWithRotation": {
  "prefix": "OpenCV_MatchTemplateWithRotation",
  "body": [
   "($$Confidence,$$X,$$Y,$$Rotation)=OpenCV_MatchTemplateWithRotation($$SearchImage,$$TemplateImage,$$MatchingAlgorithm,$$ShowDebugImage,$$StartRotation,$$EndRotation,$$RotationStepSize,$$RoiX,$$RoiY,$$RoiWidth,$$RoiHeight);"
  ],
  "description": "\n\nThis function performs a hybrid pattern matching algorithm which attempts to find the template image inside of the specified region of interest within the search image. The template can be rotated in the image and still be located by supplying a starting and stopping value for the allowable rotation. The user can also specify the \"Step Size\" for the rotation to be used when performing the template match.\n\n\n\n\n\nThe starting and stopping rotation, as well as the stepping values are supplied as \"Degrees\". For instance, if the user wants to match a template that may be rotated by up to -5 degrees to +5 degrees, the user could supply the following values $StartRotation=-5,$StopRotation=5,$StepSize=0.5.\n\n\n\n\n\nThis template matching is performed by \"sliding and rolling\" the template image over the region of interest in the search image and computes a corresponding match confidence based on the matching algorithm specified in the function.\n\n\n\n\n\nThe different pattern matching algorithms supported by this function have all been normalized to compensate for colorspace differences caused by poor lighting control.\n\nThe \"Normalized Correlation Matching\" algorithm multiplicatively matches the template against an image so that a perfect match returns a very high confidence and poor matches will have a very low confidence, or 0.\n\nThe \"Normalized Correlation Coefficient Matching\" algorithm attempts to match a template relative to it's mean against the image relative to it's respective mean so that a perfect match will result in a value of 100%, and low matches will correspond a confidence of 50% which essentially means that there is no correlation between the matches (i.e. random alignments).\n\n\n\n\n\nFinally, the \"Normalized Square Difference Matching\" algorithm attempts to match the pattern by squaring the difference between the template and the patch of the image being search, where low values (i.e. small differences) yield higher confidence intervals.\n\n\n\n\n\nThe $ShowDebug parameter presents a modal dialog window which shows the operator both the search image, the best pattern match location of the template, and also the computed match image (the correlation or difference map depending on the algorithm chosen) which is useful for debugging when attempting to choose the most appropriate algorithm for a given template matching situation.\n\n\n\n\n\nEach algorithm will perform better or worse in different situations so it's recommended to try all three, but in general, the Normalized Correlation Coefficent Matching algorithm yields the best results in most situations.\n\n\n\n\n\nNote:\n\nThis function performs a simple template match operation on two images, therefore the template image and the region of interest within the source image must be of the same alignment and scale in order to create an effective match. If a more sophisticated (and more time-consuming) method is required, please see the SURF feature detection algorithm which provides a state of the art, scale and rotation invariant pattern matching solution.\n\n\n\n\n\nRequirements:\n\nThese functions use the Open-Source OpenCV computer vision library from Intel, and therefore will offer the maximum performance when running on Intel Processors due to low-level optimizations for the Intel architecture. Any camera or input device that Windows recognizes as an imaging device should be compatible with these functions.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$SearchImage\n\nObject\n\nThe OpenCV image object to search for the corresponding template\n\n\n\n$TemplateImage\n\nObject\n\nThe OpenCV image object to serve as a template for matching inside of the 'Search Image'\n\n\n\n$MatchingAlgorithm\n\nString\n\nThe desired matching algorithm to use during the template matching operation. Allowable values are:\n\n\u00b7 \"CCOEFF_NORMALIZED\" - Correlated Coefficient Matching Algorithm\n\n\u00b7 \"CCORR_NORMALIZED\" - Correlation Matching Algorithm\n\n\u00b7 \"SQDIFF_NORMALIZED\" - Square of Differences Matching Algorithm\n\n\n\n$ShowDebug\n\nBoolean\n\nShow debug image after matching [TRUE,FALSE]\n\n\n\n$StartRotation\n\nFloat\n\nThe starting value for the rotation tolerance for pattern matching the template. Allowable values are between (-360 to 360 degrees)\n\n\n\n$EndRotation\n\nFloat\n\nThe ending value for the rotation tolerance for pattern matching the template. Allowable values are between (-360 to 360 degrees).\n\n\n\n$RotationStepSize\n\nFloat\n\nThe step size in degrees for incrementing the rotation for pattern matching Allowable values are between 0 to 360 degrees.\n\n\n\n$X\n\nInteger\n\nThe upper left X coordinate of the region of interest\n\n\n\n$Y\n\nInteger\n\nThe upper left Y coordinate of the region of interest\n\n\n\n$Width\n\nInteger\n\nThe width of the region of interest\n\n\n\n$Height\n\nInteger\n\nThe height of the region of interest\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Confidence\n\nFloat\n\nThe overall confidence interval of the match between the template and the source image.\n\n\n\n$X\n\nInteger\n\nThe X coordinate of the best matching location of the upper left hand corner of the template found in the source image.\n\n\n\n$Y\n\nInteger\n\nThe Y coordinate of the best matching location of the upper left hand corner of the template found in the source image.\n\n\n\n$Rotation\n\nFloat\n\nThe number of degrees of rotation (clock-wise) for which the best template match was found.\n\n\n\n\n\nUsage Example:\n\n// Real Test\n\n\n\n\n\n$ServerTemplate = OpenCV_LoadImageFromFile(\"c:\\\\images\\\\server_template.bmp\");\n\n\n\n\n\n$TestImage3 = OpenCV_LoadImageFromFile(\"c:\\\\images\\\\TestPictureDUT13.bmp\"); // Rotated 25 Degrees\n\n\n\n\n\n($Width,$Height) = OpenCV_GetImageSize($TestImage3);\n\n($Confidence,$X,$Y,$Rotation) = OpenCV_MatchTemplateWithRotation($TestImage3,$FaceTemplate,\"CCOEFF_NORMALIZED\",true,20,30,1,0,0,$Width,$Height);\n\n\n\n\n\n// Searches for a pattern match between 20 and 30 degrees of rotation, with a step size of 1 degree.\n\n\n\n\n\nOutput Example:\n\n\n\n\n\nOpenCV_PerformOCR\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OpenCV_PerformOCR": {
  "prefix": "OpenCV_PerformOCR",
  "body": [
   "$$RecognizedText=OpenCV_PerformOCR($$Image,$$Language,$$RoiUpperLeftX,$$RoiUpperLeftY,$$RoiWidth,$$RoiHeight,$$ShowDebugWindow);"
  ],
  "description": "\n\nThis function performs optical character recognition on a region of an OpenCV Image object and returns the text that was recognized as a string variable.\n\n\n\n\n\nThis function actually uses the Tesseract OCR library, however it was written to operate on OpenCV image structures so it is included in the OpenCV library.\n\nThe language specified configures the OCR engine to use the appropriate training files for recognizing text within the image. Currently, English, Spanish, German, Italian, Dutch, and French language definitions are included with the standard Jabil Test distribution.\n\n\n\n\n\nThe region of interest is the area from which to pull the desired text and is specified as a binding rectangle given it's upper left corner cordinates in the image, and the width and height of the region of interest.\n\n\n\n\n\nThe $ShowDebugWindow parameter is boolean value indicating whether or not you would like Jabil Test to display the thresholded region of interest to the user which can be useful when debugging OCR functionality in a test script.\n\n\n\n\n\nImportant Note: The Tesseract OCR engine performs best when the given text to recognize has an approximate height at least 35 pixels within the captured image. Although it's possible to recognize text with a height as small as 15- 20 pixels, the larger the text appears in the image will provide much more consistent recognition.\n\n\n\n\n\nImportant Note: The Tesseract OCR installer must be downloaded and installed to successfully perform character recognition. To add language files, download the desired file from the link below and paste into the \"Tesseract-OCR\\tessdata\" directory.\n\n\n\n\n\nThe Windows installer and additional language files can be downloaded from the following URL:\n\nhttp://code.google.com/p/tesseract-ocr/downloads/list\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Image\n\nObject\n\nAn OpenCV image structure of any color depth or resolution.\n\n\n\n$Language\n\nString\n\nThe language learning file to initialize the recognition engine. Currently supported language definitions are:\n\n\u00b7 \"ENG\" = English\n\n\u00b7 \"SPA\" = Spanish\n\n\u00b7 \"FRA\" = French\n\n\u00b7 \"ITA\" = Italian\n\n\u00b7 \"DEU\" = German\n\n\u00b7 \"NLD\" = Dutch\n\n\n\n$ROIUpperLeftX\n\nInteger\n\nThe upper left X coordinate for the region of interest\n\n\n\n$ROIUpperLeftY\n\nInteger\n\nThe upper left Y coordinate for the region of interest\n\n\n\n$ROIWidth\n\nInteger\n\nThe width of the region of interest (number of pixels)\n\n\n\n$ROIHeight\n\nInteger\n\nThe height of the region of interest (number of pixels)\n\n\n\n$ShowDebugWindow\n\nBoolean\n\nA boolean value indicating whether or not to show the debug window for the OCR operation.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$RecognizedText\n\nString\n\nThe text recognized by the OCR function.\n\n\n\n\n\nUsage Example:\n\n$Image = OpenCV_LoadImageFroFile(\"c:\\\\relay.jpg\");\n\n$Text = OpenCV_PerformOCR($Image,\"eng\",36,13,117,24,false);\n\n// Recognized Text = \"SIEMENS\"\n\n\n\n\n\nOriginal Image:\n\n\n\n\n\nThresholded Debug Image in the Region of Interest:\n\n\n\n\n\nOpenCV_PromptRectangleFromImage\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OpenCV_ShowImageInWindow": {
  "prefix": "OpenCV_ShowImageInWindow",
  "body": [
   "OpenCV_ShowImageInWindow($$Image);"
  ],
  "description": "\n\nThis function will open a diagnostic and debug window showing the specified image that was passed into the function. The $Image argument can be any OpenCV image structure of any resolution or color depth.\n\n\n\n\n\nThe diagnostic and debug window allows the user to view the image and analysis information such as histograms. The window also allow filters and transformations to be applied to the image in realtime, along with zoom and pan operations.\n\n\n\n\n\nThis is a useful tool for determining the best configuration of image filtering to apply to a live image acquisition before performing analysis functions on the image.\n\n\n\n\n\nRequirements:\n\nThese functions use the Open-Source OpenCV computer vision library from Intel, and therefore will offer the maximum performance when running on Intel Processors due to low-level optimizations for the Intel architecture.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Image\n\nObject\n\nAn OpenCV image object of any resolution, format, or color depth\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nUsage Example:\n\n$Image = OpenCV_LoadImageFromFile(\"c:\\\\a.png\");\n\nOpenCV_ShowImageInWindow($Image);\n\n\n\n\n\nOpenCV_ShowImageInWindowByName\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OpenCV_ShowImageInWindowByName": {
  "prefix": "OpenCV_ShowImageInWindowByName",
  "body": [
   "OpenCV_ShowImageInWindowByName($$Image,$$title);"
  ],
  "description": "\n\nThis function will open a diagnostic and debug window showing the specified image that was passed into the function and allow the user to change the title of the image window. The $Image argument can be any OpenCV image structure of any resolution or color depth.\n\n\n\n\n\nThe diagnostic and debug window allows the user to view the image and analysis information such as histograms. The window also allow filters and transformations to be applied to the image in realtime, along with zoom and pan operations.\n\n\n\n\n\nThis is a useful tool for determining the best configuration of image filtering to apply to a live image acquisition before performing analysis functions on the image.\n\n\n\n\n\nRequirements:\n\nThese functions use the Open-Source OpenCV computer vision library from Intel, and therefore will offer the maximum performance when running on Intel Processors due to low-level optimizations for the Intel architecture.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Image\n\nObject\n\nAn OpenCV image object of any resolution, format, or color depth.\n\n\n\n$title\n\nString\n\nThe title of the image window to show.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nUsage Example:\n\n$Image = OpenCV_LoadImageFromFile(\"c:\\\\a.png\");\n\n\n\n\n\nOpenCV_ShowImageInWindowByName($Image, \"Image Window\");\n\n\n\n\n\nOpenCV_DrawCircle\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OpenCV_DrawCircle": {
  "prefix": "OpenCV_DrawCircle",
  "body": [
   "$$NewImage=OpenCV_DrawCircle($$Image,$$X,$$Y,$$Radius,$$Thickness,$$ColorR,$$ColorG,$$ColorB);"
  ],
  "description": "\n\nThis function takes an OpenCV image and draws a circle on the image and returns a new image without altering the original. The circle's position, size, thickness, and color can be adjusted by setting the parameters.\n\n\n\n\n\nRequirements:\n\nThese functions use the Open-Source OpenCV computer vision library from Intel, and therefore will offer the maximum performance when running on Intel Processors due to low-level optimizations for the Intel architecture. Any camera or input device that Windows recognizes as an imaging device should be compatible with these functions.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Image\n\nObject\n\nAn OpenCV Image Structure that has been loaded from an existing file or camera capture.\n\n\n\n$X\n\nInteger\n\nThe center X coordinate of the circle to draw\n\n\n\n$Y\n\nInteger\n\nThe center Y coordinate of the circle to draw\n\n\n\n$Radius\n\nInteger\n\nThe radius of the circle to draw\n\n\n\n$Thickness\n\nInteger\n\nThe thickness (in pixels) of the circle to draw\n\n\n\n$ColorR\n\nInteger\n\nThe Red component for the circle color to be drawn (0-255)\n\n\n\n$ColorG\n\nInteger\n\nThe Green component for the circle color to be drawn (0-255)\n\n\n\n$ColorB\n\nInteger\n\nThe Blue component for the circle color to be drawn (0-255)\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$newImage\n\nObject\n\nAn OpenCV Image Structure.\n\n\n\n\n\nUsage Example:\n\n$Image = OpenCV_LoadImageFromFile(\"c:\\\\test.png\");\n\n$Image = OpenCV_DrawCircle($Image,200,200,10,2,255,255,0);\n\nOpenCV_ShowImageInWindow($Image);\n\n\n\n\n\nOpenCV_DrawCross\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OpenCV_DrawCross": {
  "prefix": "OpenCV_DrawCross",
  "body": [
   "$$NewImage=OpenCV_DrawCross($$Image,$$X,$$Y,$$Width,$$Height,$$Thickness,$$ColorR,$$ColorG,$$ColorB);"
  ],
  "description": "\n\nThis function takes an OpenCV image and draws a cross on the image and returns a new image without altering the original. The cross's position, size, thickness and color can be adjusted by setting the parameters.\n\n\n\n\n\nRequirements:\n\nThese functions use the Open-Source OpenCV computer vision library from Intel, and therefore will offer the maximum performance when running on Intel Processors due to low-level optimizations for the Intel architecture. Any camera or input device that Windows recognizes as an imaging device should be compatible with these functions.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Image\n\nObject\n\nAn OpenCV Image Structure that has been loaded from an existing file or camera capture.\n\n\n\n$X\n\nFloat\n\nThe center X coordinate of the cross to draw\n\n\n\n$Y\n\nFloat\n\nThe center Y coordinate of the cross to draw\n\n\n\n$Width\n\nFloat\n\nThe width of the cross to draw\n\n\n\n$Height\n\nFloat\n\nThe height of the cross to draw\n\n\n\n$Thickness\n\nInteger\n\nThe thickness (in pixels) of the cross to draw\n\n\n\n$ColorR\n\nInteger\n\nThe Red component for the cross color to be drawn (0-255)\n\n\n\n$ColorG\n\nInteger\n\nThe Green component for the cross color to be drawn (0-255)\n\n\n\n$ColorB\n\nInteger\n\nThe Blue component for the cross color to be drawn (0-255)\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$newImage\n\nObject\n\nAn OpenCV Image Structure.\n\n\n\n\n\nUsage Example:\n\n$Image = OpenCV_LoadImageFromFile(\"c:\\\\test.png\");\n\n$Image = OpenCV_DrawCross($Image,200,200,15,15,2,255,255,0);\n\nOpenCV_ShowImageInWindow($Image);\n\n\n\n\n\nOpenCV_Draw Ellipse\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OpenCV_DrawEllipse": {
  "prefix": "OpenCV_DrawEllipse",
  "body": [
   "$$NewImage=OpenCV_DrawEllipse($$Image,$$X,$$Y,$$Width,$$Height,$$Angle,$$Thickness,$$ColorR,$$ColorG,$$ColorB);"
  ],
  "description": "\n\nThis function takes an OpenCV image and draws an ellipse on the image and returns a new image without altering the original. The ellipse's position, size, thickness, angle and color can be adjusted by setting the parameters.\n\n\n\n\n\nRequirements:\n\nThese functions use the Open-Source OpenCV computer vision library from Intel, and therefore will offer the maximum performance when running on Intel Processors due to low-level optimizations for the Intel architecture. Any camera or input device that Windows recognizes as an imaging device should be compatible with these functions.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Image\n\nObject\n\nAn OpenCV Image Structure that has been loaded from an existing file or camera capture.\n\n\n\n$X\n\nFloat\n\nThe center X coordinate of the ellipse to draw\n\n\n\n$Y\n\nFloat\n\nThe center Y coordinate of the ellipse to draw\n\n\n\n$Width\n\nFloat\n\nThe width of the ellipse to draw\n\n\n\n$Height\n\nFloat\n\nThe height of the ellipse to draw\n\n\n\n$Angle\n\nFloat\n\nThe angle of the ellipse to draw\n\n\n\n$Thickness\n\nInteger\n\nThe thickness (in pixels) of the ellipse to draw\n\n\n\n$ColorR\n\nInteger\n\nThe Red component for the ellipse color to be drawn (0-255)\n\n\n\n$ColorG\n\nInteger\n\nThe Green component for the ellipse color to be drawn (0-255)\n\n\n\n$ColorB\n\nInteger\n\nThe Blue component for the ellipse color to be drawn (0-255)\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$newImage\n\nObject\n\nAn OpenCV Image Structure.\n\n\n\n\n\nUsage Example:\n\n$Image = OpenCV_LoadImageFromFile(\"c:\\\\test.png\");\n\n$Image = OpenCV_DrawEllipse($Image,200,200,30,15,35,2,255,255,0);\n\nOpenCV_ShowImageInWindow($Image);\n\n\n\n\n\nOpenCV_DrawLine\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OpenCV_DrawLine": {
  "prefix": "OpenCV_DrawLine",
  "body": [
   "$$NewImage=OpenCV_DrawLine($$Image,$$X1,$$Y1,$$X2,$$Y2,$$Thickness,$$ColorR,$$ColorG,$$ColorB);"
  ],
  "description": "\n\nThis function takes an OpenCV image and draws a line on the image and returns a new image without altering the original. The line's starting & ending points, thickness and color can be adjusted by setting the parameters.\n\n\n\n\n\nRequirements:\n\nThese functions use the Open-Source OpenCV computer vision library from Intel, and therefore will offer the maximum performance when running on Intel Processors due to low-level optimizations for the Intel architecture. Any camera or input device that Windows recognizes as an imaging device should be compatible with these functions.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Image\n\nObject\n\nAn OpenCV Image Structure that has been loaded from an existing file or camera capture.\n\n\n\n$X1\n\nInteger\n\nThe starting point's X coordinate of the line to draw\n\n\n\n$Y1\n\nInteger\n\nThe starting point's Y coordinate of the line to draw\n\n\n\n$X2\n\nInteger\n\nThe ending point's X coordinate of the line to draw\n\n\n\n$Y2\n\nInteger\n\nThe ending point's Y coordinate of the line to draw\n\n\n\n$Thickness\n\nInteger\n\nThe thickness (in pixels) of the line to draw\n\n\n\n$ColorR\n\nInteger\n\nThe Red component for the line color to be drawn (0-255)\n\n\n\n$ColorG\n\nInteger\n\nThe Green component for the line color to be drawn (0-255)\n\n\n\n$ColorB\n\nInteger\n\nThe Blue component for the line color to be drawn (0-255)\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$newImage\n\nObject\n\nAn OpenCV Image Structure.\n\n\n\n\n\nUsage Example:\n\n$Image = OpenCV_LoadImageFromFile(\"c:\\\\test.png\");\n\n$Image = OpenCV_DrawLine($Image,10,10,200,200,2,255,255,0);\n\nOpenCV_ShowImageInWindow($Image);\n\n\n\n\n\nOpenCV_DrawRectangle\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OpenCV_DrawRectangle": {
  "prefix": "OpenCV_DrawRectangle",
  "body": [
   "$$NewImage=OpenCV_DrawRectangle($$Image,$$UpperX,$$UpperY,$$Width,$$Height,$$Thickness,$$ColorR,$$ColorG,$$ColorB);"
  ],
  "description": "\n\nThis function takes an OpenCV image and draws an rectangle on the image and returns a new image without altering the original. The rectangle position, size, thickness, and color can be adjusted by setting the parameters.\n\n\n\n\n\nRequirements:\n\nThese functions use the Open-Source OpenCV computer vision library from Intel, and therefore will offer the maximum performance when running on Intel Processors due to low-level optimizations for the Intel architecture. Any camera or input device that Windows recognizes as an imaging device should be compatible with these functions.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Image\n\nObject\n\nAn OpenCV Image Structure that has been loaded from an existing file or camera capture.\n\n\n\n$UpperX\n\nInteger\n\nUpper left X coordinate of the Rectangle to draw\n\n\n\n$UpperY\n\nInteger\n\nUpper left Y coordinate of the Rectangle to draw\n\n\n\n$Width\n\nInteger\n\nThe width of the rectangle to draw\n\n\n\n$Height\n\nInteger\n\nThe height of the rectangle to draw\n\n\n\n$Thickness\n\nInteger\n\nThe thickness (in pixels) of the Rectangle to draw\n\n\n\n$ColorR\n\nInteger\n\nThe Red component for the rectangle color to be drawn (0-255)\n\n\n\n$ColorG\n\nInteger\n\nThe Green component for the rectangle color to be drawn (0-255)\n\n\n\n$ColorB\n\nInteger\n\nThe Blue component for the rectangle color to be drawn (0-255)\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$newImage\n\nObject\n\nAn OpenCV Image Structure.\n\n\n\n\n\nUsage Example:\n\n\n\n\n\n$Image = OpenCV_LoadImageFromFile(\"c:\\\\test.png\");\n\n$Image = OpenCV_DrawRectangle($Image,100,100,25,25,2,255,0,0);\n\nOpenCV_ShowImageInWindow($Image);\n\n\n\n\n\nOpenCV_DrawText\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OpenCV_DrawText": {
  "prefix": "OpenCV_DrawText",
  "body": [
   "$$NewImage=OpenCV_DrawText($$Image,$$Message,$$X,$$Y,$$Size,$$ColorR,$$ColorG,$$ColorB);"
  ],
  "description": "\n\nThis function takes an OpenCV image and draws a textual message on the image and returns a new image without altering the original. The message's position, text size and color can be adjusted by setting the parameters.\n\n\n\n\n\nRequirements:\n\nThese functions use the Open-Source OpenCV computer vision library from Intel, and therefore will offer the maximum performance when running on Intel Processors due to low-level optimizations for the Intel architecture. Any camera or input device that Windows recognizes as an imaging device should be compatible with these functions.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Image\n\nObject\n\nAn OpenCV Image Structure that has been loaded from an existing file or camera capture.\n\n\n\n$Message\n\nString\n\nThe message of the text to draw\n\n\n\n$X\n\nInteger\n\nThe bottom left X coordinate of the text to draw\n\n\n\n$Y\n\nInteger\n\nThe bottom left Y coordinate of the text to draw\n\n\n\n$Size\n\nFloat\n\nThe font size of the text to draw\n\n\n\n$ColorR\n\nInteger\n\nThe Red component for the line color to be drawn (0-255)\n\n\n\n$ColorG\n\nInteger\n\nThe Green component for the line color to be drawn (0-255)\n\n\n\n$ColorB\n\nInteger\n\nThe Blue component for the line color to be drawn (0-255)\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$newImage\n\nObject\n\nAn OpenCV Image Structure.\n\n\n\n\n\nUsage Example:\n\n$Image = OpenCV_LoadImageFromFile(\"c:\\\\test.png\");\n\n$Image = OpenCV_DrawText($Image,\"Message\",10,10,5,255,255,0);\n\nOpenCV_ShowImageInWindow($Image);\n\n\n\n\n\nOpenCV_AddImage\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OpenCV_AddImage": {
  "prefix": "OpenCV_AddImage",
  "body": [
   "$$sumImage=OpenCV_AddImage($$image1,$$image2);"
  ],
  "description": "\n\nThis function performs a pixel by pixel sum of the two input images and returns the resulting image.\n\n\n\nRemarks:\n\nThe two images must be the same size and the same bit-depth.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$image1\n\nObject\n\nThe first image to be added.\n\n\n\n$image2\n\nObject\n\nThe second image to be added.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$sumImage\n\nObject\n\nThe pixel by pixel sum of the two images.\n\n\n\n\n\nExample:\n\n$sumImage = OpenCV_AddImage($image1, $image2);\n\n\n\n\n\nOpenCV_AddImageWithConstant\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OpenCV_AddImageWithConstant": {
  "prefix": "OpenCV_AddImageWithConstant",
  "body": [
   "$$sumImage=OpenCV_AddImageWithConstant($$image1,$$const);"
  ],
  "description": "\n\nThis function performs a pixel by pixel sum of the input image with the constant.\n\n\n\nRemarks:\n\nThe constant will be added to each color of each pixel. If the value goes above 255, it will wrap around to 0.\n\nThe returned image is the same size as the input image.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$image1\n\nObject\n\nThe first image to be added.\n\n\n\n$const\n\nInteger\n\nThe constant to add to each pixel of the image.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$sumImage\n\nObject\n\nThe pixel by pixel sum of the image with the constant.\n\n\n\n\n\nExample:\n\n$sumImage = OpenCV_AddImageWithConstant($image1, $const);\n\n\n\n\n\nOpenCV_AdjustGrayContrastCurve\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OpenCV_AdjustGrayContrastCurve": {
  "prefix": "OpenCV_AdjustGrayContrastCurve",
  "body": [
   "$$adjImage=OpenCV_AdjustGrayContrastCurve($$image,$$steep,$$midCurve);"
  ],
  "description": "\n\nThis function adjusts the histogram curve for a gray scale image upwards. This has the effect of brightening dark pixels more than bright pixels. This will give an increase of contrast for the darker pixels while decreasing contrast for the brighter pixels. The basic function is:\n\n\n\nf(n) = x + mc "
 }
,
 "JTS OpenCV_AverageImages": {
  "prefix": "OpenCV_AverageImages",
  "body": [
   "$$AverageImage=OpenCV_AverageImages($$Image1,$$Image2);"
  ],
  "description": "\n\nThis function performs a pixel by pixel averaging of two input images and returns the resulting averaged image. This function can be useful for eliminating noise from low quality image acquisition devices such as webcams, etc.\n\nThe two input images are converted to an RGB color space before averaging, and the returned image is a 24-bit RGB image which can then be converted later using one of the available OpenCV image transformation functions.\n\n\n\n\n\nNote: This function was developed in Visual C++ 2008 and require the latest version of the Microsoft Visual C++ runtime which can be downloaded from Microsoft.\n\nRequirements:\n\nThese functions use the Open-Source OpenCV computer vision library from Intel, and therefore will offer the maximum performance when running on Intel Processors due to low-level optimizations for the Intel architecture. Any camera or input device that Windows recognizes as an imaging device should be compatible with these functions.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Image1\n\nObject\n\nThe OpenCV image object for averaging\n\n\n\n$Image2\n\nObject\n\nThe second OpenCV image object for averaging\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AverageImage\n\nObject\n\nThe OpenCV 24-bit RGB color image object that is a combined pixel by pixel value of the two input images.\n\n\n\n\n\nUsage Example:\n\n$Scene1 = OpenCV_LoadImageFromFile(\"c:\\\\scene1.jpg\");\n\n$Scene2 = OpenCV_LoadImageFromFile(\"c:\\\\scene2.jpg\");\n\n$AvgScene = OpenCV_AverageImages($Scene1,$Scene2);\n\nOpenCV_ShowImageInWindow($AvgScene);\n\n\n\n\n\nOpenCV_ConvertImageToGrayscale\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OpenCV_ConvertImageToGrayscale": {
  "prefix": "OpenCV_ConvertImageToGrayscale",
  "body": [
   "$$GrayImage=OpenCV_ConvertImageToGrayscale($$Image);"
  ],
  "description": "\n\n\n\n\n\nThis function will convert the supplied OpenCV image structure into an 8-bit grayscale image which is suitable for using in analysis and pattern matching functions.\n\n\n\n\n\nThe original color image object is left intact and is not modified.\n\n\n\n\n\nRequirements:\n\nThese functions use the Open-Source OpenCV computer vision library from Intel, and therefore will offer the maximum performance when running on Intel Processors due to low-level optimizations for the Intel architecture. Any camera or input device that Windows recognizes as an imaging device should be compatible with these functions.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Image\n\nObject\n\nAn OpenCV image object of any resolution, format, or color depth\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$GrayImage\n\nObject\n\nAn OpenCV image object in 8-bit grayscale format. The original image resolution is retained.\n\n\n\n\n\nUsage Example:\n\n\n\n\n\n$Image = OpenCV_LoadImageFromFile(\"c:\\\\a.png\");\n\n$GrayImage = OpenCV_ConvertImageToGrayscale($Image);\n\nOpenCV_ShowImageInWindow($GrayImage);\n\n\n\n\n\nOpenCV_CropImage\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OpenCV_CropImage": {
  "prefix": "OpenCV_CropImage",
  "body": [
   "$$croppedImage=OpenCV_CropImage($$Image,$$left,$$top,$$right,$$bottom);"
  ],
  "description": "\n\nCrops an area from an image, and return it as a new image..\n\n\n\nRequirements:\n\nThese functions use the Open-Source OpenCV computer vision library from Intel, and therefore will offer the maximum performance when running on Intel Processors due to low-level optimizations for the Intel architecture. Any camera or input device that Windows recognizes as an imaging device should be compatible with these functions.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Image\n\nObject\n\nAn OpenCV Image Structure that has been loaded from an existing file or camera capture.\n\n\n\n$left\n\nInteger\n\nThe left edge of the area to crop.\n\n\n\n$top\n\nInteger\n\nThe top edge of the area to crop.\n\n\n\n$right\n\nInteger\n\nThe right edge of the area to crop.\n\n\n\n$bottom\n\nInteger\n\nThe bottom edge of the are to crop.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$croppedImage\n\nObject\n\nAn OpenCV Image Structure which can be used with the other OpenCV functions in this library.\n\n\n\n\n\nExample:\n\n\n\n\n\n$newImage = OpenCV_CropImage($Image,10,10,50,50);\n\n\n\n\n\nOpenCV_DilateImage\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OpenCV_DilateImage": {
  "prefix": "OpenCV_DilateImage",
  "body": [
   "$$newImage=OpenCV_DilateImage($$Image,$$Iterations);"
  ],
  "description": "\n\n\n\n\n\nThis function takes an OpenCV image, and dilates it using a fixed 3x3 pattern of adjacent pixels. The function will be applied recursively based on the number of iterations specified.\n\n\n\n\n\nRequirements:\n\nThese functions use the Open-Source OpenCV computer vision library from Intel, and therefore will offer the maximum performance when running on Intel Processors due to low-level optimizations for the Intel architecture. Any camera or input device that Windows recognizes as an imaging device should be compatible with these functions.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Image\n\nObject\n\nAn OpenCV Image Structure that has been loaded from an existing file or camera capture.\n\n\n\n$Iterations\n\nInteger\n\nThe number of times to apply the dilating algorithm to the specified image. Each subsequent iteration is applied to the output of the last iteration.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$newImage\n\nObject\n\nA Grayscale OpenCV Image Structure which can be used with the other OpenCV functions in this library.\n\n\n\n\n\nUsage Example:\n\n$newImage = OpenCV_DilateImage($Image,5); // Dilates the image 5 times using a 3x3 matrix of adjacent pixels.\n\n\n\n\n\nOpenCV_DisposeImage\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OpenCV_DisposeImage": {
  "prefix": "OpenCV_DisposeImage",
  "body": [
   "OpenCV_DisposeImage($$Image);"
  ],
  "description": "\n\n\n\n\n\nThis function will dispose of the memory resources used to hold the supplied OpenCV Image object.\n\n\n\n\n\nThis function should be used to clean up any OpenCV Image resources after they are no longer used in the test script.\n\n\n\n\n\nRequirements:\n\nThese functions use the Open-Source OpenCV computer vision library from Intel, and therefore will offer the maximum performance when running on Intel Processors due to low-level optimizations for the Intel architecture. Any camera or input device that Windows recognizes as an imaging device should be compatible with these functions.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Image\n\nObject\n\nAn OpenCV image object of any resolution, format, or color depth\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nUsage Example:\n\n\n\n\n\nOpenCV_DisposeImage($MyImage); // Removes $MyImage from Memory...\n\n\n\n\n\nOpenCV_EqualizeHist\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OpenCV_EqualizeHist": {
  "prefix": "OpenCV_EqualizeHist",
  "body": [
   "$$ehImage=OpenCV_EqualizeHist($$image);"
  ],
  "description": "\n\nThe algorithm normalizes brightness and increases contrast of the image. For color images, a HSV representation of the image is first obtained and the V (value) channel is histogram normalized.\n\n\n\n\n\nRemarks:\n\nThese functions use the Open-Source OpenCV computer vision library from Intel, and therefore will offer the maximum performance when running on Intel Processors due to low-level optimizations for the Intel architecture.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$image\n\nObject\n\nThe image to be equalized.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ehImage\n\nObject\n\nThe resulting image with the histogram equalized.\n\n\n\n\n\nExample:\n\n$ehImage = OpenCV_EqualizeHist($image);\n\n\n\n\n\nOpenCV_ErodeImage\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OpenCV_ErodeImage": {
  "prefix": "OpenCV_ErodeImage",
  "body": [
   "$$erodedImage=OpenCV_ErodeImage($$image,$$iterations);"
  ],
  "description": "\n\nErodes the source image using the specified structuring element that determines the shape of a pixel neighborhood over which the minimum is taken: dst=erode(src,element): dst(x,y)=min((x',y') in element)) src(x+x',y+y'). Erosion can be applied several (iterations) times. In the case of a color image, each channel is processed independently.\n\n\n\n\n\nRemarks:\n\nThese functions use the Open-Source OpenCV computer vision library from Intel, and therefore will offer the maximum performance when running on Intel Processors due to low-level optimizations for the Intel architecture.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$image\n\nObject\n\nThe image to be transformed.\n\n\n\n$iterations\n\nInteger\n\nNumber of time to apply erosion.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$erodedImage\n\nObject\n\nThe resulting eroded image.\n\n\n\n\n\nExample:\n\n$erodedImage = OpenCV_ErodeImage($image, $iterations);\n\n\n\n\n\nOpenCV_FillByHSV\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OpenCV_FillByHSV": {
  "prefix": "OpenCV_FillByHSV",
  "body": [
   "($$Count,$$ResultImage)=OpenCV_FillByHSV($$Image,$$Hmin,$$Smin,$$Vmin,$$Hmax,$$Smax,$$Vmax,$$Hfill,$$Sfill,$$Vfill);"
  ],
  "description": "\n\nThis function fills a bitmap object based on HSV values. If a pixel's HSV value falls within the high and low limits specified for all three values (Hue, Saturation and Value), the pixel's color is changed to the HSV value specified by the pixel fill parameters.\n\n\n\n\n\nThis function provides the ability to segment an image based on HSV values and set pixels that fall within the HSV limits supplied to a known color value. This is useful for segmenting an image based on HSV in order to eliminate background clutter and improve image or edge pattern matching probability.\n\n\n\n\n\nThe image below is a flattened representation of the HSV color space. For more information regarding color space please visit: http://en.wikipedia.org/wiki/HSL_and_HSV\n\n\n\nRequirements:\n\nThese functions use the Open-Source OpenCV computer vision library from Intel, and therefore will offer the maximum performance when running on Intel Processors due to low-level optimizations for the Intel architecture. Any camera or input device that Windows recognizes as an imaging device should be compatible with these functions.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Image\n\nObject\n\nAn OpenCV Image Structure that has been loaded from an existing file or camera capture.\n\n\n\nLow Hue Value\n\nInteger\n\nThe lower limit of Hue for pixel color comparison. Note: Since Hue is a cylindrical-coordinate and could wrap around the zero value, if the lower limit for Hue is greater than the higher limit, the function will work on the assumption that the user wants to select Hue values that cross the zero value. The range of values for Hue is 0-360 however, the 360 value is never realized since 360 would equal zero. The actual range of Hue values is [0,360).\n\n\n\nSaturation Low Limit\n\nInteger\n\nThe lower limit of Saturation for pixel color comparison. The range of Saturation values is [0,100].\n\n\n\nValue Low Limit\n\nInteger\n\nThe lower limit of Value for pixel color comparison. The range of Value values is [0,100].\n\n\n\nHigh Hue Value\n\nInteger\n\nThe upper limit of Hue for pixel color comparison. See note above regarding wrap.\n\n\n\nSaturation High Limit\n\nInteger\n\nThe upper limit of Saturation for pixel color comparison. The range of Saturation values is [0,100].\n\n\n\nValue High Limit\n\nInteger\n\nThe upper limit of Value for pixel color comparison. The range of Value values is [0,100].\n\n\n\nHue Fill for pixels within limits\n\nInteger\n\nPixels within all three criteria of Hue, Saturation and Value will be set to this Hue value. Hue range is [0,360).\n\n\n\nSaturation Fill for pixels within limits\n\nInteger\n\nPixels within all three criteria of Hue, Saturation and Value will be set to this Saturation value. Saturation range is [0,100].\n\n\n\nValue Fill for pixels within limits\n\nInteger\n\nPixels within all three criteria of Hue, Saturation and Value will be set to this Value. Value range is [0,100].\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Count\n\nInteger\n\nNumber of pixels filled.\n\n\n\n$Image\n\nObject\n\nA Bitmap Image object.\n\n\n\n\n\nUsage Example:\n\nTo simplify pattern matching via image or edge, it is desired to eliminate background clutter in the image below. In the example below, all pixels not within a narrow range of hue and high saturation are set to black.\n\n\n\n\n\n//Load image\n\n$Image = OpenCV_LoadImageFromFile(\"C:\\\\JabilTestScripts\\\\Jellyfish.jpg\");\n\n// Display original image\n\nOpenCV_ShowImageInWindow($Image);\n\n// Fill pixels with black (HSV = 0,0,0) based on Hue to eliminate colors other than redish orange\n\n($Count1, $ResultImage) = OpenCV_FillByHSV($Image,71,0,0,249,100,100,0,0,0);\n\n// Display and save results of 1st fill\n\nOpenCV_ShowImageInWindow($ResultImage);\n\nOpenCV_SaveImageToFile($ResultImage,\"C:\\\\JabilTestScripts\\\\Jellyfish1stFill.jpg\",\"JPEG\");\n\n// Fill pixels with black (HSV = 0,0,0) to eliminate lower saturation levels\n\n($Count2,$ResultImage) = OpenCV_FillByHSV($ResultImage,0,0,0,360,40,100,0,0,0);\n\n// Display and save results of 2nd fill\n\nOpenCV_ShowImageInWindow($ResultImage);\n\nOpenCV_SaveImageToFile($ResultImage,\"C:\\\\JabilTestScripts\\\\Jellyfish2ndFill.jpg\",\"JPEG\");\n\n// Dispose and quit\n\nOpenCV_DisposeImage($Image);\n\nOpenCV_DisposeImage($ResultImage);\n\nEnd;\n\n\n\n\n\nOriginal Image\n\n\n\nAfter 1st OpenCV_FillByHSV\n\n\n\nAfter 2nd OpenCV_FillByHSV\n\n\n\n\n\nOpenCV_InvertColor\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OpenCV_InvertColor": {
  "prefix": "OpenCV_InvertColor",
  "body": [
   "$$newImage=OpenCV_InvertColor($$Image);"
  ],
  "description": "\n\n\n\n\n\nThis function takes an OpenCV image, computes the complement image and returns the inverted color result.\n\n\n\nRequirements:\n\nThese functions use the Open-Source OpenCV computer vision library from Intel, and therefore will offer the maximum performance when running on Intel Processors due to low-level optimizations for the Intel architecture. Any camera or input device that Windows recognizes as an imaging device should be compatible with these functions.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Image\n\nObject\n\nAn OpenCV Image Structure that has been loaded from an existing file or camera capture.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$newImage\n\nObject\n\nA color OpenCV Image Structure which can be used with the other OpenCV functions in this library.\n\n\n\n\n\nUsage Example:\n\n$newImage= OpenCV_InvertColor($Image);\n\n\n\n\n\nOpenCV_InvertGrayscale\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OpenCV_InvertGrayscale": {
  "prefix": "OpenCV_InvertGrayscale",
  "body": [
   "$$newImage=OpenCV_InvertGrayscale($$Image);"
  ],
  "description": "\n\n\n\n\n\nThis function takes an OpenCV image, computes the complement image and returns the inverted gray-scale result.\n\n\n\nRequirements:\n\nThese functions use the Open-Source OpenCV computer vision library from Intel, and therefore will offer the maximum performance when running on Intel Processors due to low-level optimizations for the Intel architecture. Any camera or input device that Windows recognizes as an imaging device should be compatible with these functions.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Image\n\nObject\n\nAn OpenCV Image Structure that has been loaded from an existing file or camera capture.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$newImage\n\nObject\n\nA Grayscale OpenCV Image Structure which can be used with the other OpenCV functions in this library.\n\n\n\n\n\nUsage Example:\n\n$newImage= OpenCV_InvertGrayscale($Image);\n\n\n\n\n\nOpenCV_LaplaceGrayImage\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OpenCV_LaplaceGrayImage": {
  "prefix": "OpenCV_LaplaceGrayImage",
  "body": [
   "$$ltImage=OpenCV_LaplaceGrayImage($$image,$$apertureSize);"
  ],
  "description": "\n\nThis function converts the input image to gray scale and performs a LaPlace Transform on the image by summing second x and y derivatives calculated using the Sobel operator and returns the resulting gray scale image.\n\n\n\n\n\nRemarks:\n\nSpecifying an aperature size of 1 gives the fastest variant and is equal to convolving the image with a kernel of |0 1 0| |1 -4 1| |0 1 0|.\n\nThese functions use the Open-Source OpenCV computer vision library from Intel, and therefore will offer the maximum performance when running on Intel Processors due to low-level optimizations for the Intel architecture.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$image\n\nObject\n\nThe image to be transformed\n\n\n\n$apertureSize\n\nInteger\n\nThe aperture size.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ltImage\n\nObject\n\nThe resulting transformed image.\n\n\n\n\n\nExample:\n\n$ltImage = OpenCV_LaplaceGrayImage($image, $apertureSize);\n\n\n\n\n\nOpenCV_LaplaceImage\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OpenCV_LaplaceImage": {
  "prefix": "OpenCV_LaplaceImage",
  "body": [
   "$$ltImage=OpenCV_LaplaceImage($$image,$$apertureSize);"
  ],
  "description": "\n\nThis function performs a LaPlace Transform on an image by summing second x and y derivatives calculated using the Sobel operator and returns the resulting image.\n\n\n\n\n\nRemarks:\n\nSpecifying an aperature size of 1 gives the fastest variant and is equal to convolving the image with a kernel of |0 1 0| |1 -4 1| |0 1 0|.\n\nThese functions use the Open-Source OpenCV computer vision library from Intel, and therefore will offer the maximum performance when running on Intel Processors due to low-level optimizations for the Intel architecture.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$image\n\nObject\n\nThe image to be transformed\n\n\n\n$apertureSize\n\nInteger\n\nThe aperture size.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ltImage\n\nObject\n\nThe resulting transformed image.\n\n\n\n\n\nExample:\n\n$ltImage = OpenCV_LaplaceImage($image, $apertureSize);\n\n\n\n\n\nOpenCV_LoadBitmapObject\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OpenCV_LoadBitmapObject": {
  "prefix": "OpenCV_LoadBitmapObject",
  "body": [
   "$$Image=OpenCV_LoadBitmapObject($$Bitmap);"
  ],
  "description": "\n\n\n\n\n\nThis function opens a bitmap image (BMP,TIFF,JPG,GIF,PNG,etc) and converts it into an OpenCV image structure so that analysis, filtering, or transformation can be applied to the image.\n\n\n\nRequirements:\n\nThese functions use the Open-Source OpenCV computer vision library from Intel, and therefore will offer the maximum performance when running on Intel Processors due to low-level optimizations for the Intel architecture. Any camera or input device that Windows recognizes as an imaging device should be compatible with these functions.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Bitmap\n\nObject\n\nThe bitmap image object to be loaded into an OpenCV image object. This object is of type System.Drawing.Bitmap.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Image\n\nObject\n\nAn OpenCV Image Structure which can be used with the other OpenCV functions in this library.\n\n\n\n\n\nUsage Example:\n\n$Image = OpenCV_LoadBitmapObject($Bitmap);\n\n\n\n\n\nOpenCV_LoadImageFromFile\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OpenCV_LoadImageFromFile": {
  "prefix": "OpenCV_LoadImageFromFile",
  "body": [
   "$$Image=OpenCV_LoadImageFromFile($$Filename);"
  ],
  "description": "\n\nThis function opens a bitmap image (BMP,TIFF,JPG,GIF,PNG,etc) stored on the local computer and converts it into an OpenCV image structure so that analysis, filtering, or transformation can be applied to the image.\n\n\n\n\n\nRequirements:\n\nThese functions use the Open-Source OpenCV computer vision library from Intel, and therefore will offer the maximum performance when running on Intel Processors due to low-level optimizations for the Intel architecture. Any camera or input device that Windows recognizes as an imaging device should be compatible with these functions.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Filename\n\nString\n\nThe filename and path of the image to be loaded into an OpenCV image object.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Image\n\nObject\n\nAn OpenCV Image Structure which can be used with the other OpenCV functions in this library.\n\n\n\n\n\nUsage Example:\n\n$Image = OpenCV_LoadImageFromFile(\"c:\\\\goldenscreen.png\");\n\n\n\n\n\nOpenCV_LogGrayImage\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OpenCV_LogGrayImage": {
  "prefix": "OpenCV_LogGrayImage",
  "body": [
   "$$logImage=OpenCV_LogGrayImage($$image);"
  ],
  "description": "\n\nThis function converts the input image to gray scale and performs a natural log of every pixel in the image and returns the resulting gray scale image.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$image\n\nObject\n\nThe image to take the log of.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$logImage\n\nObject\n\nThe resulting gray scale image.\n\n\n\n\n\nExample:\n\n$logImage = OpenCV_LogGrayImage($image);\n\n\n\n\n\nOpenCV_LogImage\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OpenCV_LogImage": {
  "prefix": "OpenCV_LogImage",
  "body": [
   "$$logImage=OpenCV_LogImage($$image);"
  ],
  "description": "\n\nThis function performs a natural log of every pixel in the image and returns the resulting image.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$image\n\nObject\n\nThe image to take the log of.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$logImage\n\nObject\n\nThe resulting image.\n\n\n\n\n\nExample:\n\n$logImage = OpenCV_LogImage($image);\n\n\n\n\n\nOpenCV_MaskImageToBlack\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OpenCV_MaskImageToBlack": {
  "prefix": "OpenCV_MaskImageToBlack",
  "body": [
   "$$mImage=OpenCV_MaskImageToBlack($$image,$$mask);"
  ],
  "description": "\n\nThis function applies a gray scale mask to an image. A black pixel on the mask will return a black pixel and white on the mask will return the original pixel from the image. Gray on the mask will move the pixel on the image towards black based on the darkness of the mask pixel.\n\n\n\n\n\nRemarks:\n\nThe image and the mask must be the same size and the same bit-depth.\n\nThese functions use the Open-Source OpenCV computer vision library from Intel, and therefore will offer the maximum performance when running on Intel Processors due to low-level optimizations for the Intel architecture.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$image\n\nObject\n\nThe image to be masked.\n\n\n\n$mask\n\nObject\n\nThe gray scale mask to apply to the image.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$mImage\n\nObject\n\nThe resulting masked image.\n\n\n\n\n\nExample:\n\n$mImage = OpenCV_MaskImageToBlack($image, $mask);\n\n\n\n\n\nOpenCV_MulGrayImage\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OpenCV_MulGrayImage": {
  "prefix": "OpenCV_MulGrayImage",
  "body": [
   "$$mulImage=OpenCV_MulGrayImage($$image1,$$image2);"
  ],
  "description": "\n\nThis function converts the input images to gray scale and performs a pixel by pixel multiplication of the two images and returns the resulting gray scale image.\n\n\n\n\n\nRemarks:\n\nThe two images must be the same size and the same bit-depth.\n\nThese functions use the Open-Source OpenCV computer vision library from Intel, and therefore will offer the maximum performance when running on Intel Processors due to low-level optimizations for the Intel architecture.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$image1\n\nObject\n\nThe first image to multiply together.\n\n\n\n$image2\n\nObject\n\nThe second image to multiply.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$mulImage\n\nObject\n\nThe resulting image of multiplying the pixels of the input images.\n\n\n\n\n\nExample:\n\n$mulImage = OpenCV_MulGrayImage($image1, $image2);\n\n\n\n\n\nOpenCV_MulGrayImageWithConstant\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OpenCV_MulGrayImageWitConstant": {
  "prefix": "OpenCV_MulGrayImageWitConstant",
  "body": [
   "$$mulImage=OpenCV_MulGrayImageWitConstant($$image,$$scale);"
  ],
  "description": "\n\nThis function will converts the image to gray scale and performs a pixel by pixel multiplication of the image with a constant and returns the resulting image.\n\n\n\n\n\nRemarks:\n\nThese functions use the Open-Source OpenCV computer vision library from Intel, and therefore will offer the maximum performance when running on Intel Processors due to low-level optimizations for the Intel architecture.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$image\n\nObject\n\nThe image to be modified.\n\n\n\n$scale\n\nInteger\n\nThe number to multiply each pixel by.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$mulImage\n\nObject\n\nThe resulting gray scale image from multiplying the pixels by the scale constant.\n\n\n\n\n\nExample:\n\n$mulImage = OpenCV_MulGrayImageWithConstant($image, $scale);\n\n\n\n\n\nOpenCV_MulImage\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OpenCV_MulImage": {
  "prefix": "OpenCV_MulImage",
  "body": [
   "$$mulImage=OpenCV_MulImage($$image1,$$image2);"
  ],
  "description": "\n\nThis function performs a pixel by pixel multiplication of the two images and returns the resulting image.\n\n\n\n\n\nRemarks:\n\nThe two images must be the same size and the same bit-depth.\n\nThese functions use the Open-Source OpenCV computer vision library from Intel, and therefore will offer the maximum performance when running on Intel Processors due to low-level optimizations for the Intel architecture.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$image1\n\nObject\n\nThe first image to multiply together.\n\n\n\n$image2\n\nObject\n\nThe second image to multiply.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$mulImage\n\nObject\n\nThe resulting image of multiplying the pixels of the input images.\n\n\n\n\n\nExample:\n\n$mulImage = OpenCV_MulImage($image1, $image2);\n\n\n\n\n\nOpenCV_MulImageWithConstant\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OpenCV_MulImageWitConstant": {
  "prefix": "OpenCV_MulImageWitConstant",
  "body": [
   "$$mulImage=OpenCV_MulImageWitConstant($$image,$$scale);"
  ],
  "description": "\n\nThis function performs a pixel by pixel multiplication of the image with a constant and returns the resulting image.\n\n\n\n\n\nRemarks:\n\nThese functions use the Open-Source OpenCV computer vision library from Intel, and therefore will offer the maximum performance when running on Intel Processors due to low-level optimizations for the Intel architecture.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$image\n\nObject\n\nThe image to be modified.\n\n\n\n$scale\n\nInteger\n\nThe number to multiply each pixel by.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$mulImage\n\nObject\n\nThe resulting image from multiplying the pixels by the scale constant.\n\n\n\n\n\nExample:\n\n$mulImage = OpenCV_MulImageWithConstant($image, $scale);\n\n\n\n\n\nOpenCV_PowGrayImage\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OpenCV_PowGrayImage": {
  "prefix": "OpenCV_PowGrayImage",
  "body": [
   "$$powImage=OpenCV_PowGrayImage($$image,$$power);"
  ],
  "description": "\n\nThis function converts the input image to gray scale and raises every pixel of the image to a power and returns the resulting image.\n\n\n\n\n\nRemarks:\n\nThese functions use the Open-Source OpenCV computer vision library from Intel, and therefore will offer the maximum performance when running on Intel Processors due to low-level optimizations for the Intel architecture.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$image\n\nObject\n\nThe image to be modified.\n\n\n\n$power\n\nFloat\n\nThe number to raise each pixel to.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$powImage\n\nObject\n\nThe resulting gray scale image from raising each pixel to the power.\n\n\n\n\n\nExample:\n\n$powImage = OpenCV_PowGrayImage($image, $power);\n\n\n\n\n\nOpenCV_PowImage\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OpenCV_PowImage": {
  "prefix": "OpenCV_PowImage",
  "body": [
   "$$powImage=OpenCV_PowImage($$image,$$power);"
  ],
  "description": "\n\nThis function raises every pixel of the image to a power and returns the resulting image.\n\n\n\n\n\nRemarks:\n\nEach channel is raised to the power separately.\n\nThese functions use the Open-Source OpenCV computer vision library from Intel, and therefore will offer the maximum performance when running on Intel Processors due to low-level optimizations for the Intel architecture.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$image\n\nObject\n\nThe image to be modified.\n\n\n\n$power\n\nFloat\n\nThe number to raise each pixel to.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$powImage\n\nObject\n\nThe resulting image from raising each pixel to the power.\n\n\n\n\n\nExample:\n\n$powImage = OpenCV_PowImage($image, $power);\n\n\n\n\n\nOpenCV_PyramidUpDown\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OpenCV_PyramidUpDown": {
  "prefix": "OpenCV_PyramidUpDown",
  "body": [
   "$$newImage=OpenCV_PyramidUpDown($$Image,$$Pyramid);"
  ],
  "description": "\n\nThis function takes an OpenCV image and performs an up or down sampling step Gaussian pyramid decomposition.\n\n\n\n\n\nUp: First it up-samples the image by injecting even zero rows and columns and then convolves result with the specified filter multiplied by 4 for interpolation. So the resulting image is four times larger than the source image.\n\n\n\n\n\nDown: First it convolves this image with the specified filter and then down-samples the image by rejecting even rows and columns.\n\n\n\n\n\nNote: Pyramid Up is not the inverse of Pyramid Down and vice versa because Pyramid Down loses information. Please see descriptions for both above.\n\n\n\n\n\nRequirements:\n\nThese functions use the Open-Source OpenCV computer vision library from Intel, and therefore will offer the maximum performance when running on Intel Processors due to low-level optimizations for the Intel architecture. Any camera or input device that Windows recognizes as an imaging device should be compatible with these functions.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Image\n\nObject\n\nAn OpenCV Image Structure that has been loaded from an existing file or camera capture.\n\n\n\n$Pyramid\n\nString\n\nDetermines whether the Gaussian pyramid decomposition will be done with up sampling or down sampling. Valid inputs are: [UP,DOWN]\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$newImage\n\nObject\n\nAn OpenCV Image Structure which can be used with the other OpenCV functions in this library.\n\n\n\n\n\nUsage Example:\n\n$newImage= OpenCV_PyramidUpDown($Image,\"UP\");\n\n\n\n\n\nOpenCV_ResizeImage\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OpenCV_ResizeImage": {
  "prefix": "OpenCV_ResizeImage",
  "body": [
   "$$newImage=OpenCV_ResizeImage($$Image,$$scaleFactor,$$interpolationMethod);"
  ],
  "description": "\n\nThis function takes an OpenCV image and scales it up or down based on the supplied scaling factor and using the specified interpolation method.\n\n\n\n\n\nScaling factors less than 1 will scale the image down in size and scaling factors greater than 1 with scale the image up in size.\n\n\n\n\n\nInterpolation methods are:\n\n\u00b7 NN - nearest-neighbor interpolation\n\n\u00b7 Linear - bilinear interpolation (the default)\n\n\u00b7 Area - resampling using pixel area relation. The preferred method for moire-free image decimation\n\n\u00b7 Cubic - bicubic interpolation\n\n\n\n\n\nRequirements:\n\nThese functions use the Open-Source OpenCV computer vision library from Intel, and therefore will offer the maximum performance when running on Intel Processors due to low-level optimizations for the Intel architecture. Any camera or input device that Windows recognizes as an imaging device should be compatible with these functions.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Image\n\nObject\n\nAn OpenCV Image Structure that has been loaded from an existing file or camera capture.\n\n\n\n$scaleFactor\n\nFloat\n\nThe amount to scale the image up or down.\n\nscaleFactor < 1 scales the image down.\n\nscaleFactor > 1 scales the image up.\n\n\n\n$interpolationMethod\n\nString\n\nThe interpolation method to use when scaling the image.\n\nValues: NN, Area, Cubic, Linear\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$newImage\n\nObject\n\nAn OpenCV Image Structure which can be used with the other OpenCV functions in this library.\n\n\n\n\n\nExamples::\n\n// Scale image to twice its original size using linear interpolation\n\n$largerImage = OpenCV_ResizeImage($Image, 2, \"Linear\");\n\n\n\n\n\n// Scale image to half its size using pixel area relation\n\n$smallerImage = OpenCV_ResizeImage($Image, 0.5, \"Area\");\n\n\n\n\n\nOpenCV_RotateImage\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OpenCV_RotateImage": {
  "prefix": "OpenCV_RotateImage",
  "body": [
   "$$rotatedImage=OpenCV_RotateImage($$Image,$$Degrees,$$Crop);"
  ],
  "description": "\n\nThis function takes an OpenCV image and rotates it the desired amount of degrees in the clockwise direction. This function can also crop the resultant image based on the original dimensions or it will automatically resize the canvas to display the entire newly rotated image.\n\n\n\n\n\nRemarks:\n\nThis function uses the OpenCV and EMGU CV libraries version 3.3.0.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Image\n\nObject\n\nAn OpenCV Image Structure that has been loaded from an existing file or camera capture.\n\n\n\n$Degrees\n\nFloat\n\nThe number of degrees to rotate in the clockwise direction.\n\n\n\n$Crop\n\nBoolean\n\nSpecifies whether the resultant image will be cropped to display the entire rotated image.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$rotatedImage\n\nObject\n\nAn OpenCV Image Structure which can be used with the other OpenCV functions in this library.\n\n\n\n\n\nExample:\n\n\n\n\n\n// Rotate an image 90 degrees.\n\n$rotatedImage = OpenCV_RotateImage($Image, 90, false);\n\n\n\n\n\nOpenCV_RotateImageBkg\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OpenCV_RotateImageBkg": {
  "prefix": "OpenCV_RotateImageBkg",
  "body": [
   "$$rotatedImage=OpenCV_RotateImageBkg($$Image,$$Degrees,$$Crop,$$BkgColor);"
  ],
  "description": "\n\nThis function takes an OpenCV image and rotates it the desired amount of degrees in the clockwise direction and changes the background color to the specified color. This function can also crop the resultant image based on the original dimensions or it will automatically resize the canvas to display the entire newly rotated image.\n\n\n\n\n\nRemarks:\n\nThis function uses the OpenCV and EMGU CV libraries version 3.3.0.\n\nThe background color is specified by one byte each for Red, Green, Blue, separated by commas. White would be 255, 255, 255.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Image\n\nObject\n\nAn OpenCV Image Structure that has been loaded from an existing file or camera capture.\n\n\n\n$Degrees\n\nFloat\n\nThe number of degrees to rotate in the clockwise direction.\n\n\n\n$Crop\n\nBoolean\n\nSpecifies whether the resultant image will be cropped to display the entire rotated image.\n\n\n\n$BkgColor\n\nString\n\nColor to make the background in R, G, B values.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$rotatedImage\n\nObject\n\nAn OpenCV Image Structure which can be used with the other OpenCV functions in this library.\n\n\n\n\n\nExample:\n\n\n\n\n\n// Rotate an image 90 degrees and change the background to blue.\n\n$bkColor = \"0, 0, 200\";\n\n\n\n$rotatedImage = OpenCV_RotateImageBkg($Image, 90, false, $bkColor);\n\n\n\n\n\nOpenCV_SaveImageAsBitmap\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OpenCV_SaveImageAsBitmap": {
  "prefix": "OpenCV_SaveImageAsBitmap",
  "body": [
   "OpenCV_SaveImageAsBitmap($$Image,$$FileName);"
  ],
  "description": "\n\nThis functions saves an OpenCV image structure as a bitmap file. The image color depth, resolution, and pixel format are all preserved.\n\n\n\nRequirements:\n\n\n\n\n\nThese functions use the Open-Source OpenCV computer vision library from Intel, and therefore will offer the maximum performance when running on Intel Processors due to low-level optimizations for the Intel architecture. Any camera or input device that Windows recognizes as an imaging device should be compatible with these functions.\n\n\n\n\n\nNote: This function has been deprecated in favor of 'OpenCV_SaveImageToFile' which provides a mechanism to save an OpenCV image multiple file formats.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Image\n\nObject\n\nAn OpenCV Image object of any format or color depth.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nUsage Example:\n\n\n\n\n\n$Camera = OpenCV_OpenCamera(0);\n\n$Image = OpenCV_QueryFrame($Camera);\n\nOpenCV_SaveImageAsBitmap($Image,\"c:\\\\testImage.bmp\");\n\nOpenCV_CloseCamera($Camera);\n\n\n\n\n\nOpenCV_SaveImageToFile\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OpenCV_SaveImageToFile": {
  "prefix": "OpenCV_SaveImageToFile",
  "body": [
   "OpenCV_SaveImageToFile($$Image,$$FileName,$$FileFormat);"
  ],
  "description": "\n\nThis functions saves an OpenCV image structure as an file of the specified format. The image color depth, resolution, and pixel format are all preserved.\n\n\n\nRequirements:\n\n\n\n\n\nThese functions use the Open-Source OpenCV computer vision library from Intel, and therefore will offer the maximum performance when running on Intel Processors due to low-level optimizations for the Intel architecture. Any camera or input device that Windows recognizes as an imaging device should be compatible with these functions.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Image\n\nObject\n\nAn OpenCV Image object of any format or color depth.\n\n\n\n$FileName\n\nString\n\nThe file name of the image to store\n\n\n\n$FileFormat\n\nString\n\nThe desired file format of the image. Supported File Types are:\n\n\u00b7 BMP\n\n\u00b7 GIF\n\n\u00b7 JPEG\n\n\u00b7 PNG\n\n\u00b7 TIFF\n\n\u00b7 WMF\n\n\u00b7 EXIF\n\n\u00b7 EMF\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nUsage Example:\n\n\n\n\n\n$File = OpenCV_LoadImageFromFile(\"c:\\\\images\\\\callTemplate.jpg\");\n\nOpenCV_SaveImageToFile($File,\"c:\\\\images\\\\myFile.bmp\",\"BMP\");\n\nOpenCV_SaveImageToFile($File,\"c:\\\\images\\\\myFile.jpg\",\"JPEG\");\n\nOpenCV_SaveImageToFile($File,\"c:\\\\images\\\\myFile.tiff\",\"TIFF\");\n\n\n\n\n\nOpenCV_SmoothBilatral\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OpenCV_SmoothBilatral": {
  "prefix": "OpenCV_SmoothBilatral",
  "body": [
   "$$smoothImage=OpenCV_SmoothBilatral($$Image,$$KernelSize,$$ColorSigma,$$SpaceSigma);"
  ],
  "description": "\n\nThis function takes an OpenCV image and performs Bilatral smoothing and returns the resultant image. Bilatral filtering smoothes the image without smoothing away the edges. The size of the kernel determines how many neighboring pixels will be smoothed from the center pixel.\n\n\n\n\n\nThe color sigma is the width of the Kernel in the color domain. The larger the color sigma is, the broader is the range of intensities (or colors) that will be included in the smoothing.\n\n\n\n\n\nThe space sigma is the difference in intensity from the center pixel. Bilatral smoothing weights more similar pixels more highly than less similar ones.\n\n\n\n\n\nRequirements:\n\nThese functions use the Open-Source OpenCV computer vision library from Intel, and therefore will offer the maximum performance when running on Intel Processors due to low-level optimizations for the Intel architecture. Any camera or input device that Windows recognizes as an imaging device should be compatible with these functions.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Image\n\nObject\n\nAn OpenCV Image Structure that has been loaded from an existing file or camera capture.\n\n\n\n$KernalSize\n\nInteger\n\nThe width of the Kernel. Must be an odd integer greater than zero.\n\n\n\n$ColorSigma\n\nInteger\n\nThe width of the Kernel in the color domain.\n\n\n\n$SpaceSigma\n\nInteger\n\nThe width of the Kernel in the spatial domain.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$smoothImage\n\nObject\n\nAn OpenCV Image Structure which can be used with the other OpenCV functions in this library.\n\n\n\n\n\nUsage Example:\n\n$smoothImage= OpenCV_SmoothBilatral($Image,7,3,3);\n\n\n\n\n\nOpenCV_SmoothBlur\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OpenCV_SmoothBlur": {
  "prefix": "OpenCV_SmoothBlur",
  "body": [
   "$$smoothImage=OpenCV_SmoothBlur($$Image,$$Width,$$Height);"
  ],
  "description": "\n\nThis function takes an OpenCV image and performs Blur smoothing and returns the resultant image. Each pixel in the output is the simple mean of all the pixels in a window around the corresponding pixel in the input. The surrounding pixel window size is determined by the $Width and $Height arguments.\n\n\n\n\n\nRequirements:\n\nThese functions use the Open-Source OpenCV computer vision library from Intel, and therefore will offer the maximum performance when running on Intel Processors due to low-level optimizations for the Intel architecture. Any camera or input device that Windows recognizes as an imaging device should be compatible with these functions.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Image\n\nObject\n\nAn OpenCV Image Structure that has been loaded from an existing file or camera capture.\n\n\n\n$Width\n\nInteger\n\nThe Width of the surrounding pixel window used to calculate the mean.\n\n\n\n$Height\n\nInteger\n\nThe Height of the surrounding pixel window used to calculate the mean.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$smoothImage\n\nObject\n\nAn OpenCV Image Structure which can be used with the other OpenCV functions in this library.\n\n\n\n\n\nUsage Example:\n\n$smoothImage= OpenCV_SmoothBlur($Image,5,5);\n\n\n\n\n\nOpenCV_SmoothGaussian\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OpenCV_SmoothGaussian": {
  "prefix": "OpenCV_SmoothGaussian",
  "body": [
   "$$smoothImage=OpenCV_SmoothGaussian($$Image,$$KernelWidth,$$KernelHeight,$$Sigma1,$$Sigma2);"
  ],
  "description": "\n\nThis function takes an OpenCV image and performs Gaussian smoothing and returns the resultant image. The second and third arguments give the width and height of the filter window. The dimensions of the kernel determine how many neighboring pixels will be smoothed from the center pixel. Gaussian smoothing reduces noise while preserving signal.\n\n\n\n\n\nNote: Gaussian smoothing smoothes away the edges. Use OpenCV_SmoothBilatral to preserve the edges.\n\n\n\n\n\nRequirements:\n\nThese functions use the Open-Source OpenCV computer vision library from Intel, and therefore will offer the maximum performance when running on Intel Processors due to low-level optimizations for the Intel architecture. Any camera or input device that Windows recognizes as an imaging device should be compatible with these functions.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Image\n\nObject\n\nAn OpenCV Image Structure that has been loaded from an existing file or camera capture.\n\n\n\n$KernelWidth\n\nInteger\n\nThe width of the Gaussian Kernel. Must be an odd integer greater than zero.\n\n\n\n$KernelHeight\n\nInteger\n\nThe height of the Gaussian Kernel. Must be an odd integer greater than zero.\n\n\n\n$Sigma1\n\nFloat\n\nThe standard deviation of the Gaussian kernel in the horizontal dimension.\n\n\n\n$Sigma2\n\nFloat\n\nThe standard deviation of the Gaussian kernel in the vertical dimension.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$smoothImage\n\nObject\n\nAn OpenCV Image Structure which can be used with the other OpenCV functions in this library.\n\n\n\n\n\nUsage Example:\n\n$smoothImage = OpenCV_SmoothGaussian($Image, 3, 3, 5, 5);\n\n\n\n\n\nOpenCV_SmoothMedian\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OpenCV_SmoothMedian": {
  "prefix": "OpenCV_SmoothMedian",
  "body": [
   "$$smoothImage=OpenCV_SmoothMedian($$Image,$$KernelSize);"
  ],
  "description": "\n\nThis function takes an OpenCV image and performs Median smoothing and returns the resultant image. Median smoothing replaces each pixel by the median or \"middle\" pixel value in a square neighborhood around the center pixel set by the KernelSize argument.\n\n\n\n\n\nRequirements:\n\nThese functions use the Open-Source OpenCV computer vision library from Intel, and therefore will offer the maximum performance when running on Intel Processors due to low-level optimizations for the Intel architecture. Any camera or input device that Windows recognizes as an imaging device should be compatible with these functions.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Image\n\nObject\n\nAn OpenCV Image Structure that has been loaded from an existing file or camera capture.\n\n\n\n$KernalSize\n\nInteger\n\nThe width of the Kernel. Must be an odd integer greater than zero.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$smoothImage\n\nObject\n\nAn OpenCV Image Structure which can be used with the other OpenCV functions in this library.\n\n\n\n\n\nUsage Example:\n\n$smoothImage= OpenCV_SmoothMedian($Image,7);\n\n\n\n\n\nOpenCV_SobelGrayImage\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OpenCV_SobelGrayImage": {
  "prefix": "OpenCV_SobelGrayImage",
  "body": [
   "$$sImage=OpenCV_SobelGrayImage($$image,$$xorder,$$yorder,$$apertureSize);"
  ],
  "description": "\n\nThis function converts the image to gray scale and calculates the image derivative by convolving the image with the appropriate kernel. The Sobel operators combine Gaussian smoothing and differentiation so the result is more or less robust to the noise.\n\n\n\n\n\nRemarks:\n\nMost often, the function is called with (xorder = 1, yorder = 0, aperture size = 3) or (xorder = 0, yorder = 1, aperture size = 3) to calculate the first x and y image derivative.\n\nThese functions use the Open-Source OpenCV computer vision library from Intel, and therefore will offer the maximum performance when running on Intel Processors due to low-level optimizations for the Intel architecture.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$image\n\nObject\n\nThe image to be transformed.\n\n\n\n$xorder\n\nInteger\n\nOrder of the x derivative (0 or 1).\n\n\n\n$yorder\n\nInteger\n\nOrder of the y derivative (0 or 1).\n\n\n\n$apertureSize\n\nInteger\n\nSize of the extended Sobel kernel. Must be 1, 3, 5, or 7.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$sImage\n\nObject\n\nThe resulting transformed gray scale image.\n\n\n\n\n\nExample:\n\n$sImage = OpenCV_SobelGrayImage($image, $xorder, $yorder, $apertureSize);\n\n\n\n\n\nOpenCV_SobelImage\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OpenCV_SobelImage": {
  "prefix": "OpenCV_SobelImage",
  "body": [
   "$$sImage=OpenCV_SobelImage($$image,$$xorder,$$yorder,$$apertureSize);"
  ],
  "description": "\n\nThis function calculates the image derivative by convolving the image with the appropriate kernel. The Sobel operators combine Gaussian smoothing and differentiation so the result is more or less robust to the noise.\n\n\n\nRemarks:\n\nMost often, the function is called with (xorder = 1, yorder = 0, aperture size = 3) or (xorder = 0, yorder = 1, aperture size = 3) to calculate the first x and y image derivative.\n\nThese functions use the Open-Source OpenCV computer vision library from Intel, and therefore will offer the maximum performance when running on Intel Processors due to low-level optimizations for the Intel architecture.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$image\n\nObject\n\nThe image to be transformed.\n\n\n\n$xorder\n\nInteger\n\nOrder of the x derivative (0 or 1).\n\n\n\n$yorder\n\nInteger\n\nOrder of the y derivative (0 or 1).\n\n\n\n$apertureSize\n\nInteger\n\nSize of the extended Sobel kernel. Must be 1, 3, 5, or 7.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$sImage\n\nObject\n\nThe resulting transformed image.\n\n\n\n\n\nExample:\n\n$sImage = OpenCV_SobelImage($image, $xorder, $yorder, $apertureSize);\n\n\n\n\n\nOpenCV_SubGrayImage\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OpenCV_SubGrayImage": {
  "prefix": "OpenCV_SubGrayImage",
  "body": [
   "$$subImage=OpenCV_SubGrayImage($$image1,$$image2);"
  ],
  "description": "\n\nThis function converts both images to gray scale and performs a pixel by pixel subtraction of the of the second image from the first image and returns the resulting gray scale image.\n\n\n\n\n\nRemarks:\n\nThe two images must be the same size and the same bit-depth.\n\nThese functions use the Open-Source OpenCV computer vision library from Intel, and therefore will offer the maximum performance when running on Intel Processors due to low-level optimizations for the Intel architecture.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$image1\n\nObject\n\nThe first image.\n\n\n\n$image2\n\nObject\n\nThe image to be subtracted from the first image.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$subImage\n\nObject\n\nThe gray scale pixel by pixel subtraction of the two images.\n\n\n\n\n\nExample:\n\n$subImage = OpenCV_SubGrayImage($image1, $image2);\n\n\n\n\n\nOpenCV_SubImage\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OpenCV_SubImage": {
  "prefix": "OpenCV_SubImage",
  "body": [
   "$$subImage=OpenCV_SubImage($$image1,$$image2);"
  ],
  "description": "\n\nThis function performs a pixel by pixel subtraction of the of the second image from the first image and returns the resulting image.\n\n\n\n\n\nRemarks:\n\nThe two images must be the same size and the same bit-depth.\n\nThese functions use the Open-Source OpenCV computer vision library from Intel, and therefore will offer the maximum performance when running on Intel Processors due to low-level optimizations for the Intel architecture.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$image1\n\nObject\n\nThe first image.\n\n\n\n$image2\n\nObject\n\nThe image to be subtracted from the first image.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$subImage\n\nObject\n\nThe pixel by pixel subtraction of the two images.\n\n\n\n\n\nExample:\n\n$subImage = OpenCV_SubImage($image1, $image2);\n\n\n\n\n\nOpenCV_ThresholdBinary\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OpenCV_ThresholdBinaryColor": {
  "prefix": "OpenCV_ThresholdBinaryColor",
  "body": [
   "$$newImage=OpenCV_ThresholdBinaryColor($$Image,$$ThreshR,$$ThreshG,$$ThreshB,$$MaxR,$$MaxG,$$MaxB);"
  ],
  "description": "\n\nThis function takes an OpenCV image and performs a binary threshold and returns the resultant image.\n\n\n\n\n\nAny pixel values less than the threshold value are set to 0, otherwise they are set to the maximum value passed into the function. This is useful for removing noise and other artifacts from an image before analyzing it.\n\n\n\n\n\nRequirements:\n\nThese functions use the Open-Source OpenCV computer vision library from Intel, and therefore will offer the maximum performance when running on Intel Processors due to low-level optimizations for the Intel architecture. Any camera or input device that Windows recognizes as an imaging device should be compatible with these functions.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Image\n\nObject\n\nAn OpenCV Image Structure that has been loaded from an existing file or camera capture.\n\n\n\n$ThreshR\n\nFloat\n\nThe Red Value of the pixel threshold.\n\n\n\n$ThreshG\n\nFloat\n\nThe Green Value of the pixel threshold.\n\n\n\n$ThreshB\n\nFloat\n\nThe Blue Value of the pixel threshold.\n\n\n\n$MaxR\n\nFloat\n\nThe Red Value of the pixel maximum..\n\n\n\n$MaxG\n\nFloat\n\nThe Green Value of the pixel maximum.\n\n\n\n$MaxB\n\nFloat\n\nThe Blue Value of the pixel maximum.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$newImage\n\nObject\n\nAn OpenCV Image Structure which can be used with the other OpenCV functions in this library.\n\n\n\n\n\nUsage Example:\n\n$newImage= OpenCV_ThresholdBinaryColor($Image,80,80,80,255,255,255);\n\n\n\n\n\nOpenCV_ThresholdBinaryGrayBetweenLimits\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OpenCV_ThresholdBinaryGrayBetweenLimits": {
  "prefix": "OpenCV_ThresholdBinaryGrayBetweenLimits",
  "body": [
   "$$threshImage=OpenCV_ThresholdBinaryGrayBetweenLimits($$image,$$minR,$$minG,$$minB,$$maxR,$$maxG,$$maxB);"
  ],
  "description": "\n\nThis function checks each pixel to see if its color levels are between the minimum and maximum limits (inclusive) and, if it is, sets the pixel to white. If the color levels are outside the limits, the pixel is set to black.\n\n\n\n\n\nRemarks:\n\nThese functions use the Open-Source OpenCV computer vision library from Intel, and therefore will offer the maximum performance when running on Intel Processors due to low-level optimizations for the Intel architecture.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$image\n\nObject\n\nThe image to check the pixel color levels of.\n\n\n\n$minR\n\nInteger\n\nThe minimum level for the red color of each pixel (inclusive).\n\n\n\n$minG\n\nInteger\n\nThe minimum level for the green color of each pixel (inclusive).\n\n\n\n$minB\n\nInteger\n\nThe minimum level for the blue color of each pixel (inclusive).\n\n\n\n$maxR\n\nInteger\n\nThe maximum level for the red color of each pixel (inclusive).\n\n\n\n$maxG\n\nInteger\n\nThe maximum level for the green color of each pixel (inclusive).\n\n\n\n$maxB\n\nInteger\n\nThe maximum level for the blue color of each pixel (inclusive).\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$threshImage\n\nObject\n\nThe resulting black and white image showing which pixels were between the limits.\n\n\n\n\n\nExample:\n\n$threshImage = OpenCV_ThresholdBinaryGrayBetweenLimits($image, 40, 45, 40, 100, 120, 100);\n\n\n\n\n\nOpenCV_ThresholdBinaryGrayscale\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OpenCV_ThresholdBinaryGrayscale": {
  "prefix": "OpenCV_ThresholdBinaryGrayscale",
  "body": [
   "$$newImage=OpenCV_ThresholdBinaryGrayscale($$Image,$$Threshold,$$Maximum);"
  ],
  "description": "\n\nThis function takes an OpenCV image and performs a binary gray-scale threshold and returns the resultant gray-scale image.\n\nAny pixel values less than the threshold value are set to 0, otherwise they are set to the maximum value passed into the function. This is useful for removing noise and other artifacts from an image before analyzing it.\n\n\n\n\n\nRequirements:\n\nThese functions use the Open-Source OpenCV computer vision library from Intel, and therefore will offer the maximum performance when running on Intel Processors due to low-level optimizations for the Intel architecture. Any camera or input device that Windows recognizes as an imaging device should be compatible with these functions.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Image\n\nObject\n\nAn OpenCV Image Structure that has been loaded from an existing file or camera capture.\n\n\n\n$Threshold\n\nFloat\n\nThe pixel threshold value\n\n\n\n$Maximum\n\nFloat\n\nThe maximum pixel value\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$newImage\n\nObject\n\nAn OpenCV Image Grayscale Structure which can be used with the other OpenCV functions in this library.\n\n\n\n\n\nUsage Example:\n\n$newImage= OpenCV_ThresholdBinaryGrayscale($Image,80,255);\n\n\n\n\n\nOpenCV_ThresholdBinaryInvColor\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OpenCV_ThresholdBinaryInvColor": {
  "prefix": "OpenCV_ThresholdBinaryInvColor",
  "body": [
   "$$newImage=OpenCV_ThresholdBinaryInvColor($$Image,$$ThreshR,$$ThreshG,$$ThreshB,$$MaxR,$$MaxG,$$MaxB);"
  ],
  "description": "\n\nThis function takes an OpenCV image and performs an inverse binary threshold and returns the resultant image.\n\n\n\n\n\nAny pixel values exceeding the threshold value are set to 0, otherwise they are set to the maximum value passed into the function. This is useful for removing noise and other artifacts from an image before analyzing it.\n\n\n\n\n\nRequirements:\n\nThese functions use the Open-Source OpenCV computer vision library from Intel, and therefore will offer the maximum performance when running on Intel Processors due to low-level optimizations for the Intel architecture. Any camera or input device that Windows recognizes as an imaging device should be compatible with these functions.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Image\n\nObject\n\nAn OpenCV Image Structure that has been loaded from an existing file or camera capture.\n\n\n\n$ThreshR\n\nFloat\n\nThe Red Value of the pixel threshold.\n\n\n\n$ThreshG\n\nFloat\n\nThe Green Value of the pixel threshold.\n\n\n\n$ThreshB\n\nFloat\n\nThe Blue Value of the pixel threshold.\n\n\n\n$MaxR\n\nFloat\n\nThe Red Value of the pixel maximum..\n\n\n\n$MaxG\n\nFloat\n\nThe Green Value of the pixel maximum.\n\n\n\n$MaxB\n\nFloat\n\nThe Blue Value of the pixel maximum.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$newImage\n\nObject\n\nAn OpenCV Image Structure which can be used with the other OpenCV functions in this library.\n\n\n\n\n\nUsage Example:\n\n$newImage= OpenCV_ThresholdBinaryInvColor($Image,80,80,80,255,255,255);\n\n\n\n\n\nOpenCV_ThresholdBinaryInvGrayscale\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OpenCV_ThresholdBinaryInvGrayscale": {
  "prefix": "OpenCV_ThresholdBinaryInvGrayscale",
  "body": [
   "$$newImage=OpenCV_ThresholdBinaryInvGrayscale($$Image,$$Threshold,$$Maximum);"
  ],
  "description": "\n\nThis function takes an OpenCV image and performs an inverse binary gray-scale threshold and returns the resultant gray-scale image.\n\n\n\n\n\nAny pixel values exceeding the threshold value are set to 0, otherwise they are set to the maximum value passed into the function. This is useful for removing noise and other artifacts from an image before analyzing it.\n\n\n\n\n\nRequirements:\n\nThese functions use the Open-Source OpenCV computer vision library from Intel, and therefore will offer the maximum performance when running on Intel Processors due to low-level optimizations for the Intel architecture. Any camera or input device that Windows recognizes as an imaging device should be compatible with these functions.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Image\n\nObject\n\nAn OpenCV Image Structure that has been loaded from an existing file or camera capture.\n\n\n\n$Threshold\n\nFloat\n\nThe pixel threshold value\n\n\n\n$Maximum\n\nFloat\n\nThe maximum pixel value\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$newImage\n\nObject\n\nAn OpenCV Image Grayscale Structure which can be used with the other OpenCV functions in this library.\n\n\n\n\n\nUsage Example:\n\n$newImage= OpenCV_ThresholdBinaryInvGrayscale($Image,80,255);\n\n\n\n\n\nOpenCV_ThresholdToZeroColor\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OpenCV_ThresholdToZeroColor": {
  "prefix": "OpenCV_ThresholdToZeroColor",
  "body": [
   "$$newImage=OpenCV_ThresholdToZeroColor($$Image,$$ThreshR,$$ThreshG,$$ThreshB);"
  ],
  "description": "\n\nThis function takes an OpenCV image and performs a threshold to zero and returns the resultant image.\n\n\n\n\n\nAny pixel values less than the threshold values passed into the function are set to 0, otherwise they are set to the corresponding pixel value of the image passed into the function. This is useful for removing noise and other artifacts from an image before analyzing it.\n\n\n\n\n\nRequirements:\n\nThese functions use the Open-Source OpenCV computer vision library from Intel, and therefore will offer the maximum performance when running on Intel Processors due to low-level optimizations for the Intel architecture. Any camera or input device that Windows recognizes as an imaging device should be compatible with these functions.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Image\n\nObject\n\nAn OpenCV Image Structure that has been loaded from an existing file or camera capture.\n\n\n\n$ThreshR\n\nFloat\n\nThe Red Value of the pixel threshold.\n\n\n\n$ThreshG\n\nFloat\n\nThe Green Value of the pixel threshold.\n\n\n\n$ThreshB\n\nFloat\n\nThe Blue Value of the pixel threshold.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$newImage\n\nObject\n\nAn OpenCV Image Structure which can be used with the other OpenCV functions in this library.\n\n\n\n\n\nUsage Example:\n\n$newImage= OpenCV_ThresholdToZeroColor($Image,80,80,80);\n\n\n\n\n\nOpenCV_ThresholdToZeroColorHSV\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OpenCV_ThresholdToZeroColorHSV": {
  "prefix": "OpenCV_ThresholdToZeroColorHSV",
  "body": [
   "$$newImage=OpenCV_ThresholdToZeroColorHSV($$Image,$$ThreshH,$$ThreshS,$$ThreshV);"
  ],
  "description": "\n\nThis function takes an OpenCV image and performs a threshold to zero and returns the resultant image. This function operates in the Hue, Saturation, and Value color space.\n\n\n\n\n\nAny pixel values less than the threshold values passed into the function are set to 0, otherwise they are set to the corresponding pixel value of the image passed into the function. This is useful for removing noise and other artifacts from an image before analyzing it.\n\n\n\n\n\nRequirements:\n\nThese functions use the Open-Source OpenCV computer vision library from Intel, and therefore will offer the maximum performance when running on Intel Processors due to low-level optimizations for the Intel architecture. Any camera or input device that Windows recognizes as an imaging device should be compatible with these functions.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Image\n\nObject\n\nAn OpenCV Image Structure that has been loaded from an existing file or camera capture.\n\n\n\n$ThreshH\n\nFloat\n\nThe Hue Value of the pixel threshold. (Values 0 to 360)\n\n\n\n$ThreshS\n\nFloat\n\nThe Saturation Value of the pixel threshold. (Values 0 to 100)\n\n\n\n$ThreshV\n\nFloat\n\nThe ' Value' Value of the pixel threshold. (Values 0 to 100)\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$newImage\n\nObject\n\nAn OpenCV Image Structure which can be used with the other OpenCV functions in this library.\n\n\n\n\n\nUsage Example:\n\n$newImage= OpenCV_ThresholdToZeroColorHSV($Image,120,50,50);\n\n\n\n\n\nOpenCV_ThresholdToZeroGrayscale\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OpenCV_ThresholdToZeroGrayscale": {
  "prefix": "OpenCV_ThresholdToZeroGrayscale",
  "body": [
   "$$newImage=OpenCV_ThresholdToZeroGrayscale($$Image,$$Threshold);"
  ],
  "description": "\n\nThis function takes an OpenCV image and performs a gray-scale threshold to zero and returns the resultant gray-scale image.\n\n\n\n\n\nAny pixel values less than the threshold values passed into the function are set to 0, otherwise they are set to the corresponding pixel value of the image passed into the function. This is useful for removing noise and other artifacts from an image before analyzing it.\n\n\n\n\n\nRequirements:\n\nThese functions use the Open-Source OpenCV computer vision library from Intel, and therefore will offer the maximum performance when running on Intel Processors due to low-level optimizations for the Intel architecture. Any camera or input device that Windows recognizes as an imaging device should be compatible with these functions.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Image\n\nObject\n\nAn OpenCV Image Structure that has been loaded from an existing file or camera capture.\n\n\n\n$Threshold\n\nFloat\n\nThe pixel threshold value\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$newImage\n\nObject\n\nAn OpenCV Image Grayscale Structure which can be used with the other OpenCV functions in this library.\n\n\n\n\n\nUsage Example:\n\n$newImage= OpenCV_ThresholdToZeroGrayscale($Image,80);\n\n\n\n\n\nOpenCV_ThresholdToZeroInvColor\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OpenCV_ThresholdToZeroInvColor": {
  "prefix": "OpenCV_ThresholdToZeroInvColor",
  "body": [
   "$$newImage=OpenCV_ThresholdToZeroInvColor($$Image,$$ThreshR,$$ThreshG,$$ThreshB);"
  ],
  "description": "\n\nThis function takes an OpenCV image and performs an inverse threshold to zero and returns the resultant image.\n\n\n\n\n\nAny pixel values exceeding the threshold value are set to 0, otherwise they are set to the corresponding pixel value of the image passed into the function. This is useful for removing noise and other artifacts from an image before analyzing it.\n\n\n\n\n\nRequirements:\n\nThese functions use the Open-Source OpenCV computer vision library from Intel, and therefore will offer the maximum performance when running on Intel Processors due to low-level optimizations for the Intel architecture. Any camera or input device that Windows recognizes as an imaging device should be compatible with these functions.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Image\n\nObject\n\nAn OpenCV Image Structure that has been loaded from an existing file or camera capture.\n\n\n\n$ThreshR\n\nFloat\n\nThe Red Value of the pixel threshold.\n\n\n\n$ThreshG\n\nFloat\n\nThe Green Value of the pixel threshold.\n\n\n\n$ThreshB\n\nFloat\n\nThe Blue Value of the pixel threshold.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$newImage\n\nObject\n\nAn OpenCV Image Structure which can be used with the other OpenCV functions in this library.\n\n\n\n\n\nUsage Example:\n\n$newImage= OpenCV_ThresholdToZeroInvColor($Image,80,80,80);\n\n\n\n\n\nOpenCV_ThresholdToZeroInvColorHSV\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OpenCV_ThresholdToZeroInvColorHSV": {
  "prefix": "OpenCV_ThresholdToZeroInvColorHSV",
  "body": [
   "$$newImage=OpenCV_ThresholdToZeroInvColorHSV($$Image,$$ThreshH,$$ThreshS,$$ThreshV);"
  ],
  "description": "\n\nThis function takes an OpenCV image and performs an inverse threshold to zero and returns the resultant image. This function operates in the Hue, Saturation, and Value color space.\n\n\n\n\n\nAny pixel values exceeding the threshold value are set to 0, otherwise they are set to the corresponding pixel value of the image passed into the function. This is useful for removing noise and other artifacts from an image before analyzing it.\n\n\n\n\n\nRequirements:\n\nThese functions use the Open-Source OpenCV computer vision library from Intel, and therefore will offer the maximum performance when running on Intel Processors due to low-level optimizations for the Intel architecture. Any camera or input device that Windows recognizes as an imaging device should be compatible with these functions.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Image\n\nObject\n\nAn OpenCV Image Structure that has been loaded from an existing file or camera capture.\n\n\n\n$ThreshH\n\nFloat\n\nThe Hue threshold value (Values between 0 and 360)\n\n\n\n$ThreshS\n\nFloat\n\nThe Saturation threshold value (Values between 0 and 100)\n\n\n\n$ThreshV\n\nFloat\n\nThe Value threshold value (Values between 0 and 100)\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$newImage\n\nObject\n\nAn OpenCV Image Structure which can be used with the other OpenCV functions in this library.\n\n\n\n\n\nUsage Example:\n\n$newImage= OpenCV_ThresholdToZeroInvColorHSV($Image,180,255,255);\n\n\n\n\n\nOpenCV_ThresholdToZeroInvGrayscale\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OpenCV_ThresholdToZeroInvGrayscale": {
  "prefix": "OpenCV_ThresholdToZeroInvGrayscale",
  "body": [
   "$$newImage=OpenCV_ThresholdToZeroInvGrayscale($$Image,$$Threshold);"
  ],
  "description": "\n\nThis function takes an OpenCV image and performs a gray-scale threshold to zero and returns the resultant gray-scale image.\n\n\n\n\n\nAny pixel values exceeding the threshold value are set to 0, otherwise they are set to the corresponding pixel value of the image passed into the function. This is useful for removing noise and other artifacts from an image before analyzing it.\n\n\n\n\n\nRequirements:\n\nThese functions use the Open-Source OpenCV computer vision library from Intel, and therefore will offer the maximum performance when running on Intel Processors due to low-level optimizations for the Intel architecture. Any camera or input device that Windows recognizes as an imaging device should be compatible with these functions.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Image\n\nObject\n\nAn OpenCV Image Structure that has been loaded from an existing file or camera capture.\n\n\n\n$Threshold\n\nFloat\n\nThe pixel threshold value\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$newImage\n\nObject\n\nAn OpenCV Image Grayscale Structure which can be used with the other OpenCV functions in this library.\n\n\n\n\n\nUsage Example:\n\n$newImage= OpenCV_ThresholdToZeroInvGrayscale($Image,80);\n\n\n\n\n\nOpenCV_ThresholdTruncateColor\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OpenCV_ThresholdTruncateColor": {
  "prefix": "OpenCV_ThresholdTruncateColor",
  "body": [
   "$$newImage=OpenCV_ThresholdTruncateColor($$Image,$$ThreshR,$$ThreshG,$$ThreshB);"
  ],
  "description": "\n\nThis function takes an OpenCV image and performs a threshold truncate and returns the resultant image.\n\n\n\n\n\nAny pixel values exceeding the threshold value are set to the threshold values passed into the function otherwise they are set to the corresponding pixel value of the image passed into the function. This is useful for removing noise and other artifacts from an image before analyzing it.\n\n\n\n\n\nRequirements:\n\nThese functions use the Open-Source OpenCV computer vision library from Intel, and therefore will offer the maximum performance when running on Intel Processors due to low-level optimizations for the Intel architecture. Any camera or input device that Windows recognizes as an imaging device should be compatible with these functions.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Image\n\nObject\n\nAn OpenCV Image Structure that has been loaded from an existing file or camera capture.\n\n\n\n$ThreshR\n\nFloat\n\nThe Red Value of the pixel threshold.\n\n\n\n$ThreshG\n\nFloat\n\nThe Green Value of the pixel threshold.\n\n\n\n$ThreshB\n\nFloat\n\nThe Blue Value of the pixel threshold.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$newImage\n\nObject\n\nAn OpenCV Image Structure which can be used with the other OpenCV functions in this library.\n\n\n\n\n\nUsage Example:\n\n$newImage= OpenCV_ThresholdTruncateColor($Image,80,80,80);\n\n\n\n\n\nOpenCV_ThresholdTruncateGrayscale\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OpenCV_ThresholdTruncateGrayscale": {
  "prefix": "OpenCV_ThresholdTruncateGrayscale",
  "body": [
   "$$newImage=OpenCV_ThresholdTruncateGrayscale($$Image,$$Threshold);"
  ],
  "description": "\n\nThis function takes an OpenCV image and performs a gray-scale threshold truncate and returns the resultant gray-scale image.\n\n\n\n\n\nAny pixel values exceeding the threshold value are set to the threshold value passed into the function otherwise they are set to the corresponding pixel value of the image passed into the function. This is useful for removing noise and other artifacts from an image before analyzing it.\n\n\n\n\n\nRequirements:\n\nThese functions use the Open-Source OpenCV computer vision library from Intel, and therefore will offer the maximum performance when running on Intel Processors due to low-level optimizations for the Intel architecture. Any camera or input device that Windows recognizes as an imaging device should be compatible with these functions.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Image\n\nObject\n\nAn OpenCV Image Structure that has been loaded from an existing file or camera capture.\n\n\n\n$Threshold\n\nFloat\n\nThe pixel threshold value\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$newImage\n\nObject\n\nAn OpenCV Image Grayscale Structure which can be used with the other OpenCV functions in this library.\n\n\n\n\n\nUsage Example:\n\n$newImage= OpenCV_ThresholdTruncateGrayscale($Image,80);\n\n\n\n\n\nOpenCV_ZeroSaturatedColorImagePixels\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OpenCV_ZeroSaturatedColorImagePixels": {
  "prefix": "OpenCV_ZeroSaturatedColorImagePixels",
  "body": [
   "($$newImage,$$pixelCount)=OpenCV_ZeroSaturatedColorImagePixels($$Image,$$Threshold,$$UpperX,$$UpperY,$$Width,$$Height);"
  ],
  "description": "\n\nThis function takes an OpenCV image, the upper left coordinates & width and height of the region of interest. This function will check each red, green and blue pixel value in the region of interest and if all three values are greater than or equal to the threshold value, the pixel will be set to black. The resultant image is returned along with the the number of pixels that were changed.\n\nNote: If the requested region of interest is outside of the maximum bounds of the image, the function will automatically return a failing test result.\n\n\n\n\n\nRequirements:\n\nThese functions use the Open-Source OpenCV computer vision library from Intel, and therefore will offer the maximum performance when running on Intel Processors due to low-level optimizations for the Intel architecture. Any camera or input device that Windows recognizes as an imaging device should be compatible with these functions.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Image\n\nObject\n\nAn OpenCV Image Structure that has been loaded from an existing file or camera capture.\n\n\n\n$Threshold\n\nDouble\n\nPixel threshold value\n\n\n\n$UpperX\n\nInteger\n\nUpper left X coordinate of the ROI\n\n\n\n$UpperY\n\nInteger\n\nUpper left Y coordinate of the ROI\n\n\n\n$Width\n\nInteger\n\nROI Width (Pixels)\n\n\n\n$Height\n\nInteger\n\nROI Height (Pixels)\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$newImage\n\nObject\n\nAn OpenCV Image Structure.\n\n\n\n$pixelCount\n\nInteger\n\nAmount of pixels that have been changed to black.\n\n\n\n\n\nUsage Example:\n\n($newImage, $pixelCount) = OpenCV_ZeroSaturatedColorImagePixels($Image,245, 20,20,100,100);\n\n\n\n\n\nAbs\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Abs": {
  "prefix": "Abs",
  "body": [
   "$$value=Abs($$number);"
  ],
  "description": "\n\nThis function returns the absolute value of the number supplied. The number must be an integer, float, or string representing a numeric value.\n\nResult:\n\n$value = $number or -$number Function Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$number\n\nFloat, Integer, String\n\nThe number.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$value\n\nfloat\n\nThe resulting value is returned as a float data-type regardless of the input data-types\n\n\n\n\n\nAdd\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Add": {
  "prefix": "Add",
  "body": [
   "$$value=Add($$number1,$$number2);"
  ],
  "description": "\n\nThis function returns the result of a numeric ADD operation on the two numbers supplied. The two numbers must be integers, floats, or strings representing a numeric value.\n\nResult:\n\n$value = $number1 + $number2 Function Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$number1\n\nFloat, Integer, String\n\nThe first number.\n\n\n\n$number2\n\nFloat, Integer, String\n\nThe second number\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$value\n\nfloat\n\nThe resulting value is returned as a float data-type regardless of the input data-types\n\n\n\n\n\nAddToCRC\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AddToCRC": {
  "prefix": "AddToCRC",
  "body": [
   "$$NewCRC=AddToCRC($$CurrentCRC,$$value,$$Method);"
  ],
  "description": "\n\nThis function adds the value to the current CRC using the specified method and returns the updated CRC. The only the lower 8 bits of the value are used. Only the CRC-CCITT (0x1021) And ANSI-CRC16 (X16 + X12 + X5 + 1) methods are supported at this time with the result returned in the lower 16 bits return value.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$CurrentCRC\n\nInteger\n\nCurrent CRC\n\n\n\n$value\n\nInteger\n\nNew value to add to CRC\n\n\n\n$Method\n\nString\n\nCRC method to use. Only the CRC-CCITT and ANSI-CRC16 methods are support at this time.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NewCRC\n\nInteger\n\nUpdate CRC\n\n\n\n\n\nArcTangent\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ArcTangent": {
  "prefix": "ArcTangent",
  "body": [
   "$$value=ArcTangent($$number);"
  ],
  "description": "\n\nThis function returns the angle whose tangent is supplied for the argument of the function. This function is essentially the inverse of the tangent function.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$number\n\nFloat, Integer, String\n\nThe value of of the tangent of a particular angle.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$value\n\nfloat\n\nThe angle in radians of the triangle whose tangent matches the supplied function argument.\n\nThe resulting value is returned as a float data-type regardless of the input data-types\n\n\n\n\n\nBitWiseAnd\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS BitWiseAnd": {
  "prefix": "BitWiseAnd",
  "body": [
   "$$value=BitWiseAnd($$number1,$$number2);"
  ],
  "description": "\n\nThis function returns the result of a bit-wise AND operation on the two numbers supplied. The two numbers must be strings representing valid hexidecimal values, otherwise a failure is generated by this test step.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$number1\n\nString\n\nThe first string representing a hexidecimal number. (Example: \"55AF11\")\n\n\n\n$number2\n\nString\n\nThe second string representing a hexidecimal number. (Example: \"A0\")\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$value\n\nString\n\nThe string representing the hexidecimal number resulting from the bit-wise operation.\n\n\n\n\n\nBitWiseNot\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS BitWiseNot": {
  "prefix": "BitWiseNot",
  "body": [
   "$$value=BitWiseNot($$number1);"
  ],
  "description": "\n\nThis function returns the result of a bit-wise NOT operation on the number supplied. The number must be a string representing a valid hexidecimal value, otherwise a failure is generated by this test step.\n\nExample:\n\n$value = BitWiseNot(\"1\");\n\n$value will be \"FFFFFFFE\".\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$number1\n\nString\n\nThe first string representing a hexidecimal number.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$value\n\nString\n\nThe string representing the hexidecimal number resulting from the bit-wise NOT operation.\n\n\n\n\n\nBitWiseOr\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS BitWiseOr": {
  "prefix": "BitWiseOr",
  "body": [
   "$$value=BitWiseOr($$number1,$$number2);"
  ],
  "description": "\n\nThis function returns the result of a bit-wise OR operation on the two numbers supplied. The two numbers must be strings representing valid hexidecimal values, otherwise a failure is generated by this test step.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$number1\n\nString\n\nThe first string representing a hexidecimal number. (Example: \"55AF11\")\n\n\n\n$number2\n\nString\n\nThe second string representing a hexidecimal number. (Example: \"A0\")\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$value\n\nString\n\nThe string representing the hexidecimal number resulting from the bit-wise operation.\n\n\n\n\n\nBitWiseShift\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS BitWiseShift": {
  "prefix": "BitWiseShift",
  "body": [
   "$$value=BitWiseShift($$number1,$$number2,$$direction);"
  ],
  "description": "\n\nThis function returns the result of a bit-wise SHIFT operation on the number supplied. The number must be a string representing a valid hexidecimal value, otherwise a failure is generated by this test step.\n\nExample:\n\n$value = BitWiseShift(\"1\",\"1\",\"<<\");\n\n$value will be \"2\".\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$number1\n\nString\n\nA string representing a hexidecimal number. (Example: \"55AF11\")\n\n\n\n$number2\n\nString\n\nA string representing the shift count in hexidecimal.\n\n\n\n$direction\n\nString\n\nThe shift direction. Valid strings are:\n\n\u00b7 \"<<\": Shift Left\n\n\u00b7 \">>\": Shift Right\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$value\n\nString\n\nThe string representing the hexidecimal number resulting from the bit-wise SHIFT operation.\n\n\n\n\n\nBitWiseXor\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS BitWiseXor": {
  "prefix": "BitWiseXor",
  "body": [
   "$$value=BitWiseXor($$number1,$$number2);"
  ],
  "description": "\n\nThis function returns the result of a bit-wise XOR operation on the two numbers supplied. The two numbers must be strings representing valid hexidecimal values, otherwise a failure is generated by this test step.\n\nExample:\n\n$value = BitWiseXor(\"5A\",\"AA\");\n\n$value will be \"'F0\".\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$number1\n\nString\n\nThe first string representing a hexidecimal number.\n\n\n\n$number2\n\nString\n\nThe second string representing a hexidecimal number.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$value\n\nString\n\nThe string representing the hexidecimal number resulting from the bit-wise XOR operation.\n\n\n\n\n\nCalculateLinearRegressionOfArray\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS CalculateLinearRegressionOfArray": {
  "prefix": "CalculateLinearRegressionOfArray",
  "body": [
   "($$Slope,$$YIntercept,$$R,$$RSquared)=CalculateLinearRegressionOfArray($$InputArray,$$StartIndex,$$EndIndex,$$DisplayCalculation);"
  ],
  "description": "\n\nThis function calculates a \"best-fit\" line of an array of sampled data using linear regression. This function can be used for finding the slope, y-intercept, R and R Squared values of an array of sampled data.\n\n\n\n\n\nThe supplied input array should be a two dimensional array of either integer or floating point values where the first dimension contains the X values of the sampled data, and the second dimension contains the Y values of the sampled data.\n\n\n\n\n\nThe Slope and Y Intercept data returned from the function can be used to determine the best fit line for the portion of data for which the regression was peformed i.e. (Y=mx + B)\n\n\n\n\n\nThe R and R Squared parameters are used evaluate the total amount of deviation of each sample from the ideal best fit line. (For a more detailed explanation, do a search for linear regression or 'Best Fit' regression)\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InputArray\n\nArray\n\nAn array of either integers or floating point values containing the X and Y coordinates.\n\n\n\n$StartIndex\n\nInteger\n\nThe starting point in the index to begin calculating the linear regression. This parameter is useful if you are only interested in computing a linear regression of a portion of the data contained in the input array.\n\n\n\n$EndIndex\n\nInteger\n\nThe ending point in the array index to stop calculating the linear regression. This parameter is useful if you are only interested in compuing a linear regression of a portion of the data contained in the input array.\n\n\n\n$DisplayCalculation\n\nBoolean\n\nIf this value is set to true, the function will display a pop up window showing a graph of the supplied data along with a chart showing the linear regression. This is useful for debugging test scripts during the development phase.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Slope\n\nInteger\n\nThe integer value of the binary string\n\n\n\n$Y-Intercept\n\nDouble\n\nThe point at which the sampled data's best fit line would intersect the X axis\n\n\n\n$R\n\nDouble\n\nThe sum of the total deviation of each sample point from the best fit line.\n\n\n\n$RSquared\n\nDouble\n\nThe square of the sum of the total deviation of each sample point from the best fit line.\n\n\n\n\n\nExample:\n\n\n\n\n\n($Slope,$YIntercept,$R,$RSquared) = CalculateLinearRegressionOfArray($MeasureArray,100,500);\n\n\n\n\n\nCeiling\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Ceiling": {
  "prefix": "Ceiling",
  "body": [
   "$$value=Ceiling($$number);"
  ],
  "description": "\n\nThis function rounds a floating point number to the next integer of equal or higher value. (Rounds Up)\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$number\n\nFloat, Integer, String\n\nThe number.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$value\n\nfloat\n\nThe resulting value is returned as a float data-type regardless of the input data-types\n\n\n\n\n\nConvertPolarToRectangularCoordinate\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ConvertPolarToRectangularCoordinate": {
  "prefix": "ConvertPolarToRectangularCoordinate",
  "body": [
   "($$X,$$Y)=ConvertPolarToRectangularCoordinate($$Theta,$$R);"
  ],
  "description": "\n\nThis function converts a standard polar coordinate consisting of a value of theta specified in radians, and a radius length which is unitless. The function returns the X,Y equivalent cartesian coordinates.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Theta\n\nFloat\n\nAn angle measured in radians of the polar coordinate\n\n\n\n$R\n\nFloat\n\nThe radius of the moment arm of the polar coordinate\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$X\n\nFloat\n\nThe equivalent X value coordinate\n\n\n\n$Y\n\nFloat\n\nThe equivalent Y value coordinate\n\n\n\n\n\nExample:\n\n\n\n\n\n($X,$Y) = ConvertPolarToRectangularCoordinate(3.14159,1);\n\n\n\n\n\nConvertRectangulartoPolarCoordinate\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ConvertRectangularToPolarCoordinate": {
  "prefix": "ConvertRectangularToPolarCoordinate",
  "body": [
   "($$Theta,$$R)=ConvertRectangularToPolarCoordinate($$X,$$Y);"
  ],
  "description": "\n\nThis function converts a standard cartesian coordinate consisting of a unitless X and Y value and returns the equivalent polar coordinate specified by the angle \"theta\" returned in radians, and a unitless R radius.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$X\n\nFloat\n\nX Value Coordinate\n\n\n\n$Y\n\nFloat\n\nY Value Coordinate\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Theta\n\nFloat\n\nAn angle measured in radians\n\n\n\n$R\n\nFloat\n\nThe moment arm radius length of the polar coordinate\n\n\n\n\n\nExample:\n\n\n\n\n\n($Theta,$R) = ConvertRectangularToPolarCoordinate(0,1);\n\n\n\n\n\nCosine\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Cosine": {
  "prefix": "Cosine",
  "body": [
   "$$value=Cosine($$number);"
  ],
  "description": "\n\nThis function returns the Cosine of the angle value specified in Radians.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$number\n\nFloat, Integer, String\n\nThe value of the angle in radians.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$value\n\nfloat\n\nThe resulting value is returned as a float data-type regardless of the input data-types\n\n\n\n\n\nDivide\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Divide": {
  "prefix": "Divide",
  "body": [
   "$$value=Divide($$number1,$$number2);"
  ],
  "description": "\n\nThis function returns the result of a numeric Divide operation on the two numbers supplied. The two numbers must be integers, floats, or strings representing a numeric value.\n\nResult:\n\n$value = $number1 / $number2\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$number1\n\nFloat, Integer, String\n\nThe first number.\n\n\n\n$number2\n\nFloat, Integer, String\n\nThe second number\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$value\n\nFloat\n\nThe resulting value is returned as a float data-type regardless of the input data-types\n\n\n\n\n\nFloor\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Floor": {
  "prefix": "Floor",
  "body": [
   "$$value=Floor($$number);"
  ],
  "description": "\n\nThis function rounds a floating point number to the next integer of equal or lower value. (Rounds Down)\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$number\n\nFloat, Integer, String\n\nThe number.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$value\n\nfloat\n\nThe resulting value is returned as a float data-type regardless of the input data-types\n\n\n\n\n\nGetRandomInteger\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS GetRandomInteger": {
  "prefix": "GetRandomInteger",
  "body": [
   "$$value=GetRandomInteger($$lowerBound,$$upperBound);"
  ],
  "description": "\n\nThis function returns an integer between the two numbers. It's random seed is supplied by the number of system ticks currently elapsed.\n\n\n\n\n\nNote: The $lowerBound is included in the possible numbers, but the $upperBound is not.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$lowerBound\n\nInteger\n\nThe lower limit of the random number to be returned (inclusive).\n\n\n\n$upperBound\n\nInteger\n\nThe upper limit of the random number to be returned (non-inclusive).\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$value\n\nInteger\n\nThe random number returned by this function.\n\n\n\n\n\nExample:\n\n\n\n\n\n// Select a number from 1 to 10 (note upper bound not included so we must supply 11).\n\n$lowerBound = 1;\n\n$upperBound = 11;\n\n\n\n\n\n$value = GetRandomInteger($lowerBound, $upperBound);\n\n\n\n\n\n$outStr = \"Random Number: \" + $value;\n\nUpdateStatus($outStr);\n\n\n\n\n\nHyperbolicCosine\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS HyperbolicCosine": {
  "prefix": "HyperbolicCosine",
  "body": [
   "$$value=HyperbolicCosine($$number);"
  ],
  "description": "\n\nThis function returns the Hyperbolic Cosine of the angle value specified in Radians.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$number\n\nFloat, Integer, String\n\nThe value of the angle in radians.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$value\n\nfloat\n\nThe resulting value is returned as a float data-type regardless of the input data-types\n\n\n\n\n\nHyperbolicSine\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS HyperbolicSine": {
  "prefix": "HyperbolicSine",
  "body": [
   "$$value=HyperbolicSine($$number);"
  ],
  "description": "\n\nThis function returns the Hyperbolic Sine of the angle value specified in Radians.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$number\n\nFloat, Integer, String\n\nThe value of the angle in radians.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$value\n\nfloat\n\nThe resulting value is returned as a float data-type regardless of the input data-types\n\n\n\n\n\nLog\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Log": {
  "prefix": "Log",
  "body": [
   "$$value=Log($$number);"
  ],
  "description": "\n\nThis function returns the base 10 Logarithm of the supplied value.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$number\n\nFloat, Integer, String\n\nThe value supplied to the log function.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$value\n\nfloat\n\nThe resulting value is returned as a float data-type regardless of the input data-types\n\n\n\n\n\nLogSpecifyBase\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS LogSpecifyBase": {
  "prefix": "LogSpecifyBase",
  "body": [
   "$$value=LogSpecifyBase($$number,$$base);"
  ],
  "description": "\n\nThis function returns the result of a logarithm function computed to a specific base.\n\nThe most common use of this function is to compute a natural log in which the base value of 2.718281828 should be used. Function Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$number\n\nFloat, Integer, String\n\nThe value supplied to the log function.\n\n\n\n$base\n\nFloat,Integer\n\nThe desired base for the logarithm computation\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$value\n\nfloat\n\nThe resulting value is returned as a float data-type regardless of the input data-types\n\n\n\n\n\nExample:\n\n$Value = LogSpecifyBase(10, 2.718281828); // Computes Ln(1)\n\n\n\n\n\nLogical_AND\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Logical_AND": {
  "prefix": "Logical_AND",
  "body": [
   "$$value=Logical_AND($$value1,$$value2);"
  ],
  "description": "\n\nThis function performs a logical AND operation on two boolean script variables and returns the result. In the event that one of the supplied arguments can not be cast as a boolean, a failure is returned to the executive.\n\nResult:\n\n$value = $value1 && $value2\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$value1\n\nBoolean\n\nThe first boolean argument.\n\n\n\n$value2\n\nBoolean\n\nThe second boolean argument.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$value\n\nBoolean\n\nThe result of the logical AND operation on the two supplied boolean arguments.\n\n\n\n\n\nLogical_OR\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Logical_OR": {
  "prefix": "Logical_OR",
  "body": [
   "$$value=Logical_OR($$value1,$$value2);"
  ],
  "description": "\n\nThis function performs a logical OR operation on two boolean script variables and returns the result. In the event that one of the supplied arguments can not be cast as a boolean, a failure is returned to the executive.\n\nResult:\n\n$value = $value1 || $value2\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$value1\n\nBoolean\n\nThe first boolean argument.\n\n\n\n$value2\n\nBoolean\n\nThe second boolean argument.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$value\n\nBoolean\n\nThe result of the logical OR operation on the two supplied boolean arguments.\n\n\n\n\n\nMod\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Mod": {
  "prefix": "Mod",
  "body": [
   "$$value=Mod($$number1,$$number2);"
  ],
  "description": "\n\nThis function returns the result of a numeric MOD operation on the two numbers supplied. The two numbers must be integers, floats, or strings representing a numeric value.\n\nResult:\n\n$value = $number1 % $number2\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$number1\n\nFloat, Integer, String\n\nThe first number.\n\n\n\n$number2\n\nFloat, Integer, String\n\nThe second number\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$value\n\nFloat\n\nThe resulting value is returned as a float data-type regardless of the input data-types\n\n\n\n\n\nMultiply\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Multiply": {
  "prefix": "Multiply",
  "body": [
   "$$value=Multiply($$number1,$$number2);"
  ],
  "description": "\n\nThis function returns the result of a numeric MULTIPLY operation on the two numbers supplied. The two numbers must be integers, floats, or strings representing a numeric value.\n\nResult:\n\n$value = $number1 "
 }
,
 "JTS NaturalLog": {
  "prefix": "NaturalLog",
  "body": [
   "$$value=NaturalLog($$number);"
  ],
  "description": "\n\nThis function returns the natural logarithm of the supplied number.\n\n\n\nNOTE:\n\nThe natural logarithm refers to a base of the number 'e'.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$number\n\nFloat, Integer, String\n\nThe number to find the natural logarithm of.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$value\n\nFloat\n\nThe natural logarithm of the number, returned as a floating point value.\n\n\n\n\n\nExample:\n\n// Connect to the instrument.\n\n$number = 10;\n\n$value = NaturalLog($number);\n\n\n\n\n\nPower\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Power": {
  "prefix": "Power",
  "body": [
   "$$value=Power($$number,$$exponent);"
  ],
  "description": "\n\nThis function returns the result of $number raised to the power of $exponent.\n\n\n\nRemarks:\n\nThe returned value is always of type Float, regardless of the input types.\n\nThis function can also be used to find the roots of functions by inverting the $exponent number. For example to find the cube root of a number, use an exponent of 1/3.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$number\n\nFloat, Integer\n\nThe number to use as the base.\n\n\n\n$exponent\n\nFloat, Integer\n\nThe number to use as the exponent.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$value\n\nFloat\n\nThe result of raising $number to the power of $exponent.\n\n\n\n\n\nExample:\n\n// Get 2 raised to the power of 10.\n\n$number = 2;\n\n$expon = 10;\n\n$value = Power($number, $expon);\n\n\n\n\n\n// Get the cube root of 27.\n\n$number = 27;\n\n$expon = 1 / 3;\n\n$cubeRoot = Power($number, $expon);\n\n\n\n\n\nRound\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Round": {
  "prefix": "Round",
  "body": [
   "$$value=Round($$number,$$NumberOfDigits);"
  ],
  "description": "\n\nThis function rounds a floating point number to the specified number of digits after the decimal place.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$number\n\nFloat, Integer, String\n\nThe number.\n\n\n\n$NumberOfDigits\n\nInteger\n\nThe number of digits after the decimal place.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$value\n\nfloat\n\nThe resulting value is returned as a float data-type regardless of the input data-types\n\n\n\n\n\nSine\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Sine": {
  "prefix": "Sine",
  "body": [
   "$$value=Sine($$number);"
  ],
  "description": "\n\nThis function returns the Sine of the angle value specified in Radians.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$number\n\nFloat, Integer, String\n\nThe value of the angle in radians.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$value\n\nfloat\n\nThe resulting value is returned as a float data-type regardless of the input data-types\n\n\n\n\n\nSquareRoot\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SquareRoot": {
  "prefix": "SquareRoot",
  "body": [
   "$$value=SquareRoot($$number1);"
  ],
  "description": "\n\nThis function returns the square root of the supplied number.\n\n\n\nRemarks:\n\nThe returned data type is always Float, regardless of the input data type.\n\nThe same data can be achieved using the Power function and a power of 1/2.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$number1\n\nFloat, Integer\n\nThe number to find the square root of.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$value\n\nFloat\n\nThe square root of the input number.\n\n\n\n\n\nExample:\n\n// Get the square root of 81.\n\n$number = 81;\n\n$sqrt = SquareRoot($number);\n\n\n\n\n\nSubtract\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Subtract": {
  "prefix": "Subtract",
  "body": [
   "$$value=Subtract($$number1,$$number2);"
  ],
  "description": "\n\nThis function returns the result of a numeric SUBTRACT operation on the two numbers supplied. The two numbers must be integers, floats, or strings representing a numeric value.\n\nResult:\n\n$value = $number1 - $number2\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$number1\n\nFloat, Integer, String\n\nThe first number.\n\n\n\n$number2\n\nFloat, Integer, String\n\nThe second number\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$value\n\nFloat\n\nThe resulting value is returned as a float data-type regardless of the input data-types\n\n\n\n\n\nTangent\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Tangent": {
  "prefix": "Tangent",
  "body": [
   "$$value=Tangent($$number);"
  ],
  "description": "\n\nThis function returns the Tangent of the angle value specified in Radians.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$number\n\nFloat, Integer, String\n\nThe value of the angle in radians.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$value\n\nfloat\n\nThe resulting value is returned as a float data-type regardless of the input data-types\n\n\n\n\n\nRecordMeasurement\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS RecordMeasurement": {
  "prefix": "RecordMeasurement",
  "body": [
   "RecordMeasurement($$measurementName,$$measurement,$$measurementUnit,$$parametricMeasurement);"
  ],
  "description": "\n\nThis function will record a measurement that will be included in any report writer.\n\n\n\n\n\nRemarks:\n\nWhether any of the data here is included in a report is a function of the report writer. For example, the HTML report writer will output the Test Name (set with the SetTestName function), but does not include the Measurement Name, even though it includes the measurement data.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$measurementName\n\nString\n\nThe name of the measurement to be recorded.\n\n\n\n$measurement\n\nString,\n\nInteger, or\n\nFloat\n\nThe measurement data to be recorded.\n\n\n\n$measurmentUnit\n\nString\n\nThe unit associated with the measurement.\n\n\n\n$parametricMeasurement\n\nBoolean\n\nIf True, the measurement can be used for parametric data analysis.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n// Record a voltage measurement\n\n$measName = \"Input_Voltage\";\n\n$measUnit = \"Volts\";\n\n$parametric = true;\n\n\n\n\n\nRecordMeasurement($measName, $measurement, $measUnit, $parametric);\n\n\n\n\n\nRecordMeasurementPassFail\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS RecordMeasurementPassFail": {
  "prefix": "RecordMeasurementPassFail",
  "body": [
   "RecordMeasurementPassFail($$measurementName,$$measurement,$$measurementUnit,$$parametricMeasurement,$$passFail);"
  ],
  "description": "\n\nThis function will record a measurement that will be included in any report writer and includes a parameter to Pass or Fail this particular test.\n\n\n\n\n\nRemarks:\n\nWhether any of the data here is included in a report is a function of the report writer. For example, the HTML report writer will output the Test Name (set with the SetTestName function), but does not include the Measurement Name, even though it includes the measurement data.\n\nSetting $passFail to false will cause the test to fail and stop the test script.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$measurementName\n\nString\n\nThe name of the measurement to be recorded.\n\n\n\n$measurement\n\nString,\n\nInteger, or\n\nFloat\n\nThe measurement data to be recorded.\n\n\n\n$measurmentUnit\n\nString\n\nThe unit associated with the measurement.\n\n\n\n$parametricMeasurement\n\nBoolean\n\nIf True, the measurement can be used for parametric data analysis.\n\n\n\n$passFail\n\nBoolean\n\nWether to Pass (set to true) or Fail (set to false) this test step.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n// Record a voltage measurement and pass this test.\n\n$measName = \"Input_Voltage\";\n\n$measUnit = \"Volts\";\n\n$parametric = true;\n\n$passFail = true;\n\n\n\n\n\nRecordMeasurementPassFail($measName, $measurement, $measUnit, $parametric, $passFail);\n\n\n\n\n\nRecordMeasurementWithLimits\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS RecordMeasurementWithLimits": {
  "prefix": "RecordMeasurementWithLimits",
  "body": [
   "RecordMeasurementWithLimits($$measureName,$$measurement,$$measureUnit,$$parametricMeasure,$$lowerLimit,$$upperLimit,$$failOnLimits);"
  ],
  "description": "\n\nThis function will record a measurement that will be included in any report writer and tests the measurement against upper and lower limits. If $failOnLimits is set to True and the measurement is outside of the limits, this test will Fail.\n\n\n\nRemarks:\n\nWhether any of the data here is included in a report is a function of the report writer. For example, the HTML report writer will output the Test Name (set with the SetTestName function), but does not include the Measurement Name, even though it includes the measurement data.\n\n\n\nSetting $failOnLimits to true and having the measurement outside of the limits will cause the test to fail and stop the test script.\n\n\n\nOnly numerical types can be included in the $measurement so it can be tested against the limits.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$measureName\n\nString\n\nThe name of the measurement to be recorded.\n\n\n\n$measurement\n\nInteger, or Float\n\nThe measurement data to be recorded.\n\n\n\n$measureUnit\n\nString\n\nThe unit associated with the measurement.\n\n\n\n$parametricMeasure\n\nBoolean\n\nIf true, the measurement can be used for parametric data analysis.\n\n\n\n$lowerLimit\n\nFloat\n\nThe lower numerical limit.\n\n\n\n$upperLimit\n\nFloat\n\nThe upper numerical limit.\n\n\n\n$failOnLimits\n\nBoolean\n\nWhether to return a Fail to the script interpreter if $measurement is outside of the limits.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n\n\n\n\n// Record a voltage measurement and pass the test.\n\n$measName = \"Input Voltage\";\n\n$measUnit = \"Volts\";\n\n$parametric = true;\n\n$lowerLimit = 10.3;\n\n$upperLimit = 14.2;\n\n$failOnLimits = true;\n\n\n\nRecordMeasurementWithLimits($measName, $measurement, $measUnit, $parametric, $lowerLimit, $upperLimit, $failOnLimits);\n\n\n\n\n\nRecordMeasurementWithLimitsSetFailLabel\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS RecordMeasurementWithLimitsSetFailLabel": {
  "prefix": "RecordMeasurementWithLimitsSetFailLabel",
  "body": [
   "RecordMeasurementWithLimitsSetFailLabel($$MeasurementName,$$Measurement,$$MeasurementUnit,$$ParametricMeasurement,$$LowerLimit,$$UpperLimit,$$FailOnLimits);"
  ],
  "description": "\n\nThis function is used to record a parametric measurement to TARS. This function is an extension of the regular RecordMeasurement function since it allows for recording a measurement and testing it against a set of limits in a single test step. The limit checking may be ignored by passing a value of false to the $FailOnLimits parameter.\n\n\n\n\n\nRemarks:\n\nThis function is basically a duplicate of the 'RecordMeasurementWithLimits' function with the exception that in the event of a failure, this function sets the failure label reported to TARS or MES to [Test Group Name]-[Measurement Name]. This can cause an issue with truncation when viewing test data in MES since there is a 25 character limit on MES failure labels, so please be aware of this limitation when using the function. Aside from this change, the function works in the exact same manner as the standard 'RecordMeasurementWithLimits' function.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$MeasurementName\n\nString\n\nThe name of the measurement to be recorded.\n\n\n\n$Measurement\n\nInteger, Float\n\nThe actual measurement data to record.\n\n\n\n$MeasurementUnit\n\nString\n\nThe unit associated with the measurement.\n\n\n\n$ParametricMeasurement\n\nBoolean\n\nA boolean flag indicating whether or not the recorded measurement can be used for parametric data analysis.\n\n\n\n$LowerLimit\n\nFloat\n\nThe lower numeric limit.\n\n\n\n$UpperLimit\n\nFloat\n\nThe upper numeric limit.\n\n\n\n$FailOnLimits\n\nBoolean\n\nIf this value is set to true, the $Measurement variable is compared to the upper and lower limit, and the test will automatically return a failing result to the test executive.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n\n\n\n\n// Record a passing measurement.\n\n$MeasName = \"ThisMeasure\";\n\n$Measure = 300;\n\n$MeasUnit = \"flops\";\n\n$ParamMeas = true;\n\n$LowLimit = 225;\n\n$UpLimit = 512;\n\n$FailOn = true;\n\nRecordMeasurementWithLimitsSetFailLabel($MeasName, $Measure, $MeasUnit, $ParamMeas, $LowLimit, $UpLimit, $FailOn);\n\n\n\n\n\nRecordMeasurementWithPercentLimits\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS RecordMeasurementWithPercentLimits": {
  "prefix": "RecordMeasurementWithPercentLimits",
  "body": [
   "RecordMeasurementWithPercentLimits($$MeasurementName,$$ExpectedValue,$$MeasuredValue,$$PercentLimit,$$ParametricMeasurement,$$FailOnLimits);"
  ],
  "description": "\n\nThis function works just like the RecordMeasurementWithLimits function except you pass it the expected measurement, the actual measurement, and the highest percentage the measured value can differ from the expected Value.The limit checking may be ignored by passing a value of 'FALSE' to the $FailOnLimits parameter.\n\nnote: the percent limit is expressed in Percent (%)\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$MeasurementName\n\nString\n\nThe name of the measurement to be recorded\n\n\n\n$ExpectedValue\n\nString, Integer, Float\n\nThe expected Value\n\n\n\n$MeasuredValue\n\nString, Integer, Float\n\nThe actual measurement data to record\n\n\n\n$PercentLimit\n\nFloat\n\nThe Percent Limit\n\n\n\n$ParametricMeasurement\n\nBoolean\n\nA boolean flag indicating whether or not the recorded measurement can be used for parametric data analysis.\n\n\n\n$FailOnLimits\n\nBoolean\n\nIf this value is set to true, the $Measurement variable is compared to the upper and lower limit, and the test will automatically return a failing result to the test executive.\n\n\n\n\n\nMES_GetUnitChildren\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS MES_GetUnitChildren": {
  "prefix": "MES_GetUnitChildren",
  "body": [
   "($$parentSN,$$childSN)=MES_GetUnitChildren($$serialNum,$$assemblyNum,$$serverName,$$databaseName);"
  ],
  "description": "\n\nThis function returns the latest child link as detailed in MES based on the assembly number ($assemblyNum).\n\n\n\nRemarks:\n\nThe MES Static API Proxy must be installed to use this function.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$serialNum\n\nString\n\nThe unit serial number.\n\n\n\n$assemblyNum\n\nString\n\nThe unit assembly number.\n\n\n\n$serverName\n\nString\n\nThe name of the MES server to connect to.\n\n\n\n$databaseName\n\nString\n\nThe name of the database to get data from.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$parentSN\n\nString\n\nThe serial number of the parent to the current unit.\n\n\n\n$childSN\n\nString\n\nThe serial number of the last child of the current unit.\n\n\n\n\n\nExamples:\n\n\n\n\n\n// Get the parent and the last child.\n\n$sn = \"123456789\";\n\n$assem = \"this_assembly\";\n\n$serv = \"AUHSERVER\";\n\n$db = \"JEMS3\";\n\n\n\n($parent, $child) = MES_GetUnitChildren($sn, $assem, $serv, $db);\n\n\n\n$outString = \"The parent of this unit is:\\t\" + $parent;\n\nUpdateStatus($outString)\n\n$outString = \"The last child of this unit is:\\t\" + $child;\n\nUpdateStatus($outString)\n\n\n\n\n\nMES_GetUserStats\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS MES_GetUserStats": {
  "prefix": "MES_GetUserStats",
  "body": [
   "($$active,$$mesID,$$fName,$$lName,$$winID)=MES_GetUserStats($$userName,$$serverName,$$database);"
  ],
  "description": "\n\nThis function will return information about the user from the MES database.\n\n\n\nRemarks\n\nThe user, server and database must exist or this function will return a fail.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$userName\n\nString\n\nThe name of the MES user to get data about.\n\n\n\n$serverName\n\nString\n\nThe name of the MES server to connect to.\n\n\n\n$database\n\nString\n\nThe name of the MES database to get data from.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$active\n\nBoolean\n\nWhether the specified user is active in the system.\n\n\n\n$mesID\n\nString\n\nThe MES ID of the specified user.\n\n\n\n$fName\n\nString\n\nThe first name of the specified user.\n\n\n\n$lName\n\nString\n\nThe last name of the specified user.\n\n\n\n$winID\n\nString\n\nThe windows ID of the specified user.\n\n\n\n\n\nExample:\n\n\n\n\n\n// Connect to server MESTESTSRV, database JEMS and get info on user smithj.\n\n$serv = \"MESTESTSRV\";\n\n$db = \"JEMS\";\n\n$user = \"smithj\";\n\n\n\n($active, $mesID, $fName, $lName, $winID) = MES_GetUserStats($user, $serv, $db);\n\n\n\n// Output the information on the user.\n\n$outStr = \"User is active:\\t\" + $active;\n\n$outStr = $outStr + \"\\r\\nMES user ID:\\t\" + $mesID;\n\n$outStr = $outStr + \"\\r\\nFirst Name:\\t\" + $fName;\n\n$outStr = $outStr + \"\\r\\nLast Name:\\t\" + $lName;\n\n$outStr = $outStr + \"\\r\\nWIN user ID:\\t\" + $winID;\n\nUpdateStatus($outStr);\n\n\n\n\n\nMES_GetValidUser\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS MES_GetValidUser": {
  "prefix": "MES_GetValidUser",
  "body": [
   "$$valid=MES_GetValidUser($$userName,$$serverName,$$database);"
  ],
  "description": "\n\nThis function will return whether or not the user is a valid MES user.\n\n\n\nRemarks\n\nThe user, server and database must exist or this function will return a fail.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$userName\n\nString\n\nThe name of the MES user to check.\n\n\n\n$serverName\n\nString\n\nThe name of the MES server to connect to.\n\n\n\n$database\n\nString\n\nThe name of the MES database to check.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$valid\n\nBoolean\n\nWhether the user is a valid user of the specified server and database.\n\n\n\n\n\nExample:\n\n\n\n\n\n// Connect to server MESTESTSRV, database JEMS and check if user smithj is a valid user.\n\n$serv = \"MESTESTSRV\";\n\n$db = \"JEMS\";\n\n$user = \"smithj\";\n\n\n\n$valid = MES_GetValidUser($user, $serv, $db);\n\n\n\n// Output the result of the user validity check.\n\n$notStr = \"\";\n\nif(!$valid)\n\n{\n\n$notStr = \"not \";\n\n}\n\n$outStr = \"User is \" + $notStr + \"valid.\";\n\nUpdateStatus($outStr);\n\n\n\n\n\nMES_CheckOKToTest\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS MES_CheckOKToTest": {
  "prefix": "MES_CheckOKToTest",
  "body": [
   "$$OKToTest=MES_CheckOKToTest($$ServiceURL,$$CustomerName,$$DivisionName,$$SerialNumber,$$AssemblyNumber,$$TesterName,$$ProcessStep);"
  ],
  "description": "\n\n\n\nThis function queries the Jabil MES system via the MES-TIS web service and returns a string variable containing \"PASS\" or \"FAIL\" indicating whether the current test process is valid to proceed.\n\n\n\n\n\nResult:\n\nThis function returns PASS if it is OK to proceed with test.\n\nThis function returns FAIL if it is NOT OK to proceed with test.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ServiceURL\n\nString\n\nThe Web URL For the MES-TIS webservice. This is usually installed on the COM+ MES server for the plant.\n\n\n\n$CustomerName\n\nString\n\nThe product's customer name.\n\n\n\n$DivisionName\n\nString\n\nThe product's division name.\n\n\n\n$SerialNumber\n\nString\n\nThe product's serial number.\n\n\n\n$AssemblyNumber\n\nString\n\nThe product's assembly number.\n\n\n\n$TesterName\n\nString\n\nThe name of the tester\n\n\n\n$ProcessStep\n\nString\n\nThe name of the current process step to evaluate for test validility.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$OKToTest\n\nString\n\nReturns \"PASS\" if the supplied test process is the next valid step.\n\n\n\n\n\nMES_CheckOKToTestLinkMaterial\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS MES_CheckOKToTestLinkMaterial": {
  "prefix": "MES_CheckOKToTestLinkMaterial",
  "body": [
   "$$OKToTest=MES_CheckOKToTestLinkMaterial($$ServiceURL,$$CustomerName,$$DivisionName,$$SerialNumber,$$AssemblyNumber,$$TesterName,$$ProcessStep);"
  ],
  "description": "\n\nThis function queries the Jabil MES system via the MES-TIS web service and returns a string variable containing \"PASS\" or \"FAIL\" indicating whether the current test process is valid to proceed with a link material.\n\n\n\n\n\nResult:\n\nThis function returns PASS if it is OK to proceed with test.\n\nThis function returns FAIL if it is NOT OK to proceed with test.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ServiceURL\n\nString\n\nThe Web URL For the MES-TIS webservice. This is usually installed on the COM+ MES server for the plant.\n\n\n\n$CustomerName\n\nString\n\nThe product's customer name.\n\n\n\n$DivisionName\n\nString\n\nThe product's division name.\n\n\n\n$SerialNumber\n\nString\n\nThe product's serial number.\n\n\n\n$AssemblyNumber\n\nString\n\nThe product's assembly number.\n\n\n\n$TesterName\n\nString\n\nThe name of the tester\n\n\n\n$ProcessStep\n\nString\n\nThe name of the current process step to evaluate for test validility.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$OKToTest\n\nString\n\nReturns \"PASS\" if the supplied test process is the next valid step for the link material.\n\n\n\n\n\nExample:\n\n// These are the parameters that need to be passed:\n\n$url = \"http://servername/MES-TIS/TIS.asmx\";\n\n$cust = \"customername\";\n\n$div = \"divisionname\";\n\n$lmSN = \"SN123456B\";\n\n$asmb = \"ASM45678-001\";\n\n$tstr = \"TESTERname\";\n\n$proc = \"Process2\";\n\n\n\n\n\n// Check that the MES-TIS system is up and running.\n\n$sysUp = MES_CheckSystemUp($url);\n\n\n\n\n\n// Now check the material.\n\n$ret = MES_CheckOKToTestLinkMaterial($url, $cust, $div, $lmSN, $asmb, $tstr, $proc);\n\n\n\n\n\nMES_CheckSystemUp\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS MES_CheckSystemUp": {
  "prefix": "MES_CheckSystemUp",
  "body": [
   "$$SystemUp=MES_CheckSystemUp($$ServiceURL);"
  ],
  "description": "\n\n\n\nThis function queries the Jabil MES system via the MES-TIS web service and returns a boolean indicating whether the system is up and responding or not.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ServiceURL\n\nString\n\nThe Web URL For the MES-TIS webservice. This is usually installed on the COM+ MES server for the plant.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$SystemUp\n\nBoolean\n\nReturns true if the MES-TIS system is responding, false otherwise.\n\n\n\n\n\nMES_GetCurrentRouteStep\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS MES_GetCurrentRouteStep": {
  "prefix": "MES_GetCurrentRouteStep",
  "body": [
   "($$StepType,$$StepName,$$Status)=MES_GetCurrentRouteStep($$ServiceURL,$$SerialNumber);"
  ],
  "description": "\n\n\n\nThis function queries the MES service via the MES-TIS web service and returns the current route step for a given serial number.\n\n\n\n\n\nResult:\n\nReturns a string with the current route step name from MES for the given serial number.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ServiceURL\n\nString\n\nThe Web URL For the MES-TIS webservice. This is usually installed on the COM+ MES server for the plant.\n\n\n\n$SerialNumber\n\nString\n\nThe product serial number.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$StepType\n\nString\n\nThe current route step type (such as \"AOI\",\"ICT\",\"FVT\",etc)\n\n\n\n$StepName\n\nString\n\nThe name of the step station\n\n\n\n$Status\n\nString\n\nThe status of the last Route Step (Pass/Fail)\n\n\n\n\n\nUsage Example:\n\n($StepType,$StepName,$Status) = MES_GetCurrentRouteStep(\"http://arslabcmp02/MES-TIS/TIS.asmx\",\"JAB110203CJ\");\n\n\n\n\n\nMES_GetCurrentRouteStepBool\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS MES_GetCurrentRouteStepBool": {
  "prefix": "MES_GetCurrentRouteStepBool",
  "body": [
   "($$StepType,$$StepName,$$Status,$$Found)=MES_GetCurrentRouteStepBool($$ServiceURL,$$SerialNumber);"
  ],
  "description": "\n\n\n\nThis function queries the MES service via the MES-TIS web service and returns the current route step for a given serial number. If not information is present, the $Found flag will be false and all other fields empty string.\n\n\n\n\n\nResult:\n\nReturns a string with the current route step name from MES for the given serial number, if present.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ServiceURL\n\nString\n\nThe Web URL For the MES-TIS webservice. This is usually installed on the COM+ MES server for the plant.\n\n\n\n$SerialNumber\n\nString\n\nThe product serial number.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$StepType\n\nString\n\nThe current route step type (such as \"AOI\",\"ICT\",\"FVT\",etc)\n\n\n\n$StepName\n\nString\n\nThe name of the step station\n\n\n\n$Status\n\nString\n\nThe status of the last Route Step (Pass/Fail)\n\n\n\n$Found\n\nBoolean\n\nReturns true if the route information was found; false otherwise.\n\n\n\n\n\nUsage Example:\n\n($StepType,$StepName,$Status,$Found) = MES_GetCurrentRouteStepBool(\"http://arslabcmp02/MES-TIS/TIS.asmx\",\"JAB110203CJ\");\n\nif(!$Found)\n\n{\n\nUpdateStatus(\"No route step information found!\");\n\n}\n\n\n\n\n\nMES_GetLastTestResult\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS MES_GetLastTestResult": {
  "prefix": "MES_GetLastTestResult",
  "body": [
   "($$startTime,$$stopTime,$$status,$$machineName,$$operatorName,$$StepOrTestName)=MES_GetLastTestResult($$ServiceURL,$$CustomerName,$$DivisionName,$$SerialNumber,$$StepName);"
  ],
  "description": "\n\n\n\n\n\nThis function queries the MES-TIS web service and returns the details of the last test performed at a specific test step for a specific product serial number.\n\n\n\n\n\nNote: This function was added after the first release of MES-TIS server, so you may need to update your MES-TIS installation in order to use this client side function.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ServiceURL\n\nString\n\nThe Web URL For the MES-TIS webservice. This is usually installed on the COM+ MES server for the plant.\n\n\n\n$CustomerName\n\nString\n\nThe name of the customer for the product\n\n\n\n$DivisionName\n\nString\n\nThe name of the division for the product\n\n\n\n$SerialNumber\n\nString\n\nThe product serial number.\n\n\n\n$StepName\n\nString\n\nThe MES Step or Test Name to check\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$StartTime\n\nString\n\nThe starting date/time of the test.\n\n\n\n$StopTime\n\nString\n\nThe stopping date/time of the test.\n\n\n\n$Status\n\nString\n\nThe pass/fail status of the test.\n\n\n\n$MachineName\n\nString\n\nThe machine name which performed the test.\n\n\n\n$OperatorName\n\nString\n\nThe name of the operator who performed the test.\n\n\n\n$StepOrTestName\n\nString\n\nThe name of the step or test.\n\n\n\n\n\nExample: \n\n\n\n\n\n($startTime,$stopTime,$status,$machineName,$operatorName,$StepOrTestName) = MES_GetLastTestResult(\"http://teopsdevstg/mes-tis/tis.asmx\",\"Cisco\",\"\",\"JAB104201F2\",\"POST WAVE TOUCHUP\");\n\n\n\n\n\nMES_GetPanelSerializeResult\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS MES_GetPanelSerializeResult": {
  "prefix": "MES_GetPanelSerializeResult",
  "body": [
   "($$numPanels,$$panelArray)=MES_GetPanelSerializeResult($$mesUrl,$$customerName,$$division,$$serialNum);"
  ],
  "description": "\n\nThis function will return the information for all sub-panels associated with one serial number. The data is returned in a two-dimensional array...\n\n\n\nThe two dimensional array is formatted as:\n\nArray[x][0] = Panel ID\n\nArray[x][1] = Panel\n\nArray[x][2] = WIP ID\n\nArray[x][3] = Serial Number Ori\n\nArray[x][4] = Mapping\n\nArray[x][5] = XOut\n\nArray[x][6] = XOut Stats\n\nArray[x][7] = Serial Number\n\n(X = Test Record Number)\n\n\n\n\n\nRemarks:\n\nIf the MES-TIS system does not respond to the query, the test step will fail the script.\n\nIf the serial number is not found, the test step will fail the script.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$mesUrl\n\nString\n\nThe Web URL For the MES-TIS webservice. This is usually installed on the COM+ MES server for the plant.\n\n\n\n$customerName\n\nString\n\nThe name of the customer for this panel.\n\n\n\n$division\n\nString\n\nThe name of the division for this panel.\n\n\n\n$serialNum\n\nString\n\nThe serial number to return the data for.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$numPanels\n\nInteger\n\nThe number of results that are returned.\n\n\n\n$panelArray\n\nArray\n\nThe results for the sub-panels found.\n\n\n\n\n\nExample:\n\n// Get data for one serial number.\n\n$mesUrl = \"129.169.10.123\";\n\n$custName = \"OurCustomer\";\n\n$div = \"TheDivision\";\n\n$sn = \"12345678\";\n\n($numPanels, $panArray) = MES_GetPanelSerializeResult($mesUrl, $custName, $div, $sn);\n\n\n\n\n\nMES_GetTestHistoryAsArray\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS MES_GetTestHistoryAsArray": {
  "prefix": "MES_GetTestHistoryAsArray",
  "body": [
   "($$RowCount,$$Array)=MES_GetTestHistoryAsArray($$ServiceURL,$$CustomerName,$$DivisionName,$$SerialNumber);"
  ],
  "description": "\n\n\n\n\n\nThis function queries the MES system via the MES-TIS web service and returns the complete test history of the product into a two dimensional array...\n\n\n\n\n\nThe two dimensional array is formatted as:\n\nArray[x][0] = Start Time\n\nArray[x][1] = Stop Time\n\nArray[x][2] = Pass/Fail\n\nArray[x][3] = Machine Name\n\nArray[x][4] = Operator\n\nArray[x][5] = Step or Test Name\n\nArray[x][6] = Failure Label\n\nArray[x][7] = Failure Message\n\n(X = Test Record Number)\n\n\n\n\n\nNote: This function was added after the first release of MES-TIS server, so you may need to update your MES-TIS installation in order to use this client side function.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ServiceURL\n\nString\n\nThe Web URL For the MES-TIS webservice. This is usually installed on the COM+ MES server for the plant.\n\n\n\n$CustomerName\n\nString\n\nThe name of the customer for the product\n\n\n\n$DivisionName\n\nString\n\nThe name of the division for the product\n\n\n\n$SerialNumber\n\nString\n\nThe product serial number.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$RowCount\n\nString\n\nThe number of rows returned into the array\n\n\n\n$Array\n\nArray\n\nA two dimensional array containing the test details for the product being queried.\n\n\n\n\n\nExample: \n\n\n\n\n\n($RowCount,$Array) = MES_GetTestHistoryAsArray(\"http://teopsdevstg/mes-tis/tis.asmx\",\"Cisco\",\"\",\"JAB104201F2\");\n\n$x = 0;\n\nLabel Loop:\n\n$StartTime = ArrayGetValue($Array,$x,0);\n\n$StopTime = ArrayGetValue($Array,$x,1);\n\n$PassFail = ArrayGetValue($Array,$x,2);\n\n$MachineName = ArrayGetValue($Array,$x,3);\n\n$Operator = ArrayGetValue($Array,$x,4);\n\n$StepOrTestName = ArrayGetValue($Array,$x,5);\n\n$FailureLabel = ArrayGetValue($Array,$x,6);\n\n$FailureMessage = ArrayGetValue($Array,$x,7);\n\nUpdateStatus($StartTime);\n\nUpdateStatus($StopTime);\n\nUpdateStatus($PassFail);\n\nUpdateStatus($MachineName);\n\nUpdateStatus($Operator);\n\nUpdateStatus($StepOrTestName);\n\nUpdateStatus($FailureLabel);\n\nUpdateStatus($FailureMessage);\n\nif ($x < $RowCount-1)\n\n{\n\n$x = $x + 1;\n\ngoto Loop;\n\n}\n\n\n\n\n\nEnd;\n\n\n\n\n\nMES_LookupCustomerAssembly\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS MES_LookupCustomerAssembly": {
  "prefix": "MES_LookupCustomerAssembly",
  "body": [
   "($$Family,$$Number,$$Revision,$$Version,$$Description,$$OnHold,$$RMA,$$ReferenceUnit)=MES_LookupCustomerAssembly($$ServiceURL,$$CustomerName,$$DivisionName,$$SerialNumber);"
  ],
  "description": "\n\n\n\nThis function queries the MES service via the MES-TIS web service and returns the assembly information for the supplied customer, division, and serial number.\n\n\n\n\n\nResult:\n\nReturns a string with the assembly name from MES for the given product information.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ServiceURL\n\nString\n\nThe Web URL For the MES-TIS webservice. This is usually installed on the COM+ MES server for the plant.\n\n\n\n$CustomerName\n\nString\n\nThe name of the customer for the product\n\n\n\n$DivisionName\n\nString\n\nThe name of the division for the product\n\n\n\n$SerialNumber\n\nString\n\nThe product serial number.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Family\n\nString\n\nThe product's assembly string in MES.\n\n\n\n$Number\n\nString\n\nThe assembly number of the product\n\n\n\n$Revision\n\nString\n\nThe revision number of the product\n\n\n\n$Version\n\nString\n\nThe version number of the product\n\n\n\n$Description\n\nString\n\nThe description for the assembly\n\n\n\n$OnHold\n\nBoolean\n\nIndicates that this board is on hold\n\n\n\n$RMA\n\nBoolean\n\nIndicates that this board is an RMA\n\n\n\n$ReferenceUnit\n\nBoolean\n\nIndicates that this board is a reference unit.\n\n\n\n\n\nExample: \n\n\n\n\n\n($Family,$Number,$Revision,$Version,$Text,$OnHold,$RMA,$RefUnit) = MES_LookupCustomerAssembly(\"http://arslabcmp02/MES-TIS/TIS.asmx\",\"Cisco\",\"Cisco\",\"JAB105006NF\");\n\n\n\n\n\nMESGOF_CheckOkToTest\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS MESGOF_CheckOKToTest": {
  "prefix": "MESGOF_CheckOKToTest",
  "body": [
   "$$Response=MESGOF_CheckOKToTest($$ServiceURL,$$SFONumber,$$ProcessStep);"
  ],
  "description": "Queries the MES Global Order Fulfillment web services interface to check if a given shop floor order number is ready to be tested at a given process step.\n\n\n\n\n\nNote: The MES GOF System has not yet been launched for production, so these functions should only be used for testing new test systems currently in development designed to interact with the new MES Global Order Fulfillment system.\n\nThe arguments and return values of these functions are subject to change until the GOF project team has reached a release candidate status.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ServiceURL\n\nString\n\nThe Web URL For the MES GOF TIS webservice. This is usually installed on the COM+ MES server for the plant.\n\n\n\n$SFONumber\n\nString\n\nThe Shop Floor Order Number\n\n\n\n$ProcessStep\n\nString\n\nThe MES Process Step Name to query\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Response\n\nString\n\nXML Response String\n\n\n\n\n\nMESGOF_GenerateUPDData\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS MESGOF_GenerateUPDData": {
  "prefix": "MESGOF_GenerateUPDData",
  "body": [
   "$$Response=MESGOF_GenerateUPDData($$ServiceURL,$$CustomerName,$$DivisionName,$$MaterialName,$$SerialNumber,$$UPDData,$$Quantity,$$UserName);"
  ],
  "description": "This function instructs the MES Global Order Fulfillment system to generate UPD (Unique Product Data) such as Mac Addresses, WWN Addresses, etc for a given product. The UPD Data Generation algorithm must be configured in MES prior to executing this function.\n\n\n\n\n\nNote: The MES GOF System has not yet been launched for production, so these functions should only be used for testing new test systems currently in development designed to interact with the new MES Global Order Fulfillment system.\n\nThe arguments and return values of these functions are subject to change until the GOF project team has reached a release candidate status.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ServiceURL\n\nString\n\nThe Web URL For the MES GOF TIS webservice. This is usually installed on the COM+ MES server for the plant.\n\n\n\n$CustomerName\n\nString\n\nThe Customer Name\n\n\n\n$DivisionName\n\nString\n\nThe Customer's Division Name\n\n\n\n$MaterialName\n\nString\n\nThe Material Name for UPD Data Generation.\n\n\n\n$SerialNumber\n\nString\n\nThe serial number of the product for UPD data generation.\n\n\n\n$UPDData\n\nString\n\nA string name indicating the type of UPD Data to generate for the product.\n\n\n\n$Quantity\n\nInteger\n\nAn integer indicating the number of UPD Data items to generate. The sequence of the generated data is dependent on the algorithm configured for UPD data generation in MES.\n\n\n\n$UserName\n\nString\n\nThe name of the user to permanently associate with the UPD data generation.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Response\n\nString\n\nXML Response String\n\n\n\n\n\nMESGOF_GetAsBuiltData\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS MESGOF_GetAsBuiltData": {
  "prefix": "MESGOF_GetAsBuiltData",
  "body": [
   "$$Response=MESGOF_GetAsBuiltData($$ServiceURL,$$SFONumber);"
  ],
  "description": "This function queries the MES Global Order Fulfillment system to get the 'As Built' data for a particular shop floor order number.\n\n\n\n\n\nNote: The MES GOF System has not yet been launched for production, so these functions should only be used for testing new test systems currently in development designed to interact with the new MES Global Order Fulfillment system.\n\nThe arguments and return values of these functions are subject to change until the GOF project team has reached a release candidate status.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ServiceURL\n\nString\n\nThe Web URL For the MES GOF TIS webservice. This is usually installed on the COM+ MES server for the plant.\n\n\n\n$SFONumber\n\nString\n\nThe SFO Number\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Response\n\nString\n\nXML Response String\n\n\n\n\n\nMESGOF_GetCurrentRouteStep\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS MESGOF_GetCurrentRouteStep": {
  "prefix": "MESGOF_GetCurrentRouteStep",
  "body": [
   "$$Response=MESGOF_GetCurrentRouteStep($$ServiceURL,$$SFONumber);"
  ],
  "description": "This function queries the MES Global Order Fulfillment system to get the current route step for a particular shop floor order number.\n\n\n\n\n\nNote: The MES GOF System has not yet been launched for production, so these functions should only be used for testing new test systems currently in development designed to interact with the new MES Global Order Fulfillment system.\n\nThe arguments and return values of these functions are subject to change until the GOF project team has reached a release candidate status.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ServiceURL\n\nString\n\nThe Web URL For the MES GOF TIS webservice. This is usually installed on the COM+ MES server for the plant.\n\n\n\n$SFONumber\n\nString\n\nThe SFO Number\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Response\n\nString\n\nXML Response String\n\n\n\n\n\nMESGOF_GetLastTestResult\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS MESGOF_GetLastTestResult": {
  "prefix": "MESGOF_GetLastTestResult",
  "body": [
   "$$Response=MESGOF_GetLastTestResult($$ServiceURL,$$SFONumber,$$ProcessStep);"
  ],
  "description": "This function queries the MES Global Order Fulfillment system to get the last test result for a particular shop floor order number at a given test process step.\n\n\n\n\n\nIf a particular SFO was tested multiple times at a given process step, this function will return the last test result for the given process step.\n\n\n\n\n\nNote: The MES GOF System has not yet been launched for production, so these functions should only be used for testing new test systems currently in development designed to interact with the new MES Global Order Fulfillment system.\n\nThe arguments and return values of these functions are subject to change until the GOF project team has reached a release candidate status.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ServiceURL\n\nString\n\nThe Web URL For the MES GOF TIS webservice. This is usually installed on the COM+ MES server for the plant.\n\n\n\n$SFONumber\n\nString\n\nThe SFO Number\n\n\n\n$ProcessStep\n\nString\n\nThe name of the MES Process Step to query for the last test result.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Response\n\nString\n\nXML Response String\n\n\n\n\n\nMESGOF_GetMESTestDataFormats\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS MESGOF_GetMESTestDataFormats": {
  "prefix": "MESGOF_GetMESTestDataFormats",
  "body": [
   "$$Response=MESGOF_GetMESTestDataFormats($$ServiceURL);"
  ],
  "description": "This function returns a list of the MES Test Data Formats currently supported by the MES GOF Web Services interface.\n\n\n\n\n\nNote: The MES GOF System has not yet been launched for production, so these functions should only be used for testing new test systems currently in development designed to interact with the new MES Global Order Fulfillment system.\n\nThe arguments and return values of these functions are subject to change until the GOF project team has reached a release candidate status.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ServiceURL\n\nString\n\nThe Web URL For the MES GOF TIS webservice. This is usually installed on the COM+ MES server for the plant.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Response\n\nString\n\nXML Response String containing a list of the MES Test Data Formats\n\n\n\n\n\nMESGOF_GetSFOHeader\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS MESGOF_GetSFOHeader": {
  "prefix": "MESGOF_GetSFOHeader",
  "body": [
   "$$Response=MESGOF_GetSFOHeader($$ServiceURL,$$CustomerName,$$DivisionName,$$TopLevelSerial);"
  ],
  "description": "This function queries the MES Global Order Fulfillment system to retrieve the Shop Floor Order Header for a given top level serial number for a customer and division.\n\n\n\n\n\nNote: The MES GOF System has not yet been launched for production, so these functions should only be used for testing new test systems currently in development designed to interact with the new MES Global Order Fulfillment system.\n\nThe arguments and return values of these functions are subject to change until the GOF project team has reached a release candidate status.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ServiceURL\n\nString\n\nThe Web URL For the MES GOF TIS webservice. This is usually installed on the COM+ MES server for the plant.\n\n\n\n$CustomerName\n\nString\n\nThe name of the customer\n\n\n\n$Division\n\nString\n\nThe name of the customer's division\n\n\n\n$TopLevelSerial\n\nString\n\nThe top level serial number for a given shop floor order number.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Response\n\nString\n\nXML Response String\n\n\n\n\n\nMESGOF_GetSerialNumbersByUPD\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS MESGOF_GetSerialNumbersByUPD": {
  "prefix": "MESGOF_GetSerialNumbersByUPD",
  "body": [
   "$$Response=MESGOF_GetSerialNumbersByUPD($$ServiceURL,$$CustomerName,$$DivisionName,$$UPDName,$$UPDValue);"
  ],
  "description": "This function queries the MES Global Order Fulfillment system and retrieves a list of Serial Numbers that are associated with a given unique product data name and value for the specified customer and division.\n\n\n\n\n\nNote: The MES GOF System has not yet been launched for production, so these functions should only be used for testing new test systems currently in development designed to interact with the new MES Global Order Fulfillment system.\n\nThe arguments and return values of these functions are subject to change until the GOF project team has reached a release candidate status.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ServiceURL\n\nString\n\nThe Web URL For the MES GOF TIS webservice. This is usually installed on the COM+ MES server for the plant.\n\n\n\n$CustomerName\n\nString\n\nThe customer name\n\n\n\n$DivisionName\n\nString\n\nThe name of the particular division within the customer.\n\n\n\n$UPDName\n\nString\n\nThe name of the UPD identifier or tag such as 'MAC ADDRESS'.\n\n\n\n$UPDValue\n\nString\n\nThe value for the given UPD identifier that you wish to locate the corresponding serial number(s) for in the MES system.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Response\n\nString\n\nXML Response String\n\n\n\n\n\nMESGOF_GetTestHistory\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS MESGOF_GetTestHistory": {
  "prefix": "MESGOF_GetTestHistory",
  "body": [
   "$$Response=MESGOF_GetTestHistory($$ServiceURL,$$SFONumber,$$ProcessStep);"
  ],
  "description": "This function queries the MES Global Order Fulfillment system to get the entire test history of a particular SFO number at a specific process step.\n\n\n\n\n\nNote: The MES GOF System has not yet been launched for production, so these functions should only be used for testing new test systems currently in development designed to interact with the new MES Global Order Fulfillment system.\n\nThe arguments and return values of these functions are subject to change until the GOF project team has reached a release candidate status.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ServiceURL\n\nString\n\nThe Web URL For the MES GOF TIS webservice. This is usually installed on the COM+ MES server for the plant.\n\n\n\n$SFONumber\n\nString\n\nThe SFO Number\n\n\n\n$ProcessStep\n\nString\n\nThe name of the MES Process Step to query for the test results history.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Response\n\nString\n\nXML Response String\n\n\n\n\n\nMESGOF_GetUPDData\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS MESGOF_GetUPDData": {
  "prefix": "MESGOF_GetUPDData",
  "body": [
   "$$Response=MESGOF_GetUPDData($$ServiceURL,$$SFONumber,$$Material,$$SerialNumber);"
  ],
  "description": "This function queries the MES Global Order Fulfillment system to get the assigned Unique Product Data for a particular material item and serial number in a given shop floor order number.\n\n\n\n\n\nNote: The MES GOF System has not yet been launched for production, so these functions should only be used for testing new test systems currently in development designed to interact with the new MES Global Order Fulfillment system.\n\nThe arguments and return values of these functions are subject to change until the GOF project team has reached a release candidate status.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ServiceURL\n\nString\n\nThe Web URL For the MES GOF TIS webservice. This is usually installed on the COM+ MES server for the plant.\n\n\n\n$SFONumber\n\nString\n\nThe SFO Number\n\n\n\n$Material\n\nString\n\nThe particular material for a given serial number to return the assigned UPD Data.\n\n\n\n$SerialNumber\n\nString\n\nThe serial number in the given shop floor order to which a particular material UPD has been assigned.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Response\n\nString\n\nXML Response String\n\n\n\n\n\nMESGOF_GetVersion\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS MESGOF_GetVersion": {
  "prefix": "MESGOF_GetVersion",
  "body": [
   "$$VersionString=MESGOF_GetVersion($$ServiceURL);"
  ],
  "description": "This function returns the particular version string of the current MES installation.\n\n\n\n\n\nNote: The MES GOF System has not yet been launched for production, so these functions should only be used for testing new test systems currently in development designed to interact with the new MES Global Order Fulfillment system.\n\nThe arguments and return values of these functions are subject to change until the GOF project team has reached a release candidate status.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ServiceURL\n\nString\n\nThe Web URL For the MES GOF TIS webservice. This is usually installed on the COM+ MES server for the plant.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$VersionString\n\nString\n\nThe MES Version String for the current installation\n\n\n\n\n\nMESGOF_SetUPDData\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS MESGOF_SetUPDData": {
  "prefix": "MESGOF_SetUPDData",
  "body": [
   "MESGOF_SetUPDData($$ServiceURL,$$CustomerName,$$DivisionName,$$MaterialName,$$SerialNumber,$$UPDName,$$UPDValues,$$UserName);"
  ],
  "description": "This function instructs the MES Global Order Fulfillment system to assigned Unique Product Data values for a particular material item and serial number. The UPD Name parameter is essentially a dictionary key naming the UPD values for a given material. The $UPDValues parameter is an array of strings which will be stored into the MES database for a given UPD data key. The $UserName argument permanently associates a given user with having generated the Unique Product Data.\n\n\n\n\n\nNote: The MES GOF System has not yet been launched for production, so these functions should only be used for testing new test systems currently in development designed to interact with the new MES Global Order Fulfillment system.\n\nThe arguments and return values of these functions are subject to change until the GOF project team has reached a release candidate status.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ServiceURL\n\nString\n\nThe Web URL For the MES GOF TIS webservice. This is usually installed on the COM+ MES server for the plant.\n\n\n\n$CustomerName\n\nString\n\nThe Customer Name\n\n\n\n$MaterialName\n\nString\n\nThe particular material for a given serial number to assign the UPD Data.\n\n\n\n$SerialNumber\n\nString\n\nThe serial number in the given shop floor order to which a particular material UPD will be assigned.\n\n\n\n$UPDName\n\nString\n\nThe key for the UPD dictionary for the given serial number.\n\n\n\n$UPDValues\n\nArray\n\nA 1-Dimensional array of strings to assign to the serial number's UPD data key. If a multidimensional array is supplied to the function, a failure will be generated.\n\n\n\n$UserName\n\nString\n\nThe name of the user who assigned the UPD Data to a given serial number/product.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nBarrierAddParticipant\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS BarrierAddParticipant": {
  "prefix": "BarrierAddParticipant",
  "body": [
   "BarrierAddParticipant($$barrierHandle);"
  ],
  "description": "\n\nAdds the cell this function is called from to the barrier's participant list, raising the number of signals needed for waiting cells to continue.\n\n\n\n\n\nA test cell must be part of the barrier\u2019s participant list for it to wait on a BarrierSignalAndWait() call.\n\n\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$barrierHandle\n\nObject\n\nHandle to barrier object previously created with the BarrierCreate() function.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariably Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\nBarrierAddParticipant($barrier1); //adds this cell to 1st barrier\u2019s participant list\n\n\n\n\n\nBarrierCancelAllWaits\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS BarrierCancelAllWaits": {
  "prefix": "BarrierCancelAllWaits",
  "body": [
   "BarrierCancelAllWaits($$barrierHandle);"
  ],
  "description": "\n\nCancels all blocking at the given barrier, allowing any cells waiting to continue. Cells reaching the barrier after this call will continue without being blocked.\n\n\n\n\n\nThis function has a similar effect to a call to BarrierDestroy(), but does not fail any other test cells that attempt to interact with the barrier.\n\n\n\n\n\nNote:\n\nThe cancel command is permanent. The barrier object must be re-created to enable blocking again.\n\n\n\n\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$barrierHandle\n\nObject\n\nHandle to barrier object previously created with the BarrierCreate() function.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariably Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\nBarrierRemoveParticipant($barrier1); //removes this cell from the 1st barrier\u2019s participant list\n\n\n\n\n\nBarrierCreate\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS BarrierCreate": {
  "prefix": "BarrierCreate",
  "body": [
   "$$barrierHandle=BarrierCreate($$barrierName);"
  ],
  "description": "\n\nCreates a barrier object, used to synchronize multiple cells. Barrier description must be unique among active barriers.\n\n\n\n\n\nCells are added to the barrier's participant list with the BarrierAddParticipant() function. When a cell reaches the barrier (by calling the BarrierSignalAndWait() function), it will pause until ALL cells in the participant list reach the barrier and signal as well.\n\n\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$barrierName\n\nString\n\nUnique name for the barrier.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariably Type\n\nDescription\n\n\n\n$barrierHandle\n\nObject\n\nVariable holding reference to newly created barrier object.\n\n\n\n\n\nExample:\n\n$barrier1 = BarrierCreate(\"1st Test Barrier\"); //create barrier named \u201c1st Test Barrier\u201d\n\n$barrier2 = BarrierCreate(\"2nd Test Barrier\"); //create barrier named \u201c2nd Test Barrier\u201d\n\n\n\n\n\nBarrierDestroy\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS BarrierDestroy": {
  "prefix": "BarrierDestroy",
  "body": [
   "BarrierDestroy($$barrierHandle);"
  ],
  "description": "\n\nManually disposes of a barrier object. Calls to a disposed barrier will produce an error.\n\n\n\n\n\nThis function is generally unnecessary as the GC will dispose of unused and out-of-scope barriers automatically.\n\n\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$barrierHandle\n\nObject\n\nHandle to barrier object previously created with the BarrierCreate() function.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariably Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\nBarrierDestroy($barrier1); //dispose of barrier object\n\n\n\n\n\nBarrierGetDescription\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS BarrierGetDescription": {
  "prefix": "BarrierGetDescription",
  "body": [
   "$$barrierName=BarrierGetDescription($$barrierHandle);"
  ],
  "description": "\n\nRetrieves the name/description of the barrier. This will be same string as the $barrierName argument of the BarrierCreate() function that produced the barrier object.\n\n\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$barrierHandle\n\nObject\n\nHandle to barrier object previously created with the BarrierCreate() function.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariably Type\n\nDescription\n\n\n\n$barrierName\n\nString\n\nName/description of barrier object.\n\n\n\n\n\nExample:\n\n$barrier1 = BarrierCreate(\"1st Test Barrier\"); //create barrier named \u201c1st Test Barrier\u201d\n\n$barrierName = BarrierGetDescription($barrier1);\n\nUpdateStatus($barrierName); //prints out \u201c1st Test Barrier\u201d\n\n\n\n\n\nBarrierGetParticipantCount\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS BarrierGetParticipantCount": {
  "prefix": "BarrierGetParticipantCount",
  "body": [
   "$$participantCount=BarrierGetParticipantCount($$barrierHandle);"
  ],
  "description": "\n\nGets the current number of cells in the barrier's participant list.\n\n\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$barrierHandle\n\nObject\n\nHandle to barrier object previously created with the BarrierCreate() function.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariably Type\n\nDescription\n\n\n\n$participantCount\n\nInteger\n\n# of cells in barrier's participant list.\n\n\n\n\n\nExample:\n\n$barrier1 = BarrierCreate(\"1st Test Barrier\"); //create barrier named \u201c1st Test Barrier\u201d\n\n$participantCount = BarrierGetParticipantCount($barrier1);\n\nUpdateStatus($participantCount); //prints out \u201c0\u201d - if this is only cell adding to list!\n\nBarrierAddParticipant($barrier1); //adds this cell to 1st barrier\u2019s participant list\n\n$participantCount = BarrierGetParticipantCount($barrier1);\n\nUpdateStatus($participantCount); //prints out \u201c1\u201d - if this is only cell adding to list!\n\n\n\n\n\nBarrierGetPhaseNumber\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS BarrierGetPhaseNumber": {
  "prefix": "BarrierGetPhaseNumber",
  "body": [
   "$$phaseNumber=BarrierGetPhaseNumber($$barrierHandle);"
  ],
  "description": "\n\nGets current phase of the barrier.\n\n\n\n\n\nThe phase is a type of loop counter that records the number of times all cells in the barrier\u2019s participant list have passed through the barrier, due to timeouts or signaling.\n\n\n\n\n\nThis value can be used to track how many times the expected synchronized behavior has been executed by all relevant cells. E.g., it can be checked by a cell that times out to see if the other cells are still waiting for it. If the phase number has not increased, the cell knows that the other cells might be \u201cstuck\u201d at the barrier waiting for it to signal or remove itself from the participant list.\n\n\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$barrierHandle\n\nObject\n\nHandle to barrier object previously created with the BarrierCreate() function.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariably Type\n\nDescription\n\n\n\n$phaseNumber\n\nInteger\n\nCurrent phase number.\n\n\n\n\n\nExample:\n\n$phaseNumber1 = BarrierGetPhaseNumber($barrier1);\n\n$signalReceived = BarrierSignalAndWait($barrier1, 10000, false); //timeout after 10 seconds\n\n$phaseNumber2 = BarrierGetPhaseNumber($barrier1);\n\nif($phaseNumber1 == $phaseNumber2)\n\n{\n\nUpdateStatus(\u201cTimeout occurred!\u201d);\n\n}\n\n\n\n\n\nBarrierRemoveParticipant\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS BarrierRemoveParticipant": {
  "prefix": "BarrierRemoveParticipant",
  "body": [
   "BarrierRemoveParticipant($$barrierHandle);"
  ],
  "description": "\n\nRemoves cell from barrier's participant list, lowering the number of signals needed for waiting cells to continue.\n\n\n\n\n\nTest cells that have been removed from the barrier\u2019s participant list will not wait on a BarrierSignalAndWait() call. In addition, any test cells that are paused because of a barrier that was waiting on this cell will continue.\n\n\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$barrierHandle\n\nObject\n\nHandle to barrier object previously created with the BarrierCreate() function.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariably Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\nBarrierRemoveParticipant($barrier1); //removes this cell from the 1st barrier\u2019s participant list\n\n\n\n\n\nBarrierSignalAndWait\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS BarrierSignalAndWait": {
  "prefix": "BarrierSignalAndWait",
  "body": [
   "$$signalReceived=BarrierSignalAndWait($$barrierHandle$$timeout]$$autoRemove]);"
  ],
  "description": "\n\nSignals that the cell has reached the barrier. If the cell is in the barrier participant list, it will wait until every other cell in the barrier's participant list signals an arrival as well, or the timeout time elapses; whichever occurs first.\n\n\n\n\n\nIf the $autoRemove parameter is true, cells will remove themselves from the barrier participant list after they pass through the barrier.\n\n\n\n\n\nNote:\n\nCells that time out do NOT automatically remove themselves from the list or decrement the participant wait count (unless $autoRemove is true). If you select a non-infinite timeout value, be sure to check the state of the $signalReceived return parameter to check for a timeout condition and handle it appropriately (e.g., removing the timing out cell from the participant list, or retrying the BarrierSignalAndWait() call). Failure to do so can lead to other cells deadlocking at the barrier!\n\n\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$barrierHandle\n\nObject\n\nHandle to barrier object previously created with the BarrierCreate() function.\n\n\n\n$timeout\n\nInteger\n\n[optional] Maximum time to wait at a closed barrier, in milliseconds. A timeout value of 0 or less indicates an infinite timeout.\n\n\n\n$autoRemove\n\nBoolean\n\n[optional, if $timeout present] Whether or not to automatically remove a cell from the barrier's participant list after it passes through the barrier.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariably Type\n\nDescription\n\n\n\n$signalReceived\n\nBoolean\n\nTrue if all other cells in participant list reached the barrier (cells removed from the participant list with BarrierRemovedParticipant() do not count).\n\n\n\n\n\nFalse in all other cases which cause the cell to continue past the barrier (such as when the timeout expires).\n\n\n\n\n\nExample:\n\n$signalReceived = BarrierSignalAndWait($barrier1, 0, false); //wait indefinitely for other cells in list\n\n\n\n\n\nEnterCS\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS EnterCS": {
  "prefix": "EnterCS",
  "body": [
   "EnterCS($$criticalSectionName);"
  ],
  "description": "\n\nThis is a special instruction to the script interpreter which informs it that this particular script is entering a section of code that has been dubbed a critical section. This script function is used when multiple cells are running a common test script and need certain points of mutual exclusion such as sharing test equipment, etc. The EnterCS function will have the following effect on script execution, depending on the condition of other test cells which may or may not currently be executing the code in the critical section. Only one cell is allowed to execute a critical section at a time.\n\nIn the event that no other cells are currently in the critical section of code, this cell enters the critical section and locks out all other cells from proceeding until the current script execution encounters an ExitCS() statement closing the critical section, or the script terminates with either a pass/fail/abort status.\n\nIn the event that another cell is currently in the critical section of code, this cell will block and wait for the critical section to become available. If several cells are waiting to enter the critical section of code, they will all queue in the order that they attempted to access the critical section. A linked list is maintained which serves as a FIFO for the cells waiting to enter the critical section.\n\nThe parameter $critcalSectionName is an arbitrary value chosen by the script author to differentiate among different critical sections in the same script file. If more than one critical section is used in a script file, care must be taken by the script author to ensure that a deadlock condition can't occur. In the event of a deadlock condition, the script will enter an endless loop and never terminate.\n\nEach EnterCS() command must have a corresponding ExitCS() command for proper use of critical sections of code.\n\nExample:\n\nEnterCS(\"My Critical Section\");\n\nUpdateStatus(\"Only One Cell At a Time May Enter this Section\");\n\nSleep(5);\n\nExitCS(\"My Critical Section\");...\n\n\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$criticalSectionName\n\nString\n\nThe arbitrary name given to a critical section of code.\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExitCS\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ExitCS": {
  "prefix": "ExitCS",
  "body": [
   "ExitCS($$criticalSectionName);"
  ],
  "description": "\n\nThis is a special instruction to the script interpreter which informs it that this particular script is exiting a section of code that has been dubbed a critical section. This script function is used when multiple cells are running a common test script and need certain points of mutual exclusion such as sharing test equipment, etc. Only one cell is allowed to execute a critical section at a time.\n\nIn the event that no other cells are currently waiting for the criticalSection, the ExitCS statement merely removes the current cell from the queue.\n\nIn the event that one or more cells are currently waiting for the critical Section, the ExitCS statement removes the current cell from the queue, and sends a notification to all the waiting cells that they are allowed to proceed. The cell that first executed the EnterCS() statement will proceed first through the critical section, and all other cells will follow in the order they were queued.\n\nThe parameter $critcalSectionName is an arbitrary value chosen by the script author to differentiate among different critical sections in the same script file. If more than one critical section is used in a script file, care must be taken by the script author to ensure that a deadlock condition can't occur. In the event of a deadlock condition, the script will enter an endless loop and never terminate.\n\nEach ExitCS() command must have a corresponding EnterCS() command for proper use of critical sections of code.\n\nExample:\n\nEnterCS(\"My Critical Section\");\n\nUpdateStatus(\"Only One Cell At a Time May Enter this Section\");\n\nSleep(5);\n\nExitCS(\"My Critical Section\");...\n\n\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$criticalSectionName\n\nString\n\nThe arbitrary name given to a critical section of code.\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nQuickEnterCS\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS QuickEnterCS": {
  "prefix": "QuickEnterCS",
  "body": [
   "QuickEnterCS($$mutexName$$timeout]);"
  ],
  "description": "\n\nMutexes (from Mutual Exclusion) are used to implement efficient critical sections, which are blocks of code that can be executed by only one cell at a time.\n\n\n\n\n\nThis function attempts to give control of the named system mutex to the calling cell, which allows the cell past this function and into the critical section it protects.\n\n\n\n\n\nOnly one cell at a time can enter the critical section; other cells are blocked from entering until either the owning cell exits the critical section with a call to the QuickExitCS() function (releasing ownership of the mutex), the owning cell ends execution (abandoning the mutex), or the waiting cell(s) timeout expires.\n\n\n\n\n\nCare must be taken when using multiple critical sections to avoid deadlocks! A deadlocked cell will be blocked indefinitely, until the Jabil Test executive is closed.\n\n\n\n\n\nNote:\n\nFIFO execution is not guaranteed with these functions! If multiple cells are waiting to enter the critical section, there is no guarantee the first cell blocked will be the first cell to resume. If FIFO operation is required, use the slower EnterCS()/ExitCS() functions.\n\n\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$mutexName\n\nString\n\nName of system mutex used in the MutexCreate() function. Can be any arbitrary string.\n\n\n\n$timeout\n\nInteger\n\n[optional] Maximum time to wait for an owned mutex to be released before skipping ownership request and entering the critical section.\n\n\n\n\n\nA value of 0 or less indicates an infinite timeout period - the cell will block indefinitely until it gains ownership of the mutex.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariably Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\nQuickEnterCS(\u201cPS Critical Section\u201d, 0); //Wait indefinitely for chance to enter critical section\n\n//Critical Section code here\n\n\n\n\n\nQuickExitCS\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS QuickExitCS": {
  "prefix": "QuickExitCS",
  "body": [
   "QuickExitCS($$mutexName);"
  ],
  "description": "\n\nReleases ownership of the named system mutex, allowing other cells to enter the critical section protected by the QuickEnterCS() call with the same mutex name.\n\n\n\n\n\nNote:\n\nIf a test cell fails while inside a critical section (preventing this function from being called), the mutex will be abandoned by the cell when execution stops. This allows another test cell to claim the mutex and enter the critical section, preventing a potential deadlock.\n\n\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$mutexName\n\nString\n\nName of system mutex used in the QuickEnterCS() function.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariably Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n//Critical Section code here\n\nQuickExitCS(\u201cPS Critical Section\u201d); //releases ownership of mutex, allowing other cells into the CS code above\n\n\n\n\n\nWaitEventCreate\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS WaitEventCreate": {
  "prefix": "WaitEventCreate",
  "body": [
   "$$waitHandle=WaitEventCreate($$eventName);"
  ],
  "description": "\n\nCreates an object based on the EventWaitHandle class, used to synchronize multiple cells. The event description must be unique among active wait events.\n\n\n\n\n\nWait events act like gates, allowing cell execution to continue past them when the wait signal is set (turned on) with WaitEventRelease() and blocking cells when the wait signal is reset (turned off) with WaitEventHold(). Cells attempt to wait at these \"gates\" using calls to WaitOnEvent().\n\n\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$eventName\n\nString\n\nUnique name for the event.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariably Type\n\nDescription\n\n\n\n$waitHandle\n\nObject\n\nVariable holding reference to newly created wait event object.\n\n\n\n\n\nExample:\n\n$waitEvent1 = WaitEventCreate(\"1st Wait Event\"); //create a wait event named \u201c1st Wait Event\u201d\n\n$waitEvent2 = WaitEventCreate(\"2nd Wait Event\"); //create a wait event named \u201c2nd Wait Event\u201d\n\n\n\n\n\nWaitEventDestroy\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS WaitEventDestroy": {
  "prefix": "WaitEventDestroy",
  "body": [
   "WaitEventDestroy($$waitHandle);"
  ],
  "description": "\n\nManually disposes of wait event. Calls to a disposed event will produce an error. This function is generally unnecessary as the GC will automatically dispose of unused events.\n\n\n\n\n\nRemarks:\n\nDisposing of a wait event will release all other test cells that are waiting for this event.\n\nThe $waitHandle must have been previously created using the WaitEventCreate function.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$waitHandle\n\nObject\n\nThe previously created Wait Event.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n\n\n\n\n// Create a wait event, wait for the event for 2 seconds, then destroy the event.\n\n$eventName = \"FirstWaitEvent\";\n\n$timeout = 2000;\n\n\n\n$waitHandle = WaitEventCreate($eventName);\n\n\n\n$signalReceived = WaitOnEvent($waitHandle, $timeout);\n\n\n\nif ($signalReceived)\n\n{\n\nUpdateStatus(\"The event signal was received.\");\n\n}\n\n\n\nWaitEventDestroy($waitHandle);\n\n\n\n\n\nWaitEventHold\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS WaitEventHold": {
  "prefix": "WaitEventHold",
  "body": [
   "WaitEventHold($$waitHandle);"
  ],
  "description": "\n\nClears (turns off) the wait event object\u2019s signal. All cells calling WaitOnEvent() on this object will block until released with a call to WaitEventRelease().\n\n\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$waitHandle\n\nObject\n\nWait event object previously created with the WaitEventCreate() function.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariably Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\nWaitEventHold($waitEvent1); //block all cells calling WaitOnEvent($waitEvent1)\n\n\n\n\n\nWaitEventRelease\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS WaitEventRelease": {
  "prefix": "WaitEventRelease",
  "body": [
   "WaitEventRelease($$waitHandle);"
  ],
  "description": "\n\nSets (turns on) WaitObject signal. Cells that call WaitOnEvent() on this object (or any cells that are currently blocked by a previous call) will continue.\n\n\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$waitHandle\n\nObject\n\nWait event object previously created with the WaitEventCreate() function.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariably Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\nWaitEventRelease($waitEvent1); //allow all cells calling WaitOnEvent($waitEvent1) to continue\n\n\n\n\n\nWaitOnEvent\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS WaitOnEvent": {
  "prefix": "WaitOnEvent",
  "body": [
   "$$signalRecieved=WaitOnEvent($$waitHandle$$timeout]);"
  ],
  "description": "\n\nBlocks cells calling this function until the wait event signal for the object is set with a call to WaitEventRelease(), or the timeout elapses.\n\n\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$waitHandle\n\nObject\n\nWait event object previously created with the WaitEventCreate() function.\n\n\n\n$timeout\n\nInteger\n\n[optional] Timeout for each cell to wait for the event signal to be set, in milliseconds.\n\n\n\n\n\nValues of 0 or less indicate an infinite timeout period.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariably Type\n\nDescription\n\n\n\n$signalRecieved\n\nBoolean\n\nTrue if the event signal was received (a call to WaitEventRelease() occurred.\n\n\n\n\n\nFalse if the timeout expired or an error occurred.\n\n\n\n\n\nExample:\n\n$signalReceived = WaitOnEvent($waitEvent1, 10000); //block for 10s if the wait event signal is not set\n\n\n\n\n\nPlaySoundFile\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS PlaySoundFile": {
  "prefix": "PlaySoundFile",
  "body": [
   "$$SoundHandle=PlaySoundFile($$SoundFilePath);"
  ],
  "description": "\n\nThis function supports the playback of WAV, MP3 or MIDI files from the test executive. It uses the default WaveOut device specified in the Windows configuration settings. In the event that the file is not found, or is an unsupported sound file format, a failure is returned to the test executive interpreter. Otherwise a pass is returned. The function returns a handle to the current sound file playing so that it can be later stopped using the StopSoundFile function.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$SoundFilePath\n\nString\n\nThe filename and path of the sound file to play (e.g. c:\\\\testfrequency.wav)\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$SoundHandle\n\nObject\n\nReturns a handle to the Sound File currently being played\n\n\n\n\n\nRecordSoundFile\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS RecordSoundFile": {
  "prefix": "RecordSoundFile",
  "body": [
   "RecordSoundFile($$SoundFilePath,$$CaptureDeviceID,$$NumberOfChannels,$$BitsPerSample,$$SamplesPerSecond,$$RecordDuration);"
  ],
  "description": "\n\nThis function is used to capture a WAV file from the a Wave Capture device such as Microphone or Line-In input on a sound card. In the event of an error, a failing result is returned to the test executive interpreter. In the event that the recording is successful, a pass result is returned to the test executive interpreter.\n\nExample:\n\nRecordSoundFile(\"c:\\\\test.wav\", 0, 1, 8, 22000, 5);\n\nThe example above will record a mono 8-bit sampled input at 22,0000 samples per second for 5 seconds. The results will be stored in a WAV file at c:\\test.wav.\n\nNote: This command requires the Microsoft DirectX SDK to be installed on the computer running Jabil Test. If the Operating System is Windows 7 x64 edition, then Jabil Test will need to be run as an administrator to use this command due to the heightened privileges required for low-level access to sound hardware in the newer versions of Microsoft Windows.\n\nThis library was last tested with the July 2010 release of the Microsoft DirectX SDK.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$SoundFilePath\n\nString\n\nThe filename and path of the sound file to play (e.g. c:\\\\testfrequency.wav)\n\n\n\n$CaptureDeviceID\n\nInteger\n\nThe ID of the capture device to be used. The default windows Wave-In device is assigned the capture ID of 0, so this parameter will usually be 0.\n\n\n\n$NumberOfChannels\n\nInteger\n\nThe number of channels to record in the Wave File.\n\n1 = \"Mono\"\n\n2 = \"Stereo\n\n\n\n$BitsPerSample\n\nInteger\n\nThe number of bits per sample. Supported values are 8, and 16.\n\n\n\n$SamplesPerSecond\n\nInteger\n\nThe number of samples per second.\n\n\n\n$RecordDuration\n\nInteger\n\nThe number of seconds to record.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$SoundHandle\n\nObject\n\nReturns a handle to the Sound File currently being played\n\n\n\n\n\nRecordSourceSelect\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Multimedia.RecordSourceSelect": {
  "prefix": "Multimedia.RecordSourceSelect",
  "body": [
   "Multimedia.RecordSourceSelect($$Device,$$Line);"
  ],
  "description": "\n\nThis function is used to select the which of the available recording line is to be used for Recording.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Device\n\nString\n\nThis is the name of the device which is default. I left blank function will fail and error message will list available device\n\n\n\n$Line\n\nString\n\nThis is the name of the device which is default. I left blank function will fail and error message will list available device\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nStopSoundFile\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS StopSoundFile": {
  "prefix": "StopSoundFile",
  "body": [
   "StopSoundFile($$SoundHandle);"
  ],
  "description": "\n\nThis function stops the playback of a particular sound file which has been started with the PlaySoundFile function. In the event that the passed in object can't be casted to an IMediaControl interface, an error is returned to the test executive interpreter.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$SoundHandle\n\nObject\n\nA handle to the sound file for which to terminate playback.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nAnalyzeWaveFileAmplitude\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AnalyzeWaveFileAmplitude": {
  "prefix": "AnalyzeWaveFileAmplitude",
  "body": [
   "($$Amplitude,$$HighValue,$$LowValue)=AnalyzeWaveFileAmplitude($$SoundFilePath);"
  ],
  "description": "\n\nThis function analyzes a recorded WAV file and returns it's amplitude as well as it's peak data values. The WAV file must be a MONO 8-BIT RIFF encoded wave form. All sample rates are supported.\n\nNote: This function requires the Lab View 6.1 runtime to be installed since it uses libraries out of the LabView signal analysis library.\n\nThis function relies on the LabVIEW 6.1 runtime that can not be loaded on Windows 7+. This function can not be used on Windows 7+ computers.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$soundFilePath\n\nString\n\nThe file path and file name to the WAV file to be analyzed.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Amplitude\n\nfloat\n\nThe primary frequency component of the WAV file measured in Hertz\n\n\n\n$HighValue\n\nfloat\n\nThe highest peak value found in the wave file data\n\n\n\n$LowValue\n\nfloat\n\nThe lowest peak value found in the wave file data\n\n\n\n\n\nAnalyzeWaveFileAmplitudeAtFrequency\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AnalyzeWaveFileAtFrequency": {
  "prefix": "AnalyzeWaveFileAtFrequency",
  "body": [
   "$$value=AnalyzeWaveFileAtFrequency($$SoundFilePath,$$Frequency);"
  ],
  "description": "\n\nThis function performs a fast fourier-transform on the data contained in the WAV file specified in the $SoundFilePath variable. The WAV file must be a MONO 8-BIT RIFF encoded wave form. All sample rates are supported. The value returned should only be considered a relative value that is suitable for comparisons with measurements taken on the same computer and sound card.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$soundFilePath\n\nString\n\nThe file path and file name to the WAV file to be analyzed.\n\n\n\n$Frequency\n\nFloat\n\nThe desired frequency at which to compute the relative amplitude.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$value\n\nfloat\n\nThe amplitude (relative value) of the file at the supplied frequency.\n\n\n\n\n\nAnalyzeWaveFileFrequency\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AnalyzeWaveFileFrequency": {
  "prefix": "AnalyzeWaveFileFrequency",
  "body": [
   "$$value=AnalyzeWaveFileFrequency($$SoundFilePath);"
  ],
  "description": "\n\nThis function performs a fast fourier-transform on the data contained in the WAV file specified in the $SoundFilePath variable. The WAV file must be a MONO 8-BIT RIFF encoded wave form. All sample rates are supported. The primary frequency component contained in the WAV file data is returned to the test executive. The measurement returned is in Hertz.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$soundFilePath\n\nString\n\nThe file path and file name to the WAV file to be analyzed.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$value\n\nfloat\n\nThe primary frequency component of the WAV file measured in Hertz\n\n\n\n\n\nAudio_ReadWaveFile\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Audio_ReadWaveFile": {
  "prefix": "Audio_ReadWaveFile",
  "body": [
   "($$sampleRate,$$Data,$$Length,$$numChannels)=Audio_ReadWaveFile($$fileName);"
  ],
  "description": "\n\nThis function will read a WAVE file and return the data in a 2D array. This function will work with 8, 16, 24 and 32 bits/sample files with any number of channels. Each channel will be returned as one row in the output array.The data is returned in an array of integers.\n\n\n\nRemarks:\n\n\u00b7 The data is returned in an array of integers.\n\n\u00b7 If the file has only one channel, the data will be returned in the left channel (row index 0) and the right channel (row index 1) will be filled with zeroes.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$fileName\n\nString\n\nThe path and filename of the .WAV file to load.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$sampleRate\n\nInteger\n\nThe sample rate for the audio data (from the header data in the WAV file).\n\n\n\n$Data\n\nArray\n\nThe audio data in a 2D array with one row for each channel.\n\n\n\n$Length\n\nInteger\n\nThe number of samples for each channel.\n\n\n\n$numChannels\n\nInteger\n\nThe number of audio channels in the WAV file.\n\n\n\n\n\nExample:\n\n// Read an audio file.\n\n$fileName = \"C:\\\\Samples\\\\AudioFile1.wav\";\n\n($sampleRate, $Data, $Length, $numChan) = Audio_ReadWaveFile($fileName);\n\n\n\n\n\nConvertWaveFileToArray\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ConvertWaveFileToArray": {
  "prefix": "ConvertWaveFileToArray",
  "body": [
   "($$SampleRate,$$Data,$$Length)=ConvertWaveFileToArray(\"c:\\\\1KHi.wav\");"
  ],
  "description": "\n\nThis function converts the wave form data into an array of floats. The function returns the array, the length of the array, as well as the sample rate of the wave file.\n\nThis function only works with 8 bits/sample data files.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$soundFilePath\n\nString\n\nThe file path and file name to the WAV file to be analyzed.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$SampleRate\n\nInteger\n\nThe number of samples per second that the input wave file was recorded at.\n\n\n\n$Data\n\nArray\n\nAn array of floats containing the wave file data\n\n\n\n$Length\n\nInteger\n\nThe total number of items in the returned $Data array.\n\n\n\n\n\nSplitWaveFile\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SplitWaveFile": {
  "prefix": "SplitWaveFile",
  "body": [
   "SplitWaveFile($$InputFile,$$OutputFile1,$$OutputFile2);"
  ],
  "description": "\n\nThis function reads in a PCM formatted stereo wave file and splits the wave file into two mono-wave files for each sound channel.\n\n\n\n\n\nThe output files are stored to disk for analysis or data retention.\n\n\n\n\n\nRemarks:\n\nThis function only works with 8 bits/sample data files.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InputFile\n\nString\n\nThe filepath and name of the input file\n\n\n\n$OutputFile1\n\nString\n\nThe file path and name of the first output file (Left Channel)\n\n\n\n$OutputFile2\n\nString\n\nThe file path and name of the second output file (Right Channel)\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nUsage Example:\n\nSplitWaveFile(\"c:\\\\inputfile1.wav\", \"c:\\\\outputwave1.wav\", \"c:\\\\outputwave2.wav\");\n\n\n\n\n\nFTPCreateDirectory\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS FTPCreateDirectory": {
  "prefix": "FTPCreateDirectory",
  "body": [
   "FTPCreateDirectory($$ServerURL,$$DirName,$$UserName,$$Password);"
  ],
  "description": "\n\nThis function can be used to create a directory on an FTP server.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ServerURL\n\nString\n\nThe URL of the server. This should be in the format \"ftp://ftp.jabil.com/\"\n\n\n\n$DirName\n\nString\n\nThe name of the new directory.\n\n\n\n$UserName\n\nString\n\nThe username to supply as a credential to the FTP server.\n\n\n\n$Password\n\nString\n\nThe password to supply as a credential to the FTP server.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$status\n\nBoolean\n\nReturns true if directory is successfully created, false otherwise\n\n\n\n\n\nExample:\n\n\n\n$status = FTPCreateDirectory(\"ftp://ftp.jabil.com/\",\"newDirectory\",\"un\",\"pw\");\n\n\n\n\n\nFTPDeleteDirectory\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS FTPDeleteDirectory": {
  "prefix": "FTPDeleteDirectory",
  "body": [
   "FTPDeleteDirectory($$ServerURL,$$DirName,$$UserName,$$Password);"
  ],
  "description": "\n\nThis function can be used to delete a directory on an FTP server.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ServerURL\n\nString\n\nThe URL of the server. This should be in the format \"ftp://ftp.jabil.com/\"\n\n\n\n$DirName\n\nString\n\nThe name of the directory to delete.\n\n\n\n$UserName\n\nString\n\nThe username to supply as a credential to the FTP server.\n\n\n\n$Password\n\nString\n\nThe password to supply as a credential to the FTP server.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$status\n\nBoolean\n\nReturns true if directory is successfully deleted, false otherwise\n\n\n\n\n\nExample:\n\n\n\n$status = FTPDeleteDirectory(\"ftp://ftp.jabil.com/\",\"Directory\",\"un\",\"pw\");\n\n\n\n\n\nFTPDeleteRemoteFile\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS FTPDeleteRemoteFile": {
  "prefix": "FTPDeleteRemoteFile",
  "body": [
   "$$status=FTPDeleteRemoteFile($$serverURL,$$remoteFileName,$$userName,$$password);"
  ],
  "description": "\n\n\n\n\n\nDeletes specified file from FTP server.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$serverURL\n\nString\n\nURL of FTP server. Must start with \"ftp://\"\n\n\n\n$remoteFileName\n\nString\n\nPath and filename of file to be delete.\n\n\n\n$userName\n\nString\n\nFTP server username.\n\n\n\n$password\n\nString\n\nPassword for username.\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$status\n\nBoolean\n\nReturns true is file successfully delete, false otherwise.\n\n\n\n\n\nExample:\n\n$ServerURL = \"ftp://10.0.0.1/\";\n\n$RemoteFileName = \"EXAMPLE.TXT\";\n\n$UserName = \"test\";\n\n$Password = \"password\";\n\n\n\n\n\n$status = FTPDeleteRemoteFile($ServerURL,$RemoteFileName,$UserName,$Password);\n\n\n\n\n\nFTPDownloadFile\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS FTPDownloadFile": {
  "prefix": "FTPDownloadFile",
  "body": [
   "$$BytesTransferred=FTPDownloadFile($$ServerURL,$$LocalFileName,$$RemoteFileName,$$UserName,$$Password,$$TransferMode);"
  ],
  "description": "\n\nThis function can be used to download a file from an FTP server and save it to a specified file name, if the transfer is successful, the function returns the number of bytes transferred by the operation.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ServerURL\n\nString\n\nThe URL of the server on which the file to download resides. This should be in the format \"ftp://ftp.jabil.com/\"\n\n\n\n$LocalFileName\n\nString\n\nThe local filename which to save the downloaded file, for instance \"c:\\\\mylocation\\\\myfile.zip\"\n\n\n\n$RemoteFileName\n\nString\n\nThe remote path and filename, for instance \"pub/downloads/myfile.zip\";\n\n\n\n$UserName\n\nString\n\nThe username to supply as a credential to the FTP server.\n\n\n\n$Password\n\nString\n\nThe password to supply as a credential to the FTP server.\n\n\n\n$TransferMode\n\nString\n\nThe desired transfer mode. The valid options are:\n\n\u00b7 \"BINARY\"\n\n\u00b7 \"ASCII\"\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$BytesTransferred\n\nInteger\n\nThe Number of Bytes Transferred during the FTP File Download.\n\n\n\n\n\nExample:\n\n\n\n$TotalSize = FTPDownloadFile(\"ftp://ftp.jabil.com/\",\"c:\\\\myfile.zip\",\"pub/myfile.zip\",\"Dan\",\"Password\",\"BINARY\");\n\n\n\n\n\nFTPGetFileSize\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS FTPGetFileSize": {
  "prefix": "FTPGetFileSize",
  "body": [
   "$$Size=FTPGetFileSize($$ServerURL,$$FileName,$$UserName,$$Password);"
  ],
  "description": "\n\nThis function can be used retrieve the size of a file (bytes) from an FTP server.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ServerURL\n\nString\n\nThe URL of the server including the directory in which the file resides. This should be in the format \"ftp://ftp.jabil.com/filedirectory/\"\n\n\n\n$FileName\n\nString\n\nThe name of the file.\n\n\n\n$UserName\n\nString\n\nThe username to supply as a credential to the FTP server.\n\n\n\n$Password\n\nString\n\nThe password to supply as a credential to the FTP server.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Size\n\nString\n\nThe size of the file in bytes\n\n\n\n\n\nExample:\n\n\n\n$Size= FTPGetFileSize(\"ftp://ftp.jabil.com/directory\",\"fileName.txt\",\"un\",\"pw\");\n\n\n\n\n\nFTPListDirectory\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS FTPListDirectory": {
  "prefix": "FTPListDirectory",
  "body": [
   "($$numFiles,filelistArray)=FTPListDirectory($$directoryUrl,$$username,$$password);"
  ],
  "description": "\n\n\n\nReturns the directory contents of the URL specified as a list of strings, along with the number of items found.\n\n\n\nRemarks:\n\n\u00b7 If the directory is not found or the user does not have read access to the directory, the test generates a failure.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$directoryUrl\n\nString\n\nURL of the directory on the FTP server to list. Format should be \"ftp://ftp.jabil.com/directory/\"\n\n\n\n$username\n\nString\n\nName of user on FTP server.\n\n\n\n$password\n\nString\n\nPassword for user on FTP server.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$numFiles\n\nInteger\n\nThe number of files/directories found in the directory.\n\n\n\n$filelistArray\n\nArray\n\nA one-row 2D array (string[1,X]) of file/directory names.\n\n\n\n\n\nExamples:\n\n\n\n\n\n($numFiles, $fileArray) = FTPListDirectory(\"ftp://localhost/\",\"root\",\"password\");\n\nUpdateStatus(\"Number of items:\");\n\nUpdateStatus($numFiles);\n\n\n\n\n\n$index = 0;\n\n$dirString = \"\\n@\";\n\nLabel Loop:\n\n$Value = ArrayGetValue($fileArray, 0, $index);\n\n$dirString = $dirString + \"\\n\" + $Value;\n\n$index = $index + 1;\n\nif($index < $numFiles)\n\n{\n\ngoto Loop;\n\n}\n\n\n\n\n\n$dirString = $dirString + \"\\n@\\n\";\n\nUpdateStatus($dirString);\n\n\n\n\n\nFTPRenameDirectory\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS FTPRenameDirectory": {
  "prefix": "FTPRenameDirectory",
  "body": [
   "FTPRenameDirectory($$ServerURL,$$oldName,$$newName,$$UserName,$$Password);"
  ],
  "description": "\n\nThis function can be used to rename a directory on an FTP server.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ServerURL\n\nString\n\nThe URL of the server. This should be in the format \"ftp://ftp.jabil.com/\"\n\n\n\n$oldName\n\nString\n\nThe original name of the directory to rename.\n\n\n\n$newName\n\nString\n\nThe new name of the directory.\n\n\n\n$UserName\n\nString\n\nThe username to supply as a credential to the FTP server.\n\n\n\n$Password\n\nString\n\nThe password to supply as a credential to the FTP server.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$status\n\nBoolean\n\nReturns true if directory is successfully renamed, false otherwise\n\n\n\n\n\nExample:\n\n\n\n$status = FTPRenameDirectory(\"ftp://ftp.jabil.com/\",\"oldName\", \"newName\",\"un\",\"pw\");\n\n\n\n\n\nFTPRenameFile\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS FTPRenameFile": {
  "prefix": "FTPRenameFile",
  "body": [
   "FTPRenameFile($$ServerURL,$$oldName,$$newName,$$UserName,$$Password);"
  ],
  "description": "\n\nThis function can be used to rename a file on an FTP server.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ServerURL\n\nString\n\nThe URL of the server. This should be in the format \"ftp://ftp.jabil.com/\"\n\n\n\n$oldName\n\nString\n\nThe original name of the file to rename.\n\n\n\n$newName\n\nString\n\nThe new name of the file.\n\n\n\n$UserName\n\nString\n\nThe username to supply as a credential to the FTP server.\n\n\n\n$Password\n\nString\n\nThe password to supply as a credential to the FTP server.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$status\n\nBoolean\n\nReturns true if file is successfully renamed, false otherwise\n\n\n\n\n\nExample:\n\n\n\n$status = FTPRenameFile(\"ftp://ftp.jabil.com/\",\"oldName\", \"newName\",\"un\",\"pw\");\n\n\n\n\n\nFTPUploadFile\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS FTPUploadFile": {
  "prefix": "FTPUploadFile",
  "body": [
   "$$BytesTransferred=FTPUploadFile($$ServerURL,$$LocalFileName,$$UserName,$$Password,$$TransferMode);"
  ],
  "description": "\n\nThis function can be used to upload a file to an FTP server, if the transfer is successful, the function returns the number of bytes transferred by the operation.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ServerURL\n\nString\n\nThe URL of the server on which to upload the file. This should be in the format \"ftp://ftp.jabil.com/\"\n\n\n\n$LocalFileName\n\nString\n\nThe local filename to upload to the server, for instance \"c:\\\\mylocation\\\\myfile.zip\"\n\n\n\n$UserName\n\nString\n\nThe username to supply as a credential to the FTP server.\n\n\n\n$Password\n\nString\n\nThe password to supply as a credential to the FTP server.\n\n\n\n$TransferMode\n\nString\n\nThe desired transfer mode. The valid options are:\n\n\u00b7 \"BINARY\"\n\n\u00b7 \"ASCII\"\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$BytesTransferred\n\nInteger\n\nThe Number of Bytes Transferred during the FTP File Upload.\n\n\n\n\n\nExample:\n\n\n\n$TotalSize = FTPUploadFile(\"ftp://ftp.jabil.com/\", \"c:\\\\myfile.zip\", \"Dan\", \"Password\", \"BINARY\");\n\n\n\n\n\nFileDownload\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS FileDownload": {
  "prefix": "FileDownload",
  "body": [
   "FileDownload($$sourceLocation,$$destination);"
  ],
  "description": "\n\nThis function will download a file using the HTTP protocol and save the file on the local disk.\n\n\n\n\n\nRemarks:\n\nIf the source file does not exist, this function will return an error and fail the script.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$sourceLocation\n\nString\n\nThe URI of the source file to download.\n\n\n\n$destination\n\nString\n\nThe full path (including the file name) to save the downloaded file to.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n// Download a file and save is locally.\n\n$source = \"http://somesite.org/filename.txt\";\n\n$dest = \"C:\\\\Temp\\\\filename.txt\";\n\n\n\n\n\nFileDownload($source, $dest);\n\n\n\n\n\nGetIpAndMacAddresses\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS GetIpAndMacAddresses": {
  "prefix": "GetIpAndMacAddresses",
  "body": [
   "($$networkinfo,$$interfaceCount)=GetIpAndMacAddresses($$ipenabledonly);"
  ],
  "description": "\n\nUses WMI to query and return a table of all local network interfaces with a valid MAC address assigned. The interface name, IP address, and MAC address are returned.\n\n\n\n\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ipenabledonly\n\nBoolean\n\nWhen set to true, only interfaces where TCP/IP has been bound and enabled are listed.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$networkinfo\n\nObject\n\nDataTable of network interface information. The column names are \"Name\", \"IP\", and \"MAC\".\n\n\n\n$interfaceCount\n\nInteger\n\n# of network interfaces found\n\n\n\n\n\nExample:\n\n($networkInfo, $interfaceCount) = GetIpAndMacAddresses(false);\n\nUpdateStatus(\"# of network interfaces:\");\n\nUpdateStatus($interfaceCount);\n\nDataTable_ShowInWindow($networkInfo);\n\n\n\n\n\nGetMacAddressFromIp\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS GetMacAddressFromIp": {
  "prefix": "GetMacAddressFromIp",
  "body": [
   "$$macaddress=GetMacAddressFromIp($$ipaddress);"
  ],
  "description": "\n\nSends an Address Resolution Protocol (ARP) request to obtain the physical address that corresponds to the specified destination IPv4 address. If the information requested is not in the ARP table on the local computer, then the function will cause an ARP request to be sent to obtain the physical address.\n\n\n\n\n\nNote: the physical address of an IPv4 address is only available if the destination IPv4 address is on the local subnet (the IPv4 address can be reached directly without going through any routers). The function will fail if the destination IPv4 address is not on the local subnet.\n\n\n\n\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ipaddress\n\nString\n\nIPv4 address to retrieve the MAC address of.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$macaddress\n\nString\n\nMAC address associated with the IP address.\n\n\n\n\n\nExample:\n\n$ipAddress = \"10.2.49.37\";\n\n$mac = GetMacAddressFromIp($ipAddress);\n\nUpdateStatus($mac);\n\n\n\n\n\nPingTest\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS PingTest": {
  "prefix": "PingTest",
  "body": [
   "$$returnString=PingTest($$target,$$retryCount,$$Delay);"
  ],
  "description": "\n\nAttempts to Ping a target that can be either a DNS name, or IP address, and awaits a response. If a ping is returned, the test generates a status of pass, otherwise a failure is returned. The $retryCount argument specifies the number of attempts to make before failing, and the $Delay argument specifies the time in seconds to pause between each attempt.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$target\n\nString\n\nThe DNS name or IP address for the target to be pinged.\n\n\n\n$retryCount\n\nInteger\n\nThe number of times to attempt the Ping\n\n\n\n$Delay\n\nInteger\n\nThe number of seconds to pause between each re-attempt to ping.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$returnString\n\nString\n\nReturns the a description of the status of the ping, such as \"The ping was not returned\", or \"The ping was returned in [xxxxx] ms.\".\n\n\n\n\n\nPingTestBool\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS PingTestBool": {
  "prefix": "PingTestBool",
  "body": [
   "$$returnBoolean=PingTestBool($$target,$$retryCount,$$Delay);"
  ],
  "description": "\n\nAttempts to Ping a target that can be either a DNS name, or IP address, and awaits a response. The $retryCount argument specifies the number of attempts to make before failing, and the $Delay argument specifies the time in seconds to pause between each attempt.\n\nIf a ping is returned, the function returns a status of TRUE. If no ping is returned on all attempts, the function returns FALSE.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$target\n\nString\n\nThe DNS name or IP address for the target to be pinged.\n\n\n\n$retryCount\n\nInteger\n\nThe number of times to attempt the Ping\n\n\n\n$Delay\n\nInteger\n\nThe number of seconds to pause between each re-attempt to ping.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$returnBoolean\n\nBoolean\n\nIf a ping response is returned, the function returns a status of TRUE. If no ping is returned on all attempts, the function returns FALSE.\n\n\n\n\n\nSendEmail\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SendEmail": {
  "prefix": "SendEmail",
  "body": [
   "SendEmail($$To,$$From,$$CCList,$$BCCList,$$Subject,$$Message,$$Format,$$Priority$$SmtpHost]);"
  ],
  "description": "\n\nThis function sends an email from the test script. Both HTML or TEXT formats are supported.\n\n\n\nRemarks:\n\nTo use multiple email addresses separate them by a comma.\n\nYou can use the SendEmail or SendEmailWithAttachment functions while running a local SMTP server configured for port 25 on the test machine. This can be accomplished by installing the built in IIS SMTP Server on Microsoft Windows, or installing any free SMTP server utility.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$To\n\nString\n\nThe list of email recipients\n\n\n\n$From\n\nString\n\nThe email address the message will be sent from.\n\n\n\n$CCList\n\nString\n\nThe CC List of email addresses (comma delimited).\n\n\n\n$BCCList\n\nString\n\nThe BCC List of email addresses (comma delimited).\n\n\n\n$Subject\n\nString\n\nThe subject of the email.\n\n\n\n$Message\n\nString\n\nThe body of the email.\n\n\n\n$Format\n\nString\n\nThe format of the email message. Supported values are:\n\n\"HTML\"\n\n\"TEXT\"\n\n\n\n$Priority\n\nString\n\nThe priority of the email (only works with outlook). Supported values are:\n\n\"LOW\"\n\n\"NORMAL\"\n\n\"HIGH\"\n\n\n\n$SmtpHost\n\nString\n\nThe name of the SMTP host to send the messages to. This setting is optional. If not supplied, the message will be sent to an SMTP server on the computer running the script.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\n\n\n\n\n// Send email through a server running on the local computer.\n\n$to = \"bob@mail.com, fred@mail.com\";\n\n$from = \"me@jabil.com\";\n\n$cc = \"\";\n\n$bcc = \"\";\n\n$subject = \"Test Message Subject\";\n\n$message = \"This is a test message.\";\n\n$format = \"TEXT\";\n\n$priority = \"HIGH\";\n\nSendEmail($to, $from, $cc, $bcc, $subject, $message, $format, $priority);\n\n\n\n// Send the same email through a remote server (not on the local computer).\n\n$smtp = \"server.name.com\";\n\nSendEmail($to, $from, $cc, $bcc, $subject, $message, $format, $priority, $smtp);\n\n\n\n\n\nSendEmailWithAttachment\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SendEmailWithAttachment": {
  "prefix": "SendEmailWithAttachment",
  "body": [
   "SendEmailWithAttachment($$To,$$From,$$CCList,$$BCCList,$$Subject,$$Message,$$Format,$$Priority,$$SmtpHost,$$Filename);"
  ],
  "description": "\n\nThis function sends an email from the test script. Both HTML or TEXT formats are supported with a single attachment.\n\n\n\nRemarks:\n\nTo use multiple email addresses separate them by a comma.\n\nYou can use the SendEmail or SendEmailWithAttachment functions while running a local SMTP server configured for port 25 on the test machine. This can be accomplished by installing the built in IIS SMTP Server on Microsoft Windows, or installing any free SMTP server utility.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$To\n\nString\n\nThe list of email recipients\n\n\n\n$From\n\nString\n\nThe email address the message will be sent from.\n\n\n\n$CCList\n\nString\n\nThe CC List of email addresses (comma delimited).\n\n\n\n$BCCList\n\nString\n\nThe BCC List of email addresses (comma delimited).\n\n\n\n$Subject\n\nString\n\nThe subject of the email.\n\n\n\n$Message\n\nString\n\nThe body of the email.\n\n\n\n$Format\n\nString\n\nThe format of the email message. Supported values are:\n\n\"HTML\"\n\n\"TEXT\"\n\n\n\n$Priority\n\nString\n\nThe priority of the email (only works with outlook). Supported values are:\n\n\"LOW\"\n\n\"NORMAL\"\n\n\"HIGH\"\n\n\n\n$SmtpHost\n\nString\n\nThe name of the SMTP host to send the messages to. This setting is optional. If left blank, the message will be sent to an SMTP server on the computer running the script.\n\n\n\n$Filename\n\nString\n\nThe path to the file to send as an attachment.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\n\n\n\n\n// Send email through a server running on the local computer.\n\n$to = \"bob@mail.com, fred@mail.com\";\n\n$from = \"me@jabil.com\";\n\n$cc = \"\";\n\n$bcc = \"\";\n\n$subject = \"Test Message Subject\";\n\n$message = \"This is a test message.\";\n\n$format = \"TEXT\";\n\n$priority = \"HIGH\";\n\n$smtp = \"\";\n\n$attach = \"C:\\\\Temp\\\\testfile.zip\";\n\nSendEmailWithAttachment($to, $from, $cc, $bcc, $subject, $message, $format, $priority, $smtp, $attach);\n\n\n\n// Send the same email through a remote server (not on the local computer).\n\n$smtp = \"server.name.com\";\n\nSendEmailWithAttachment($to, $from, $cc, $bcc, $subject, $message, $format, $priority, $smtp, $attach);\n\n\n\n\n\nSetMaxNetworkConnections\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SetMaxNetworkConnections": {
  "prefix": "SetMaxNetworkConnections",
  "body": [
   "SetMaxNetworkConnections($$maxConnections);"
  ],
  "description": "\n\nSets the maximum # of persistent network connections.\n\n\n\n\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$maxConnections\n\nInterger\n\nMaximum # of persistent TCP/IP connections allowed.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n-\n\n\n\n\n\nExample:\n\nSetMaxNetworkConnections(1); //only allow 1 network connection to be open at a time\n\n\n\n\n\nAuthenticateOperatorByPassword\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AuthenticateOperatorByPassword": {
  "prefix": "AuthenticateOperatorByPassword",
  "body": [
   "($$IsAuthenticated,$$UserName,$$Domain)=AuthenticateOperatorByPassword($$PromptString,$$DefaultToLoggedInUser,$$DefaultToCurrentDomain,$$FailOnAuthenticationFailure,$$RetryLimit);"
  ],
  "description": "\n\n\n\nThis function authorizes the current user against the local machine users, or the domain name controller. If the supplied credentials could be verified successfully, the user name and domain name are returned, and the $IsAuthenticate return variable is set to TRUE, otherwise this variable will be returned as FALSE. The $RetryLimit sets the maximum number of password attempts that can be performed before closing the Dialog Prompt. The $FailOnAuthenticationFailure boolean argument sets whether or not the function will automatically generate a failure if the authentication process is unsuccessful.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$PromptString\n\nString\n\nThe text string displayed to the operator on the Dialog prompt.\n\n\n\n$DefaultToLoggedInUser\n\nBoolean\n\nIf this variable is set to true, the current windows user name is automatically populated in the User Name field.\n\n\n\n$DefaultToCurrentDomain\n\nBoolean\n\nIf this variable is set to true, the current machine's domain name is automatically populated in the Domain Name field.\n\n\n\n$FailOnAuthenticationFailure\n\nBoolean\n\nIf this variable is set to false, the function will always pass regardless of the whether or not the authentication was successful. If the authentication was unsuccessful and this argument is set to TRUE, then the function will generate a failure if the authentication is not possible.\n\n\n\n$RetryLimit\n\nInteger\n\nThe maximum number of password attempts that is allowed before the dialog box closes and returns an authentication failure.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$IsAuthenticated\n\nBoolean\n\nReturns true if the supplied username, domain, and password could be authenticated against the local machine user database, or the domain controller.\n\n\n\n$UserName\n\nString\n\nReturns the user name of the authenticated windows user.\n\n\n\n$DomainName\n\nString\n\nReturns the domain of the current authenticated windows user.\n\n\n\n\n\nExample:\n\n($IsAuthenticated,$UserName,$Domain) = AuthenticateOperatorByPassword(\"Please Provide Authentication To Prove that U R U\",\"TRUE\",\"TRUE\",\"FALSE\",3);\n\n\n\n\n\nAuthenticateUserByFingerprint\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AuthenticateUserByFingerprint": {
  "prefix": "AuthenticateUserByFingerprint",
  "body": [
   "($$IsAuthenticated,$$UserName)=AuthenticateUserByFingerprint($$PromptString,$$FailOnAuthenticationFailure,$$RetryLimit);"
  ],
  "description": "\n\n\n\nThis function authorizes the current user from the Jabil Test security definition file. If a matching fingerprint is found in the user file, the user name is returned, and the $IsAuthenticate return variable is set to TRUE, otherwise this variable will be returned as FALSE. The $RetryLimit sets the maximum number of fingerprint scans that will be performed before closing the Dialog Prompt. The $FailOnAuthenticationFailure boolean argument sets whether or not the function will automatically generate a failure if the authentication process is unsuccessful.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$PromptString\n\nString\n\nThe text string displayed to the operator on the Dialog prompt.\n\n\n\n$FailOnAuthenticationFailure\n\nBoolean\n\nIf this variable is set to false, the function will always pass regardless of the whether or not the authentication was successful. If the authentication was unsuccessful and this argument is set to TRUE, then the function will generate a failure if the authentication is not possible.\n\n\n\n$RetryLimit\n\nInteger\n\nThe maximum number of fingerprint scans that can be performed before the dialog is closed and an unsuccessful authentication result is returned.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$IsAuthenticated\n\nBoolean\n\nReturns true if a matching fingerprint was found in the Jabil Test security definitions file.\n\n\n\n$UserName\n\nString\n\nReturns the username of the matching fingerprint found in the Jabil Test security definitions file.\n\n\n\n\n\nExample:\n\n($IsAuthenticated,$UserName) = AuthenticateUserByFingerprint(\"Please give me the finger!\",\"TRUE\",3);\n\n\n\n\n\nCheckFormExists\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS CheckFormExists": {
  "prefix": "CheckFormExists",
  "body": [
   "$$exists=CheckFormExists($$Form);"
  ],
  "description": "\n\nReturns true if the form is still open, and false if it has been closed and disposed of by the system.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Form\n\nObject\n\nA handle to the form created using any of the non-blocking prompt functions.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$exists\n\nBoolean\n\nWhether or not the form has been disposed of. Closing an operator prompt window will dispose of the form after a short period of time.\n\n\n\n\n\nExample:\n\n\n\n\n\n$WindowHandle = OperatorPromptNonBlockingWithButtons(\"Just a prompt.\",400,600,\"BUTTON1\",50,50,\"BUTTON2\",50,200);\n\n\n\n\n\n$Button1Pressed = false;\n\n$Button2Pressed = false;\n\n\n\n\n\nwhile(!$Button2Pressed)\n\n{\n\n$windowPresent = CheckFormExists($WindowHandle);\n\nif(!$windowPresent)\n\n{\n\nFail(\"Error! Someone closed the window.\");\n\n}\n\n\n\n$Button1Pressed = OperatorPromptNonBlockingGetButtonState($WindowHandle,\"BUTTON1\");\n\n$Button2Pressed = OperatorPromptNonBlockingGetButtonState($WindowHandle,\"BUTTON2\");\n\n\n\nUpdateStatus($Button1Pressed);\n\nUpdateStatus($Button2Pressed);\n\n\n\nif($Button1Pressed)\n\n{\n\nOperatorPrompt(\"BUTTON1 pressed!\",\"OK\");\n\n}\n\n\n\nSleep(1);\n\n}\n\n\n\n\n\nEnd;\n\n\n\n\n\nCloseForm\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS CloseForm": {
  "prefix": "CloseForm",
  "body": [
   "CloseForm($$myForm);"
  ],
  "description": "\n\nThis function closes a Form object that has been created in a previous test step. In the event that the function argument $myForm can't be cast as a form object, a failure is returned to the script interpreter. If the form is currently already closed, or hidden, no action is taken.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$myForm\n\nObject\n\nA handle to a windows form that has been created in a previous test step\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nDataEntry\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS DataEntry": {
  "prefix": "DataEntry",
  "body": [
   "($$SN1,$$MN1,$$SN2,$$MN2)=DataEntry($$DataEntryTitle,$$NoOfCells);"
  ],
  "description": "\n\nThis function will require 2 variables the first the title of the Data Entry window and is expected to be a string, and the second is the number of cells required to show.\n\nThe Function will return 4 or 6 strings depending on the number of cells shown. The first variable is the serial number on the first cell, the second variable is the Model number on the first cell, the third and forth variables correspond to the second cell and finally the fifth and sixth variables correspond to the third cell.\n\n\n\n\n\nExample:\n\n($SN1,$MN1,$SN2,$MN2) = DataEntry(\"Danny's logic test\", 2);\n\nOr\n\n($SN1,$MN1,$SN2,$MN2,$SN3,$MN3 ) = DataEntry(\"Danny's logic test\", 3);\n\n\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ DataEntryTitle\n\nString\n\nTitle of the DataEntry window\n\n\n\n$ NoOfCells\n\nInteger\n\nNumber of cells, either 2 or 3 cells\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$SN1\n\nString\n\nSerial number of the first cell\n\n\n\n$MN1\n\nString\n\nModel number of the first cell\n\n\n\n$SN2\n\nString\n\nSerial number of the second cell\n\n\n\n$MN2\n\nString\n\nModel number of the second cell\n\n\n\n$SN3\n\nString\n\nSerial number of the third cell\n\n\n\n$MN3\n\nString\n\nModel number of the third cell\n\n\n\n\n\nGetPicturePromptResult\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS HideImage": {
  "prefix": "HideImage",
  "body": [
   "HideImage($$handle);"
  ],
  "description": "\n\nCloses a window that has an image in it that was created with the ShowImage function.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$handle\n\nObject\n\nA handle to a window with an image in it that was created with the ShowImage function.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n\n\n\n\n$imagePath = \"C:\\\\Temp\\\\TestImage.png\";\n\n$imageHandle = ShowImage($imagePath, 600, 350);\n\nHideImage($imageHandle);\n\n\n\n\n\nHidePromptImage\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS HidePromptImage": {
  "prefix": "HidePromptImage",
  "body": [
   "HidePromptImage($$handle);"
  ],
  "description": "\n\nCloses a window that has an image in it that was created with the ShowPicturePrompt or ShowPicturePromptWithLocation function.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$handle\n\nObject\n\nA handle to a window with an image in it that was previously created.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n\n\n\n\n$imagePath = \"C:\\\\Temp\\\\TestImage.png\";\n\n$imageHandle = ShowImage($imagePath, 600, 350);\n\nHideImage($imageHandle);\n\n\n\n\n\nHookWindowImage\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OperatorCountDownTimer": {
  "prefix": "OperatorCountDownTimer",
  "body": [
   "OperatorCountDownTimer($$DisplayString,$$TimeInSeconds,$$ShowAbortButton);"
  ],
  "description": "\n\n\n\n\n\nThis function is used to display a count down timer to the user. This function is generally used when the operator must wait for a finite amount of time for an event to complete before the script can continue. The $DisplayString is displayed to the operator on the countdown GUI form. The $ShowAbortButton boolean argument is used to control whether or not an abort button is shown to the operator. If the operator either closes the form, or clicks the abort button the function will return with an \"ABORT\" status. Otherwise, if the entire time duration has elapsed, the function will return with a PASS status.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$DisplayString\n\nString\n\nThe text which is shown to the operator on the count down timer form.\n\n\n\n$TimeInSeconds\n\nInteger\n\nThe number of seconds that you would like the timer to wait before closing the form and continue the script execution.\n\n\n\n$ShowAbortButton\n\nBoolean\n\nThis argument controls whether or not an abort button is displayed on the count-down timer form.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n\n\n\n\nOperatorCountDownTimer(\"Hello World!\", 30, true);\n\n\n\n\n\nOperatorCountDownTimerWithPause\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OperatorCountDownTimerWithPause": {
  "prefix": "OperatorCountDownTimerWithPause",
  "body": [
   "OperatorCountDownTimerWithPause($$DisplayString,$$TimeInSeconds,$$ShowControlButtons);"
  ],
  "description": "\n\n\n\n\n\nThis function is used to display a count down timer to the user. This function is generally used when the operator must wait for a finite amount of time for an event to complete before the script can continue. The $DisplayString is displayed to the operator on the countdown GUI form. The $ShowControlButtons boolean argument is used to control whether or not the interactive control buttons are shown to the operator - Continue (continues execution), Pause (stops timer countdown), Abort (aborts test), and Add Time (adds time to countdown). If the operator either closes the form, or clicks the abort button the function will return with an \"ABORT\" status. Otherwise, if the entire time duration has elapsed, the function will return with a PASS status.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$DisplayString\n\nString\n\nThe text which is shown to the operator on the count down timer form.\n\n\n\n$TimeInSeconds\n\nInteger\n\nThe number of seconds that you would like the timer to wait before closing the form and continuing the script execution.\n\n\n\n$ShowControlButtons\n\nBoolean\n\nThis argument controls whether or not the pause, continue, and abort buttons are displayed on the count-down timer form.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n\n\n\n\nOperatorCountDownTimerWithPause(\"Hello World!\",30, true);\n\n\n\n\n\nOperatorCountDownTimerWithPauseAndLocation\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OperatorCountDownTimerWithPauseAndLocation": {
  "prefix": "OperatorCountDownTimerWithPauseAndLocation",
  "body": [
   "OperatorCountDownTimerWithPauseAndLocation($$prompt,$$time,$$showButtons,$$width,$$height,$$left,$$top);"
  ],
  "description": "\n\nThis function will pop up a window with a prompt and a countdown timer. The $showButtons argument is used to control whether or not the interactive control buttons are shown to the operator. The buttons are:\n\n\u00b7 Continue - closes the window and continues script execution.\n\n\u00b7 Pause - stops the timer from counting down. Says \"Resume\" while paused.\n\n\u00b7 Abort - closes the window and aborts test execution.\n\n\u00b7 Add Time - adds 30 seconds to the count down time.\n\n\n\n\n\nIf the timer runs all the way down or the operator clicks on the Continue button, the function will return a PASS status.\n\nIf the operator clicks on Abort or closes the window, the test will Abort.\n\n\n\n\n\nRemarks:\n\nThe word \"Location\" is used in the prompt functions to denote position and size instead of saying \"WithPositionAndSize\".\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$prompt\n\nString\n\nString displayed to the user.\n\n\n\n$time\n\nInteger\n\nThe number of seconds that the time will count down.\n\n\n\n$showButtons\n\nBoolean\n\nWhether or not to show the control buttons.\n\n\n\n$width\n\nInteger\n\nThe width of the countdown timer window in pixels.\n\n\n\n$height\n\nInteger\n\nThe height of the countdown timer window in pixels.\n\n\n\n$left\n\nInteger\n\nThe location of the left edge of the countdown timer window in pixels measured from the left edge of the screen.\n\n\n\n$top\n\nInteger\n\nThe location of the top edge of the countdown timer window in pixels measured from the top edge of the screen.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n// Set up the values for the timer window.\n\n$prompt = \"This is the prompt.\";\n\n$time = 6;\n\n$show = true;\n\n$width = 1500;\n\n$height = 750;\n\n$xPos = 50;\n\n$yPos = 0;\n\n\n\n\n\nOperatorCountDownTimerWithPauseAndLocation($prompt, $time, $show, $width, $height, $xPos, $yPos);\n\n\n\n\n\nOperatorCountDownTimerWithPosition\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OperatorCountDownTimerWithPosition": {
  "prefix": "OperatorCountDownTimerWithPosition",
  "body": [
   "OperatorCountDownTimerWithPosition($$DisplayString,$$TimeInSeconds,$$ShowAbortButton,$$leftEdge,$$topEdge);"
  ],
  "description": "\n\n\n\n\n\nThis function is used to display a count down timer to the user at the location specified by $leftEdge and $topEdge. This function is generally used when the operator must wait for a finite amount of time for an event to complete before the script can continue. The $DisplayString is displayed to the operator on the countdown GUI form. The $ShowAbortButton boolean argument is used to control whether or not an abort button is shown to the operator. If the operator either closes the form, or clicks the abort button the function will return with an \"ABORT\" status. Otherwise, if the entire time duration has elapsed, the function will return with a PASS status.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$DisplayString\n\nString\n\nThe text which is shown to the operator on the count down timer form.\n\n\n\n$TimeInSeconds\n\nInteger\n\nThe number of seconds that you would like the timer to wait before closing the form and continue the script execution.\n\n\n\n$ShowAbortButton\n\nBoolean\n\nThis argument controls whether or not an abort button is displayed on the count-down timer form.\n\n\n\n$leftEdge\n\nInteger\n\nThe left edge of the count down timer window in pixels measured from the left edge of the screen.\n\n\n\n$topEdge\n\nInteger\n\nThe top edge of the count down timer window in pixels measured from the top edge of the screen.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n\n\n\n\nOperatorCountDownTimerWithPosition(\"Hello World!\", 30, true, 1000, 150);\n\n\n\n\n\nOperatorInputCheckedListPrompt\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OperatorInputCheckedListPrompt": {
  "prefix": "OperatorInputCheckedListPrompt",
  "body": [
   "$$SelectedItem=OperatorInputCheckedListPrompt($$PromptString,$$OptionList,$$WindowWidth,$$WindowHeight);"
  ],
  "description": "\n\n\n\n\n\nThis function is used to prompt the operator with a list of choices that appear in a checked list box control. The $PromptString is displayed at the top of the form to give the operator instructions on how to respond. The $OptionList is a semicolon delimited list of options that will appear in the list control for the operator to choose from. The $WindowWidth and $WindowHeight parameters control the size of the window that will be displayed to the operator.\n\n\n\n\n\nThis function returns an array of boolean values indicated whether or not a particular option was checked depending on it's position in the list (see Example Below);\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$PromptString\n\nString\n\nThe text shown to the operator at the top of the input form.\n\n\n\n$OptionList\n\nString\n\nA semicolon delimited list of options that the operator may select to check from a list box. The operator may check multiple items. (If restricting the operator to a single selection is desired, see the OperatorInputListPrompt function).\n\n\n\n$WindowWidth\n\nInteger\n\nThe width of the window that will be displayed to the user. The window width is specified in pixels.\n\n\n\n$WindowHeight\n\nInteger\n\nThe height of the window that will be displayed to the user. The window height is specified in pixels.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$CheckedItemArray\n\nArray\n\nA list of boolean values indicating whether or not a particular item was checked depending on it's position in the list.\n\n\n\n\n\nExample:\n\n\n\n$RetArray = OperatorInputCheckedListPrompt(\"Pick a Delicious Fruit, or face the Consequences!\",\"Apple;Pear;Bananna;Tangerine;Orange;Pineapple\",200,400);\n\n$Length = ArrayGetLength($RetArray);\n\n$Value0 = ArrayGetValue($RetArray,0,0);\n\n$Value1 = ArrayGetValue($RetArray,1,0);\n\n$Value2 = ArrayGetValue($RetArray,2,0);\n\n$Value3 = ArrayGetValue($RetArray,3,0);\n\n$Value4 = ArrayGetValue($RetArray,4,0);\n\n$Value5 = ArrayGetValue($RetArray,5,0);\n\nUpdateStatus($Value0);\n\nUpdateStatus($Value1);\n\nUpdateStatus($Value2);\n\nUpdateStatus($Value3);\n\nUpdateStatus($Value4);\n\nUpdateStatus($Value5);\n\n\n\n\n\nOperatorInputCheckedListPromptWithLocation\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OperatorInputCheckedListPromptWithLocation": {
  "prefix": "OperatorInputCheckedListPromptWithLocation",
  "body": [
   "$$checked=OperatorInputCheckedListPromptWithLocation($$prompt,$$optionList,$$width,$$height,$$left,$$top);"
  ],
  "description": "\n\nThis function will pop up a window with a prompt and a list of checkboxes. The user can select and check multiple items in the list. The list is returned as an array of booleans (true if checked, false otherwise).\n\n\n\n\n\nRemarks:\n\nThe word \"Location\" is used in the prompt functions to denote position and size instead of saying \"WithPositionAndSize\".\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$prompt\n\nString\n\nString displayed to the user.\n\n\n\n$optionList\n\nString\n\nA semicolon delimited list of the items to put in the checked list. They will be shown one to a line with a checkbox at the start of the line.\n\n\n\n$width\n\nInteger\n\nThe width of the checked list prompt window in pixels.\n\n\n\n$height\n\nInteger\n\nThe height of the checked list prompt window in pixels.\n\n\n\n$left\n\nInteger\n\nThe location of the left edge of the checked list prompt window in pixels measured from the left edge of the screen.\n\n\n\n$top\n\nInteger\n\nThe location of the top edge of the checked list prompt window in pixels measured from the top edge of the screen.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$checked\n\nArray\n\nA 2D array of booleans with one column that represents which check boxes are checked.\n\n\n\n\n\nExample:\n\n// Set up the values for the timer window.\n\n$prompt = \"This is the prompt.\";\n\n$optList = \"Line_1;Line_2;Line_3;Line_4\";\n\n$width = 400;\n\n$height = 350;\n\n$xPos = 20;\n\n$yPos = 20;\n\n\n\n\n\nOperatorInputCheckedListPromptWithLocation($prompt, $optList, $width, $height, $xPos, $yPos);\n\n\n\n\n\nOperatorInputComboBox\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OperatorInputComboBox": {
  "prefix": "OperatorInputComboBox",
  "body": [
   "$$selected=OperatorInputComboBox($$prompt,$$optionList);"
  ],
  "description": "\n\nThis function prompts the user to select an item from a drop-down combo box.\n\n\n\n\n\nRemarks:\n\nIf the user makes no selection, an empty string is returned.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$prompt\n\nString\n\nText shown to the operator at the top of the input form.\n\n\n\n$optionList\n\nString\n\nSemicolon delimited list of options the operator will select from.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$selected\n\nString\n\nThe item the operator selected from the combo box.\n\n\n\n\n\nExample:\n\n\n\n// Get the user to select from 5 lines.\n\n$prompt = \"Select an option from the list below:\";\n\n$options = \"Option 1;Option 2;Option 3;Option 4;Option 5\";\n\n\n\n$selected = OperatorInputComboBox($prompt, $options);\n\n\n\n\n\nOperatorInputListPrompt\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OperatorInputListPrompt": {
  "prefix": "OperatorInputListPrompt",
  "body": [
   "$$SelectedItem=OperatorInputListPrompt($$PromptString,$$OptionList,$$WindowWidth,$$WindowHeight);"
  ],
  "description": "\n\n\n\n\n\nThis function is used to prompt the operator with a list of choices that appear in a drop down list control. The $PromptString is displayed at the top of the form to give the operator instructions on how to respond. The $OptionList is a semicolon delimited list of options that will appear in the list control for the operator to choose from. The $WindowWidth and $WindowHeight parameters control the size of the window that will be displayed to the operator.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$PromptString\n\nString\n\nThe text shown to the operator at the top of the input form.\n\n\n\n$OptionList\n\nString\n\nA semicolon delimited list of options that the operator may select from a list box.\n\n\n\n$WindowWidth\n\nInteger\n\nThe width of the window that will be displayed to the user. The window width is specified in pixels.\n\n\n\n$WindowHeight\n\nInteger\n\nThe height of the window that will be displayed to the user. The window height is specified in pixels.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$SelectedItem\n\nString\n\nThe item that the operator selected from the list box. If no option was selected, an empty string is returned.\n\n\n\n\n\nExample:\n\n$OperatorPick = OperatorInputListPrompt(\"Pick A Fruit In The List Or Face Serious Consequences!\",\"Apple;Orange;Pear;Bananna\",500,600);\n\nUpdateStatus($OperatorPick);\n\n\n\n\n\nOperatorInputListPromptPosition\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OperatorInputListPromptPosition": {
  "prefix": "OperatorInputListPromptPosition",
  "body": [
   "$$SelectedItem=OperatorInputListPromptPosition($$PromptString,$$OptionList,$$WindowWidth,$$WindowHeight,WindowXPosition,$$WindowYPosition);"
  ],
  "description": "\n\n\n\n\n\nThis function is used to prompt the operator with a list of choices that appear in a list control. The $PromptString is displayed at the top of the form to give the operator instructions on how to respond. The $OptionList is a semicolon delimited list of options that will appear in the list control for the operator to choose from. The $WindowWidth and $WindowHeight parameters control the size of the window that will be displayed to the operator. The $WindowXPosition and $WindowYPosition parameters control the placement of the window on the screen that will be displayed to the operator.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$PromptString\n\nString\n\nThe text shown to the operator at the top of the input form.\n\n\n\n$OptionList\n\nString\n\nA semicolon delimited list of options that the operator may select from a list box.\n\n\n\n$WindowWidth\n\nInteger\n\nThe width of the window that will be displayed to the user. The window width is specified in pixels.\n\n\n\n$WindowHeight\n\nInteger\n\nThe height of the window that will be displayed to the user. The window height is specified in pixels.\n\n\n\n$WindowXPosition\n\nInteger\n\nThe X position of the window that will be displayed to the user. The window X position is specified in pixels. 0 is at the left of the screen.\n\n\n\n$WindowYPosition\n\nInteger\n\nThe Y position of the window that will be displayed to the user. The window Y position is specified in pixels. 0 is at the top of the screen.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$SelectedItem\n\nString\n\nThe item that the operator selected from the list box. If no option was selected, an empty string is returned.\n\n\n\n\n\nExample:\n\n$OperatorPick = OperatorInputListPromptPosition(\"Pick A Fruit In The List Or Face Serious Consequences!\",\"Apple;Orange;Pear;Banana\",500,600,0,0); //Window is in top left Corner\n\nUpdateStatus($OperatorPick);\n\n\n\n\n\nOperatorInputMultiCheckedLists\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OperatorInputPasswordPrompt": {
  "prefix": "OperatorInputPasswordPrompt",
  "body": [
   "$$password=OperatorInputPasswordPrompt($$promptString);"
  ],
  "description": "\n\nThis function will prompt the user to enter a string. The entered text will show in the text box as a series of dots.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$promptString\n\nString\n\nThe string displayed to the users to instruct them in what to do.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$password\n\nString\n\nThe text string that was typed in by the user.\n\n\n\n\n\nExample:\n\n\n\n\n\n// Ask the user for a password.\n\n$prompt = \"Enter your password:\";\n\n\n\n$password = OperatorInputPasswordPrompt($prompt);\n\n\n\n\n\nOperatorInputMultiCheckedListsWithLocation\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OperatorInputMultiCheckedLists": {
  "prefix": "OperatorInputMultiCheckedLists",
  "body": [
   "$$checkedItems=OperatorInputMultiCheckedLists($$prompt,$$headers,$$optionList1,$$optionList2,...,$$optionListn,$$windowWidth,$$windowHeight,#windowLeft,$$windowTop);"
  ],
  "description": "\n\n\n\n\n\nThis function is used to prompt the operator with a number of lists of choices that appear in checked list box controls. The list box controls are all shown beside each other. The $prompt is displayed at the top of the form to give the operator instructions on how to respond. $headers is a semicolon delimited list of strings that are displayed at the top of the columns of check boxes. $optionList# is a semicolon delimited list of options that will appear in the list control for the operator to choose from. There must be as many $headers as there are $optionLists. The $windowWidth and $windowHeight parameters control the size of the window that will be displayed to the operator. The $windowWidth is divided up evenly among all of the columns of check boxes. $windowLeft and $windowTop denote the left and top edges of the window measured from the Left and Top edges of the display.\n\n\n\n\n\nThis function returns a 2D array of boolean values indicated whether or not a particular option was checked depending on it's position in the lists (see Example Below).\n\n\n\n\n\nRemarks:\n\nThe word \"Location\" is used in the prompt functions to denote position and size instead of saying \"WithPositionAndSize\".\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$prompt\n\nString\n\nThe text shown to the operator at the top of the input form.\n\n\n\n$headers\n\nString\n\nA semicolon delimited list of headers to show at the top of each column of check boxes\n\n\n\n$optionList1\n\n$optionList2\n\n...\n\n$optionListn\n\nString\n\nA semicolon delimited list of options that the operator may select to check from a list box. The operator may check multiple items. There must be as many Option Lists as there are Header Strings.\n\n\n\n$windowWidth\n\nInteger\n\nThe width of the window that will be displayed to the user. The window width is specified in pixels.\n\n\n\n$windowHeight\n\nInteger\n\nThe height of the window that will be displayed to the user. The window height is specified in pixels.\n\n\n\n$windowLeft\n\nInteger\n\nThe left edge of the window measured from the left edge of the screen - in pixels.\n\n\n\n$windowTop\n\nInteger\n\nThe top edge of the window measured from the top edge of the screen - in pixels.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$checkedItems\n\nArray\n\nA 2D array of boolean values indicating whether or not a particular item was checked depending on it's position in the lists.\n\n\n\n\n\nExample:\n\n\n\n\n\n// The parameters to send.\n\n$boxTitle = \"Make Selections From the Lists Below\";\n\n$headerTxts = \"Header 1;Header 2;Header 3\";\n\n$col1Boxes = \"Col 1 Check 1;Col 1 Check 2\";\n\n$col2Boxes = \"Col 2 Check 1;Col 2 Check 2;Col 2 Check 3;Col 2 Check 4;Col 2 Check 5;Col 2 Check 6;Col 2 Check 7;Col 2 Check 8\";\n\n$col3Boxes = \"Col 3 Check 1;Col 3 Check 2;Col 3 Check 3;Col 3 Check 4;Col 3 Check 5\";\n\n$width = 750;\n\n$height = 500;\n\n$left = 20;\n\n$top = 20;\n\n\n\n\n\n// Create the checkboxes.\n\n$return = OperatorInputMultiCheckedListsWithLocation($boxTitle, $headerTxts, $col1Boxes, $col2Boxes, $col3Boxes, $width, $height, $left, $top);\n\n\n\n\n\n// Get the number of rows and the number of colulmns.\n\n$rows = ArrayGetDimensionSize($return, 0);\n\n$cols = ArrayGetDimensionSize($return, 1);\n\n\n\n\n\n// Get the value from each cell.\n\n$rowCount = 0;\n\nwhile ($rowCount < $rows)\n\n{\n\n$rowStr = \"\";\n\n$colCount = 0;\n\n// For each row count across the columns.\n\nwhile ($colCount < $cols)\n\n{\n\n$cell = ArrayGetValue($return, $rowCount, $colCount);\n\n\n\nif ($cell == true)\n\n{\n\n$rowStr = $rowStr + \"True \";\n\n}\n\nif ($cell == false)\n\n{\n\n$rowStr = $rowStr + \"False \";\n\n}\n\n$colCount = $colCount + 1;\n\n}\n\nUpdateStatus($rowStr);\n\n$rowCount = $rowCount + 1;\n\n}\n\n\n\n\n\nEnd;\n\n\n\n\n\nOperatorInputPicturePrompt\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OperatorInputPicturePrompt": {
  "prefix": "OperatorInputPicturePrompt",
  "body": [
   "$$OperatorResponse=OperatorInputPicturePrompt($$PromptString,$$GraphicFilePath,$$PictureMode,$$WindowHeight,$$WindowWidth);"
  ],
  "description": "\n\nPrompts the Operator with a given string and accompanying graphic file. This operator prompt will automatically assume focus, and is a modal dialog box. If the image is not found at the location given, a blank dialog box is displayed, and no error is generated. The operator has the capability to enter any free form text.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$PromptString\n\nString\n\nThe String which is displayed to the operator for instruction or notification purposes.\n\n\n\n$GraphicFilePath\n\nString\n\nThe path and filename for the graphic image to display. The following graphic formats are supported: GIF,TIFF,BMP,JPG\n\n\n\n$PictureMode\n\nString\n\nThe resizing mode for the graphic file, supported modes are:\n\n\"AUTOSIZE\" = Automatically positions the image, size is unchanged\n\n\"CENTER\" = Centers the image in the form, size is unchanged\n\n\"STRETCH\" = Centers the image in the form, and sizes it to fit the dialog window\n\n\n\n$WindowHeight\n\nInteger\n\nThe height of the dialog box in pixels\n\n\n\n$WindowWidth\n\nInteger\n\nThe width of the dialogi box in pixels\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$OperatorResponse\n\nString\n\nThe text entered by the operator\n\n\n\n\n\nOperatorInputPrompt\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OperatorInputPrompt": {
  "prefix": "OperatorInputPrompt",
  "body": [
   "$$output=OperatorInputPrompt($$PromptString);"
  ],
  "description": "\n\nPrompts the Operator with a given string in a dialog box which contains a text entry box allowing free form text entry. The dialog box automatically assumes focus so that it is convienent to use from a handheld barcode scanner without keyboard interaction.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$PromptString\n\nString\n\nThe String which is displayed to the operator for instruction or notification purposes.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$output\n\nString\n\nThe text string that was typed or scanned in by the operator\n\n\n\n\n\nOperatorInputPromptWithLocation\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OperatorInputPromptWithLocation": {
  "prefix": "OperatorInputPromptWithLocation",
  "body": [
   "$$entered=OperatorInputPromptWithLocation($$prompt,$$width,$$height,$$left,$$top);"
  ],
  "description": "\n\nThis function will pop up a window with a prompt and textbox that the user can enter data into. The entered data is returned.\n\n\n\n\n\nRemarks:\n\nThe word \"Location\" is used in the prompt functions to denote position and size instead of saying \"WithPositionAndSize\".\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$prompt\n\nString\n\nString displayed to the user.\n\n\n\n$width\n\nInteger\n\nThe width of the prompt window in pixels.\n\n\n\n$height\n\nInteger\n\nThe height of the prompt window in pixels.\n\n\n\n$left\n\nInteger\n\nThe location of the left edge of the prompt window in pixels measured from the left edge of the screen.\n\n\n\n$top\n\nInteger\n\nThe location of the top edge of the prompt window in pixels measured from the top edge of the screen.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$entered\n\nString\n\nThe text that was entered by the user.\n\n\n\n\n\nExample:\n\n// Set up the values for the window.\n\n$prompt = \"This is the prompt.\";\n\n$width = 400;\n\n$height = 350;\n\n$xPos = 20;\n\n$yPos = 20;\n\n\n\n\n\n$entered = OperatorInputPromptWithLocation($prompt, $width, $height, $xPos, $yPos);\n\n\n\n\n\nOperatorInputPromptWithVerify\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OperatorInputPromptWithVerify": {
  "prefix": "OperatorInputPromptWithVerify",
  "body": [
   "$$output=OperatorInputPromptWithVerify($$PromptString,$$StartString,$$MinLength,$$MaxLength,$$RetryCount);"
  ],
  "description": "\n\nPrompts the Operator with a given string in a dialog box which contains a text entry box allowing free form text entry. The dialog box automatically assumes focus so that it is convienent to use from a handheld barcode scanner without keyboard interaction. The Operator.InputPromptWithVerify function will ensure that the operator supplied data begins with the string passed in the $StringString argument. In addition, the length of the string is verified against the $MinLength and $MaxLength variables. In the event that any of these comparisons failed, the operator will be informed of the error and given the opportunity to correct it. The $RetryCount argument controls how many times an operator will be prompted for correct input before a failure is returned to the script. If the supplied input meets all the critieria, it will be returned to the script, and a passing result is returned to the executive. For Operator Input without verification, please see the Operator.InputPrompt function.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$PromptString\n\nString\n\nThe String which is displayed to the operator for instruction or notification purposes.\n\n\n\n$StartString\n\nString\n\nThe prefix of the string that will be accepted as allowable input. For example the prefix string for a Jabil Serial number may be \"JBL\".\n\n\n\n$MinLength\n\nInteger\n\nThe minimum allowable length for the operator supplied input.\n\n\n\n$MaxLength\n\nInteger\n\nThe maximum allowable length for the operator supplied input.\n\n\n\n$RetryCount\n\nInteger\n\nThe number of times to prompt the operator for corrected input before a failure is generated.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$output\n\nString\n\nThe text string that was typed or scanned in by the operator\n\n\n\n\n\nOperatorInputPromptWithVerifyAndLocation\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OperatorInputPromptWithVerifyAndLocation": {
  "prefix": "OperatorInputPromptWithVerifyAndLocation",
  "body": [
   "$$entered=OperatorInputPromptWithVerifyAndLocation($$prompt,$$stringStart,$$minLength,$$maxLength,maxRetries,$$width,$$height,$$left,$$top);"
  ],
  "description": "\n\nThis function will pop up a window with a prompt and textbox that the user can enter data into. The data is tested against the verification parameters. The entered data must begin with the characters in $stringStart, must be at least $minLength long and no longer than $maxLength. If the user enters data that does not meet the verification criteria, an error message will appear with information about the requirement that was not met and the user will be asked to try again. If the data does not meet the verification criteria after $maxRetries times, an error will be generated. The entered data is returned.\n\n\n\n\n\nRemarks:\n\nThe word \"Location\" is used in the prompt functions to denote position and size instead of saying \"WithPositionAndSize\".\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$prompt\n\nString\n\nString displayed to the user.\n\n\n\n$stringStart\n\nString\n\nThe prefix of the string that will be accepted as allowable input. Example: the prefix string for a Jabil serial number may be \"JBL\".\n\n\n\n$minLength\n\nInteger\n\nThe minimum allowable length for the operator supplied input.\n\n\n\n$maxLength\n\nInteger\n\nThe maximum allowable length for the operator supplied input.\n\n\n\n$maxRetries\n\nInteger\n\nThe number of times to prompt the operator for corrected input before a failure is generated.\n\n\n\n$width\n\nInteger\n\nThe width of the prompt window in pixels.\n\n\n\n$height\n\nInteger\n\nThe height of the prompt window in pixels.\n\n\n\n$left\n\nInteger\n\nThe location of the left edge of the prompt window in pixels measured from the left edge of the screen.\n\n\n\n$top\n\nInteger\n\nThe location of the top edge of the prompt window in pixels measured from the top edge of the screen.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$entered\n\nString\n\nThe text that was entered by the user.\n\n\n\n\n\nExample:\n\n// Set up the values for the window.\n\n$prompt = \"This is the prompt.\";\n\n$startStr = \"Inc\";\n\n$minLen = 6;\n\n$maxLen = 12;\n\n$maxRetries = 3;\n\n$width = 400;\n\n$height = 350;\n\n$xPos = 20;\n\n$yPos = 20;\n\n\n\n\n\n$entered = OperatorInputPromptWithVerifyAndLocation($prompt, $startStr, $minLen, $maxLen, $maxRetries, $width, $height, $xPos, $yPos);\n\n\n\n\n\nOperatorMultiInputPrompt\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OperatorMultiInputPrompt": {
  "prefix": "OperatorMultiInputPrompt",
  "body": [
   "($$Response1,[$$Response2],[$$Response3]....)=OperatorMultiInputPrompt($$PromptCount,$$Prompt1,[$$Prompt2],[$$Prompt3].....);"
  ],
  "description": "\n\n\n\n\n\nThis function is used to prompt the operator for a list of inputs on a single dialog, without the need for multiple pop-up windows.\n\nThe function takes a variable number of arguments based on the $PromptCount parameter which specifies the number of input fields to display to the test operator.\n\n\n\n\n\nThe $Prompt[x] parameters are used to specify the prompt that will be shown to the operator for a particular input field.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$PromptCount\n\nInteger\n\nThe number of input fields to display to the Operator. The allowable number of prompts can be any number between 1 and 10.\n\n\n\n$Prompt1\n\nString\n\nThe message to display to the operator for the first input prompt.\n\n\n\n[$Prompt...X]\n\nString\n\nThe message to display to the operator for the 2nd to 10th input prompt (Optional... see Examples: below)\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Response1\n\nString\n\nThe value that was recorded by the operator for the first message prompt.\n\n\n\n[$Response...X]\n\nString\n\nThe value that was recorded by the operator for the Nth message prompt. (The number of return arguments is determined by the value of the $PromptCount parameter).\n\n\n\n\n\nExample:\n\n\n\n\n\n// Example 1 with 3 prompts\n\n($SerialNumber, $ModelNumber, $MacAddress) = OperatorMultiInputPrompt(3, \"Serial Number\", \"Model Number\", \"MAC Address\");\n\n\n\n\n\n// Example 2 with 5 prompts\n\n($SerialNumber, $ModelNumber, $MacAddress, $EIN, $Vendor) = OperatorMultiInputPrompt(5, \"Serial Number\", \"Model Number\", \"MAC Address\", \"EIN Number\", \"Vendor\");\n\n\n\n\n\nOperatorMultiInputPromptWithLocation\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OperatorMultiInputPromptWithLocation": {
  "prefix": "OperatorMultiInputPromptWithLocation",
  "body": [
   "($$Response1,[$$Response2],...[$$ResponseN])=OperatorMultiInputPromptWithLocation($$PromptCount,$$Prompt1,[$$Prompt2],...[$$PromptN],$$width,$$height,$$left,$$top);"
  ],
  "description": "\n\n\n\n\n\nThis function is used to prompt the operator for a list of inputs on a single dialog, without the need for multiple pop-up windows.\n\nThe function takes a variable number of arguments based on the $PromptCount parameter which specifies the number of input fields to display to the test operator.\n\n\n\n\n\nThe $Prompt[x] parameters are used to specify the prompt that will be shown to the operator for a particular input field.\n\n\n\n\n\nRemarks:\n\nThe word \"Location\" is used in the prompt functions to denote position and size instead of saying \"WithPositionAndSize\".\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$PromptCount\n\nInteger\n\nThe number of input fields to display to the Operator. The allowable number of prompts can be any number between 1 and 10.\n\n\n\n$Prompt1\n\nString\n\nThe message to display to the operator for the first input prompt.\n\n\n\n[$Prompt...X]\n\nString\n\nThe message to display to the operator for the 2nd to 10th input prompt (Optional... see Examples: below).\n\n\n\n$width\n\nInteger\n\nThe width of the prompt window in pixels.\n\n\n\n$height\n\nInteger\n\nThe height of the prompt window in pixels.\n\n\n\n$left\n\nInteger\n\nThe location of the left edge of the prompt window in pixels measured from the left edge of the screen.\n\n\n\n$top\n\nInteger\n\nThe location of the top edge of the prompt window in pixels measured from the top edge of the screen.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Response1\n\nString\n\nThe value that was recorded by the operator for the first message prompt.\n\n\n\n[$Response...X]\n\nString\n\nThe value that was recorded by the operator for the Nth message prompt. (The number of return arguments is determined by the value of the $PromptCount parameter).\n\n\n\n\n\nExample:\n\n\n\n\n\n// Example 1 with 3 prompts\n\n($SerialNumber, $ModelNumber, $MacAddress) = OperatorMultiInputPromptWithLocation(3, \"Serial Number\", \"Model Number\", \"MAC Address\", 700, 430, 10, 10);\n\n\n\n\n\n// Example 2 with 5 prompts\n\n($SerialNumber, $ModelNumber, $MacAddress, $EIN, $Vendor) = OperatorMultiInputPromptWithLocation(5, \"Serial Number\", \"Model Number\", \"MAC Address\", \"EIN Number\", \"Vendor\", 700, 430, 10, 10);\n\n\n\n\n\nOperatorNumericInputPicturePrompt\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OperatorNumericInputPicturePrompt": {
  "prefix": "OperatorNumericInputPicturePrompt",
  "body": [
   "$$OperatorResponse=OperatorNumericInputPicturePrompt($$PromptString,$$GraphicFilePath,$$PictureMode,$$WindowHeight,$$WindowWidth);"
  ],
  "description": "\n\nPrompts the Operator with a given string and accompanying graphic file. This operator prompt will automatically assume focus, and is a modal dialog box. If the image is not found at the location given, a blank dialog box is displayed, and no error is generated. The operator has the capability to enter any valid numeric value. If a valid numeric value is not supplied, the function will re-prompt the operator until an acceptable value is entered.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$PromptString\n\nString\n\nThe String which is displayed to the operator for instruction or notification purposes.\n\n\n\n$GraphicFilePath\n\nString\n\nThe path and filename for the graphic image to display. The following graphic formats are supported: GIF,TIFF,BMP,JPG\n\n\n\n$PictureMode\n\nString\n\nThe resizing mode for the graphic file, supported modes are:\n\n\"AUTOSIZE\" = Automatically positions the image, size is unchanged\n\n\"CENTER\" = Centers the image in the form, size is unchanged\n\n\"STRETCH\" = Centers the image in the form, and sizes it to fit the dialog window\n\n\n\n$WindowHeight\n\nInteger\n\nThe height of the dialog box in pixels\n\n\n\n$WindowWidth\n\nInteger\n\nThe width of the dialogi box in pixels\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$OperatorResponse\n\nFloat\n\nThe numeric value entered by the test operator.\n\n\n\n\n\nOperatorNumericInputPicturePromptWithLocation\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OperatorNumericInputPicturePromptWithLocation": {
  "prefix": "OperatorNumericInputPicturePromptWithLocation",
  "body": [
   "$$response=OperatorNumericInputPicturePromptWithLocation($$prompt,$$filePath,$$pictureMode,$$width,$$height,$$left,$$top);"
  ],
  "description": "\n\nThis function displays a picture to the user and has a text box for the user to input a number. If the input is not numeric, the prompt window will re-appear. This will continue until the user enters a valid number.\n\n\n\n\n\nRemarks:\n\nThe word \"Location\" is used in the prompt functions to denote position and size instead of saying \"WithPositionAndSize\".\n\nThe supported image formats are: BMP, GIF, JPG, PNG, TIFF.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$prompt\n\nString\n\nString displayed to the user.\n\n\n\n$filePath\n\nString\n\nThe path and filename for the graphic to display.\n\n\n\n$pictureMode\n\nString\n\nThe resizing mode for the image. The supported modes are:\n\n\u00b7 AUTOSIZE\n\n\u00b7 CENTER\n\n\u00b7 STRETCH\n\n\n\n$width\n\nInteger\n\nThe width of the prompt window in pixels.\n\n\n\n$height\n\nInteger\n\nThe height of the prompt window in pixels.\n\n\n\n$left\n\nInteger\n\nThe location of the left edge of the prompt window in pixels measured from the left edge of the screen.\n\n\n\n$top\n\nInteger\n\nThe location of the top edge of the prompt window in pixels measured from the top edge of the screen.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$response\n\nFloat\n\nThe numeric value entered by the operator.\n\n\n\n\n\nExample:\n\n\n\n\n\n// Fill the prompt with the picture.\n\n$prompt = \"This is the prompt.\";\n\n$picture = \"C:\\\\Graphics\\\\Prompt1.jpg\";\n\n$mode = \"STRETCH\";\n\n$width = 600;\n\n$height = 650;\n\n$left = 20;\n\n$top = 50;\n\n$response = OperatorNumericInputPicturePromptWithLocation($prompt, $picture, $mode, $width, $height, $left, $top);\n\n\n\n\n\nOperatorNumericInputPrompt\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OperatorNumericInputPrompt": {
  "prefix": "OperatorNumericInputPrompt",
  "body": [
   "$$output=OperatorNumericInputPrompt($$PromptString,$$MinValue,$$MaxValue);"
  ],
  "description": "\n\nPrompts the Operator with a given string in a dialog box which contains a text entry box allowing numeric text entry. The dialog box automatically assumes focus so that it is convienent to use from a handheld barcode scanner without keyboard interaction. This box allows numeric input only in a range of allowable values.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$PromptString\n\nString\n\nThe String which is displayed to the operator for instruction or notification purposes.\n\n\n\n$MinValue\n\nFloat\n\nThe minimum numeric value allowable for input.\n\n\n\n$MaxValue\n\nFloat\n\nThe maximum numeric value allowable for input.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$output\n\nString\n\nThe numeric string that was typed or scanned in by the operator\n\n\n\n\n\nOperatorNumericInputPromptDefault\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OperatorNumericInputPromptDefault": {
  "prefix": "OperatorNumericInputPromptDefault",
  "body": [
   "$$response=OperatorNumericInputPromptDefault($$prompt,$$minValue,$$maxValue,$$defaultValue);"
  ],
  "description": "\n\nThis function displays a prompt to the user that has a text box for the user to input a number. If the input is not numeric, less than the minimum value or more than the maximum, the prompt window will re-appear with a message stating why the input was rejected. This will continue until the user enters a valid number.\n\n\n\nRemarks:\n\nThe text box is pre-filled with a default number (supplied by the script) - the user can accept this value by clicking on the OK button without entering a new number.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$prompt\n\nString\n\nThe string to be displayed to the user.\n\n\n\n$minValue\n\nFloat\n\nThe minimum value of the user entered number.\n\n\n\n$maxValue\n\nFloat\n\nThe maximum value of the user entered number.\n\n\n\n$defaultValue\n\nFloat\n\nThe default value to be placed in the input text box.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$response\n\nFloat\n\nThe numeric value entered by the operator.\n\n\n\n\n\nExamples:\n\n\n\n\n\n// Prompt the user to select a number between 6 and 1000. Default to 500.\n\n$prompt = \"Please enter a number.\";\n\n$min = 6;\n\n$max = 1000;\n\n$default = 500;\n\n\n\n$response = OperatorNumericInputPromptDefault($prompt, $min, $max, $default);\n\n\n\n\n\nOperatorNumericInputPromptWithLocation\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OperatorNumericInputPromptWithLocation": {
  "prefix": "OperatorNumericInputPromptWithLocation",
  "body": [
   "$$response=OperatorNumericInputPromptWithLocation($$prompt,$$minValue,$$maxValue,$$width,$$height,$$left,$$top);"
  ],
  "description": "\n\nThis function displays a prompt to the user that has a text box for the user to input a number. If the input is not numeric, less than the minimum value or more than the maximum, the prompt window will re-appear with a message stating why the input was rejected. This will continue until the user enters a valid number.\n\n\n\n\n\nRemarks:\n\nThe word \"Location\" is used in the prompt functions to denote position and size instead of saying \"WithPositionAndSize\".\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$prompt\n\nString\n\nString displayed to the user.\n\n\n\n$minValue\n\nFloat\n\nThe minimum value of the user entered number.\n\n\n\n$maxValue\n\nFloat\n\nThe maximum value of the user entered number.\n\n\n\n$width\n\nInteger\n\nThe width of the prompt window in pixels.\n\n\n\n$height\n\nInteger\n\nThe height of the prompt window in pixels.\n\n\n\n$left\n\nInteger\n\nThe location of the left edge of the prompt window in pixels measured from the left edge of the screen.\n\n\n\n$top\n\nInteger\n\nThe location of the top edge of the prompt window in pixels measured from the top edge of the screen.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$response\n\nFloat\n\nThe numeric value entered by the operator.\n\n\n\n\n\nExample:\n\n\n\n\n\n// Prompt for a number between 6 and 1000.\n\n$prompt = \"This is the prompt.\";\n\n$minNum = 6;\n\n$maxNum = 1000;\n\n$width = 600;\n\n$height = 650;\n\n$left = 20;\n\n$top = 50;\n\n$response = OperatorNumericInputPromptWithLocation($prompt, $minNum, $maxNum, $width, $height, $left, $top);\n\n\n\n\n\nOperatorPicturePrompt\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OperatorPicturePrompt": {
  "prefix": "OperatorPicturePrompt",
  "body": [
   "OperatorPicturePrompt($$PromptString,$$GraphicFilePath,$$PictureMode,$$WindowHeight,$$WindowWidth);"
  ],
  "description": "\n\nPrompts the Operator with a given string and accompanying graphic file. This operator prompt will automatically assume focus, and is a modal dialog box. If the image is not found at the location given, a blank dialog box is displayed, and no error is generated.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$PromptString\n\nString\n\nThe String which is displayed to the operator for instruction or notification purposes.\n\n\n\n$GraphicFilePath\n\nString\n\nThe path and filename for the graphic image to display. The following graphic formats are supported: GIF,TIFF,BMP,JPG\n\n\n\n$PictureMode\n\nString\n\nThe resizing mode for the graphic file, supported modes are:\n\n\"AUTOSIZE\" = Automatically positions the image, size is unchanged\n\n\"CENTER\" = Centers the image in the form, size is unchanged\n\n\"STRETCH\" = Centers the image in the form, and sizes it to fit the dialog window\n\n\n\n$WindowHeight\n\nInteger\n\nThe height of the dialog box in pixels\n\n\n\n$WindowWidth\n\nInteger\n\nThe width of the dialogi box in pixels\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nOperatorPicturePromptNonBlockingWithButtons\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OperatorPicturePromptNonBlockingWithButtons": {
  "prefix": "OperatorPicturePromptNonBlockingWithButtons",
  "body": [
   "$$WindowHandle=OperatorPicturePromptNonBlockingWithButtons($$PromptString,$$GraphicFilePath,$$PictureMode,$$WindowHeight,$$WindowWidth,$$Button1Text,$$Button2Text);"
  ],
  "description": "\n\nThis function will prompt the operator with a graphic in a separate window, and allows the script to continue. Two programmable buttons can be displayed on the form. The operator prompt dialog continues to exist in a separate thread until it is disposed of with the CloseForm function.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$PromptString\n\nString\n\nThe String which is displayed to the operator for instruction or notification purposes.\n\n\n\n$GraphicFilePath\n\nString\n\nThe path and filename for the graphic image to display. The following graphic formats are supported: GIF,TIFF,BMP,JPG\n\n\n\n$PictureMode\n\nString\n\nThe resizing mode for the graphic file, supported modes are:\n\n\"AUTOSIZE\" = Automatically positions the image, size is unchanged\n\n\"CENTER\" = Centers the image in the form, size is unchanged\n\n\"STRETCH\" = Centers the image in the form, and sizes it to fit the dialog window\n\n\n\n$WindowHeight\n\nInteger\n\nThe height of the dialog box in pixels\n\n\n\n$WindowWidth\n\nInteger\n\nThe width of the dialog box in pixels\n\n\n\n$Button1Text\n\nString\n\nThe label for button 1. If this string is null the button will not be displayed.\n\n\n\n$Button2Text\n\nString\n\nThe label for button 2. If this string is null the button will not be displayed\n\n\n\n\n\nReturn arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$WindowHandle\n\nObject\n\nA handle to the operator dialog box. This can later be closed with the CloseForm function.\n\n\n\n\n\nExample:\n\n$window = OperatorPicturePromptNonBlockingWithButtons(\"wassup\",\"c:\\\\import\\\\words.jpg\", \"CENTER\", 500,500,\"button1\",\"button2\");\n\n$clicked = false;\n\nwhile ($clicked==false)\n\n{\n\n$clicked = OperatorPicturePromptNonBlockingWithButtonsGetButtonState($window,\"button1\");\n\nSleepMilliseconds(100);\n\n}\n\nUpdateStatus($clicked);\n\nCloseForm($window);\n\nEnd;\n\n\n\n\n\nOperatorPicturePromptNonBlockingWithButtonsAndLocation\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OperatorPicturePromptNonBlockingWithButtonsAndLocation": {
  "prefix": "OperatorPicturePromptNonBlockingWithButtonsAndLocation",
  "body": [
   "$$winHandle=OperatorPicturePromptNonBlockingWithButtonsAndLocation($$prompt,$$filePath,$$pictureMode,$$button1Text,$$button2Text,$$width,$$height,$$left,$$top);"
  ],
  "description": "\n\nThis function displays a picture to the user in a non-blocking window that has two buttons to close the prompt. The text on the buttons can be set by the script.\n\n\n\n\n\nRemarks:\n\nThe state of the buttons can be read using the function, OperatorPicturePromptNonBlockingWithButtonsGetButtonState.\n\nThe window can be closed with the function, CloseForm.\n\nThe supported image formats are: BMP, GIF, JPG, PNG, TIFF.\n\nThe word \"Location\" is used in the prompt functions to denote position and size instead of saying \"WithPositionAndSize\".\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$prompt\n\nString\n\nString displayed to the user.\n\n\n\n$filePath\n\nString\n\nThe path and filename for the graphic to display.\n\n\n\n$pictureMode\n\nString\n\nThe resizing mode for the image. The supported modes are:\n\n\u00b7 AUTOSIZE\n\n\u00b7 CENTER\n\n\u00b7 STRETCH\n\n\n\n$button1Text\n\nString\n\nThe text that will appear on the button on the left of the window. If left blank, the default of \"OK\" will be used.\n\n\n\n$button2Text\n\nString\n\nThe text that will appear on the button on the right of the window. If left blank, the default of \"Cancel\" will be used.\n\n\n\n$width\n\nInteger\n\nThe width of the prompt window in pixels.\n\n\n\n$height\n\nInteger\n\nThe height of the prompt window in pixels.\n\n\n\n$left\n\nInteger\n\nThe location of the left edge of the prompt window in pixels measured from the left edge of the screen.\n\n\n\n$top\n\nInteger\n\nThe location of the top edge of the prompt window in pixels measured from the top edge of the screen.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$winHandle\n\nObject\n\nA handle to the window that was opened. Passed to other functions to read the button state or close the window.\n\n\n\n\n\nExample:\n\n\n\n\n\n// Fill the prompt with the picture.\n\n$prompt = \"This is the prompt.\";\n\n$picture = \"C:\\\\Graphics\\\\Prompt1.jpg\";\n\n$mode = \"STRETCH\";\n\n$btn1 = \"PASS\";\n\n$btn2 = \"FAIL\";\n\n$width = 600;\n\n$height = 650;\n\n$left = 20;\n\n$top = 50;\n\n$handle = OperatorPicturePromptWithLocation($prompt, $picture, $mode, $btn1, $btn2, $width, $height, $left, $top);\n\n\n\n\n\nOperatorPicturePromptNonBlockingWithButtonsGetButtonState\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OperatorPicturePromptNonBlockingGetButtonState": {
  "prefix": "OperatorPicturePromptNonBlockingGetButtonState",
  "body": [
   "$$ButtonState=OperatorPicturePromptNonBlockingGetButtonState($$WindowHandle,$$ButtonName);"
  ],
  "description": "\n\nThis function will return the state of the requested button. TRUE indicates that the button has been pressed. The state of the button will be cleared after this function is called.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$WindowHandle\n\nString\n\nThe handle that was returned when the form was created.\n\n\n\n$ButtonName\n\nString\n\nThe text name of the button whose state is requested.\n\n\n\n\n\nReturn arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ButtonState\n\nBoolean\n\nThe state of the requested button. TRUE indicates that the button has been pressed.\n\n\n\n\n\nExample:\n\n$window = OperatorPicturePromptNonBlockingWithButtons(\"wassup\",\"c:\\\\import\\\\words.jpg\", \"CENTER\", 500,500,\"button1\",\"button2\");\n\n$clicked = false;\n\nwhile ($clicked==false)\n\n{\n\n$clicked = OperatorPicturePromptNonBlockingWithButtonsGetButtonState($window,\"button1\");\n\nSleepMilliseconds(100);\n\n}\n\nUpdateStatus($clicked);\n\nCloseForm($window);\n\nEnd;\n\n\n\n\n\nOperatorPicturePromptOptionsHotkeys\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OperatorPicturePromptOptionsHotkeys": {
  "prefix": "OperatorPicturePromptOptionsHotkeys",
  "body": [
   "$$ButtonText=OperatorPicturePromptOptionsHotkeys($$PromptString,$$GraphicFilePath,$$PictureMode,$$WindowHeight,$$WindowWidth,$$ButtonOptions);"
  ],
  "description": "\n\nPrompts the Operator with a given string and accompanying graphic file. This operator prompt will automatically assume focus, and is a modal dialog box. If the image is not found at the location given, a blank dialog box is displayed, and no error is generated.\n\nThis is a more flexible version of the OperatorPicturePrompt command. This function allows you to also specify the number and text displays of the buttons and returns the text of the button that is clicked.\n\nThe buttons in this function respond to Hotkeys. The keys assigned are <CTRL-1> to <CTRL-0>. The first button will activate when <CTRL-1> is pressed, the second button when <CTRL-2> is pressed and so on up to a maximum of 10 buttons or the number of buttons whichever is less.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$PromptString\n\nString\n\nThe String which is displayed to the operator for instruction or notification purposes.\n\n\n\n$GraphicFilePath\n\nString\n\nThe path and filename for the graphic image to display. The following graphic formats are supported: GIF, TIFF, BMP, JPG, PNG.\n\n\n\n$PictureMode\n\nString\n\nThe resizing mode for the graphic file, supported modes are:\n\n\"AUTOSIZE\" = Automatically positions the image, size is unchanged\n\n\"CENTER\" = Centers the image in the form, size is unchanged\n\n\"STRETCH\" = Centers the image in the form, and sizes it to fit the dialog window\n\n\n\n$WindowHeight\n\nInteger\n\nThe height of the dialog box in pixels\n\n\n\n$WindowWidth\n\nInteger\n\nThe width of the dialog box in pixels\n\n\n\n$ButtonOptions\n\nString\n\nA text string containing the text of each button that you would like displayed on the operator prompt form separated by semicolons. For example, \"Red;Green;Blue\"\n\n\n\n\n\nReturn arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ButtonText\n\nString\n\nThe text of the button clicked on by the operator.\n\n\n\n\n\nExample:\n\n$ButtonText = OperatorPicturePromptOptionsHotkeys(\"Test Prompt\", \"C:\\\\testPic.jpg\", \"CENTER\", 500, 500 ,\"red;green;blue\");\n\n\n\n\n\nOperatorPicturePromptOptionsHotkeysWithPosition\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OperatorPicturePromptOptionsHotkeysWithPosition": {
  "prefix": "OperatorPicturePromptOptionsHotkeysWithPosition",
  "body": [
   "$$ButtonText=OperatorPicturePromptOptionsHotkeysWithPosition($$PromptString,$$GraphicFilePath,$$PictureMode,$$WindowHeight,$$WindowWidth,$$ButtonOptions,$$xPos,$$yPos);"
  ],
  "description": "\n\nPrompts the Operator with a given string and accompanying graphic file. This operator prompt will automatically assume focus, and is a modal dialog box. If the image is not found at the location given, a blank dialog box is displayed, and no error is generated.\n\nThis is a more flexible version of the OperatorPicturePrompt command. This function allows you to also specify the number and text displays of the buttons and returns the text of the button that is clicked. The prompt window will be positioned on the screen at the specified X and Y coordinates.\n\nThe buttons in this function respond to Hotkeys. The keys assigned are <CTRL-1> to <CTRL-0>. The first button will activate when <CTRL-1> is pressed, the second button when <CTRL-2> is pressed and so on up to a maximum of 10 buttons or the number of buttons whichever is less.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$PromptString\n\nString\n\nThe String which is displayed to the operator for instruction or notification purposes.\n\n\n\n$GraphicFilePath\n\nString\n\nThe path and filename for the graphic image to display. The following graphic formats are supported: GIF, TIFF, BMP, JPG, PNG.\n\n\n\n$PictureMode\n\nString\n\nThe resizing mode for the graphic file, supported modes are:\n\n\"AUTOSIZE\" = Automatically positions the image, size is unchanged\n\n\"CENTER\" = Centers the image in the form, size is unchanged\n\n\"STRETCH\" = Centers the image in the form, and sizes it to fit the dialog window\n\n\n\n$WindowHeight\n\nInteger\n\nThe height of the dialog box in pixels\n\n\n\n$WindowWidth\n\nInteger\n\nThe width of the dialog box in pixels\n\n\n\n$ButtonOptions\n\nString\n\nA text string containing the text of each button that you would like displayed on the operator prompt form separated by semicolons. For example, \"Red;Green;Blue\"\n\n\n\n$xPos\n\nInteger\n\nThe X coordinate of the top-left point of the picture prompt window\n\n\n\n$yPos\n\nInteger\n\nThe Y coordinate of the top-left point of the picture prompt window.\n\n\n\n\n\nReturn arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ButtonText\n\nString\n\nThe text of the button clicked on by the operator.\n\n\n\n\n\nExample:\n\n$ButtonText = OperatorPicturePromptOptionsHotkeysWithPosition(\"Test Prompt\", \"C:\\\\testPic.jpg\", \"CENTER\", 500, 500, \"red;green;blue\", 100, 100);\n\n\n\n\n\nOperatorPicturePromptSpecifyOptions\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OperatorPicturePromptSpecifyOptions": {
  "prefix": "OperatorPicturePromptSpecifyOptions",
  "body": [
   "$$ButtonText=OperatorPicturePromptSpecifyOptions($$PromptString,$$GraphicFilePath,$$PictureMode,$$WindowHeight,$$WindowWidth,$$ButtonOptions);"
  ],
  "description": "\n\nPrompts the Operator with a given string and accompanying graphic file. This operator prompt will automatically assume focus, and is a modal dialog box. If the image is not found at the location given, a blank dialog box is displayed, and no error is generated.\n\nThis is a more flexible version of the OperatorPicturePrompt command. This function allows you to also specify the number and text displays of the buttons and returns the text of the button that is clicked.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$PromptString\n\nString\n\nThe String which is displayed to the operator for instruction or notification purposes.\n\n\n\n$GraphicFilePath\n\nString\n\nThe path and filename for the graphic image to display. The following graphic formats are supported: GIF, TIFF, BMP, JPG, PNG.\n\n\n\n$PictureMode\n\nString\n\nThe resizing mode for the graphic file, supported modes are:\n\n\"AUTOSIZE\" = Automatically positions the image, size is unchanged\n\n\"CENTER\" = Centers the image in the form, size is unchanged\n\n\"STRETCH\" = Centers the image in the form, and sizes it to fit the dialog window\n\n\n\n$WindowHeight\n\nInteger\n\nThe height of the dialog box in pixels\n\n\n\n$WindowWidth\n\nInteger\n\nThe width of the dialog box in pixels\n\n\n\n$ButtonOptions\n\nString\n\nA text string containing the text of each button that you would like displayed on the operator prompt form separated by semicolons. For example, \"Red;Green;Blue\"\n\n\n\n\n\nReturn arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ButtonText\n\nString\n\nThe text of the button clicked on by the operator.\n\n\n\n\n\nExample:\n\n$ButtonText = OperatorPicturePromptSpecifyOptions(\"Test Prompt\", \"C:\\\\testPic.jpg\", \"CENTER\", 500, 500, \"red;green;blue\");\n\n\n\n\n\nOperatorPicturePromptSpecifyOptionsWithPosition\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OperatorPicturePromptSpecifyOptionsWithPosition": {
  "prefix": "OperatorPicturePromptSpecifyOptionsWithPosition",
  "body": [
   "$$ButtonText=OperatorPicturePromptSpecifyOptionsWithPosition($$PromptString,$$GraphicFilePath,$$PictureMode,$$WindowHeight,$$WindowWidth,$$ButtonOptions,$$xPos,$$yPos);"
  ],
  "description": "\n\nPrompts the Operator with a given string and accompanying graphic file. This operator prompt will automatically assume focus, and is a modal dialog box. If the image is not found at the location given, a blank dialog box is displayed, and no error is generated.\n\nThis is a more flexible version of the OperatorPicturePrompt command. This function allows you to also specify the number and text displays of the buttons and returns the text of the button that is clicked. The prompt window will be positioned on the screen at the specified X and Y coordinates.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$PromptString\n\nString\n\nThe String which is displayed to the operator for instruction or notification purposes.\n\n\n\n$GraphicFilePath\n\nString\n\nThe path and filename for the graphic image to display. The following graphic formats are supported: GIF, TIFF, BMP, JPG, PNG.\n\n\n\n$PictureMode\n\nString\n\nThe resizing mode for the graphic file, supported modes are:\n\n\"AUTOSIZE\" = Automatically positions the image, size is unchanged\n\n\"CENTER\" = Centers the image in the form, size is unchanged\n\n\"STRETCH\" = Centers the image in the form, and sizes it to fit the dialog window\n\n\n\n$WindowHeight\n\nInteger\n\nThe height of the dialog box in pixels\n\n\n\n$WindowWidth\n\nInteger\n\nThe width of the dialog box in pixels\n\n\n\n$ButtonOptions\n\nString\n\nA text string containing the text of each button that you would like displayed on the operator prompt form separated by semicolons. For example, \"Red;Green;Blue\"\n\n\n\n$xPos\n\nInteger\n\nThe X coordinate of the top-left point of the picture prompt window\n\n\n\n$yPos\n\nInteger\n\nThe Y coordinate of the top-left point of the picture prompt window.\n\n\n\n\n\nReturn arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ButtonText\n\nString\n\nThe text of the button clicked on by the operator.\n\n\n\n\n\nExample:\n\n$ButtonText = OperatorPicturePromptSpecifyOptionsWithPosition(\"Test Prompt\", \"C:\\\\testPic.jpg\", \"CENTER\", 500, 500, \"red;green;blue\", 100, 100);\n\n\n\n\n\nOperatorPicturePromptWithLocation\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OperatorPicturePromptWithLocation": {
  "prefix": "OperatorPicturePromptWithLocation",
  "body": [
   "OperatorPicturePromptWithLocation($$prompt,$$filePath,$$pictureMode,$$width,$$height,$$left,$$top);"
  ],
  "description": "\n\nThis function displays a picture to the user and a has a button to close the prompt.\n\n\n\n\n\nRemarks:\n\nThe word \"Location\" is used in the prompt functions to denote position and size instead of saying \"WithPositionAndSize\".\n\nThe supported image formats are: BMP, GIF, JPG, PNG, TIFF.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$prompt\n\nString\n\nString displayed to the user.\n\n\n\n$filePath\n\nString\n\nThe path and filename for the graphic to display.\n\n\n\n$pictureMode\n\nString\n\nThe resizing mode for the image. The supported modes are:\n\n\u00b7 AUTOSIZE\n\n\u00b7 CENTER\n\n\u00b7 STRETCH\n\n\n\n$width\n\nInteger\n\nThe width of the prompt window in pixels.\n\n\n\n$height\n\nInteger\n\nThe height of the prompt window in pixels.\n\n\n\n$left\n\nInteger\n\nThe location of the left edge of the prompt window in pixels measured from the left edge of the screen.\n\n\n\n$top\n\nInteger\n\nThe location of the top edge of the prompt window in pixels measured from the top edge of the screen.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n\n\n\n\n// Fill the prompt with the picture.\n\n$prompt = \"This is the prompt.\";\n\n$picture = \"C:\\\\Graphics\\\\Prompt1.jpg\";\n\n$mode = \"STRETCH\";\n\n$width = 600;\n\n$height = 650;\n\n$left = 20;\n\n$top = 50;\n\nOperatorPicturePromptWithLocation($prompt, $picture, $mode, $width, $height, $left, $top);\n\n\n\n\n\nOperatorPrompt\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OperatorPrompt": {
  "prefix": "OperatorPrompt",
  "body": [
   "$$output=OperatorPrompt($$PromptString,$$ButtonOptions);"
  ],
  "description": "\n\nPrompts the Operator with a given string, and returns the text of the button selected. This operator prompt will automatically assume focus, and is a modal dialog box.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$PromptString\n\nString\n\nThe String which is displayed to the operator for instruction or notification purposes.\n\n\n\n$ButtonOptions\n\nString\n\nThe Button Options supplied for the operator to provide feedback to the test script. Valid Options are:\n\n\"AbortRetryIgnore\"\n\n\"OKCancel\"\n\n\"RetryCancel\"\n\n\"YesNo\"\n\n\"YesNoCancel\"\n\n\"OK\"\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$output\n\nString\n\nThe Text Label Of The Button Which was selected by the operator.\n\n\n\n\n\nOperatorPromptCreateGaugeNonBlocking\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OperatorPromptCreateGaugeNonBlocking": {
  "prefix": "OperatorPromptCreateGaugeNonBlocking",
  "body": [
   "$$GaugeForm=OperatorPromptCreateGaugeNonBlocking($$Instructions,$$MinValue,$$MaxValue,$$LowerLimit,$$UpperLimit,$$InitialValue,$$GaugeArc);"
  ],
  "description": "\n\n\n\n\n\nThis function displays the following gauge window to the operator which remains on the screen while script execution continues. The gauge value can be updated by using the OperatorPromptNonBlockingGaugeUpdate function.\n\n\n\n\n\nWhen the value is within the limits specified by the $LowerLimit and $UpperLimit functions, the current value box will turn green, otherwise it remains red while the current value is outside of the allowable limits.\n\nThe gauge form window can be closed at any time by using the CloseForm function.\n\n\n\n\n\nThe Arc of the gauge can be modified by using the $GaugeArc parameter which specifies the total number of degrees that the gauge's arc will span.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Instructions\n\nString\n\nThe text shown to the operator at the top of the window display.\n\n\n\n$MinValue\n\nFloat\n\nThe minimum value for the gauge.\n\n\n\n$MaxValue\n\nFloat\n\nThe maximum value for the gauge.\n\n\n\n$LowerLimit\n\nFloat\n\nThe lower limit of the acceptable value range.\n\n\n\n$UpperLimit\n\nFloat\n\nThe upper limit of the acceptable value range.\n\n\n\n$InitialValue\n\nFloat\n\nThe starting value for the gauge.\n\n\n\n$GaugeArc\n\nFloat\n\nThe number of degrees that the gauge arc will occupy. This can be useful for creating different styles of gauges for display to the operator.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Gauge\n\nObject\n\nThe handle to the newly created window which can be passed to subsequent functions to update or close the gauge window.\n\n\n\n\n\nExample:\n\n$MyGauge = OperatorPromptCreateGaugeNonBlocking(\"Here are some instructions for the Operator...\", 100, 500, 300, 400, 325, 280);\n\nSleep(2);\n\nOperatorPromptNonBlockingGaugeUpdate($MyGauge, 50);\n\nSleep(2);\n\nOperatorPromptNonBlockingGaugeUpdate($MyGauge, 100);\n\nSleep(2);\n\nOperatorPromptNonBlockingGaugeUpdate($MyGauge, 200);\n\nSleep(2);\n\nOperatorPromptNonBlockingGaugeUpdate($MyGauge, 300);\n\nSleep(2);\n\nOperatorPromptNonBlockingGaugeUpdate($MyGauge, 400);\n\nSleep(2);\n\nOperatorPromptNonBlockingGaugeUpdate($MyGauge, 500);\n\nSleep(2);\n\nOperatorPromptNonBlockingGaugeUpdate($MyGauge, 600);\n\nSleep(2);\n\nOperatorPromptNonBlockingGaugeUpdate($MyGauge, 700);\n\nSleep(2);\n\n\n\n\n\nCloseForm($MyGauge);\n\n\n\n\n\nOperatorPromptCreateGaugeNonBlockingWithPosition\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OperatorPromptCreateGaugeNonBlockingWithPosition": {
  "prefix": "OperatorPromptCreateGaugeNonBlockingWithPosition",
  "body": [
   "$$GaugeForm=OperatorPromptCreateGaugeNonBlockingWithPosition($$Instruct,$$MinValue,$$MaxValue,$$LowerLimit,$$UpperLimit,$$InitialValue,$$GaugeArc,$$leftEdge,$$topEdge);"
  ],
  "description": "\n\n\n\n\n\nThis function displays the following gauge window to the operator which remains on the screen while script execution continues. The gauge value can be updated by using the OperatorPromptNonBlockingGaugeUpdate function.\n\n\n\n\n\nWhen the value is within the limits specified by the $LowerLimit and $UpperLimit functions, the current value box will turn green, otherwise it remains red while the current value is outside of the allowable limits.\n\n\n\n\n\nThe Gauge window will show up at a location on screen defined by $leftEdge and $topEdge.\n\nThe gauge form window can be closed at any time by using the CloseForm function.\n\n\n\n\n\nThe Arc of the gauge can be modified by using the $GaugeArc parameter which specifies the total number of degrees that the gauge's arc will span.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Instruct\n\nString\n\nThe text shown to the operator at the top of the window display.\n\n\n\n$MinValue\n\nFloat\n\nThe minimum value for the gauge.\n\n\n\n$MaxValue\n\nFloat\n\nThe maximum value for the gauge.\n\n\n\n$LowerLimit\n\nFloat\n\nThe lower limit of the acceptable value range.\n\n\n\n$UpperLimit\n\nFloat\n\nThe upper limit of the acceptable value range.\n\n\n\n$InitialValue\n\nFloat\n\nThe starting value for the gauge.\n\n\n\n$GaugeArc\n\nFloat\n\nThe number of degrees that the gauge arc will occupy. This can be useful for creating different styles of gauges for display to the operator.\n\n\n\n$leftEdge\n\nInteger\n\nThe left edge of the gauge window in pixels measured from the left edge of the screen.\n\n\n\n$topEdge\n\nInteger\n\nThe top edge of the gauge window in pixels measured from the top edge of the screen.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$GaugeForm\n\nObject\n\nThe handle to the newly created window which can be passed to subsequent functions to update or close the gauge window.\n\n\n\n\n\nExample:\n\n$MyGauge = OperatorPromptCreateGaugeNonBlockingWithPosition(\"Here are some instructions for the Operator...\", 100, 500, 300, 400, 325, 280, 1000, 250);\n\nSleep(2);\n\nOperatorPromptNonBlockingGaugeUpdate($MyGauge, 50);\n\nSleep(2);\n\nOperatorPromptNonBlockingGaugeUpdate($MyGauge, 100);\n\nSleep(2);\n\nOperatorPromptNonBlockingGaugeUpdate($MyGauge, 200);\n\nSleep(2);\n\nOperatorPromptNonBlockingGaugeUpdate($MyGauge, 300);\n\nSleep(2);\n\nOperatorPromptNonBlockingGaugeUpdate($MyGauge, 400);\n\nSleep(2);\n\nOperatorPromptNonBlockingGaugeUpdate($MyGauge, 500);\n\nSleep(2);\n\nOperatorPromptNonBlockingGaugeUpdate($MyGauge, 600);\n\nSleep(2);\n\nOperatorPromptNonBlockingGaugeUpdate($MyGauge, 700);\n\nSleep(2);\n\n\n\n\n\nCloseForm($MyGauge);\n\n\n\n\n\nOperatorPromptCreateTuningBarNonBlocking\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OperatorPromptCreateTuningBarNonBlocking": {
  "prefix": "OperatorPromptCreateTuningBarNonBlocking",
  "body": [
   "$$TuningForm=OperatorPromptCreateTuningBarNonBlocking($$Instructions,$$MinValue,$$MaxValue,$$LowerLimit,$$UpperLimit,$$InitialValue);"
  ],
  "description": "\n\n\n\n\n\nThis function displays the following \"Tuning Bar\" window to the operator which remains on the screen while script execution continues. The tuning bar value and instructions can be updated by using the OperatorPromptNonBlockingTuningBarUpdate function.\n\n\n\n\n\nWhen the value is within the limits specified by the $LowerLimit and $UpperLimit functions, the current value box will turn green, otherwise it remains red while the current value is outside of the allowable limits.\n\nThe tuning bar form window can be closed at any time by using the CloseForm function.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Instructions\n\nString\n\nThe text shown to the operator at the top of the window display.\n\n\n\n$MinValue\n\nFloat\n\nThe minimum value for the tuning bar.\n\n\n\n$MaxValue\n\nFloat\n\nThe maximum value for the tuning bar.\n\n\n\n$LowerLimit\n\nFloat\n\nThe lower limit of the acceptable value range.\n\n\n\n$UpperLimit\n\nFloat\n\nThe upper limit of the acceptable value range.\n\n\n\n$InitialValue\n\nFloat\n\nThe starting value for the tuning bar.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$TuningForm\n\nObject\n\nThe handle to the newly created window which can be passed to subsequent functions to update or close the tuning bar window.\n\n\n\n\n\nExample:\n\n\n\n\n\n$TuningForm = OperatorPromptCreateTuningBarNonBlocking(\"Here are Instructions\", 20, 90, 58.5, 72.5, 68.42, 300, 150);\n\nSleep(2);\n\n$Closed = OperatorPromptNonBlockingTuningBarUpdate($TuningForm, 71.2, \"New Message 1\");\n\nUpdateStatus($Closed);\n\nSleep(2);\n\n$Closed = OperatorPromptNonBlockingTuningBarUpdate($TuningForm, 74.3, \"New Message 2\");\n\nUpdateStatus($Closed);\n\nSleep(2);\n\n$Closed = OperatorPromptNonBlockingTuningBarUpdate($TuningForm, 75.6, \"New Message 3\");\n\nUpdateStatus($Closed);\n\nSleep(2);\n\n$Closed = OperatorPromptNonBlockingTuningBarUpdate($TuningForm, 76.3, \"New Message 5\");\n\nUpdateStatus($Closed);\n\nSleep(2);\n\n$Closed = OperatorPromptNonBlockingTuningBarUpdate($TuningForm, 45.5, \"New Message 6\");\n\nUpdateStatus($Closed);\n\nSleep(2);\n\n$Closed = OperatorPromptNonBlockingTuningBarUpdate($TuningForm, 71.2, \"New Message 7\");\n\nUpdateStatus($Closed);\n\nSleep(2);\n\n$Closed = OperatorPromptNonBlockingTuningBarUpdate($TuningForm, 71.99, \"New Message 8\");\n\nUpdateStatus($Closed);\n\nCloseForm($TuningForm);\n\n\n\n\n\nOperatorPromptCreateTuningBarNonBlockingWithPosition\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OperatorPromptCreateTuningBarNonBlockingWithPosition": {
  "prefix": "OperatorPromptCreateTuningBarNonBlockingWithPosition",
  "body": [
   "$$TuningForm=OperatorPromptCreateTuningBarNonBlockingWithPosition($$Instruct,$$MinValue,$$MaxValue,$$LowerLimit,$$UpperLimit,$$InitialValue,$$leftEdge,$$topEdge);"
  ],
  "description": "\n\n\n\n\n\nThis function displays the following \"Tuning Bar\" window to the operator which remains on the screen while script execution continues. The tuning bar value and instructions can be updated by using the OperatorPromptNonBlockingTuningBarUpdate function.\n\n\n\n\n\nWhen the value is within the limits specified by the $LowerLimit and $UpperLimit functions, the current value box will turn green, otherwise it remains red while the current value is outside of the allowable limits.\n\n\n\n\n\nThe Tuning Bar window will show up at a location on screen defined by $leftEdge and $topEdge.\n\nThe tuning bar form window can be closed at any time by using the CloseForm function.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Instruct\n\nString\n\nThe text shown to the operator at the top of the window display.\n\n\n\n$MinValue\n\nFloat\n\nThe minimum value for the tuning bar.\n\n\n\n$MaxValue\n\nFloat\n\nThe maximum value for the tuning bar.\n\n\n\n$LowerLimit\n\nFloat\n\nThe lower limit of the acceptable value range.\n\n\n\n$UpperLimit\n\nFloat\n\nThe upper limit of the acceptable value range.\n\n\n\n$InitialValue\n\nFloat\n\nThe starting value for the tuning bar.\n\n\n\n$leftEdge\n\nInteger\n\nThe left edge of the tuning bar window in pixels measured from the left edge of the screen.\n\n\n\n$topEdge\n\nInteger\n\nThe top edge of the tuning bar window in pixels measured from the top edge of the screen.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$TuningForm\n\nObject\n\nThe handle to the newly created window which can be passed to subsequent functions to update or close the tuning bar window.\n\n\n\n\n\nExample:\n\n\n\n\n\n$TuningForm = OperatorPromptCreateTuningBarNonBlockingWithPosition(\"Here are Instructions\", 20, 90, 58.5, 72.5, 68.42, 300, 150);\n\nSleep(2);\n\n$Closed = OperatorPromptNonBlockingTuningBarUpdate($TuningForm, 71.2, \"New Message 1\");\n\nUpdateStatus($Closed);\n\nSleep(2);\n\n$Closed = OperatorPromptNonBlockingTuningBarUpdate($TuningForm, 74.3, \"New Message 2\");\n\nUpdateStatus($Closed);\n\nSleep(2);\n\n$Closed = OperatorPromptNonBlockingTuningBarUpdate($TuningForm, 75.6, \"New Message 3\");\n\nUpdateStatus($Closed);\n\nSleep(2);\n\n$Closed = OperatorPromptNonBlockingTuningBarUpdate($TuningForm, 76.3, \"New Message 5\");\n\nUpdateStatus($Closed);\n\nSleep(2);\n\n$Closed = OperatorPromptNonBlockingTuningBarUpdate($TuningForm, 45.5, \"New Message 6\");\n\nUpdateStatus($Closed);\n\nSleep(2);\n\n$Closed = OperatorPromptNonBlockingTuningBarUpdate($TuningForm, 71.2, \"New Message 7\");\n\nUpdateStatus($Closed);\n\nSleep(2);\n\n$Closed = OperatorPromptNonBlockingTuningBarUpdate($TuningForm, 71.99, \"New Message 8\");\n\nUpdateStatus($Closed);\n\nCloseForm($TuningForm);\n\n\n\n\n\nOperatorPromptForFile\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OperatorPromptForFile": {
  "prefix": "OperatorPromptForFile",
  "body": [
   "$$FileName=OperatorPromptForFile($$TitleString,$$InitialFolder,$$Filters);"
  ],
  "description": "\n\n\n\n\n\nThis function is used to open the File dialog prompt and display it to the operator.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$TitleString\n\nString\n\nThe text shown on the Open File Dialog Display\n\n\n\n$InitialFolder\n\nString\n\nThe initial folder to which the Open File Dialog will be shown.\n\n\n\n$Filters\n\nString\n\nThe filter string to be displayed on the dialog. The format is the same as the MFC style filter string for file dialogs:\n\nExample: Text Files ("
 }
,
 "JTS OperatorPromptNonBlocking": {
  "prefix": "OperatorPromptNonBlocking",
  "body": [
   "$$WindowHandle=OperatorPromptNonBlocking($$PromptString,$$Height,$$Width);"
  ],
  "description": "\n\nThis function will prompt the operator in a separate window, and allows the script to continue. The operator prompt dialog continues to exist in a separate thread until it is disposed of with the CloseForm function.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$PromptString\n\nString\n\nThe String which is displayed to the operator for instruction or notification purposes.\n\n\n\n$Height\n\nInteger\n\nThe height in pixels of the prompt dialog box\n\n\n\n$Width\n\nInteger\n\nThe width in pixels of the prompt dialog box\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$WindowHandle\n\nObject\n\nA handle to the operator dialog box. This can later be closed with the CloseForm function.\n\n\n\n\n\nOperatorPromptNonBlockingGaugeUpdate\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OperatorPromptNonBlockingGaugeUpdate": {
  "prefix": "OperatorPromptNonBlockingGaugeUpdate",
  "body": [
   "$$FormClosed=OperatorPromptNonBlockingGaugeUpdate($$Form,$$Value);"
  ],
  "description": "\n\n\n\n\n\nThis function is used to update the current value display on a gauge form that has been created using the OperatorPromptCreateGaugeNonBlocking script command.\n\n\n\n\n\nIn the event that the value supplied for the gauge is less than or greater than the minimum or maximum values for the gauge, it's range will be automatically updated to include the new value.\n\n\n\n\n\nThe function returns a boolean variable indicating whether or not the form has been closed by the user.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Form\n\nObject\n\nA handle to the form created using the OperatorPromptCreateGaugeNonBlocking function.\n\n\n\n$Value\n\nFloat\n\nThe desired value to display on the gauge control.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$FormClosed\n\nBoolean\n\nA boolean value indicating whether or not the form has been closed.\n\n\u00b7 False = form is still visible\n\n\u00b7 True = form has been closed and is no longer visible\n\n\n\n\n\nExample:\n\n\n\n\n\n$MyGauge = OperatorPromptCreateGaugeNonBlocking(\"Here are some instructions for the Operator...\",100,500,300,400,325,280);\n\nSleep(2);\n\nOperatorPromptNonBlockingGaugeUpdate($MyGauge,50);\n\nSleep(2);\n\nOperatorPromptNonBlockingGaugeUpdate($MyGauge,100);\n\nSleep(2);\n\nOperatorPromptNonBlockingGaugeUpdate($MyGauge,200);\n\nSleep(2);\n\nOperatorPromptNonBlockingGaugeUpdate($MyGauge,300);\n\nSleep(2);\n\nOperatorPromptNonBlockingGaugeUpdate($MyGauge,400);\n\nSleep(2);\n\nOperatorPromptNonBlockingGaugeUpdate($MyGauge,500);\n\nSleep(2);\n\nOperatorPromptNonBlockingGaugeUpdate($MyGauge,600);\n\nSleep(2);\n\nOperatorPromptNonBlockingGaugeUpdate($MyGauge,700);\n\nSleep(2);\n\n\n\n\n\nCloseForm($MyGauge);\n\n\n\n\n\nOperatorPromptNonBlockingGetButtonState\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OperatorPromptNonBlockingGetButtonState": {
  "prefix": "OperatorPromptNonBlockingGetButtonState",
  "body": [
   "$$ButtonState=OperatorPromptNonBlockingGetButtonState($$WindowHandle,$$ButtonName);"
  ],
  "description": "\n\nThis function will return the state of the requested button. TRUE indicates that the button has been pressed. The state of the button will be cleared after this function is called.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$WindowHandle\n\nObject\n\nThe handle that was returned when the form was created.\n\n\n\n$ButtonName\n\nString\n\nText name of the button whose state is requested\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ButtonState\n\nBoolean\n\nThe state of the requested button. TRUE indicates that the button has been pressed.\n\n\n\n\n\nOperatorPromptNonBlockingKeepOnTop\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OperatorPromptNonBlockingKeepOnTop": {
  "prefix": "OperatorPromptNonBlockingKeepOnTop",
  "body": [
   "OperatorPromptNonBlockingKeepOnTop($$windowHandle,$$keepOnTop);"
  ],
  "description": "\n\nThis function will force the non-blocking prompt to be on top of all other windows or remove that ability (other windows can be on top of the prompt).\n\n\n\nRemarks:\n\nThe prompt must already have been opened with OperatorPromptNonBlocking.\n\n\n\nIf the prompt is not already open, the function will fail.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$windowHandle\n\nObject\n\nThe handle to the prompt that was previously opened using OperatorPromptNonBlocking.\n\n\n\n$keepOnTop\n\nBoolean\n\nWhether the prompt should stay on top of all other windows. true = stay on top, false = do not stay on top.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n\n\n\n\n// Open a non-blocking prompt.\n\n$prompt = \"This is a non-blocking prompt.\";\n\n$height = 150;\n\n$width = 300;\n\n$winHandle = OperatorPromptNonBlocking($fileName);\n\n\n\n//Keep the prompt on top.\n\n$keepOnTop = true;\n\n\n\nOperatorPromptNonBlockingKeepOnTop($winHandle, $keepOnTop);\n\n\n\nEnd;\n\n\n\n\n\nOperatorPromptNonBlockingPositionToCell\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OperatorPromptNonBlockingPositionToCell": {
  "prefix": "OperatorPromptNonBlockingPositionToCell",
  "body": [
   "OperatorPromptNonBlockingPositionToCell($$Form);"
  ],
  "description": "\n\n\n\n\n\nThis function is used to set a non-blocking operator prompt directly over the test cell which created the user prompt.\n\n\n\n\n\nThis function can be useful when several test cells may be presenting non-blocking user-prompts to clarify which test cell opened which non-blocking user prompt.\n\n\n\n\n\nNote: Because the non-blocking user prompt is running on a completely different thread than the test cell, it may be necessary to pause for a length of time between creating the non-blocking window and positioning it over the test cell to ensure that the prompt has been created by the other thread running in parallel with the test cell. This is especially true on a test station running very large numbers of test cells.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Form\n\nObject\n\nA handle to the form created using the OperatorPromptNonBlocking function.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n\n\n\n\nUpdateStatus(\"Starting Test\");\n\n$WindowHandle = OperatorPromptNonBlocking(\"Hello World!\",75,75);\n\nSleep(1); // Provide Time For the Window to be created\n\nOperatorPromptNonBlockingPositionToCell($WindowHandle);\n\nSleep(5);\n\nCloseForm($MyGauge);\n\n\n\n\n\nOperatorPromptNonBlockingTuningBarUpdate\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OperatorPromptNonBlockingTuningBarUpdate": {
  "prefix": "OperatorPromptNonBlockingTuningBarUpdate",
  "body": [
   "$$FormClosed=OperatorPromptNonBlockingTuningBarUpdate($$Form,$$Value,$$Instructions);"
  ],
  "description": "\n\n\n\n\n\nThis function is used to update the current value display on a tuning bar form that has been created using the OperatorPromptCreateTuningBarNonBlocking script command.\n\n\n\n\n\nIn the event that the value supplied for the tuning bar is less than or greater than the minimum or maximum values for the tuning bar, it's range will be automatically updated to include the new value.\n\n\n\n\n\nThe function returns a boolean variable indicating whether or not the form has been closed by the user.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Form\n\nObject\n\nA handle to the form created using the OperatorPromptCreateTuningBarNonBlocking function.\n\n\n\n$Value\n\nFloat\n\nThe desired value to display on the tuning bar control.\n\n\n\n$Instructions\n\nString\n\nUpdated Instructions to Display to the Operator\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$FormClosed\n\nBoolean\n\nA boolean value indicating whether or not the form has been closed.\n\n\u00b7 False = form is still visible\n\n\u00b7 True = form has been closed and is no longer visible\n\n\n\n\n\nExample:\n\n\n\n\n\n$TuningForm = OperatorPromptCreateTuningBarNonBlocking(\"Here are Instructions\",20,90,58.5,72.5,68.42);\n\nSleep(2);\n\n$Closed = OperatorPromptNonBlockingTuningBarUpdate($TuningForm,71.2,\"New Message 1\");\n\nUpdateStatus($Closed);\n\nSleep(2);\n\n$Closed = OperatorPromptNonBlockingTuningBarUpdate($TuningForm,74.3,\"New Message 2\");\n\nUpdateStatus($Closed);\n\nSleep(2);\n\n$Closed = OperatorPromptNonBlockingTuningBarUpdate($TuningForm,75.6,\"New Message 3\");\n\nUpdateStatus($Closed);\n\nSleep(2);\n\n$Closed = OperatorPromptNonBlockingTuningBarUpdate($TuningForm,76.3,\"New Message 5\");\n\nUpdateStatus($Closed);\n\nSleep(2);\n\n$Closed = OperatorPromptNonBlockingTuningBarUpdate($TuningForm,45.5,\"New Message 6\");\n\nUpdateStatus($Closed);\n\nSleep(2);\n\n$Closed = OperatorPromptNonBlockingTuningBarUpdate($TuningForm,71.2,\"New Message 7\");\n\nUpdateStatus($Closed);\n\nSleep(2);\n\n$Closed = OperatorPromptNonBlockingTuningBarUpdate($TuningForm,71.99,\"New Message 8\");\n\nUpdateStatus($Closed);\n\nCloseForm($TuningForm);\n\n\n\n\n\nEnd;\n\n\n\n\n\nOperatorPromptNonBlockingUpdateMessage\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OperatorPromptNonBlockingUpdateMessage": {
  "prefix": "OperatorPromptNonBlockingUpdateMessage",
  "body": [
   "OperatorPromptNonBlockingUpdateMessage($$WindowHandle,$$Message);"
  ],
  "description": "\n\nThis function will update the prompt message in the form. The form must already have been created using the OperatorPromptNonBlocking function.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$WindowHandle\n\nObject\n\nThat handle that was returned when the form was created.\n\n\n\n$Message\n\nString\n\nThe new message to prompt the user with.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n// Open the form.\n\n$WindowHandle = OperatorPromptNonBlocking(\"The Prompt String:\", 200, 400);\n\n\n\n\n\n// Change the prompt.\n\nOperatorPromptNonBlockingUpdateMessage($WindowHandle, \"A new prompt\");\n\n\n\n\n\nOperatorPromptNonBlockingWithButtons\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OperatorPromptNonBlockingWithButtons": {
  "prefix": "OperatorPromptNonBlockingWithButtons",
  "body": [
   "$$WindowHandle=OperatorPromptNonBlockingWithButtons($$PromptString,$$Height,$$Width,$$Button1Text,$$Button1Top,$$Button1Left,$$Button2Text,$$Button2Top,$$Button2Left);"
  ],
  "description": "\n\nThis function will prompt the operator in a separate window, and allows the script to continue. Two programmable buttons can be displayed on the form. The operator prompt dialog continues to exist in a separate thread until it is disposed of with the CloseForm function.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$PromptString\n\nString\n\nThe String which is displayed to the operator for instruction or notification purposes.\n\n\n\n$Height\n\nInteger\n\nThe height in pixels of the prompt dialog box\n\n\n\n$Width\n\nInteger\n\nThe width in pixels of the prompt dialog box\n\n\n\n$Button1Text\n\nString\n\nLabel for button. If this string is null the button will not be displayed.\n\n\n\n$Button1Top\n\nInteger\n\nPosition of the buttons top edge in the form\n\n\n\n$Button1Left\n\nInteger\n\nPosition of the buttons left edge in the form.\n\n\n\n$Button2Text\n\nString\n\nLabel for button. If this string is null the button will not be displayed.\n\n\n\n$Button2Top\n\nInteger\n\nPosition of the buttons top edge in the form\n\n\n\n$Button2Left\n\nInteger\n\nPosition of the buttons left edge in the form.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$WindowHandle\n\nObject\n\nA handle to the operator dialog box. This can later be closed with the CloseForm function.\n\n\n\n\n\nOperatorPromptNonBlockingWithButtonsAndLocation\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OperatorPromptNonBlockingWithButtonsAndLocation": {
  "prefix": "OperatorPromptNonBlockingWithButtonsAndLocation",
  "body": [
   "$$winHandle=OperatorPromptNonBlockingWithButtonsAndLocation($$prompt,$$button1Text,$$button1Left,$$button1Top,$$button2Test,$$button2Left,$$button2Top,$$width,$$height,$$left,$$top);"
  ],
  "description": "\n\nThis function opens a non-blocking window with a message to the user and up to two buttons. The script, then, continues.\n\n\n\n\n\nRemarks:\n\nThe prompt can be changed using the function, OperatorPromptNonBlockingWithButtonsUpdateMessage.\n\nThe status of the buttons can be checked with the function, OperatorPromptNonBlockingGetButtonState.\n\nThe prompt window is closed using the function, CloseForm.\n\nCheck for the window being closed without clicking on any button with the function, CheckFormExists.\n\nThe word \"Location\" is used in the prompt functions to denote position and size instead of saying \"WithPositionAndSize\".\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$prompt\n\nString\n\nString displayed to the user.\n\n\n\n$button1Text\n\nString\n\nThe text to show on button 1.\n\n\n\n$button1Left\n\nInteger\n\nThe left edge of button 1 relative to the left edge of the prompt window.\n\n\n\n$button1Top\n\nInteger\n\nThe top edge of button 1 relative to the top edge of the prompt window.\n\n\n\n$button2Text\n\nString\n\nThe text to show on button 2.\n\n\n\n$button2Left\n\nInteger\n\nThe left edge of button 2 relative to the left edge of the prompt window.\n\n\n\n$button2Top\n\nInteger\n\nThe top edge of button 2 relative to the top edge of the prompt window.\n\n\n\n$width\n\nInteger\n\nThe width of the prompt window in pixels.\n\n\n\n$height\n\nInteger\n\nThe height of the prompt window in pixels.\n\n\n\n$left\n\nInteger\n\nThe location of the left edge of the prompt window in pixels measured from the left edge of the screen.\n\n\n\n$top\n\nInteger\n\nThe location of the top edge of the prompt window in pixels measured from the top edge of the screen.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$winHandle\n\nObject\n\nA handle to the prompt window that can be passed to other functions.\n\n\n\n\n\nExample:\n\n\n\n\n\n// Set up the prompt variables.\n\n$prompt = \"This is the prompt.\";\n\n$btn1Txt = \"Button 1\";\n\n$btn1Left = 20;\n\n$btn1Top = 550;\n\n$btn2Txt = \"Button 2\";\n\n$btn2Left = 450;\n\n$btn2Top = 550;\n\n$width = 600;\n\n$height = 650;\n\n$left = 20;\n\n$top = 50;\n\n\n\n\n\n$handle = OperatorPromptNonBlockingWithButtonsAndLocation($prompt, $btn1Txt, $btn1Left, $btn1Top, $btn2Txt, $btn2Left, $btn2Top, $width, $height, $left, $top);\n\n\n\n\n\n// Check for the window closed or a button clicked.\n\n$clicked = false;\n\nwhile (!$clicked)\n\n{\n\n$exists = CheckFormExists($handle);\n\n$state1 = OperatorPromptNonBlockingGetButtonState($handle, $btn1Txt);\n\n$state2 = OperatorPromptNonBlockingGetButtonState($handle, $btn2Txt);\n\n$clicked = $state1 || $state2 || !$exists;\n\n}\n\n\n\n\n\n$btnStr = \"No button\";\n\nif ($state1)\n\n{\n\n$btnStr = $btn1Txt;\n\n}\n\nif ($state2)\n\n{\n\n$btnStr = $btn2Txt;\n\n}\n\n\n\n\n\n$outStr = \"Button pressed:\\t\" + $btnStr;\n\nUpdateStatus($outStr);\n\n\n\n\n\nOperatorPromptNonBlockingWithButtonsUpdateMessage\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OperatorPromptNonBlockingWithButtonsUpdateMessage": {
  "prefix": "OperatorPromptNonBlockingWithButtonsUpdateMessage",
  "body": [
   "OperatorPromptNonBlockingWithButtonsUpdateMessage($$WindowHandle,$$Message);"
  ],
  "description": "\n\nThis function will update the prompt message in the form.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$WidowHandle\n\nObject\n\nThe handle that was returned when the form was created\n\n\n\n$Message\n\nString\n\nThe new prompt string for the message.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nnone\n\n\n\n\n\nOperatorPromptNonBlockingWithInput\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OperatorPromptNonBlockingWithInput": {
  "prefix": "OperatorPromptNonBlockingWithInput",
  "body": [
   "$$Handle=OperatorPromptNonBlockingWithInput($$Message,$$Height,$$Width,$$InputTop,$$InputLeft,$$Button1Text,$$Button1Top,$$Button1Left,$$Button2Text,$$Button2Top,$$Button2Left);"
  ],
  "description": "\n\nThis function will prompt the operator in a separate window, and allows the script to continue. An input text box and two programmable buttons can be displayed on the form. The operator prompt dialog continues to exist in a separate thread until it is disposed of with the CloseForm function.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Message\n\nString\n\nA message that will be shows to the user at the top of the prompt window.\n\n\n\n$Height\n\nInteger\n\nThe height of the prompt window in pixels.\n\n\n\n$Width\n\nInteger\n\nThe width of the prompt window in pixels.\n\n\n\n$InputTop\n\nInteger\n\nThe top edge of the input text box in pixels.\n\n\n\n$InputLeft\n\nInteger\n\nThe left edge of the input text box in pixels.\n\n\n\n$Button1Text\n\nString\n\nThe text displayed on the first button. If left blank, the button will not be displayed.\n\n\n\n$Button1Top\n\nInteger\n\nThe top edge of button 1 in pixels.\n\n\n\n$Button2Left\n\nInteger\n\nThe left edge of button 1 in pixels.\n\n\n\n$Button2Text\n\nString\n\nThe text displayed on the second button. If left blank, the button will not be displayed.\n\n\n\n$Button2Top\n\nInteger\n\nThe top edge of button 2 in pixels.\n\n\n\n$Button2Left\n\nInteger\n\nThe left edge of button 2 in pixels.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nA pointer to the window opened as a prompt. This handle is used in other functions to access the parts of this window.\n\n\n\n\n\nExample:\n\n// Set up the prompting variables.\n\n$pPrompt = \"Enter some data and click a button.\";\n\n$pHeight = 200;\n\n$pWidth = 400;\n\n$pInpTop = 85;\n\n$pInpLeft = 85;\n\n$pBtn1 = \"OK\";\n\n$pBtn1Top = 135;\n\n$pBtn1Left = 95;\n\n$pBtn2 = \"Cancel\";\n\n$pBtn2Top = 135;\n\n$pBtn2Left = 275;\n\n\n\n\n\n$WindowHandle = OperatorPromptNonBlockingWithInput($pPrompt, $pHeight, $pWidth, $pInpTop, $pInpLeft, $pBtn1, $pBtn1Top, $pBtn1Left, $pBtn2, $pBtn2Top, $pBtn2Left);\n\n\n\n\n\nOperatorPromptNonBlockingWithInputAndLocation\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OperatorPromptNonBlockingWithInputAndLocation": {
  "prefix": "OperatorPromptNonBlockingWithInputAndLocation",
  "body": [
   "$$winHandle=OperatorPromptNonBlockingWithInputAndLocation($$prompt,$$inputLeft,$$inputTop,$$button1Text,$$button1Left,$$button1Top,$$button2Test,$$button2Left,$$button2Top,$$width,$$height,$$left,$$top);"
  ],
  "description": "\n\nThis function opens a non-blocking window with a message to the user, a text box for user entered data and up to two buttons. The script, then, continues.\n\n\n\n\n\nRemarks:\n\nThe prompt can be changed using the function, OperatorPromptNonBlockingWithInputUpdateMessage.\n\nThe status of the buttons can be checked with the function, OperatorPromptNonBlockingWithInputGetButtonState.\n\nThe user entered data can be read with the function, OperatorPromptNonBlockingWithInputGetInput.\n\nThe prompt window is closed using the function, CloseForm.\n\nCheck for the window being closed without clicking on any button with the function, CheckFormExists.\n\nThe word \"Location\" is used in the prompt functions to denote position and size instead of saying \"WithPositionAndSize\".\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$prompt\n\nString\n\nString displayed to the user.\n\n\n\n$inputLeft\n\nInteger\n\nThe left edge of the input box relative to the left edge of the prompt window.\n\n\n\n$inputTop\n\nInteger\n\nThe top edge of the input box relative to the top edge of the prompt window.\n\n\n\n$button1Text\n\nString\n\nThe text to show on button 1.\n\n\n\n$button1Left\n\nInteger\n\nThe left edge of button 1 relative to the left edge of the prompt window.\n\n\n\n$button1Top\n\nInteger\n\nThe top edge of button 1 relative to the top edge of the prompt window.\n\n\n\n$button2Text\n\nString\n\nThe text to show on button 2.\n\n\n\n$button2Left\n\nInteger\n\nThe left edge of button 2 relative to the left edge of the prompt window.\n\n\n\n$button2Top\n\nInteger\n\nThe top edge of button 2 relative to the top edge of the prompt window.\n\n\n\n$width\n\nInteger\n\nThe width of the prompt window in pixels.\n\n\n\n$height\n\nInteger\n\nThe height of the prompt window in pixels.\n\n\n\n$left\n\nInteger\n\nThe location of the left edge of the prompt window in pixels measured from the left edge of the screen.\n\n\n\n$top\n\nInteger\n\nThe location of the top edge of the prompt window in pixels measured from the top edge of the screen.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$winHandle\n\nObject\n\nA handle to the prompt window that can be passed to other functions.\n\n\n\n\n\nExample:\n\n\n\n\n\n// Set up the prompt variables.\n\n$prompt = \"This is the prompt.\";\n\n$inpLeft = 30;\n\n$inpTop = 300;\n\n$btn1Txt = \"Button 1\";\n\n$btn1Left = 20;\n\n$btn1Top = 550;\n\n$btn2Txt = \"Button 2\";\n\n$btn2Left = 450;\n\n$btn2Top = 550;\n\n$width = 600;\n\n$height = 650;\n\n$left = 20;\n\n$top = 50;\n\n\n\n\n\n$handle = OperatorPromptNonBlockingWithInputAndLocation($prompt, $inpLeft, $inpTop, $btn1Txt, $btn1Left, $btn1Top, $btn2Txt, $btn2Left, $btn2Top, $width, $height, $left, $top);\n\n\n\n\n\n// Check for the window closed or a button clicked.\n\n$clicked = false;\n\nwhile (!$clicked)\n\n{\n\n$exists = CheckFormExists($handle);\n\n$state1 = OperatorPromptNonBlockingWithInputGetButtonState($handle, $btn1Txt);\n\n$state2 = OperatorPromptNonBlockingWithInputGetButtonState($handle, $btn2Txt);\n\n$clicked = $state1 || $state2 || !$exists;\n\n}\n\n\n\n\n\n$btnStr = \"No button\";\n\nif ($state1)\n\n{\n\n$btnStr = $btn1Txt;\n\n}\n\nif ($state2)\n\n{\n\n$btnStr = $btn2Txt;\n\n}\n\n\n\n\n\n$outStr = \"Button pressed:\\t\" + $btnStr;\n\nUpdateStatus($outStr);\n\n\n\n\n\n$input = OperatorPromptNonBlockingWithInputGetInput($handle);\n\n$outStr = \"Data Entered:\\t\" + $input;\n\nUpdateStatus($outStr);\n\n\n\n\n\nOperatorPromptNonBlockingWithInputGetButtonState\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OperatorPromptNonBlockingWithInputGetButtonState": {
  "prefix": "OperatorPromptNonBlockingWithInputGetButtonState",
  "body": [
   "$$ButtonState=OperatorPromptNonBlockingWithInputGetButtonState($$WindowHandle,$$ButtonName);"
  ],
  "description": "\n\nThis function will return the state of the requested button from the prompt window that was opened using OperatorPromptNonBlockingWithInput. TRUE indicates that the button has been pressed. The state of the button will be cleared after this function is called.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$WindowHandle\n\nString\n\nThe handle that was returned when the form was created.\n\n\n\n$ButtonName\n\nString\n\nThe text name of the button whose state is requested.\n\n\n\n\n\nReturn arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ButtonState\n\nBoolean\n\nThe state of the requested button. TRUE indicates that the button has been pressed.\n\n\n\n\n\nExample:\n\n// Set up a prompt with input.\n\n$pPrompt = \"Enter some data and click a button.\";\n\n$pHeight = 200;\n\n$pWidth = 400;\n\n$pInpTop = 85;\n\n$pInpLeft = 85;\n\n$pBtn1 = \"OK\";\n\n$pBtn1Top = 135;\n\n$pBtn1Left = 95;\n\n$pBtn2 = \"Cancel\";\n\n$pBtn2Top = 135;\n\n$pBtn2Left = 275;\n\n$loopPause = 250;\n\n\n\n\n\n// Open the prompt window.\n\n$WindowHandle = OperatorPromptNonBlockingWithInput($pPrompt, $pHeight, $pWidth, $pInpTop, $pInpLeft, $pBtn1, $pBtn1Top, $pBtn1Left, $pBtn2, $pBtn2Top, $pBtn2Left);\n\n\n\n\n\n// Now loop to check the button states.\n\n$btnPress = false;\n\nwhile (!$btnPress)\n\n{\n\n// Check button 1.\n\n$btn1 = OperatorPromptNonBlockingWithInputGetButtonState($pHandle, $pBtn1);\n\nif ($btn1)\n\n{\n\nUpdateStatus(\"Clicked on Button 1\");\n\n$btnPress = true;\n\n}\n\n// Check button 2.\n\n$btn2 = OperatorPromptNonBlockingWithInputGetButtonState($pHandle, $pBtn2);\n\nif ($btn2)\n\n{\n\nUpdateStatus(\"Clicked on Button 2\");\n\n$btnPress = true;\n\n}\n\n\n\n\n\n// If a button was not pressed, wait and then check again.\n\nif (!$btnPress)\n\n{\n\nSleepMilliseconds($loopPause);\n\n}\n\n}\n\n\n\n\n\nOperatorPromptNonBlockingWithInputGetInput\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OperatorPromptNonBlockingWithInputGetInput": {
  "prefix": "OperatorPromptNonBlockingWithInputGetInput",
  "body": [
   "$$TextInput=OperatorPromptNonBlockingWithInputGetInput($$WindowHandle);"
  ],
  "description": "\n\nThis function will return the text that was entered in the text box from the prompt window that was opened using OperatorPromptNonBlockingWithInput.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$WindowHandle\n\nString\n\nThe handle that was returned when the form was created.\n\n\n\n\n\nReturn arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$TextInput\n\nString\n\nThe text that was in the text input box when this function was called.\n\n\n\n\n\nExample:\n\n// Set up a prompt with input.\n\n$pPrompt = \"Enter some data and click a button.\";\n\n$pHeight = 200;\n\n$pWidth = 400;\n\n$pInpTop = 85;\n\n$pInpLeft = 85;\n\n$pBtn1 = \"OK\";\n\n$pBtn1Top = 135;\n\n$pBtn1Left = 95;\n\n$pBtn2 = \"Cancel\";\n\n$pBtn2Top = 135;\n\n$pBtn2Left = 275;\n\n$newMessage = \"Please press the other button.\";\n\n$loopPause = 250;\n\n\n\n\n\n// Open the prompt window.\n\n$WindowHandle = OperatorPromptNonBlockingWithInput($pPrompt, $pHeight, $pWidth, $pInpTop, $pInpLeft, $pBtn1, $pBtn1Top, $pBtn1Left, $pBtn2, $pBtn2Top, $pBtn2Left);\n\n\n\n\n\n// Now loop to check the button states.\n\n$btnPress = false;\n\nwhile (!$btnPress)\n\n{\n\n// Check button 1.\n\n$btn1 = OperatorPromptNonBlockingWithInputGetButtonState($pHandle, $pBtn1);\n\nif ($btn1)\n\n{\n\nUpdateStatus(\"Clicked on Button 1\");\n\n$btnPress = true;\n\n}\n\n// Check button 2.\n\n$btn2 = OperatorPromptNonBlockingWithInputGetButtonState($pHandle, $pBtn2);\n\nif ($btn2)\n\n{\n\nUpdateStatus(\"Clicked on Button 2\");\n\n$btnPress = false;\n\n// If user pressed button 2, update the message.\n\nOperatorPromptNonBlockingWithInputUpdateMessage($pHandle, $newMessage);\n\n}\n\n\n\n\n\n// If a button was not pressed, wait and then check again.\n\nif (!$btnPress)\n\n{\n\nSleepMilliseconds($loopPause);\n\n}\n\n}\n\n\n\n\n\n// User clicked on the first button, so Get the Input and display it.\n\n$pInput = OperatorPromptNonBlockingWithInputGetInput($pHandle);\n\n\n\n\n\n$outStr = \"The user entered :\" + $pInput;\n\nUpdateStatus($outStr);\n\nCloseForm($pHandle);\n\n\n\n\n\nEnd;\n\n\n\n\n\nOperatorPromptNonBlockingWithInputUpdateMessage\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OperatorPromptNonBlockingWithInputUpdateMessage": {
  "prefix": "OperatorPromptNonBlockingWithInputUpdateMessage",
  "body": [
   "OperatorPromptNonBlockingWithInputUpdateMessage($$Handle,$$NewMessage);"
  ],
  "description": "\n\nThis function will change the prompt that is shown to the user in the specified Non-Blocking prompt that was opened using OperatorPromptNonBlockingWithInput.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Handle\n\nObject\n\nA pointer to the window that was previously opened.\n\n\n\n$NewMessage\n\nString\n\nThe new message to replace the existing prompt message with.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n// Set up a prompt with one button.\n\n$pPrompt = \"Enter some data and click the button.\";\n\n$pHeight = 200;\n\n$pWidth = 400;\n\n$pInpTop = 85;\n\n$pInpLeft = 85;\n\n$pBtn1 = \"OK\";\n\n$pBtn1Top = 135;\n\n$pBtn1Left = 95;\n\n\n\n\n\n// Open the prompt window.\n\n$WindowHandle = OperatorPromptNonBlockingWithInput($pPrompt, $pHeight, $pWidth, $pInpTop, $pInpLeft, $pBtn1, $pBtn1Top, $pBtn1Left, \"\", 0, 0);\n\n\n\n\n\n// Now change the prompt.\n\n$NewMessage = \"Enter the data and click \\\"OK\\\".\";\n\nOperatorPromptNonBlockingWithInputUpdateMessage($WindowHandle, $NewMessage);\n\n\n\n\n\nOperatorPromptNonBlockingWithLocation\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OperatorPromptNonBlockingWithLocation": {
  "prefix": "OperatorPromptNonBlockingWithLocation",
  "body": [
   "$$winHandle=OperatorPromptNonBlockingWithLocation($$prompt,$$width,$$height,$$left,$$top);"
  ],
  "description": "\n\nThis function opens a non-blocking window with the string displayed to the user.\n\n\n\n\n\nRemarks:\n\nThe prompt message can be changed using OperatorPromptNonBlockingUpdateMessage.\n\nClose the prompt window using CloseForm.\n\nThe word \"Location\" is used in the prompt functions to denote position and size instead of saying \"WithPositionAndSize\".\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$prompt\n\nString\n\nString displayed to the user.\n\n\n\n$width\n\nInteger\n\nThe width of the prompt window in pixels.\n\n\n\n$height\n\nInteger\n\nThe height of the prompt window in pixels.\n\n\n\n$left\n\nInteger\n\nThe location of the left edge of the prompt window in pixels measured from the left edge of the screen.\n\n\n\n$top\n\nInteger\n\nThe location of the top edge of the prompt window in pixels measured from the top edge of the screen.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$winHandle\n\nObject\n\nA handle to the window that was opened. Passed to other functions to read the button state or close the window.\n\n\n\n\n\nExample:\n\n\n\n\n\n// Show Prompt to the user.\n\n$prompt = \"This is the prompt.\";\n\n$width = 600;\n\n$height = 650;\n\n$left = 20;\n\n$top = 50;\n\nOperatorPromptNonBlockingWithLocation($prompt, $width, $height, $left, $top);\n\n\n\n\n\nOperatorPromptShowDocument\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OperatorPromptShowDocument": {
  "prefix": "OperatorPromptShowDocument",
  "body": [
   "OperatorPromptShowDocument($$PromptString,$$URL,$$WindowWidth,$$WindowHeight);"
  ],
  "description": "\n\n\n\n\n\nThis function shows a window to the operator with a text box containing instructions, and a web browser window that can be used to show different type of documents such as images, PDF files, static HTML files, or intranet/internet sites.\n\n\n\n\n\nNote: Since this function uses an ActiveX web browser control, this function must be running under a single threaded apartment model. You can adjust this setting in the Global Cell Options window.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$PromptString\n\nString\n\nThe text shown to the operator at the top of the window display.\n\n\n\n$URL\n\nString\n\nThe file path, or URL to the document to display to the operator.\n\n\n\n$WindowWidth\n\nString\n\nThe width of the displayed window.\n\n\n\n$WindowHeight\n\nString\n\nThe height of the displayed window.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n\n\n\n\nOperatorPromptShowDocument(\"Showing an Image\",\"C:\\\\brain.jpg\",500,500);\n\nOperatorPromptShowDocument(\"Showing a PDF\",\"C:\\\\dxf.pdf\",500,500);\n\nOperatorPromptShowDocument(\"Showing an HTML document\",\"C:\\\\myfile.html\",500,500);\n\nOperatorPromptShowDocument(\"Showing a web page\",\"http://www.google.com\",500,500);\n\n\n\n\n\nOperatorPromptShowDocumentWithLocation\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OperatorPromptShowDocumentWithLocation": {
  "prefix": "OperatorPromptShowDocumentWithLocation",
  "body": [
   "OperatorPromptShowDocumentWithLocation($$prompt,$$URL,$$width,$$height,$$left,$$top);"
  ],
  "description": "\n\nThis function shows a window to the operator with a text box containing instructions, and a web browser window that can be used to show different type of documents such as images, PDF files, static HTML files, or intranet/internet sites.\n\n\n\n\n\nRemarks:\n\nThe word \"Location\" is used in the prompt functions to denote position and size instead of saying \"WithPositionAndSize\".\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$prompt\n\nString\n\nThe text shown to the operator at the top of the window display.\n\n\n\n$URL\n\nString\n\nThe file path, or URL to the document to display to the operator.\n\n\n\n$width\n\nInteger\n\nThe width of the displayed window measured in pixels.\n\n\n\n$height\n\nInteger\n\nThe height of the displayed window measured in pixels.\n\n\n\n$left\n\nInteger\n\nThe left edge of the prompt window measured from the left edge of the screen - in pixels.\n\n\n\n$top\n\nInteger\n\nThe top edge of the prompt window measured from the top edge of the screen - in pixels.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n\n\n\n\nOperatorPromptShowDocumentWithLocation(\"Showing an Image\", \"C:\\\\brain.jpg\", 500, 500, 10, 10);\n\nOperatorPromptShowDocumentWithLocation(\"Showing a PDF\", \"C:\\\\dxf.pdf\", 500, 500, 200, 0);\n\nOperatorPromptShowDocumentWithLocation(\"Showing an HTML document\", \"C:\\\\myfile.html\", 500, 500, 0, 500);\n\nOperatorPromptShowDocumentWithLocation(\"Showing a web page\", \"http://www.google.com\", 500, 500, 0, 0);\n\n\n\n\n\nOperatorPromptSpecifyOptions\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OperatorPromptSpecifyOptions": {
  "prefix": "OperatorPromptSpecifyOptions",
  "body": [
   "$$ButtonText=OperatorPromptSpecifyOptions($$PromptString,$$ButtonOptions,$$Width,$$Height,XPosition,YPosition);"
  ],
  "description": "\n\nThis is a more flexible version of the OperatorPrompt command. This function allows you to specify the message, the number and text displays of the buttons, the form height, the form width, and the position that the dialog box will be displayed on the screen.\n\nExample:\n\n$ReturnString = OperatorPromptSpecifyOptions(\"What is your favorite color? \",\"Red;Green;Blue;Yellow\",300,200,800,300);\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$PromptString\n\nString\n\nThe String which is displayed to the operator for instruction or notification purposes.\n\n\n\n$ButtonOptions\n\nString\n\nA text string containin the text of each button that you would like displayed on the operator prompt form seperated by semicolons. . For example \"Red;Green;Blue\" will generate a dialog box with three buttons labeled with the colors specified.\n\n\n\n$Width\n\nInteger\n\nThe width of the dialog box in pixels\n\n\n\n$Height\n\nInteger\n\nThe height of the dialog box in pixels\n\n\n\n$XPosition\n\nInteger\n\nThe location of the left of the dialog box specified in pixels from the left of the display.\n\n\n\n$YPosition\n\nInteger\n\nThe top of the dialog box specified in pixels from the top of the display.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ButtonText\n\nString\n\nThe text of the button clicked on by the operator\n\n\n\n\n\nOperatorPromptSpecifyOptionsAndSizes\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OperatorPromptSpecifyOptionsAndSizes": {
  "prefix": "OperatorPromptSpecifyOptionsAndSizes",
  "body": [
   "$$ButtonText=OperatorPromptSpecifyOptionsAndSizes($$PromptString,$$ButtonOptions,$$Width,$$Height,$$XPosition,$$YPosition,$$FontSize,$$ButtonWidth,$$ButtonHeight);"
  ],
  "description": "\n\n\n\n\n\nThis is a more flexible version of the OperatorPromptSpecifyOptions command. Along with the options provided by the OperatorPromptSpecifyOptions command (window text, button text, window size, window position), this function also allows the user to set the font height, button width and button height.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$PromptString\n\nString\n\nThe String which is displayed to the operator for instruction or notification purposes.\n\n\n\n$ButtonOptions\n\nString\n\nA text string containing the text of each button that you would like displayed on the operator prompt form separated by semicolons. . For example \"Red;Green;Blue\" will generate a dialog box with three buttons labeled with the colors specified.\n\n\n\n$Width\n\nInteger\n\nThe width of the dialog box in pixels\n\n\n\n$Height\n\nInteger\n\nThe height of the dialog box in pixels\n\n\n\n$XPosition\n\nInteger\n\nThe location of the left of the dialog box specified in pixels from the left of the display.\n\n\n\n$YPosition\n\nInteger\n\nThe top of the dialog box specified in pixels from the top of the display.\n\n\n\n$FontSize\n\nInteger\n\nThe size of the font to be displayed in the prompt window. This font size will be applied to both the message text and the button text.\n\n\n\n$ButtonWidth\n\nInteger\n\nThe width of the buttons to be displayed.\n\n\n\n$ButtonHeight\n\nInteger\n\nThe height of the buttons to be displayed.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ButtonText\n\nString\n\nThe text of the button clicked on by the operator\n\n\n\n\n\nExample:\n\n\n\n\n\n$ButtonText = OperatorPromptSpecifyOptionsAndSizes(\"hello\",\"one;two;three\",300,200,20,20,15,80,50);\n\n\n\n\n\nOperatorShiftBarCreate\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OperatorShiftBarCreate": {
  "prefix": "OperatorShiftBarCreate",
  "body": [
   "$$WindowHandle=OperatorShiftBarCreate($$Title,$$LowerLimitValue,$$UpperLimitValue,$$StartValue);"
  ],
  "description": "\n\nThis function will prompt the operator with a colored shiftbar in a seperate window, and allows the script to continue. The operator prompt dialog continues to exist in a seperate thread until it is disposed of with the CloseForm function. To update the shiftbar use the OperatorShiftBarUpdate function. There are 2 buttons placed on the dialog box, an OK button and an Cancel Button. If we press the cancel button the script will fail. If we press the OK button the window hides.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Title\n\nString\n\nThe String which is displayed to the operator for instruction or notification purposes.\n\n\n\n$LowerLimitValue\n\nFloat\n\nThe lower limit of the prompt dialog box.\n\n\n\n$UpperLimitValue\n\nFloat\n\nThe upper limit of the prompt dialog box.\n\n\n\n$StartValue\n\nFloat\n\nThe start value of the prompt dialog box.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$WindowHandle\n\nObject\n\nA handle to the operator dialog box. This can later be closed with the CloseForm function.\n\n\n\n\n\nExample:\n\n\n\n\n\n$shiftBar = OperatorShiftBarCreate(\"Instructions to User\", 50, 500, 350);\n\n\n\n\n\nSleep(2);\n\n($return, $closed) = OperatorShiftBarUpdate($shiftBar, 400);\n\n\n\n\n\nOperatorShiftBarCreateWithPosition\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OperatorShiftBarCreateWithPosition": {
  "prefix": "OperatorShiftBarCreateWithPosition",
  "body": [
   "$$WindowHandle=OperatorShiftBarCreateWithPosition($$Title,$$LowerLimitValue,$$UpperLimitValue,$$StartValue,$$leftEdge,$$topEdge);"
  ],
  "description": "\n\nThis function will prompt the operator with a colored shiftbar in a seperate window at the position specified by $leftEdge and $topEdge, and allows the script to continue. The operator prompt dialog continues to exist in a seperate thread until it is disposed of with the CloseForm function. To update the shiftbar use the OperatorShiftBarUpdate function. There are 2 buttons placed on the dialog box, an OK button and an Cancel Button. If we press the cancel button the script will fail. If we press the OK button the window hides.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Title\n\nString\n\nThe String which is displayed to the operator for instruction or notification purposes.\n\n\n\n$LowerLimitValue\n\nFloat\n\nThe lower limit of the prompt dialog box.\n\n\n\n$UpperLimitValue\n\nFloat\n\nThe upper limit of the prompt dialog box.\n\n\n\n$StartValue\n\nFloat\n\nThe start value of the prompt dialog box.\n\n\n\n$leftEdge\n\nInteger\n\nThe left edge of the shift bar window in pixels measured from the left edge of the screen.\n\n\n\n$topEdge\n\nInteger\n\nThe top edge of the shift bar window in pixels measured from the top edge of the screen.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$WindowHandle\n\nObject\n\nA handle to the operator dialog box. This can later be closed with the CloseForm function.\n\n\n\n\n\nExample:\n\n\n\n\n\n$shiftBar = OperatorShiftBarCreateWithPosition(\"Instructions to User\", 50, 500, 350, 1000, 250);\n\n\n\n\n\nSleep(2);\n\n($return, $closed) = OperatorShiftBarUpdate($shiftBar, 400);\n\n\n\n\n\nOperatorShiftBarUpdate\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OperatorShiftBarUpdate": {
  "prefix": "OperatorShiftBarUpdate",
  "body": [
   "($$ReturnValue,$$OperatorPressedContinue)=OperatorShiftBarUpdate($$WindowHandle,$$CurrentValue);"
  ],
  "description": "\n\nThis function will update the operatorshiftbar window with the CurrentValue. The return value is the value we see on the dialog box.The operator prompt dialog continues to exist in a seperate thread until it is disposed of with the CloseForm\n\nExample:\n\n$CurrentValue = New(\"Float\",9.102);\n\n$windowHandle = OperatorShiftBarCreate($Title,$LowerLimit,$HigherLimit,$CurrentValue);\n\nLabel RemeasureAndUpdateWindow:\n\n$CurrentValue = Add($CurrentValue,0.2);\n\nSleepMicroseconds(100000);\n\n($StringValue,$OperatorPresedContinue) = OperatorShiftBarUpdate($windowHandle,$CurrentValue);\n\nScriptIf($OperatorPresedContinue,\"GOTO\",\"LimitTest\",\"RemeasureAndUpdateWindow\");\n\nLabel LimitTest:\n\nUpdateStatus(\"OperatorPresedContinue = true\");\n\nCloseForm($windowHandle);\n\nNumericLimitTest($StringValue,$LowerLimit,$HigherLimit);\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$WindowHandle\n\nObject\n\nA handle to a windows form that has been created in a previous test step\n\n\n\n$CurrentValue\n\nFloat\n\nThe current value we want to show in the prompt dialog box\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ReturnValue\n\nString\n\nThe value we see in the dialog box.\n\n\n\n$OperatorPressedContinue\n\nBool\n\nThis variable returns TRUE if the operator pressed the continue button else the variable is FALSE\n\n\n\n\n\nOperatorTextPanelsNonBlocking_Create\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OperatorTextPanelsNonBlocking_Create": {
  "prefix": "OperatorTextPanelsNonBlocking_Create",
  "body": [
   "$$winHandle=OperatorTextPanelsNonBlocking_Create($$prompt,$$numPanels,$$width,$$height,$$left,$$top);"
  ],
  "description": "\n\nThis function opens a non-blocking window with one to four text panels. The script can then replace or append to the text on each panel individually.\n\n\n\n\n\nRemarks:\n\nThe text messages can be changed using OperatorTextPanelsNonBlocking_UpdateText.\n\nClose the prompt window using CloseForm.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$prompt\n\nString\n\nString displayed to the user at the top of the window.\n\n\n\n$numPanels\n\nInteger\n\nThe number of text panels that will be in the window. Must be a number from 1 to 4.\n\n\n\n$width\n\nInteger\n\nThe width of the window in pixels.\n\n\n\n$height\n\nInteger\n\nThe height of the window in pixels.\n\n\n\n$left\n\nInteger\n\nThe location of the left edge of the window in pixels measured from the left edge of the screen.\n\n\n\n$top\n\nInteger\n\nThe location of the top edge of the window in pixels measured from the top edge of the screen.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$winHandle\n\nObject\n\nA handle to the window that was opened. Passed to other functions to change the text or close the window.\n\n\n\n\n\nExample:\n\n\n\n\n\n// Show Prompt to the user.\n\n$prompt = \"This is the prompt.\";\n\n$numPans = 3;\n\n$width = 600;\n\n$height = 650;\n\n$left = 20;\n\n$top = 50;\n\n$handle = OperatorTextPanelsNonBlocking_Create($prompt, $numPans, $width, $height, $left, $top);\n\n\n\n\n\n$text1 = \"This is the text for panel 1.\";\n\n$text2 = \"This is the text for panel 2.\";\n\n$text3 = \"Add this text to panel 3.\";\n\n\n\n\n\nOperatorTextPanelsNonBlocking_UpdateText($handle, 1, $text1, \"REPLACE\");\n\nOperatorTextPanelsNonBlocking_UpdateText($handle, 2, $text2, \"REPLACE\");\n\nOperatorTextPanelsNonBlocking_UpdateText($handle, 3, $text3, \"APPEND\");\n\n\n\n\n\nOperatorTextPanelsNonBlocking_UpdateText\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OperatorTextPanelsNonBlocking_UpdateText": {
  "prefix": "OperatorTextPanelsNonBlocking_UpdateText",
  "body": [
   "OperatorTextPanelsNonBlocking_UpdateText($$winHandle,$$numPanel,$$text,$$action);"
  ],
  "description": "\n\nThis function updates the text in one of up to four text panels. The function can replace or append to the text on the panel.\n\n\n\n\n\nRemarks:\n\nThe text message window must have been opened with OperatorTextPanelsNonBlocking_Create.\n\nClose the prompt window using CloseForm.\n\nThe panels are numbered starting from 0. For example, if there are 4 windows, they are numbered 0, 1, 2, and 3.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$winHandle\n\nObject\n\nHandle to a previously opened text window.\n\n\n\n$numPanel\n\nInteger\n\nThe number of the panel to update (0 based numbering).\n\n\n\n$text\n\nString\n\nThe new text to put on the panel.\n\n\n\n$action\n\nString\n\nThe method used to put the text into the text window. This must be \"REPLACE\" or \"APPEND\"\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n\n\n\n\n// Show Prompt to the user.\n\n$prompt = \"This is the prompt.\";\n\n$numPans = 3;\n\n$width = 600;\n\n$height = 650;\n\n$left = 20;\n\n$top = 50;\n\n$handle = OperatorTextPanelsNonBlocking_Create($prompt, $numPans, $width, $height, $left, $top);\n\n\n\n\n\n$text1 = \"This is the text for panel 1.\";\n\n$text2 = \"This is the text for panel 2.\";\n\n$text3 = \"Add this text to panel 3.\";\n\n\n\n\n\nOperatorTextPanelsNonBlocking_UpdateText($handle, 0, $text1, \"REPLACE\");\n\nOperatorTextPanelsNonBlocking_UpdateText($handle, 1, $text2, \"REPLACE\");\n\nOperatorTextPanelsNonBlocking_UpdateText($handle, 2, $text3, \"APPEND\");\n\n\n\n\n\nShowDelayPicture\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ShowDelayPictureWithLocation": {
  "prefix": "ShowDelayPictureWithLocation",
  "body": [
   "ShowDelayPictureWithLocation($$path,$$opacity,$$time,$$width,$$height,$$left,$$top);"
  ],
  "description": "\n\nThis function will pop up a window with a picture in it and delay for a set amount of time before closing. The opacity of the window is also configurable.\n\n\n\n\n\nRemarks:\n\nThe supported image formats are: BMP, GIF, JPG, PNG, TIFF.\n\nThe word \"Location\" is used in the prompt functions to denote position and size instead of saying \"WithPositionAndSize\".\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$path\n\nString\n\nThe path and file name of the image to display.\n\n\n\n$opacity\n\nInteger\n\nThe opacity of the window with 0 being fully transparent and 100 being fully opaque.\n\n\n\n$time\n\nInteger\n\nThe number of seconds to wait before closing the window.\n\n\n\n$width\n\nInteger\n\nThe width of the window in pixels.\n\n\n\n$height\n\nInteger\n\nThe height of the window in pixels.\n\n\n\n$left\n\nInteger\n\nThe location of the left edge of the window in pixels measured from the left edge of the screen.\n\n\n\n$top\n\nInteger\n\nThe location of the top edge of the window in pixels measured from the top edge of the screen.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n// Show a picture for 10 seconds.\n\n$path = \"C:\\\\Graphics\\\\Delay_Pic.jpg\";\n\n$opacity = 80;\n\n$time = 10;\n\n$width = 500;\n\n$height = 500;\n\n$left = 10;\n\n$top = 20;\n\n\n\n\n\nShowDelayPictureWithLocation($path, $opacity, $time, $width, $height, $left, $top);\n\n\n\n\n\nShowImage\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ShowImage": {
  "prefix": "ShowImage",
  "body": [
   "$$imageHandle=ShowImage($$imagePath,$$width,$$height);"
  ],
  "description": "\n\nShows an image and returns immediately. To close image use HideImage function. Function Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$imageHandle\n\nString\n\nThe location of the image to load and display.\n\n\n\n$width\n\nInteger\n\nThe width of the window to show the image on.\n\n\n\n$height\n\nInteger\n\nThe height of the window to show the image on.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$imageHandle\n\nObject\n\nA handle to the window that was opened for displaying the image.\n\n\n\n\n\nExample:\n\n\n\n\n\n$imagePath = \"C:\\\\Temp\\\\TestImage.png\";\n\n$imageHandle = ShowImage($imagePath, 600, 350);\n\nHideImage($imageHandle);\n\n\n\n\n\nShowImageWithLocation\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ShowImageWithLocation": {
  "prefix": "ShowImageWithLocation",
  "body": [
   "$$imageHandle=ShowImageWithLocation($$imagePath,$$width,$$height,$$left,$$top);"
  ],
  "description": "\n\nShows an image and returns immediately. To close image use HideImage function.\n\nRemarks:\n\nThe word \"Location\" is used in the prompt functions to denote position and size instead of saying \"WithPositionAndSize\". Function Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$imageHandle\n\nString\n\nThe location of the image to load and display.\n\n\n\n$width\n\nInteger\n\nThe width of the window to show the image on.\n\n\n\n$height\n\nInteger\n\nThe height of the window to show the image on.\n\n\n\n$left\n\nInteger\n\nThe left edge of the window, measured from the left edge of the screen - in pixels.\n\n\n\n$top\n\nInteger\n\nThe top edge of the window, measured from the top edge of the screen - in pixels.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$imageHandle\n\nObject\n\nA handle to the window that was opened for displaying the image.\n\n\n\n\n\nExample:\n\n\n\n\n\n$imagePath = \"C:\\\\Temp\\\\TestImage.png\";\n\n$width = 600;\n\n$height = 350;\n\n$left = 400;\n\n$top = 200;\n\n\n\n\n\n$imageHandle = ShowImageWithLocation($imagePath, $width, $height, $left, $top);\n\nHideImage($imageHandle);\n\n\n\n\n\nShowPickButton\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ShowPickButton": {
  "prefix": "ShowPickButton",
  "body": [
   "$$result=ShowPickButton($$imagePath,$$buttonText,$$buttonColor,$$buttonShortCut,$$textSize,$$buttonSize,$$width,$$height,$$opacity);"
  ],
  "description": "\n\nThis function will show an image with a set of buttons underneath. The number of buttons is configurable, up to 7.\n\n\n\nRemarks:\n\nLoads the image from a file. Does not work with an image in memory.\n\nThe number of button names, button colors and shortcut keys must be the same.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$imagePath\n\nString\n\nThe location and name of the file to load the image from.\n\n\n\n$buttonText\n\nString\n\nComma delimited list of text to put on the buttons.\n\n\n\n$buttonColor\n\nString\n\nComma delimited list of colors for the buttons (one color for each button).\n\n\n\n$buttonShortCut\n\nString\n\nComma delimited list of \"F\" keys that can be used to activate the buttons.\n\n\n\n$textSize\n\nInteger\n\nThe size of the button text in pixels.\n\n\n\n$buttonSize\n\nInteger\n\nThe size of the buttons in pixels.\n\n\n\n$width\n\nInteger\n\nThe width of the image window in pixels.\n\n\n\n$height\n\nInteger\n\nThe height of the entire window (including image and buttons) in pixels.\n\n\n\n$opacity\n\nInteger\n\nThe opacity of the window in percent (0 = fully transparent, 100 = fully opaque).\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$result\n\nString\n\nThe text that is on the button that was activated.\n\n\n\n\n\nExample:\n\n\n\n\n\n// Set up some variables to use.\n\n$image = \"C:\\\\Images\\\\TestImage.bmp\";\n\n$buttons = \"Button 1,Button 2,Button 3\";\n\n$butnColor = \"RED,BLUE,YELLOW\";\n\n$butnKeys = \"F1,F2,F3\";\n\n$textSize = 20;\n\n$butnSize = 50;\n\n$width = 700;\n\n$height = 400;\n\n$opacity = 80;\n\n\n\n// Display and wait for button press.\n\n$pressed = ShowPickButton($image, $buttons, $butnColor, $butnKeys, $textSize, $butnSize, $width, $height, $opacity);\n\n\n\n$outString = \"The button pressed = \" + $pressed;\n\nUpdateStatus($outString);\n\n\n\n\n\nShowPickButtonWithLocation\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ShowPickButtonWithLocation": {
  "prefix": "ShowPickButtonWithLocation",
  "body": [
   "$$result=ShowPickButtonWithLocation($$path,$$buttonText,$$buttonColor,$$buttonKeys,$$textSize,$$buttonSize,$$opacity,$$width,$$height,$$left,$$top);"
  ],
  "description": "\n\nThis function will pop up a window with a picture in it and up to seven configurable buttons. The opacity of the window is also configurable.\n\n\n\n\n\nRemarks:\n\nThe supported image formats are: BMP, GIF, JPG, PNG, TIFF.\n\nThe word \"Location\" is used in the prompt functions to denote position and size instead of saying \"WithPositionAndSize\".\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$path\n\nString\n\nThe path and file name of the image to display.\n\n\n\n$buttonText\n\nString\n\nThe text to show on each of the buttons. This is a comma delimited list - one entry for each button. Buttons with blank entries are not shown.\n\n\n\n$buttonColor\n\nString\n\nThe color of each button. This is a comma delimited list - one color for each button. Valid colors are:\n\n\u00b7 Red\n\n\u00b7 Yellow\n\n\u00b7 Blue\n\n\u00b7 Gray\n\n\u00b7 Black\n\n\u00b7 White\n\n\u00b7 Green\n\n\u00b7 Pink\n\n\u00b7 Purple\n\n\u00b7 Orange\n\n\u00b7 Brown\n\n\n\n$buttonKeys\n\nString\n\nThe shortcut key for each button. This is a comma delimited list - one entry for each button.\n\n\n\n$textSize\n\nInteger\n\nThe size of the text to put on the buttons.\n\n\n\n$buttonSize\n\nInteger\n\nThe size of the buttons in pixels.\n\n\n\n$opacity\n\nInteger\n\nThe opacity of the window with 0 being fully transparent and 100 being fully opaque.\n\n\n\n$width\n\nInteger\n\nThe width of the window in pixels.\n\n\n\n$height\n\nInteger\n\nThe height of the window in pixels.\n\n\n\n$left\n\nInteger\n\nThe location of the left edge of the window in pixels measured from the left edge of the screen.\n\n\n\n$top\n\nInteger\n\nThe location of the top edge of the window in pixels measured from the top edge of the screen.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$result\n\nString\n\nThe text that was on the button that was clicked on by the user.\n\n\n\n\n\nExample:\n\n// Show a picture and seven buttons.\n\n$pic = \"C:\\\\Graphics\\\\Delay_Pic.jpg\";\n\n$btnTxt = \"Btn 1,Btn 2,Btn 3,Btn 4,Btn 5,Btn 6,Btn 7\";\n\n$btnClr = \"Purple,Blue,Green,Yellow,Orange,Red,Pink\";\n\n$btnShr = \"F1,F2,F3,F4,F5,F6,F7\";\n\n$txtSiz = 20;\n\n$btnSiz = 50;\n\n$opacity = 80;\n\n$width = 1000;\n\n$height = 450;\n\n$left = 20;\n\n$top = 10;\n\n\n\n\n\n$result = ShowPickButtonWithLocation($pic, $btnTxt, $btnClr, $btnShr, $txtSiz, $btnSiz, $opacity, $width, $height, $left, $top);\n\n\n\n\n\n$outStr = \"Result =\\t\" + $result;\n\nUpdateStatus($outStr);\n\n\n\n\n\nShowPictureButtonPrompt\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ShowPictureButtonPromptWithLocation": {
  "prefix": "ShowPictureButtonPromptWithLocation",
  "body": [
   "ShowPictureButtonPromptWithLocation($$path,$$buttonText,$$opacity,$$width,$$height,$$left,$$top);"
  ],
  "description": "\n\nThis function will pop up a window with a picture in it and a button. The opacity of the window is also configurable.\n\n\n\n\n\nRemarks:\n\nThe supported image formats are: BMP, GIF, JPG, PNG, TIFF.\n\nThe word \"Location\" is used in the prompt functions to denote position and size instead of saying \"WithPositionAndSize\".\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$path\n\nString\n\nThe path and file name of the image to display.\n\n\n\n$buttonText\n\nString\n\nThe text to show on each of the buttons. This is a comma delimited list - one entry for each button. Buttons with blank entries are not shown.\n\n\n\n$opacity\n\nInteger\n\nThe opacity of the window with 0 being fully transparent and 100 being fully opaque.\n\n\n\n$width\n\nInteger\n\nThe width of the window in pixels.\n\n\n\n$height\n\nInteger\n\nThe height of the window in pixels.\n\n\n\n$left\n\nInteger\n\nThe location of the left edge of the window in pixels measured from the left edge of the screen.\n\n\n\n$top\n\nInteger\n\nThe location of the top edge of the window in pixels measured from the top edge of the screen.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n// Show a picture and a button.\n\n$pic = \"C:\\\\Graphics\\\\Delay_Pic.jpg\";\n\n$btnTxt = \"Button 1\";\n\n$opacity = 80;\n\n$width = 1000;\n\n$height = 450;\n\n$left = 20;\n\n$top = 10;\n\n\n\n\n\nShowPictureButtonPromptWithLocation($pic, $btnTxt, $opacity, $width, $height, $left, $top);\n\n\n\n\n\nShowPicturePrompt\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ShowPictureButtonWithLocation": {
  "prefix": "ShowPictureButtonWithLocation",
  "body": [
   "$$handle=ShowPictureButtonWithLocation($$path,$$btn1Text,$$btn2Text,$$btn1Key,$$btn2Key,$$message,$$opacity,$$width,$$height,$$left,$$top);"
  ],
  "description": "\n\nThis function will pop up a window with a picture and up to two buttons. The function will then return so the script will keep running. A message will replace the buttons when one of the buttons has been clicked on. The text on the buttons and shortcut key for each button is configurable. The opacity of the window is also configurable.\n\n\n\n\n\nRemarks:\n\nThe supported image formats are: BMP, GIF, JPG, PNG, TIFF.\n\nCheck on the status of the buttons using the function, GetPicturePromptResult.\n\nClose the window using the function, HidePromptImage.\n\nThe word \"Location\" is used in the prompt functions to denote position and size instead of saying \"WithPositionAndSize\".\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$path\n\nString\n\nThe path and file name of the image to display.\n\n\n\n$btn1Text\n\nString\n\nThe text to show on button 1.\n\n\n\n$btn2Text\n\nString\n\nThe text to show on button 2.\n\n\n\n$btn1Key\n\nString\n\nThe keyboard shortcut key for button 1.\n\n\n\n$btn2Key\n\nString\n\nThe keyboard shortcut key for button 2.\n\n\n\n$message\n\nString\n\nThe text message to show to the user after a button has been clicked. The message will replace the buttons.\n\n\n\n$opacity\n\nInteger\n\nThe opacity of the window with 0 being fully transparent and 100 being fully opaque.\n\n\n\n$width\n\nInteger\n\nThe width of the window in pixels.\n\n\n\n$height\n\nInteger\n\nThe height of the window in pixels.\n\n\n\n$left\n\nInteger\n\nThe location of the left edge of the window in pixels measured from the left edge of the screen.\n\n\n\n$top\n\nInteger\n\nThe location of the top edge of the window in pixels measured from the top edge of the screen.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$handle\n\nObject\n\nA handle to the window that can be passed to other functions.\n\n\n\n\n\nExample:\n\n// Show a picture and wait.\n\n$pic = \"C:\\\\Graphics\\\\Prompt_Pic.jpg\";\n\n$btn1Txt = \"Button 1\";\n\n$btn2Txt = \"Button 2\";\n\n$btn1Key = \"F1\";\n\n$btn2Key = \"F2\";\n\n$message = \"Button Pressed. Please Wait...\";\n\n$opacity = 80;\n\n$width = 1000;\n\n$height = 450;\n\n$left = 20;\n\n$top = 10;\n\n\n\n\n\n$handle = ShowPicturePromptWithLocation($pic, $btn1Txt, $btn2Txt, $btn1Key, $btn2Key, $message, $opacity, $width, $height, $left, $top);\n\n\n\n\n\n// Check for the form closed or a button clicked.\n\n$result = \"\";\n\nwhile ($result == \"\")\n\n{\n\n$exists = CheckFormExists($handle);\n\n$result = GetPicturePromptResult($handle);\n\n\n\n\n\n// Was the form closed with no button pressed?\n\nif (!$exists)\n\n{\n\n$result = \"Form closed with no button pressed.\";\n\n}\n\n}\n\n\n\n\n\n$outStr = \"Button Pressed:\\t\" + $result;\n\nUpdateStatus($outStr);\n\n\n\n\n\nHidePromptImage($handle);\n\n\n\n\n\nShowStaticPicturePrompt\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ShowStaticPictureButtonWithLocation": {
  "prefix": "ShowStaticPictureButtonWithLocation",
  "body": [
   "$$result=ShowStaticPictureButtonWithLocation($$path,$$btn1Text,$$btn2Text,$$btn1Key,$$btn2Key,$$opacity,$$width,$$height,$$left,$$top);"
  ],
  "description": "\n\nThis function will pop up a window with a picture and up to two buttons. The text on the buttons and shortcut key for each button is configurable. The opacity of the window is also configurable.\n\n\n\n\n\nRemarks:\n\nThe supported image formats are: BMP, GIF, JPG, PNG, TIFF.\n\nCheck on the status of the buttons using the function, GetPicturePromptResult.\n\nThe word \"Location\" is used in the prompt functions to denote position and size instead of saying \"WithPositionAndSize\".\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$path\n\nString\n\nThe path and file name of the image to display.\n\n\n\n$btn1Text\n\nString\n\nThe text to show on button 1.\n\n\n\n$btn2Text\n\nString\n\nThe text to show on button 2.\n\n\n\n$btn1Key\n\nString\n\nThe keyboard shortcut key for button 1.\n\n\n\n$btn2Key\n\nString\n\nThe keyboard shortcut key for button 2.\n\n\n\n$opacity\n\nInteger\n\nThe opacity of the window with 0 being fully transparent and 100 being fully opaque.\n\n\n\n$width\n\nInteger\n\nThe width of the window in pixels.\n\n\n\n$height\n\nInteger\n\nThe height of the window in pixels.\n\n\n\n$left\n\nInteger\n\nThe location of the left edge of the window in pixels measured from the left edge of the screen.\n\n\n\n$top\n\nInteger\n\nThe location of the top edge of the window in pixels measured from the top edge of the screen.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$result\n\nString\n\nThe name (text) of the button that was clicked.\n\n\n\n\n\nExample:\n\n// Show a picture and wait.\n\n$pic = \"C:\\\\Graphics\\\\Prompt_Pic.jpg\";\n\n$btn1Txt = \"Button 1\";\n\n$btn2Txt = \"Button 2\";\n\n$btn1Key = \"F1\";\n\n$btn2Key = \"F2\";\n\n$opacity = 80;\n\n$width = 1000;\n\n$height = 450;\n\n$left = 20;\n\n$top = 10;\n\n\n\n\n\n$result = ShowStaticPicturePromptWithLocation($pic, $btn1Txt, $btn2Txt, $btn1Key, $btn2Key, $opacity, $width, $height, $left, $top);\n\n\n\n\n\n$outStr = \"Button Pressed:\\t\" + $result;\n\nUpdateStatus($outStr);\n\n\n\n\n\nShowTextDialog\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ShowTextDialogWithLocation": {
  "prefix": "ShowTextDialogWithLocation",
  "body": [
   "$$result=ShowTextDialogWithLocation($$text,$$btn1Text,$$btn2Text,$$btn1Key,$$btn2Key,$$textSize,$$opacity,$$width,$$height,$$left,$$top);"
  ],
  "description": "\n\nThis function will pop up a window with some text and up to two buttons. The text on the buttons and shortcut key for each button is configurable. The opacity of the window and text size are also configurable.\n\n\n\n\n\nRemarks:\n\nThe word \"Location\" is used in the prompt functions to denote position and size instead of saying \"WithPositionAndSize\".\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$text\n\nString\n\nThe text to display.\n\n\n\n$btn1Text\n\nString\n\nThe text to show on button 1.\n\n\n\n$btn2Text\n\nString\n\nThe text to show on button 2.\n\n\n\n$btn1Key\n\nString\n\nThe keyboard shortcut key for button 1.\n\n\n\n$btn2Key\n\nString\n\nThe keyboard shortcut key for button 2.\n\n\n\n$textSize\n\nInteger\n\nThe size of the text that is displayed.\n\n\n\n$opacity\n\nInteger\n\nThe opacity of the window with 0 being fully transparent and 100 being fully opaque.\n\n\n\n$width\n\nInteger\n\nThe width of the window in pixels.\n\n\n\n$height\n\nInteger\n\nThe height of the window in pixels.\n\n\n\n$left\n\nInteger\n\nThe location of the left edge of the window in pixels measured from the left edge of the screen.\n\n\n\n$top\n\nInteger\n\nThe location of the top edge of the window in pixels measured from the top edge of the screen.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$result\n\nString\n\nThe name (text) of the button that was clicked.\n\n\n\n\n\nExample:\n\n// Show text and wait.\n\n$text = \"This is the text that will be shown.\";\n\n$btn1Txt = \"Button 1\";\n\n$btn2Txt = \"Button 2\";\n\n$btn1Key = \"F1\";\n\n$btn2Key = \"F2\";\n\n$textSize = 20;\n\n$opacity = 80;\n\n$width = 1000;\n\n$height = 450;\n\n$left = 20;\n\n$top = 10;\n\n\n\n\n\n$result = ShowTextDialogWithLocation($text, $btn1Txt, $btn2Txt, $btn1Key, $btn2Key, $textSize, $opacity, $width, $height, $left, $top);\n\n\n\n\n\n$outStr = \"Button Pressed:\\t\" + $result;\n\nUpdateStatus($outStr);\n\n\n\n\n\nUnhookWindowImage\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ConfigurableHtmlReportWriter_ConfigureLocations": {
  "prefix": "ConfigurableHtmlReportWriter_ConfigureLocations",
  "body": [
   "ConfigurableHtmlReportWriter_ConfigureLocations($$locationOne,$$locationTwo);"
  ],
  "description": "\n\nThis function can be used to modify the report directory to which the Configurable HTML report will be generated.\n\n\n\n\n\nNote: This function must be called from within a critical section of your script.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$locationOne\n\nString\n\nThe new #1 directory for the configurable html report writer\n\n\n\n$locationTwo\n\nString\n\nThe new #2 directory for the configurable html report writer\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\nEnterCS(\"Report\");\n\nConfigurableHtmlReportWriter_ConfigureLocations(\"C:\\\\html1\\\\\", \"C:\\\\html2\\\\\");\n\nExitCS(\"Report\");\n\n\n\n\n\nConfigureReporting\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ConfigureReporting": {
  "prefix": "ConfigureReporting",
  "body": [
   "ConfigureReporting($$ReportWriterDLLName,$$Active);"
  ],
  "description": "\n\nThis function can be used to activate and deactivate a specific report generator from inside of a test script. The report writer is specified by the DLL name of the report generator. The $Active argument is set to true or false indicating whether or not the report writer is active.\n\n\n\n\n\nNote: This function activates/deactivates the report generator for the current test cell only.\n\n\n\n\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ReportWriterName\n\nString\n\nThe name of the report generation DLL library that you would like to activate or deactivate.\n\n\n\n$Active\n\nBoolean\n\nA Boolean value indicating whether or not the selected report generator is active for the current test cell.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nDebugStatusReportWriter_ConfigureLocations\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS DebugStatusReportWriter_ConfigureLocations": {
  "prefix": "DebugStatusReportWriter_ConfigureLocations",
  "body": [
   "DebugStatusReportWriter_ConfigureLocations($$locationOne,$$locationTwo);"
  ],
  "description": "\n\nThis function can be used to modify the report directory to which the Debug Status report will be generated.\n\n\n\n\n\nNote: This function must be called from within a critical section of your script.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$locationOne\n\nString\n\nThe new #1 directory for the debug status report writer\n\n\n\n$locationTwo\n\nString\n\nThe new #2 directory for the debug status report writer\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\nEnterCS(\"Report\");\n\nDebugStatusReportWriter_ConfigureLocations(\"C:\\\\debug1\\\\\",\"C:\\\\debug2\\\\\");\n\nExitCS(\"Report\");\n\n\n\n\n\nHtmlReportWriter_ConfigureLocations\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS HtmlReportWriter_ConfigureLocations": {
  "prefix": "HtmlReportWriter_ConfigureLocations",
  "body": [
   "HtmlReportWriter_ConfigureLocations($$locationOne,$$locationTwo);"
  ],
  "description": "\n\nThis function can be used to modify the report directory to which the HTML report will be generated.\n\n\n\n\n\nNote: This function must be called from within a critical section of your script.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$locationOne\n\nString\n\nThe new #1 directory for the html report writer\n\n\n\n$locationTwo\n\nString\n\nThe new #2 directory for the html report writer\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\nEnterCS(\"Report\");\n\nHtmlReportWriter_ConfigureLocations(\"C:\\\\html1\\\\\",\"C:\\\\html2\\\\\");\n\nExitCS(\"Report\");\n\n\n\n\n\nHtmlReportWriter_GetLocations\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS HtmlReportWriter_GetLocations": {
  "prefix": "HtmlReportWriter_GetLocations",
  "body": [
   "($$primaryLocation,$$secondaryLocation)=HtmlReportWriter_GetLocations();"
  ],
  "description": "\n\nThis function returns the directory configuration information of the HTML report writer.\n\n\n\n\n\nNote: This function must be called from within a critical section of your script.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$primaryLocation\n\nString\n\nPrimary location to write HTML files to.\n\n\n\n$secondaryLocation\n\nString\n\nSecondary location to write HTML files to.\n\n\n\n\n\nExample:\n\n($primaryLocation, $secondaryLocation) = HtmlReportWriter_GetLocations();\n\n\n\n\n\n$outStr = \"Primary Location: \" + $primaryLocation;\n\nUpdateStatus($outStr);\n\n$outStr = \"Secondary Location: \" + $secondaryLocation;\n\nUpdateStatus($outStr);\n\n\n\n\n\nMesPlusReportWriter_ConfigureLocations\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS MesPlusReportWriter_ConfigureLocations": {
  "prefix": "MesPlusReportWriter_ConfigureLocations",
  "body": [
   "MesPlusReportWriter_ConfigureLocations($$primaryLoc,$$secondaryLoc,$$dropToBoth);"
  ],
  "description": "\n\nThis function will set the locations to save the report in and whether to save the report to both locations.\n\n\n\nRemarks:\n\nIf the report writer is not set to save to both locations, it will attempt to save to the primary location and, if that fails, will attempt to save to the secondary location. Only if saving to both locations fails, will an error be generated.\n\nIf the report writer is set to save to both locations, an error will only be generated if unable to save to either location.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$primaryLoc\n\nString\n\nThe first location to save the report in.\n\n\n\n$secondaryLoc\n\nString\n\nThe second location to save the report in.\n\n\n\n$dropToBoth\n\nBoolean\n\nWhether to save the report to both locations.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n\n\n\n\n// Set the report writer to save to both the local mes folder and a network folder.\n\n$primLoc = \"C:\\\\mes\\\\\";\n\n$secLoc = \"\\\\\\\\networkserver\\\\MesReports\\\\\";\n\n$dropBoth = true;\n\n\n\nMesPlusReportWriter_ConfigureLocations($primLoc, $secLoc, $dropBoth);\n\n\n\n\n\nMesPlusReportWriter_ConfigureOptions\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS MesPlusReportWriter_ConfigureOptions": {
  "prefix": "MesPlusReportWriter_ConfigureOptions",
  "body": [
   "MesPlusReportWriter_ConfigureOptions($$includeFixture,$$fixtureName,$$includeMeasurements,$$includeLimits);"
  ],
  "description": "\n\nThis function will set the options for saving the test report.\n\n\n\nRemarks:\n\nIf $includeMeasurements is set to false then the setting of $includeLimits will be ignored.\n\nIf $fixtureName is blank, the value of $includeFixture will be ignored and the fixture data will not be changed.\n\nThe fixture name is limited to 25 characters. Any characters beyond 25 will be truncated.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$includeFixture\n\nBoolean\n\nWhether to include the fixture name in the report.\n\n\n\n$fixtureName\n\nString\n\nThe fixture name to include in the report (assuming $includeFixture is set to true).\n\n\n\n$includeMeasurements\n\nBoolean\n\nWhether to save the measurement data in the report.\n\n\n\n$includeLimits\n\nBoolean\n\nWhether to save the measurement limits and limit test results in the report.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n\n\n\n\n// Set the report writer to save to the fixture name and measurements with limits in the report.\n\n$inclFix = true;\n\n$fixture = \"Fixture01-002\";\n\n$inclMeas = true;\n\n$inclLimits = true;\n\n\n\nMesPlusReportWriter_ConfigureOptions($inclFix, $fixture, $inclMeas, $inclLimits);\n\n\n\n\n\nMesPlusReportWriter_GetLocations\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS MesPlusReportWriter_GetLocations": {
  "prefix": "MesPlusReportWriter_GetLocations",
  "body": [
   "($$primaryLoc,$$secondaryLoc,$$dropToBoth)=MesPlusReportWriter_GetLocations();"
  ],
  "description": "\n\nThis function will return the locations where the report writer will attempt to save the report.\n\n\n\nRemarks:\n\nIf the report writer is not set to save to both locations, it will attempt to save to the primary location and, if that fails, will attempt to save to the secondary location. Only if saving to both locations fails, will an error be generated.\n\nIf the report writer is set to save to both locations, an error will only be generated if unable to save to either location.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$primaryLoc\n\nString\n\nThe first location where the report writer will attempt to save the report.\n\n\n\n$secondaryLoc\n\nString\n\nThe second location where the report writer will attempt to save the report.\n\n\n\n$dropToBoth\n\nBoolean\n\nWhether the report writer will attempt to save in both locations.\n\n\n\n\n\nExample:\n\n\n\n\n\n// Get save location infomation.\n\n($primLoc, $secLoc, $dropBoth) = MesPlusReportWriter_GetLocations();\n\n\n\n// Print out the information.\n\n$outString = \"Primary Location = \" + $primLoc;\n\nUpdateStatus($outString);\n\n$outString = \"Secondary Location = \" + $secLoc;\n\nUpdateStatus($outString);\n\n$outString = \"Save to both locations = \" + $dropBoth;\n\nUpdateStatus($outString);\n\n\n\n\n\nMesPlusReportWriter_GetOptions\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS MesPlusReportWriter_GetOptions": {
  "prefix": "MesPlusReportWriter_GetOptions",
  "body": [
   "($$includeFixture,$$fixtureName,$$includeMeasurements,$$includeLimits)=MesPlusReportWriter_GetOptions();"
  ],
  "description": "\n\nThis function will return the options for the report writer.\n\n\n\nRemarks:\n\nIf the report writer is set to not save the fixture, the fixture name does not matter.\n\nIf the report writer is set to not save the measurements, the setting to save the limits is ignored.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$includeFixture\n\nBoolean\n\nWhether the fixture name will be included in the report.\n\n\n\n$fixtureName\n\nString\n\nThe fixture name that will be included in the report (assuming $includeFixture is set to true).\n\n\n\n$includeMeasurements\n\nBoolean\n\nWhether the measurement data will be included in the report.\n\n\n\n$includeLimits\n\nBoolean\n\nWhether the measurement limits and limit test results will be included in the report.\n\n\n\n\n\nExample:\n\n\n\n\n\n// Get report writer options.\n\n($inclFix, $fixture, $inclMeas, $inclLimits) = MesPlusReportWriter_GetOptions();\n\n\n\n// Print out the information.\n\n$outString = \"Include Fixture= \" + $inclFix;\n\nUpdateStatus($outString);\n\n$outString = \"Fixture Name = \" + $fixture;\n\nUpdateStatus($outString);\n\n$outString = \"Include Measurements = \" + $inclMeas;\n\nUpdateStatus($outString);\n\n$outString = \"Include Limits = \" + $inclLimits;\n\nUpdateStatus($outString);\n\n\n\n\n\nMESTISReportWithOffsite_ConfigureLocations\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS MESTISReportWithOffsite_ConfigureLocations": {
  "prefix": "MESTISReportWithOffsite_ConfigureLocations",
  "body": [
   "MESTISReportWithOffsite_ConfigureLocations($$serverURL,$$dbServer,$$dbName);"
  ],
  "description": "\n\nThis function will set the location to send the report to and the database to store data in.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$serverURL\n\nString\n\nThe URL of the MES-TIS server to send the report to.\n\n\n\n$dbServer\n\nString\n\nThe name of the SQL server to store the data on.\n\n\n\n$dbName\n\nString\n\nThe name of the database to save the data in.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n\n\n\n\n// Send report to the MES-TIS server mytistestserver on port 1010 in the testserver testdatabase.\n\n$servURL = \"http://mytistestserver:1010//MES-TIS/TIS.asmx\";\n\n$dbServ = \"testserver\";\n\n$dbName = \"testdatabase\";\n\n\n\nMESTISReportWithOffsite_ConfigureLocations($servURL, $dbServ, $dbName);\n\n\n\n\n\nMESTISReportWithOffsite_GetLocations\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS MESTISReportWithOffsite_GetLocations": {
  "prefix": "MESTISReportWithOffsite_GetLocations",
  "body": [
   "($$serverURL,$$dbServer,$$dbName,$$storeMeasure,$$offsite,$$jems)=MESTISReportWithOffsite_GetLocations();"
  ],
  "description": "\n\nThis function will return the settings for location to send the report to, the database to store data in and whether/where the measurement data is to be saved.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$serverURL\n\nString\n\nThe URL of the MES-TIS server that the report will be sent to.\n\n\n\n$dbServer\n\nString\n\nThe name of the SQL database server to save the data in.\n\n\n\n$dbName\n\nString\n\nThe name of the SQL database to save the data in.\n\n\n\n$storeMeasure\n\nBoolean\n\nWhether the measurement data should be saved.\n\n\n\n$offsite\n\nBoolean\n\nWhether the measurement data should be saved in a separate MongoDB database. This setting is ignored if $storeMeasure is false.\n\n\n\n$jems\n\nBoolean\n\nWhether the data should be saved in a Jems database (true) or an iFactory database (false).\n\n\n\n\n\nExample:\n\n\n\n\n\n// Get infomation for MES-TIS server.\n\n($servURL, $dbServer, $dbName, $offsite, $jems) = MESTISReportWithOffsite_GetLocations();\n\n\n\n// Print out the information.\n\n$outString = \"MES-TIS Server URL = \" + $servURL;\n\nUpdateStatus($outString);\n\n$outString = \"SQL Server Name = \" + $dbServer;\n\nUpdateStatus($outString);\n\n$outString = \"SQL Database Name = \" + $dbName;\n\nUpdateStatus($outString);\n\n$outString = \"Measurements in MongoDB = \" + $offsite;\n\nUpdateStatus($outString);\n\n$outString = \"Use Jems DB = \" + $jems;\n\nUpdateStatus($outString);\n\n\n\n\n\nMESReportWriter_ConfigureLocations\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS MESReportWriter_ConfigureLocations": {
  "prefix": "MESReportWriter_ConfigureLocations",
  "body": [
   "MESReportWriter_ConfigureLocations($$primaryLoc,$$secondaryLoc,$$dropToBoth);"
  ],
  "description": "\n\nThis function will set the locations to save the report in and whether to save the report to both locations.\n\n\n\nRemarks:\n\nIf the report writer is not set to save to both locations, it will attempt to save to the primary location and, if that fails, will attempt to save to the secondary location. Only if saving to both locations fails, will an error be generated.\n\nIf the report writer is set to save to both locations, an error will only be generated if unable to save to either location.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$primaryLoc\n\nString\n\nThe first location to save the report in.\n\n\n\n$secondaryLoc\n\nString\n\nThe second location to save the report in.\n\n\n\n$dropToBoth\n\nBoolean\n\nWhether to save the report to both locations.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n\n\n\n\n// Set the report writer to save to both the local mes folder and a network folder.\n\n$primLoc = \"C:\\\\mes\\\\\";\n\n$secLoc = \"\\\\\\\\networkserver\\\\MesReports\\\\\";\n\n$dropBoth = true;\n\n\n\nMESReportWriter_ConfigureLocations($primLoc, $secLoc, $dropBoth);\n\n\n\n\n\nMESReportWriter_GetLocations\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS MESReportWriter_GetLocations": {
  "prefix": "MESReportWriter_GetLocations",
  "body": [
   "($$primaryLoc,$$secondaryLoc,$$dropToBoth)=MESReportWriter_GetLocations();"
  ],
  "description": "\n\nThis function will return the locations where the report writer will attempt to save the report.\n\n\n\nRemarks:\n\nIf the report writer is not set to save to both locations, it will attempt to save to the primary location and, if that fails, will attempt to save to the secondary location. Only if saving to both locations fails, will an error be generated.\n\nIf the report writer is set to save to both locations, an error will only be generated if unable to save to either location.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$primaryLoc\n\nString\n\nThe first location where the report writer will attempt to save the report.\n\n\n\n$secondaryLoc\n\nString\n\nThe second location where the report writer will attempt to save the report.\n\n\n\n$dropToBoth\n\nBoolean\n\nWhether the report writer will attempt to save in both locations.\n\n\n\n\n\nExample:\n\n\n\n\n\n// Get save location infomation.\n\n($primLoc, $secLoc, $dropBoth) = MESReportWriter_GetLocations();\n\n\n\n// Print out the information.\n\n$outString = \"Primary Location = \" + $primLoc;\n\nUpdateStatus($outString);\n\n$outString = \"Secondary Location = \" + $secLoc;\n\nUpdateStatus($outString);\n\n$outString = \"Save to both locations = \" + $dropBoth;\n\nUpdateStatus($outString);\n\n\n\n\n\nMESTISReportWriter_ConfigureLocations\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS MESTISReportWriter_ConfigureLocations": {
  "prefix": "MESTISReportWriter_ConfigureLocations",
  "body": [
   "MESTISReportWriter_ConfigureLocations($$serverURL);"
  ],
  "description": "\n\nThis function will set the URL of the MES-TIS server that the report will be sent to.\n\n\n\nRemarks\n\nThis setting will override the URL that was set in the Report Writer configuration GUI.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$serverURL\n\nString\n\nThe URL of the MES-TIS server to send the report to.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n\n\n\n\n// Send to MES-TIS server mytistestserver on port 1010.\n\n$servURL = \"http://mytistestserver:1010//MES-TIS/TIS.asmx\";\n\n\n\nMESTISReportWriter_ConfigureLocations($servURL);\n\n\n\n\n\nMESTISReportWriter_GetLocations\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS MESTISReportWriter_GetLocations": {
  "prefix": "MESTISReportWriter_GetLocations",
  "body": [
   "($$serverURL,$$includeMeasure)=MESTISReportWriter_GetLocations();"
  ],
  "description": "\n\nThis function will return the URL of the server that the report will be sent to and whether measurements are included in the report.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$serverURL\n\nString\n\nThe URL of the MES-TIS server that the report will be sent to.\n\n\n\n$includeMeasure\n\nBoolean\n\nWhether measurement data will be included in the report.\n\n\n\n\n\nExample:\n\n\n\n\n\n// Get infomation for MES-TIS server.\n\n($servURL, $includeMeas) = MESTISReportWriter_GetLocations();\n\n\n\n// Print out the information.\n\n$outString = \"MES-TIS Server URL = \" + $servURL;\n\nUpdateStatus($outString);\n\n$outString = \"Include Measurements = \" + $includeMeas;\n\nUpdateStatus($outString);\n\n\n\n\n\nMesWithLimitsReportWriter_ConfigureLocations\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS MesWithLimitsReportWriter_ConfigureLocations": {
  "prefix": "MesWithLimitsReportWriter_ConfigureLocations",
  "body": [
   "MesWithLimitsReportWriter_ConfigureLocations($$primaryLoc,$$secondaryLoc,$$dropToBoth);"
  ],
  "description": "\n\nThis function will set the locations to save the report in and whether to save the report to both locations.\n\n\n\nRemarks:\n\nIf the report writer is not set to save to both locations, it will attempt to save to the primary location and, if that fails, will attempt to save to the secondary location. Only if saving to both locations fails, will an error be generated.\n\nIf the report writer is set to save to both locations, an error will only be generated if unable to save to either location.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$primaryLoc\n\nString\n\nThe first location to save the report in.\n\n\n\n$secondaryLoc\n\nString\n\nThe second location to save the report in.\n\n\n\n$dropToBoth\n\nBoolean\n\nWhether to save the report to both locations.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n\n\n\n\n// Set the report writer to save to both the local mes folder and a network folder.\n\n$primLoc = \"C:\\\\mes\\\\\";\n\n$secLoc = \"\\\\\\\\networkserver\\\\MesReports\\\\\";\n\n$dropBoth = true;\n\n\n\nMesWithLimitsReportWriter_ConfigureLocations($primLoc, $secLoc, $dropBoth);\n\n\n\n\n\nMesWithLimitsReportWriter_GetLocations\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS MesWithLimitsReportWriter_GetLocations": {
  "prefix": "MesWithLimitsReportWriter_GetLocations",
  "body": [
   "($$primaryLoc,$$secondaryLoc,$$dropToBoth)=MesWithLimitsReportWriter_GetLocations();"
  ],
  "description": "\n\nThis function will return the locations where the report writer will attempt to save the report.\n\n\n\nRemarks:\n\nIf the report writer is not set to save to both locations, it will attempt to save to the primary location and, if that fails, will attempt to save to the secondary location. Only if saving to both locations fails, will an error be generated.\n\nIf the report writer is set to save to both locations, an error will only be generated if unable to save to either location.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$primaryLoc\n\nString\n\nThe first location where the report writer will attempt to save the report.\n\n\n\n$secondaryLoc\n\nString\n\nThe second location where the report writer will attempt to save the report.\n\n\n\n$dropToBoth\n\nBoolean\n\nWhether the report writer will attempt to save in both locations.\n\n\n\n\n\nExample:\n\n\n\n\n\n// Get save location infomation.\n\n($primLoc, $secLoc, $dropBoth) = MesWithLimitsReportWriter_GetLocations();\n\n\n\n// Print out the information.\n\n$outString = \"Primary Location = \" + $primLoc;\n\nUpdateStatus($outString);\n\n$outString = \"Secondary Location = \" + $secLoc;\n\nUpdateStatus($outString);\n\n$outString = \"Save to both locations = \" + $dropBoth;\n\nUpdateStatus($outString);\n\n\n\n\n\nTARSReportWriter_ConfigureLocations\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS TARSReportWriter_ConfigureLocations": {
  "prefix": "TARSReportWriter_ConfigureLocations",
  "body": [
   "TARSReportWriter_ConfigureLocations($$locationOne,$$locationTwo,$$writeToBoth);"
  ],
  "description": "\n\nThis function can be used to modify the report directory to which the TARS report will be generated.\n\n\n\n\n\nNote: This function must be called from within a critical section of your script.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$locationOne\n\nString\n\nThe new #1 directory for the TARS report writer\n\n\n\n$locationTwo\n\nString\n\nThe new #2 directory for the TARS report writer\n\n\n\n$writeToBoth\n\nBoolean\n\nDetermines if the report will be written to both of the specified locations [TRUE,FALSE]\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\nEnterCS(\"Report\");\n\nTARSReportWriter_ConfigureLocations(\"C:\\\\tars1\\\\\", \"C:\\\\tars2\\\\\", true);\n\nExitCS(\"Report\");\n\n\n\n\n\nTARSReportWriter_GetLocations\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS TARSReportWriter_GetLocations": {
  "prefix": "TARSReportWriter_GetLocations",
  "body": [
   "($$primaryLocation,$$secondaryLocation,$$dropToBoth)=TARSReportWriter_GetLocations();"
  ],
  "description": "\n\nThis function returns the directory configuration information of the TARS report writer.\n\n\n\n\n\nNote: This function must be called from within a critical section of your script.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$primaryLocation\n\nString\n\nPrimary location to write TARS files to.\n\n\n\n$secondaryLocation\n\nString\n\nSecondary location to write TARS files to.\n\n\n\n$dropToBoth\n\nBoolean\n\nDetermines if the report will be written to both of the specified locations [TRUE,FALSE]\n\n\n\n\n\nExample:\n\n($primaryLocation, $secondaryLocation, $dropToBoth) = TARSReportWriter_GetLocations();\n\n\n\n\n\nUpdateStatus(\"Primary Location:\");\n\nUpdateStatus($primaryLocation);\n\nUpdateStatus(\"Secondary Location:\");\n\nUpdateStatus($secondaryLocation);\n\nUpdateStatus(\"Drop to Both Locations?\");\n\nUpdateStatus($dropToBoth);\n\n\n\n\n\nTXTReportWriter_ConfigureFileName\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS TXTReportWriter_ConfigureFileName": {
  "prefix": "TXTReportWriter_ConfigureFileName",
  "body": [
   "TXTReportWriter_ConfigureFileName($$TestStepsFileName,$$TestRunsFileName);"
  ],
  "description": "\n\nThis function can be used to modify the report directory to which the TXT report will be generated.\n\n\n\nNote: This function must be called from within a critical section of your script.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$TestStepsFileName\n\nString\n\nThe file name to use to log all the test step results (all the record measurements).\n\n\n\n$TestRunsFileName\n\nString\n\nThe file to use to log the overall test run result (pass, fail, the first failure, run date, run time).\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample 1 (log all test runs for a day in one file):\n\n\n\n\n\nEnterCS(\"Reporting\");\n\nConfigureReporting(\"TXTReportWriter.dll\", true);\n\n\n\n\n\n$TARS_Customer = \"Customer\";\n\n$TARS_Process = \"FVT\";\n\n\n\n\n\n// Get system time\n\n($month, $day, $year, $hour, $minutes, $seconds, $dayOfWeek) = SystemTime();\n\n\n\n\n\nif($month < 10)\n\n{\n\n$month = \"0\" + $month;\n\n}\n\n\n\n\n\nif($day < 10)\n\n{\n\n$day = \"0\" + $day;\n\n}\n\n\n\n\n\nif($hour < 10)\n\n{\n\n$hour = \"0\" + $hour;\n\n}\n\n\n\n\n\nif($minutes < 10)\n\n{\n\n$minutes = \"0\" + $minutes;\n\n}\n\n\n\n\n\nif($seconds < 10)\n\n{\n\n$seconds = \"0\" + $seconds;\n\n}\n\n\n\n\n\n// Configure file name to log all test results for a whole day\n\n$TestStepsFileName = $day + \"-\" + $month + \"-\" + $year + \"_TestSteps_\" + $TARS_Customer + \"_ETUxxx_\" + $TARS_Process + \"_Cell\" + $CellNumber + \".txt\";\n\n$TestRunsFileName = $day + \"-\" + $month + \"-\" + $year + \"_TestRuns_\" + $TARS_Customer + \"_ETUxxx_\" + $TARS_Process + \"_Cell\" + $CellNumber + \".txt\";\n\n\n\n\n\nTXTReportWriter_ConfigureFileName($TestStepsFileName, $TestRunsFileName);\n\n\n\n\n\nTXTReportWriter_ConfigureLocations(\"C:\\\\TXT1\\\\\", \"C:\\\\TXT2\\\\\", true);\n\n\n\n\n\nExitCS(\"Reporting\");\n\n\n\n\n\nExample 2 (log each test run in a file):\n\n\n\n\n\nEnterCS(\"Reporting\");\n\nConfigureReporting(\"TXTReportWriter.dll\", true);\n\n\n\n\n\n// <locations and variables the same as the example above>...\n\n\n\n\n\n// Configure file name for each serial number\n\n$TestStepsFileName = \"TestSteps_\" + $SerialNumber + \"(\" + $month + \"-\" + $day + \"-\" + $year + \" \" + $hour + \"-\" + $minutes + \"-\" + $seconds + \")-\" + $CellNumber + \".txt\";\n\n$TestRunsFileName = \"Testrun_\" + $SerialNumber + \"(\" + $month + \"-\" + $day + \"-\" + $year + \" \" + $hour + \"-\" + $minutes + \"-\" + $seconds + \")-\" + $CellNumber + \".txt\";\n\n\n\n\n\nTXTReportWriter_ConfigureFileName($TestStepsFileName, $TestRunsFileName);\n\n\n\n\n\nTXTReportWriter_ConfigureLocations(\"C:\\\\TXT1\\\\\", \"C:\\\\TXT2\\\\\", true);\n\n\n\n\n\nExitCS(\"Reporting\");\n\n\n\n\n\nTXTReportWriter_ConfigureLocations\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS TXTReportWriter_ConfigureLocations": {
  "prefix": "TXTReportWriter_ConfigureLocations",
  "body": [
   "TXTReportWriter_ConfigureLocations($$locationOne,$$locationTwo,$$writeToBoth);"
  ],
  "description": "\n\nThis function can be used to modify the report directory to which the TXT report will be generated.\n\n\n\n\n\nNote: This function must be called from within a critical section of your script.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$locationOne\n\nString\n\nThe new #1 directory for the Txt report writer\n\n\n\n$locationTwo\n\nString\n\nThe new #2 directory for the Txt report writer\n\n\n\n$writeToBoth\n\nBoolean\n\nDetermines if the report will be written to both of the specified locations [TRUE,FALSE]\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\nEnterCS(\"Report\");\n\nTxtReportWriter_ConfigureLocations(\"C:\\\\Txt1\\\\\", \"C:\\\\Txt2\\\\\", true);\n\nExitCS(\"Report\");\n\n\n\n\n\nXmlReportWriter_ConfigureLocations\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS XmlReportWriter_ConfigureLocations": {
  "prefix": "XmlReportWriter_ConfigureLocations",
  "body": [
   "XmlReportWriter_ConfigureLocations($$locationOne,$$locationTwo,$$writeToBoth);"
  ],
  "description": "\n\nThis function can be used to modify the report directory to which the XML report will be generated.\n\n\n\n\n\nNote: This function must be called from within a critical section of your script.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$locationOne\n\nString\n\nThe new #1 directory for the XML report writer\n\n\n\n$locationTwo\n\nString\n\nThe new #2 directory for the XML report writer\n\n\n\n$writeToBoth\n\nBoolean\n\nDetermines if the report will be written to both of the specified locations [TRUE, FALSE]\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\nEnterCS(\"Report\");\n\nXmlReportWriter_ConfigureLocations(\"C:\\\\XML1\\\\\", \"C:\\\\XML2\\\\\", true);\n\nExitCS(\"Report\");\n\n\n\n\n\nXmlReportWriter_GetLocations\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS XmlReportWriter_GetLocations": {
  "prefix": "XmlReportWriter_GetLocations",
  "body": [
   "($$primaryLocation,$$secondaryLocation)=XmlReportWriter_GetLocations();"
  ],
  "description": "\n\nThis function returns the directory configuration information of the XML report writer.\n\n\n\n\n\nNote: This function must be called from within a critical section of your script.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$primaryLocation\n\nString\n\nPrimary location to write XML files to.\n\n\n\n$secondaryLocation\n\nString\n\nSecondary location to write XML files to.\n\n\n\n\n\nExample:\n\n($primaryLocation, $secondaryLocation) = XmlReportWriter_GetLocations();\n\n\n\n\n\n$outStr = \"Primary Location: \" + $primaryLocation;\n\nUpdateStatus($outStr);\n\n$outStr = \"Secondary Location: \" + $secondaryLocation;\n\nUpdateStatus($outStr);\n\n\n\n\n\nAbort\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Abort": {
  "prefix": "Abort",
  "body": [
   "Abort($$AbortMessage);"
  ],
  "description": "\n\nThis is a special function that controls script execution. When this function is encountered, the script generates an abort, and the $AbortMessage is reported to the test executive. This can be useful when combined with the ScriptIf function to force a particular failure in response to a conditional evaluation.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$AbortMessage\n\nString\n\nThe abort message that should be displayed and recorded.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nCheckIfLastCellRunning\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS CheckIfLastCellRunning": {
  "prefix": "CheckIfLastCellRunning",
  "body": [
   "$$IsLastCellRunning=CheckIfLastCellRunning();"
  ],
  "description": "\n\nThis function returns true or false indicating if the current cell is the last test cell executing... this can be useful for determining if the test cell is the last cell still executing in order to perform actions such as unlocking a gate, or actuating a test fixture.\n\nFunction Arguments\n\n\n\nNone\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$IsLastCellRunning\n\nBoolean\n\nReturns true if the current test cell is the only test cell currently running, otherwise returns false if other cells are still executing.\n\n\n\n\n\nClearStatusText\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ClearStatusText": {
  "prefix": "ClearStatusText",
  "body": [
   "ClearStatusText();"
  ],
  "description": "\n\n\n\nThis function removes all the current text from the debug status window. This can be used to conserve memory for test scripts which produce a great deal of debug output.\n\n\n\n\n\nFunction Arguments\n\n\n\nNone\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nDisableAbort\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS DisableAbort": {
  "prefix": "DisableAbort",
  "body": [
   "DisableAbort();"
  ],
  "description": "\n\nDisables all methods of aborting a test script that is currently executing (Abort button, context menu item, etc).\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nDisableLogging\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS DisableLogging": {
  "prefix": "DisableLogging",
  "body": [
   "DisableLogging();"
  ],
  "description": "\n\nAll output to the HTML report writer is suppressed after encountering this function. No more output will be reported by the HTML report writer until an Script.EnableLogging statement is encountered.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nEnableAbort\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS EnableAbort": {
  "prefix": "EnableAbort",
  "body": [
   "EnableAbort();"
  ],
  "description": "\n\nAllows aborting of a running test script by enabling abort buttons and menu items. Aborting is enabled by default; this function reverses the effects of the DisableAbort() call;\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nEnableLogging\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS EnableLogging": {
  "prefix": "EnableLogging",
  "body": [
   "EnableLogging();"
  ],
  "description": "\n\nThe output to the HTML Report writer is re-enabled after this function is encountered. In the event that the output had not previously been disabled by the DisableLogging function, than this function causes no effect.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nEnforceValidation\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS EnforceValidation": {
  "prefix": "EnforceValidation",
  "body": [
   "EnforceValidation();"
  ],
  "description": "\n\nThis function checks the validation status of all functions used in the test script and fails the test if one or more functions is/are not validated.\n\n\n\nRemarks:\n\nThis function should be used at the top of the script being checked. Then it will pass or fail the validation test before any other functions are run.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\nEnforceValidation();\n\n\n\n\n\nFail\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Fail": {
  "prefix": "Fail",
  "body": [
   "Fail($$FailMessage);"
  ],
  "description": "\n\nThis is a special function that controls script execution. This function is encountered, the script generates a failure, and the $FailMesasge is reported to the test executive. This can be useful when combined with the ScriptIf function to force a particular failure in response to a conditional evaluation.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$FailMessage\n\nString\n\nThe failure message that should be displayed and recorded.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nGetCellCount\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS GetCellCount": {
  "prefix": "GetCellCount",
  "body": [
   "$$CellsCount=GetCellCount();"
  ],
  "description": "\n\nThis function returns the total number of Jabil Test cells currently being displayed.\n\nFunction Arguments\n\n\n\nNone\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$CellsCount\n\nInteger\n\nThe Total Number of Jabil Test Cells shown to the operator.\n\n\n\n\n\nGetElapsedTime\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS GetElapsedTime": {
  "prefix": "GetElapsedTime",
  "body": [
   "$$ElapsedTime=GetElapsedTime();"
  ],
  "description": "\n\n\n\n\n\nThis function returns the total elapsed execution time for the currently running test script in seconds. (Note that this value can be reset any time during a test script's execution by using the ResetElapsedTime function).\n\n\n\n\n\nThe elapsed execution time is returned in seconds.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ElapsedTime\n\nFloat\n\nThe total test script execution time in seconds (Note: If the elapsed time has been reset in the test script, this will be the total elapsed execution time since the last reset event).\n\n\n\n\n\nExample\n\n\n\n\n\n$ElapsedTime = GetElapsedTime();\n\n\n\n\n\nGetElapsedTimeInUnits\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS GetElapsedTimeInUnits": {
  "prefix": "GetElapsedTimeInUnits",
  "body": [
   "($$TotalDays,$$TotalHours,$$TotalMinutes,$$TotalSeconds,$$Days,$$Hours,$$Minutes,$$Seconds)=GetElapsedTimeInUnits();"
  ],
  "description": "\n\n\n\n\n\nThis function returns the total elapsed execution time for the currently running test script in both total time units as well as elapsed time units.\n\n\n\n\n\nNote that this value can be reset any time during a test script's execution by using the ResetElapsedTime function.\n\n\n\n\n\nThe elapsed execution time is returned in seconds.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$TotalDays\n\nFloat\n\nThe total elapsed test execution time expressed in the unit of 'Days'\n\n\n\n$TotalHours\n\nFloat\n\nThe total elapsed test execution time expressed in the unit of 'Hours'\n\n\n\n$TotalMinutes\n\nFloat\n\nThe total elapsed test execution time expressed in the unit of 'Minutes'\n\n\n\n$TotalSeconds\n\nFloat\n\nThe total elapsed test execution time expressed in the unit of 'Seconds'\n\n\n\n$Days\n\nInteger\n\nThe 'Day' unit of the total elapsed test time.\n\n\n\n$Hours\n\nInteger\n\nThe 'Hour' unit of the total elapsed test time.\n\n\n\n$Minutes\n\nInteger\n\nThe 'Minute' unit of the total elapsed test time.\n\n\n\n$Seconds\n\nInteger\n\nThe 'Second' unit of the total elapsed test time.\n\n\n\n\n\nExample\n\n\n\n\n\n// Demonstrate the Difference between Total Units and Standard Units\n\n\n\n\n\nSleep(5);\n\n($TotalDays,$TotalHours,$TotalMinutes,$TotalSeconds,$Days,$Hours,$Minutes,$Seconds) = GetElapsedTimeInUnits();\n\nEnd;\n\n\n\n\n\n// Output Example\n\n\n\n\n\nSleeping 5 Seconds...\n\nGetElapsedTimeInUnits: Total Days [5.78703703703704E-05] Total Hours [0.00138888888888889] Total Minutes [0.0833333333333333] Total Seconds [5] --- Days [0] Hours [0] Minutes [0] Seconds [5]\n\n5.78703703703704E-05\n\n0.00138888888888889\n\n0.0833333333333333\n\n5\n\n0\n\n0\n\n0\n\n5\n\n\n\n\n\nGetNumberOfCellsRunning\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS GetNumberOfCellsRunning": {
  "prefix": "GetNumberOfCellsRunning",
  "body": [
   "$$CellsRunning=GetNumberOfCellsRunning();"
  ],
  "description": "\n\nThis function returns the number of Jabil Test cells which are currently executing.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$CellsRunning\n\nInteger\n\nThe number of test cells which are currently running or active.\n\n\n\n\n\nGetTestCellPosition\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS GetTestCellPosition": {
  "prefix": "GetTestCellPosition",
  "body": [
   "$$xPos,$$yPos,$$Width,$$Height=GetTestCellPosition();"
  ],
  "description": "\n\nThis function returns the position coordinates and size of the test cell running the current script.\n\n\n\nNote: The position coordinates returned refer to the Jabil Test cell panel and not the entire monitor.\n\n\n\n\n\nNone\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$xPos\n\nInteger\n\nThe X coordinate of the top-left position of the test cell.\n\n\n\n$yPos\n\nInteger\n\nThe Y coordinate of the top-left position of the test cell.\n\n\n\n$Width\n\nFloat\n\nThe width of the test cell.\n\n\n\n$Height\n\nFloat\n\nThe height of the test cell\n\n\n\n\n\nExample:\n\n$xPos,$yPos,$width,$height = GetTestCellPosition();\n\n\n\n\n\nGetTestResultFailures\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS GetTestResultFailures": {
  "prefix": "GetTestResultFailures",
  "body": [
   "($$failureTable)=GetTestResultFailures();"
  ],
  "description": "\n\nReturns a table of the failed test steps (one failure per row) with the following columns:\n\n\n\n\n\n\u00b7 Test Name, Measurement Name, Measurement Value, Units, Lower Limit, Upper Limit\n\n\n\n\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$failureTable\n\nDataTable\n\nTable of all failing test results that have occurred in the test so far.\n\n\n\n\n\nExample\n\n\n\n\n\n//Create some failures then display them as a table\n\nSetTestName(\"PC Check\");\n\nRecordMeasurementPassFail(\"RAM Test\", 13091, \"Readback error\", true, false);\n\nRecordMeasurementPassFail(\"Serial #\", \"\", \"\", false, false);\n\nRecordMeasurementPassFail(\"Assembly #\", \"\", \"\", false, true);\n\n\n\n\n\nSetTestName(\"Voltage Test\");\n\nRecordMeasurementWithLimits(\"20V Check\", 19.9, \"Volts\", true , 18, 22, true);\n\nRecordMeasurementWithLimits(\"12V Check\", 0.1, \"Volts\", true , 10, 14, true);\n\nRecordMeasurementWithLimits(\"5V Check\", 7.1, \"Volts\", true , 4, 6, true);\n\nRecordMeasurementWithLimits(\"3.3V Check\", 1.1, \"Volts\", true , 3, 3.6, true);\n\nRecordMeasurementWithLimits(\"1.5V Check\", 1.4, \"Volts\", true , 1, 2, true);\n\n\n\n\n\n$failureTable = GetTestResultFailures();\n\n\n\n\n\nDataTable_ShowInWindow($failureTable);\n\n\n\n\n\nEnd;\n\n\n\n\n\nResetElapsedTime\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ResetElapsedTime": {
  "prefix": "ResetElapsedTime",
  "body": [
   "ResetElapsedTime();"
  ],
  "description": "\n\n\n\n\n\nThis function resets the currently elapsed time value for the test script. This command resets the 'Elapsed Time' recorded in each test step executed. This affects the value shown for elapsed time on the test cell GUI, as well as the report writer collection.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nScriptIf\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ScriptIf": {
  "prefix": "ScriptIf",
  "body": [
   "ScriptIf($$BooleanValue,$$CallType,$$TrueLocation,$$FalseLocation);"
  ],
  "description": "\n\nThe ScriptIf command allows branching from inside of the test script. The first argument to the function, is a boolean variable. The second argument is the call type, which can be either \"CALL\" or \"GOTO\". The $TrueLocation argument represents a function name in the case of a CALL call type, or a label name in the case of a GOTO call type. The script interpreter will branch to this location if the $BooleanValue parameter is TRUE. The $FalseLocation argument represents a function name in the case of a CALL call type, or a label name in the case of a GOTO call type. The script interpreter will branch to this location if the $BooleanValue parameter is FALSE. In the event that the $TrueLocation or $FalseLocation are left blank, the script interpreter will continue on the next line, and not perform a call or goto operation.\n\nExamples:\n\nScriptIf($BooleanValue,\"GOTO\",\"HereLabel\",\"ThereLabel\");\n\nScriptIf($BooleanValue,\"CALL\",\"HereFunction\",\"ThereFunction\");\n\nScriptIf($BooleanValue,\"GOTO\",\"HereLabel\",\"\");\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$BooleanValue\n\nBoolean\n\nThe expression that will determine whether the script will CALL or GOTO a particular label or function.\n\n\n\n$CallType\n\nString\n\nThe call-type to be performed. Valid Values are:\n\n\u00b7 \"CALL\"\n\n\u00b7 \"GOTO\"\n\n\n\n$TrueLocation\n\nString\n\nIn the event that the $BooleanValue is TRUE:\n\nIn the case of a \"CALL\" call-type, the script interpreter will place the current script line on the stack, and then perform a call to the function name supplied.\n\nIn the case of a \"GOTO\" call-type, the script interpreter will perform a goto to the label name supplied.\n\nIn the event that this location is left blank, the script interpreter continues to the next line in the script.\n\n\n\n$FalseLocation\n\nString\n\nIn the event that the $BooleanValue is FALSE:\n\nIn the case of a \"CALL\" call-type, the script interpreter will place the current script line on the stack, and then perform a call to the function name supplied.\n\nIn the case of a \"GOTO\" call-type, the script interpreter will perform a goto to the label name supplied.\n\nIn the event that this location is left blank, the script interpreter continues to the next line in the script.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nSetAbortFunction\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SetAbortFunction": {
  "prefix": "SetAbortFunction",
  "body": [
   "SetAbortFunction($$functionName);"
  ],
  "description": "\n\nThis is a special function that controls script execution. When this function is used, the function name supplied as an argument will always be executed immediately before executing the finalization function in the event of a test abort caused by either manual operator intervention, or via the 'Abort' command.\n\n\n\nThis function is used to take special actions that should only occur in the event that a particular test run resulted in an abort status.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$functionName\n\nString\n\nThe name of the function to be run as an abort step. The function name should not contain the ending '()' .\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample\n\n\n\n\n\nSetFailFunction(\"OnFail\");\n\nSetFinalizeFunction(\"OnFinal\");\n\nSetAbortFunction(\"OnAbort\");\n\nSleep(1);\n\nAbort(\"DOH!\");\n\nSleep(1);\n\nEnd;\n\n\n\n\n\nfunction OnFail()\n\n{\n\nUpdateStatus(\"This function will run if the test fails.\");\n\nEnd;\n\n}\n\n\n\n\n\nfunction OnAbort()\n\n{\n\nUpdateStatus(\"This function will run if the test aborts\");\n\nEnd;\n\n}\n\n\n\n\n\nfunction OnFinal()\n\n{\n\nUpdateStatus(\"This function will always run as the last step in the test... it will be run after the abort and fail functions if they are called\");\n\nEnd;\n\n}\n\n\n\n\n\nSetCellColor\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SetCellColor": {
  "prefix": "SetCellColor",
  "body": [
   "SetCellColor($$Red1,$$Green1,$$Blue1,$$Red2,$$Green2,$$Blue2,$$ColorAngle);"
  ],
  "description": "\n\n\n\n\n\nThis function can be used to set the background color of a test cell from inside of a test script. This function can be used to alert the operator that a particular cell needs attention, or let the operator know that a particular test cell has entered a certain section of a test process.\n\n\n\n\n\nThe test cell has two colors (primary/secondary) which form a gradient for the test cells background. The first color is specified by values (0-255) assigned to $Red1,$Green1, and $Blue1 parameters. The second color is specified by values assigned to $Red2,$Green2, and $Blue2 parameters. The $ColorAngle parameter is used to set the angle at which the gradient is applied to the background color of the test cell.\n\n\n\n\n\nIf you would like to use a solid background color for the test cell, simply set the values for the top and bottom colors to the same RGB values.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Red1\n\nInteger\n\nThe red component of the cell's primary background color.\n\n\n\n$Green1\n\nInteger\n\nThe green component of the cell's primary background color.\n\n\n\n$Blue1\n\nInteger\n\nThe blue component of the cell's primary background color.\n\n\n\n$Red2\n\nInteger\n\nThe red component of the cell's secondary background color.\n\n\n\n$Green2\n\nInteger\n\nThe green component of the cell's secondary background color.\n\n\n\n$Blue2\n\nInteger\n\nThe blue component of the cell's secondary background color.\n\n\n\n$ColorAngle\n\nInteger\n\nThe angle used for applying the color gradient to the background color testing.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples::\n\n\n\n\n\n//This demo script creates a rotating rainbow effect on the test cell\n\n$Rotation = 0;\n\n$Color1 = 0;\n\n$Color2 = 0;\n\n\n\n\n\nLabel Looper:\n\nSleepMilliseconds(10);\n\n$Rotation = $Rotation + 1;\n\n$Color1 = $Color1 + 1;\n\n$Color2 = 255 - $Color1;\n\n\n\n\n\nSetCellColor($Color1,$Color2,$Color1,$Color2,$Color1,$Color2,$Rotation);\n\nif ($Rotation<360)\n\n{\n\ngoto Looper;\n\n}\n\n\n\n\n\nEnd;\n\n\n\n\n\nSetCellLabel\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SetCellLabel": {
  "prefix": "SetCellLabel",
  "body": [
   "SetCellLabel($$CellLabel);"
  ],
  "description": "\n\nSets the current cell label (normally 'Test Cell xxx') with a user defined text string. This can be useful for marking a specific cell as having a special purpose, or to display information to the user that needs to be distinct from the information displayed in the test progress window. Function Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$CellLabel\n\nString\n\nThe string representing the desire Test Cell label that will be displayed in a bold font at the top of the Test Cell executing the current script.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nSetCellViewMode\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SetCellViewMode": {
  "prefix": "SetCellViewMode",
  "body": [
   "SetCellViewMode($$ViewMode);"
  ],
  "description": "\n\n\n\n\n\nThis function can be used to set the currently selected view panel of the test cell from within a test script. The currently support Cell View Modes are 'STATUS', 'DEBUG' and 'BROWSER' which brings up the corresponding tab on the test cell's main GUI panel.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ViewMode\n\nString\n\nThe desired view mode of the test cell. Supported values are:\n\n\u00b7 \"STATUS\"\n\n\u00b7 \"DEBUG\"\n\n\u00b7 \"BROWSER\"\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples::\n\n\n\n\n\nSetCellViewMode(\"DEBUG\"); // Forces test cell to debug view.\n\n\n\n\n\nSetCurrentCellPanel\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SetCurrentCellPanel": {
  "prefix": "SetCurrentCellPanel",
  "body": [
   "SetCurrentCellPanel($$PanelNumber);"
  ],
  "description": "\n\nThis function allows setting the current visible test cell panel from inside of a test script. In order to select a cell panel, the Jabil Test main configuration options must already be configured for multiple cell panels. If the developer selects a test panel greater than the number of test panels currently configured in Jabil Test, the function will return with a failing test result, otherwise the main test cell window will be changed to the selected cell panel.\n\n\n\n\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$PanelNumber\n\nInteger\n\nThe number of the test cell panel to be displayed to the user.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples\n\n\n\n\n\nSleep(2);\n\nSetCurrentCellPanel(1);\n\nSleep(2);\n\nSetCurrentCellPanel(2);\n\nSleep(2);\n\nSetCurrentCellPanel(3);\n\nSleep(2);\n\nSetCurrentCellPanel(4);\n\nSleep(2);\n\nSetCurrentCellPanel(1);\n\nEnd;\n\n\n\n\n\nSetDebugVerbosityLevel\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SetDebugVerbosityLevel": {
  "prefix": "SetDebugVerbosityLevel",
  "body": [
   "SetDebugVerbosityLevel($$VerbosityLevel);"
  ],
  "description": "\n\n\n\n\n\nThis function sets the debug verbosity level for the test cell's current debug output. This function can be useful if you have a large number of loops occuring inside of your test script, but you don't want to have the entire debug output for that process recorded in the debug output window.\n\n\n\n\n\nThe verbosity setting only affects the current test cell, and the verbosity level is set back to the default Jabil Test setting after the test script completes execution.\n\n\n\n\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$VerbosityLevel\n\nString\n\nThis string specifies the desired verbosity level of the debug output for the test script. Supported values include:\n\n\u00b7 \"NONE\" = No Debug Output is displayed\n\n\u00b7 \"Verbose\" = All Debug Output is displayed\n\n\u00b7 \"UpdateStatusOnly\" = Only the output from the UpdateStatus command is displayed in the debug window.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nSetFailFunction\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SetFailFunction": {
  "prefix": "SetFailFunction",
  "body": [
   "SetFailFunction($$functionName);"
  ],
  "description": "\n\nThis is a special function that controls script execution. When this function is used, the function name supplied as an argument will always be executed immediately before executing the finalization function in the event of a test failure. This is done to take special actions that should only occur in the event that a particular test run resulted in failure.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$functionName\n\nString\n\nThe name of the function to be run as a finalizations step. The function name should not contain the ending '()' .\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nSetFinalizeFunction\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SetFinalizeFunction": {
  "prefix": "SetFinalizeFunction",
  "body": [
   "SetFinalizeFunction($$functionName);"
  ],
  "description": "\n\nThis is a special function that controls script execution. When this function is used, the function name supplied as an argument will always be executed as the last step of a script, regardless of how the test ends; be it a pass,fail, or abort status. This is usually used to ensure that a particular set of \"clean up\" steps is performed at the end of every script execution. This function can be placed anywhere in the script allowing for multiple pass/fail/abort conditions to be established depending on the scripts progress.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$functionName\n\nString\n\nThe name of the function to be run as a finalizations step. The function name should not contain the ending '()' .\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nSetMainWindowSize\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SetMainWindowSize": {
  "prefix": "SetMainWindowSize",
  "body": [
   "SetMainWindowSize($$x,$$y,$$width,$$height);"
  ],
  "description": "\n\nThis function can be used to modify the Jabil Test main window size and position from inside of a test script. If the Jabil Test window is maximized when this function is called, the window state will be set to normal in order to allow the window position and size to be modified.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$x\n\nInteger\n\nThe X position of the Jabil Test Main Window\n\n\n\n$y\n\nInteger\n\nThe Y position of the Jabil Test Main Window\n\n\n\n$width\n\nInteger\n\nThe width in pixels of the Jabil Test Main Window\n\n\n\n$height\n\nInteger\n\nThe height in pixels of the Jabil Test Main Window\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples\n\nSetMainWindowSize(10,10,1000,800);\n\n\n\n\n\nSetProductName\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SetProductName": {
  "prefix": "SetProductName",
  "body": [
   "SetProductName($$ProductName);"
  ],
  "description": "\n\nSets the Current Product Name. This function sets the product name property of the test results object which is passed to the report generator collection. This allows a single script to test multiple product types.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ProductName\n\nString\n\nThe supplied string will set the 'Product Name' property of a script. This property is passed to the ReportWriter collection for data logging and reporting.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nSetSerialNumberField\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SetSerialNumberField": {
  "prefix": "SetSerialNumberField",
  "body": [
   "SetSerialNumberField($$SerialNumber);"
  ],
  "description": "\n\nThis function can be used to update the serial number that's displayed in the test cell for a currently executing test. This can be useful if the serial number is changed during a long running test and you want to update the value shown to the operator.\n\n\n\nRemarks:\n\nThe serial number can be read using the reserved variable $SerialNumber.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$SerialNumber\n\nString\n\nThe serial number to set the test cell display.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n\n\n\n\n// Prompt the user for a new serial number.\n\n$newSerial = OperatorInputPrompt(\"Enter the new Serial Number\");\n\n\n\nSetSerialNumberField($newSerial);\n\n\n\n\n\nSetTestName\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SetTestName": {
  "prefix": "SetTestName",
  "body": [
   "SetTestName($$testName);"
  ],
  "description": "\n\nThis function will set the current test name. This test name will appear in the \"Current Test\" display at the top of the test cell. The $testName will also be copied into the Test Group for all recorded measurements until the test name is changed.\n\n\n\n\n\nRemarks:\n\nNote: RecordMeasurement functions will allow you to set the Measurement Name but the Test Name and Test Group that will be recorded are the ones set by this function.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$testName\n\nString\n\nThe Test Name to set for the current test.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n// Set the current test name.\n\n$testName = \"Read_Voltage\");\n\nSetTestName($testName);\n\n\n\n\n\nSetWaitingOff\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SetWaitingOff": {
  "prefix": "SetWaitingOff",
  "body": [
   "SetWaitingOff();"
  ],
  "description": "\n\nThis will make JabilTest go from a waiting status back to running status.\n\n\n\n\n\nExample Script.\n\nSetWaitingOff();\n\nYou do not need to set the status back to running, because the next script function call will do that.\n\nSee also SetWaitingOn function.\n\n\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nSetWaitingOn\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SetWaitingOn": {
  "prefix": "SetWaitingOn",
  "body": [
   "SetWaitingOn();"
  ],
  "description": "\n\nThis will make the test cell go into waiting mode.\n\nIt will be indicated by an orange flickering status.\n\nThis status is also reported to the remote channel and in the logging.\n\nThis function should be used in combination with an operator depending function.\n\nLike a message popup.\n\n\n\nExample Script.\n\nSetTestName(\"Waiting Test\");\n\nUpdateStatus(\"Waiting Test\");\n\nSetWaitingOn();\n\n$output = OperatorPrompt(\"Ask the operator do to this, do that...\",\"OK\");\n\nYou do not need to set the status back to running, because the next scriptfunction call will do that.\n\n\n\nHowever, run the SetWaitingOff() function, if you need to stop the waiting state and put JabilTest back in running mode.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nSleep\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Sleep": {
  "prefix": "Sleep",
  "body": [
   "Sleep($$Time);"
  ],
  "description": "\n\nInstructs the script to pause for the time period specified in seconds.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Time\n\nInteger\n\nThe number of seconds to pause before continuing.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nSleepMicroseconds\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SleepMicroseconds": {
  "prefix": "SleepMicroseconds",
  "body": [
   "SleepMicroseconds($$Time);"
  ],
  "description": "\n\nInstructs the script to pause for the time period specified in microseconds (millionths of a second). This can be used to fine-tuning timing that requires a finer adjustment than the Sleep function provides. See also the Sleep command.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Time\n\nInteger\n\nThe number of microseconds to pause before continuing.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nSleepMilliseconds\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SleepMilliseconds": {
  "prefix": "SleepMilliseconds",
  "body": [
   "SleepMilliseconds($$Time);"
  ],
  "description": "\n\nInstructs the script to pause for the time period specified in milliseconds.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Time\n\nInteger\n\nThe number of milliseconds to pause before continuing.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nUpdateProgressBar\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS UpdateProgressBar": {
  "prefix": "UpdateProgressBar",
  "body": [
   "UpdateProgressBar($$progress);"
  ],
  "description": "\n\nUpdates The Progress Bar in the cell display to show the current test progress. This is an integer number between 1 and 100 which indicates the percentage completion of the current script. Usage of this function is optional, but can serve as a useful indicator to the operator for tests that are longer in duration.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$progress\n\nInteger\n\nThe percentage completion that should be displayed in the script progress meter.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nUpdateStatus\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS UpdateStatus": {
  "prefix": "UpdateStatus",
  "body": [
   "UpdateStatus($$DisplayString);"
  ],
  "description": "\n\nWrites the supplied string to the current cell's progress status window.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$DisplayString\n\nString\n\nThe string that should be displayed in the progress window.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nStringCat\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS StringCat": {
  "prefix": "StringCat",
  "body": [
   "$$returnString=StringCat($$firstString,$$secondString);"
  ],
  "description": "\n\nThis function will concatenate two strings together and return the result.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$firstString\n\nString\n\nThe first string to be concatenated. This string will be at the start of the $returnString.\n\n\n\n$secondString\n\nString\n\nThe second string to be concatenated. This string will be at the end of the $returnString.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$returnString\n\nString\n\nA new string with $firstString and $secondString concatenated.\n\n\n\n\n\nExample:\n\n\n\n\n\n// Concatenate two string together.\n\n$first = \"These two strings \";\n\n$second = \"will be put together.\";\n\n\n\n\n\n$resultString = StringCat($first, $second);\n\n\n\n\n\nUpdateStatus($resultString);\n\n\n\n\n\nStringCheckMask\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS StringCheckMask": {
  "prefix": "StringCheckMask",
  "body": [
   "$$matches=StringCheckMask($$stringToCheck,$$mask);"
  ],
  "description": "\n\nThis function will check the supplied string with the RegEx espression in $mask and return a True if the string matches the mask (False, otherwise).\n\n\n\n\n\nRemarks:\n\nSee the website at: https://msdn.microsoft.com/en-us/library/hs600312(v=vs.110).aspx for more information on RegEx expressions.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$stringToCheck\n\nString\n\nThe string to test with the mask.\n\n\n\n$mask\n\nString\n\nThe RegEx expression to check the string against.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$matches\n\nBoolean\n\nTrue if the string matches the RegEx expression in $mask.\n\n\n\n\n\nExample:\n\n// Check a serial number for a the format:\n\n// 1-5 digits,\n\n// 2-4 alpha character,\n\n// 3-8 digits.\n\n$serNum = \"1234ABC1234567\"; // This will pass the test.\n\n$mask = \"[0-9]{1,5}[A-Za-z]{2,4}[0-9]{3,8}\";\n\n\n\n\n\n$match = StringCheckMask($serNum, $mask);\n\n\n\n\n\nStringCompare\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS StringCompare": {
  "prefix": "StringCompare",
  "body": [
   "StringCompare($$firstString,$$secondString);"
  ],
  "description": "\n\nCompares the first and second string parameters for equality. If the first and second parameters are identical, the test passes, otherwise a failure is returned to the executive. This function is case-sensitive.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$FirstString\n\nString\n\nThe first string to be compared.\n\n\n\n$SecondString\n\nString\n\nThe second string to be compared.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nStringCompareOrdinal\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS StringCompareOrdinal": {
  "prefix": "StringCompareOrdinal",
  "body": [
   "$$Result=StringCompareOrdinal($$String1,$$String2);"
  ],
  "description": "\n\nThe StringCompareOrdinal function compares two string objects by evaluating the numeric values of the corresponding characters in each string.\n\n\n\nExample\n\n$Result = StringCompareOrdinal(\"ABC\",\"ABD\"); // Returns -1\n\n$Result = StringCompareOrdinal(\"ABD\",\"ABC\"); // Returns 1\n\n$Result = StringCompareOrdinal(\"ABC\",\"ABC\"); // Returns 0\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$String1\n\nString\n\nThe first string to compare.\n\n\n\n$String2\n\nString\n\nThe second string to compare.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Result\n\nInteger\n\nReturns the result of the ordinal evaluation (i.e. the numerical difference between the values of the two strings)\n\n\n\n\n\nStringComparison\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS StringComparison": {
  "prefix": "StringComparison",
  "body": [
   "$$Result=StringComparison($$Value1,$$Value2,$$LogicalOperator);"
  ],
  "description": "\n\nThe StringComparison function returns a boolean resulting from the comparison of two script variables. $Value1 represents the first comparison value, $Value2 represents the second comparison value, and $LogicalOperator represents the comparison type to be performed.\n\nExample:\n\n$Result = StringComparison($Value1,\"cat\",\"==\")\n\n$Result will be 'true' if the variable contents of $Value1 are equal to \"cat\".\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Value1\n\nString\n\nFirst Comparison Value\n\n\n\n$Value2\n\nString\n\nSecond Comparison Value\n\n\n\n$LogicalOperator\n\nString\n\nThe logical comparison operation to perform on the two supplied arguments. Valid Logical Operators are:\n\n\u00b7 \"==\": Equal To\n\n\u00b7 \"!=\": Not Equal To\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Result\n\nBoolean\n\nThe result of the logical comparison operation\n\n\n\n\n\nStringContains\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS StringContains": {
  "prefix": "StringContains",
  "body": [
   "$$Result=StringContains($$String1,$$String2);"
  ],
  "description": "\n\nReturns a boolean value indicating whether or not $String2 exists in $String1. Function Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$String1\n\nString\n\nThe primary string which will be searched to see if it contains an occurence of $String2\n\n\n\n$String2\n\nString\n\nThe search string which will be searched for inside of $String1\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Result\n\nBoolean\n\nReturns \"TRUE\" if $String2 is found inside of $String1, otherwise returns \"FALSE\"\n\n\n\n\n\nStringCut\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS StringCut": {
  "prefix": "StringCut",
  "body": [
   "$$returnString=StringCut($$inputString,$$tokenString,$$numberOfCharacters);"
  ],
  "description": "\n\nSearches for the $tokenString in the $inputString. If the token string is found, the $returnString parameter will be a substring of the $inputString - starting after the location of the $tokenString and containing up to the $numberOfCharacters parameter specified.\n\n\n\n\n\nRemarks:\n\nThe test will FAIL if the token string is not found.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$inputString\n\nString\n\nThe string to be searched.\n\n\n\n$tokenString\n\nString\n\nThe string to be found in the input string.\n\n\n\n$numberOfCharacters\n\nInteger\n\nThe number of characters to be returned. If the input string contains fewer characters than specified, the entire remaining string will be returned.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$returnString\n\nString\n\nThe resulting substring returned.\n\n\n\n\n\nExample:\n\n\n\n\n\n// Return 5 characters after the word \"good\".\n\n$inStr = \"Every Good Boy Does Fine.\";\n\n$token = \"Good\";\n\n\n\n$numChars = 5;\n\n\n\n$returnStr = StringCut($inStr, $token, $numChars);\n\n\n\nThe return string will contain \" Boy \".\n\n\n\n\n\nStringEndsWith\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS StringEndsWith": {
  "prefix": "StringEndsWith",
  "body": [
   "$$Result=StringEndsWith($$String1,$$String2,$$IgnoreCase);"
  ],
  "description": "\n\nThe function will return true if the contents of $String1 ends with the string specified in $String2. The $IgnoreCase parameter allows the function to ignore differences in upper vs. lower case when doing the comparison operation.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$String1\n\nString\n\nThe primary string to search for the substring.\n\n\n\n$String2\n\nString\n\nThe string to search for at the end of the primary string\n\n\n\n$IgnoreCase\n\nBoolean\n\nSpecifies whether or not to ignore upper/lower case differences when making the comparison.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Result\n\nBoolean\n\nReturns a true/false value indicating whether or not $String2 was found at the beginning of $String1\n\n\n\n\n\nExample\n\n$Result = StringEndsWith(\"ABCDEF\",\"ABC\",true);\n\n\n\n\n\nStringIndexOf\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS StringIndexOf": {
  "prefix": "StringIndexOf",
  "body": [
   "$$location=StringIndexOf($$primaryString,$$searchString,$$startIndex);"
  ],
  "description": "\n\nThis function will find the position of the first occurrence of the $searchString occuring in the $primaryString, starting at the character position indicated by $startIndex.\n\n\n\nRemarks:\n\nIf the search string is not found, a value of -1 is returned to the executive.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$primaryString\n\nString\n\nThe string to be searched for occurrences of the search string.\n\n\n\n$searchString\n\nString\n\nThe string to be searched for in the primary string.\n\n\n\n$startIndex\n\nInteger\n\nThe 0-based index to begin searching for the second string at.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$location\n\nInteger\n\nThe location of the 0-based index of the first occurrence of the search string in the primary string. If the search string is not found, -1 is returned.\n\n\n\n\n\nExamples:\n\n\n\n\n\n$textToSearch = \"My Dog is a Good Dog.\";\n\n\n\n// Search starting from the first character.\n\n$location = StringIndexOf($textToSearch, \"Dog\", 0);\n\n// $location returns 3.\n\n\n\n// Search starting from the fourth character. Will skip first \"Dog\".\n\n$location = StringIndexOf($textToSearch, \"Dog\", 4);\n\n// $location returns 17.\n\n\n\n\n\nStringIsHexadecimal\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS StringIsHexadecimal": {
  "prefix": "StringIsHexadecimal",
  "body": [
   "$$IsHexadecimal=StringIsHexadecimal($$InputString);"
  ],
  "description": "\n\nThis function evaluates the input string to determine if it contains a valid hexadecimal value. If the string can be converted to a positive/negative integer, the function returns true, otherwise a false value is returned.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InputString\n\nString\n\nThe string to evalutate to determine if it contains a value that can be parsed into a hexadecimal value type. The string shall not contain a leading \"0x\" in order to be considered a value.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$IsHexadecimal\n\nBoolean\n\nReturns a value of true if the string represents a hexadecimal integer value, otherwise returns a false value.\n\n\n\n\n\nExample\n\n\n\n\n\n$Hex = StringIsHexadecimal(\"Kermit the Frog!\"); // Returns False\n\n\n\n\n\n$Hex = StringIsHexadecimal (\"FEDCBA01\"); // Returns True\n\n\n\n\n\nStringIsNumeric\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS StringIsNumeric": {
  "prefix": "StringIsNumeric",
  "body": [
   "$$IsNumeric=StringIsNumeric($$InputString);"
  ],
  "description": "\n\nThis function evaluates the input string to determine if it contains a valid numeric value. If the string can be converted to a positive/negative integer or floating point value, the function returns true, otherwise a false value is returned.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InputString\n\nString\n\nThe string to evaluate to determine if it contains a value that can be parsed into numeric value type.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$IsNumeric\n\nBoolean\n\nReturns a value of true if the string represents a positive/negative integer or floating point value, otherwise returns a false value.\n\n\n\n\n\nUsage Example:\n\n\n\n\n\n$Numeric = StringIsNumeric(\"Kermit the Frog!\"); // Returns False\n\n$Numeric = StringIsNumeric(\"-1232.22\"); // Returns True\n\n\n\n\n\nStringLastIndexOf\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS StringLastIndexOf": {
  "prefix": "StringLastIndexOf",
  "body": [
   "$$location=StringLastIndexOf($$primaryString,$$searchString,$$startIndex);"
  ],
  "description": "\n\nThis function will find the position of the last occurence of the $searchString occurring in the $primaryString, starting at the character position indicated by $startIndex beginning from the end of the string.\n\n\n\nRemarks:\n\nIf the search string is not found, a value of -1 is returned to the executive.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$primaryString\n\nString\n\nThe string to be searched for occurrences of the search string.\n\n\n\n$searchString\n\nString\n\nThe string to be searched for in the primary string.\n\n\n\n$startIndex\n\nInteger\n\nThe 0-based index to begin searching for the second string at. 0 = the end of the string.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$location\n\nInteger\n\nThe location of the 0-based index of the first occurrence of the search string in the primary string. If the search string is not found, -1 is returned. The index returned is from the beginning of the string.\n\n\n\n\n\nExamples:\n\n\n\n\n\n$textToSearch = \"Every Good Dog Likes to Bark at Dogs In The Neighborhood.\";\n\n$strLength = StringLength($textToSearch);\n\n\n\n// Search starting from the last character. Returns -1.\n\n$location = StringLastIndexOf($textToSearch, \"Dog\", 0);\n\n\n\n// Search starting from the first character. Returns 32.\n\n$location = StringLastIndexOf($textToSearch, \"Dog\", $strLength);\n\n\n\n// For comparison: Using StringIndexOf to find the first occurrence of the string. Returns 11.\n\n$location = StringIndexOf($textToSearch, \"Dog\", 0);\n\n\n\n\n\nStringLength\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS StringLength": {
  "prefix": "StringLength",
  "body": [
   "$$length=StringLength($$InputString);"
  ],
  "description": "\n\nReturns the Integer value representing the number of characters in the input string. Function Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Input\n\nString\n\nThe Input String\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$length\n\nInteger\n\nThe number of characters in the input string.\n\n\n\n\n\nStringLookup\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS StringLookup": {
  "prefix": "StringLookup",
  "body": [
   "$$returnString=StringLookup($$keyString,$$pairString);"
  ],
  "description": "\n\nThis function will search the $pairString argument for the the first occurence of the $keyString and return it's corresponding value.\n\nThe format of the $pairString is: \"key:value,key:value,key:value,etc\". In the event that they $keyString value doesn't exist, or can't be found in the $pairString argument, the test generates a failing result. Otherwise, a passing result is always returned.\n\nExample:\n\n$returnString = StringLookup(\"frog\",\"dog:canine,cat:feline,mouse:rodent,frog:amphibian\");\n\nAfter this operation $returnString will contain \"amphibian\".\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$keyString\n\nString\n\nThe key to be located in the $pairString argument\n\n\n\n$pairString\n\nString\n\nThe string containing the keys and values in the format \"key:value,key:value,...\"\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$returnString\n\nString\n\nThe corresponding value matching the $keyString parameter.\n\n\n\n\n\nStringParse\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS StringParse": {
  "prefix": "StringParse",
  "body": [
   "$$returnString=StringParse($$StringToParse,$$firstString,$$secondString);"
  ],
  "description": "\n\nThis function returns a portion of a string that exists between two delimiting strings.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$StringToParse\n\nString\n\nThe string to be parsed.\n\n\n\n$firstString\n\nString\n\nThe opening delimiter string.\n\n\n\n$secondString\n\nString\n\nThe closing delimiting string.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$returnString\n\nString\n\nThe portion of the input string occurring between the two delimiting strings.\n\n\n\n\n\nExample:\n\n\n\n\n\n// Find the word(s) between two specified words.\n\n$testString = \"The quick brown fox jumps over the lazy stream.\";\n\n$firstString = \"brown \";\n\n$secondString = \" jumps\";\n\n\n\n// Find the text between the two delimiters.\n\n$returnString = StringParse($testString, $firstString, $secondString);\n\n\n\n// $returnString now contains \"fox\".\n\n\n\n\n\nStringParseToBoolean\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS StringParseToBoolean": {
  "prefix": "StringParseToBoolean",
  "body": [
   "$$boolResult=StringParseToBoolean($$stringToCheck);"
  ],
  "description": "\n\nParses the start of a string to see if it gives an indication of a boolean value. White space characters at the start of the string are ignored. If the first character of the string is \"T\", \"t\", \"Y\", \"y\", or\"1\" the result returned will be True. All other characters will return False.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$stringToCheck\n\nString\n\nThe string to parse.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$boolResult\n\nBoolean\n\nWhether the first non-white-space character was T, t, Y, y or 1.\n\n\n\n\n\nExample:\n\n\n\n\n\n$checkStr = \" true\";\n\n$result = StringParseToBoolean($checkStr);\n\n// The return boolean will be True.\n\n\n\n\n\nStringParseToFloat\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS StringParseToFloat": {
  "prefix": "StringParseToFloat",
  "body": [
   "$$MyFloat=StringParseToFloat($$InputString);"
  ],
  "description": "\n\nThis functions converts a string in a numeric format to an floating point variable type. If the string is not in a valid format which can be parsed to a floating point variable type successfully, the function returns a failing result.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InputString\n\nString\n\nThe numeric string to be converted to an floating point.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$MyFloat\n\nFloat\n\nThe resulting float from the string conversion.\n\n\n\n\n\nUsage Example:\n\n$MyFloat = StringParseToFloat($MyString)\n\n\n\n\n\n//Output\n\nStringParseToFloat: [19239.232] Was Successfully Converted to a Float [19239.232]\n\n\n\n\n\nStringParseToInteger\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS StringParseToInteger": {
  "prefix": "StringParseToInteger",
  "body": [
   "$$MyInteger=StringParseToInteger($$InputString);"
  ],
  "description": "\n\nThis functions converts a string in a numeric format to an integer variable type. If the string is not in a valid format which can be parsed to an integer successfully, the function returns a failing result.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InputString\n\nString\n\nThe numeric string to be converted to an integer.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$MyInteger\n\nInteger\n\nThe resulting integer from the string conversion.\n\n\n\n\n\nUsage Example:\n\n\n\n\n\n$MyInt = StringParseToInteger($MyString);\n\n\n\n\n\n//Output\n\nStringParseToInteger: [0012345] Was Successfully Converted to an Integer [12345]\n\n\n\n\n\nStringRemoveVT100Codes\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS StringRemoveVT100Codes": {
  "prefix": "StringRemoveVT100Codes",
  "body": [
   "$$resultString=StringRemoveVT100Codes($$inputString);"
  ],
  "description": "\n\nThis function removes the ANSI / VT100 control codes from a string.\n\n\n\nRemarks:\n\n\u00b7 The code removes the ANSI / VT100 control codes only. Some of the codes for specific keys on the terminal are not removed.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$inputString\n\nStrinf\n\nThe string that will have the control codes removed.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$resultString\n\nString\n\nThe input string with all of the control codes removed.\n\n\n\n\n\nExample:\n\n$resultString = StringRemoveVT100Codes($inputString);\n\n\n\n\n\nStringReplace\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS StringReplace": {
  "prefix": "StringReplace",
  "body": [
   "$$returnString=StringReplace($$inputString,$$findString,$$replaceString);"
  ],
  "description": "\n\nThis function finds all occurences of the $findString parameter in the $inputString parameter, and replaces them with the $replaceString.\n\n\n\n\n\nExample:\n\n$returnString = StringReplace(\"Every Good Boy Does Good.\",\"Good\",\"Bad\");\n\nAfter this operation $returnString will contain \"Every Bad Boy Does Bad.\".\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$inputString\n\nString\n\nThe input string on which to perform the find and replace operation.\n\n\n\n$findString\n\nString\n\nThe string to be located and replaced in the $inputString\n\n\n\n$replaceString\n\nString\n\nThe string to be substituted in place of the $findString.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$returnString\n\nString\n\nThe newly created string with the substrings replaced.\n\n\n\n\n\nStringReplaceHexByte\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS StringReplaceHexByte": {
  "prefix": "StringReplaceHexByte",
  "body": [
   "$$returnString=StringReplaceHexByte($$inputString,$$findHexValue,$$replaceHexValue);"
  ],
  "description": "\n\nThis function replaces all occurances of the $findHexValue with the $replaceHexValue parameter.\n\nExample:\n\n$Test = New(\"String\",\"This is a good string\");\n\n$Test = StringReplaceHexByte($Test,\"6F\",\"7A\");\n\nAfter this operation $rTest will contain \"This is a gzzd string\".\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$inputString\n\nString\n\nThe input string on which to perform the find and replace operation.\n\n\n\n$findHexValueString\n\nString\n\nAn 8-bit hexidecimal value\n\n\n\n$replaceHexValue\n\nString\n\nAn 8-bit hexidecimal value\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$returnString\n\nString\n\nThe newly created string with the substrings replaced.\n\n\n\n\n\nStringReplaceHexString\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS StringReplaceHexString": {
  "prefix": "StringReplaceHexString",
  "body": [
   "$$returnString=StringReplaceHexString($$inputString,$$findHexStringValue,$$replaceHexStringValue);"
  ],
  "description": "\n\nThis function replaces all occurances of the $findHexStringValue with the $replaceHexStringValue parameter.\n\nExample: $Test = StringReplaceHexByte(\"This is a good string\",\"67 6F 6F 64 \",\"62 61 64\");\n\nAfter this operation $Test will contain \"This is a bad string\".\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$inputString\n\nString\n\nThe input string on which to perform the find and replace operation.\n\n\n\n$findHexStringValue\n\nString\n\nA list of 8-bit hexidecimal values\n\n\n\n$replaceHexStringValue\n\nString\n\nA list of 8-bit hexidecimal value\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$returnString\n\nString\n\nThe newly created string with the substrings replaced.\n\n\n\n\n\nStringReverse\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS StringReverse": {
  "prefix": "StringReverse",
  "body": [
   "$$returnString=StringReverse($$stringToReverse);"
  ],
  "description": "\n\nThis function will reverse all the bytes in a string (first byte becomes the last byte and vice versa) and return the result.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$stringToReverse\n\nString\n\nThe string that will be reversed.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$returnString\n\nString\n\nA new string with all of the bytes in reverse order.\n\n\n\n\n\nExample:\n\n\n\n\n\n// Reverse a string.\n\n$str = \"This string will be reversed.\";\n\n\n\n\n\n$resultString = StringReverse($str);\n\n\n\n\n\nUpdateStatus($resultString);\n\n// Returns: \".desrever eb lliw gnirts sihT\".\n\n\n\n\n\nStringSplit\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS StringSplit": {
  "prefix": "StringSplit",
  "body": [
   "($$retVar1,$$retVar2,$$retVar3......)=StringSplit($$MainString,$$SplitCharacter,$$MaxReturnVariables);"
  ],
  "description": "\n\nThe StringSplit function returns a collection from the $MainString argument splitting the string on the occurrence of the $SplitCharacter. The maximum strings returned to the executive is determined by the $MaxReturnVariables argument.\n\n\n\nRemarks:\n\nIf $MaxReturnVariables is too small, then all of the last strings that should be split will be in the last returned string.\n\nIf $MaxReturnVariables is too large, an error will be generated and the script will be failed.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$MainString\n\nString\n\nThe string that is to be split.\n\n\n\n$SplitCharacter\n\nString\n\nThe character to split the string on. This must be a single character string.\n\n\n\n$MaxReturnVariables\n\nString\n\nThe maximum number of strings to be returned by the function.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$retVat1, ..., $retVarN\n\nString\n\nThe individual strings that $MainString was split into. There must be $MaxReturnVariables variables to return the strings in.\n\n\n\n\n\nExample:\n\n\n\n\n\n// Set up a string and split variables.\n\n$stringToSplit = \"Split this string on the spaces\";\n\n$splitChar = \" \";\n\n$numSplits = 6;\n\n\n\n// Split the string and output the return (formatted for ease of reading).\n\n($spl1, $spl2, $spl3, $spl4, $spl5, $spl6) = StringSplit($stringToSplit, $splitChar, $numSplits);\n\n\n\n$outString = \"The split string returned:\";\n\n$outString = $outString + \"\\r\\n\\t\" + $spl1;\n\n$outString = $outString + \"\\r\\n\\t\" + $spl2;\n\n$outString = $outString + \"\\r\\n\\t\" + $spl3;\n\n$outString = $outString + \"\\r\\n\\t\" + $spl4;\n\n$outString = $outString + \"\\r\\n\\t\" + $spl5;\n\n$outString = $outString + \"\\r\\n\\t\" + $spl6;\n\nUpdateStatus($outString);\n\n\n\n\n\nStringSplitToArray\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS StringSplitToArray": {
  "prefix": "StringSplitToArray",
  "body": [
   "$$MyArray=StringSplitToArray($$MainString,$$SplitCharacter,$$MaxReturnItems);"
  ],
  "description": "\n\nThe StringSplitToArray function returns a collection of from the $MainString argument splitting the string on the occurence of the $SplitCharacter. The maximum strings returned in the array is determined by the $MaxReturnItems argument. The returned strings are placed in a single dimensional array.\n\nExample\n\n$MyArray = StringSplitToArray(\"192.168.1.1\",\".\",4);\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$MainString\n\nString\n\nThe complete file path of the file to be read.\n\n\n\n$SplitCharacter\n\nString\n\nThe character to split the string on, this must be a single character string\n\n\n\n$MaxReturnItems\n\nInteger\n\nThe maximum number of strings to be placed in the array.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ReturnArray\n\nArray\n\nThe array is returned as a single dimensional array containing the number of strings returned from the split function\n\n\n\n\n\nStringStartsWith\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS StringStartsWith": {
  "prefix": "StringStartsWith",
  "body": [
   "$$Result=StringStartsWith($$String1,$$String2,$$IgnoreCase);"
  ],
  "description": "\n\nThe function will return true if the contents of $String1 starts with the string specified in $String2. The $IgnoreCase parameter allows the function to ignore differences in upper vs. lower case when doing the comparison operation.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$String1\n\nString\n\nThe primary string to search for the substring.\n\n\n\n$String2\n\nString\n\nThe string to search for at the beginning of the primary string\n\n\n\n$IgnoreCase\n\nBoolean\n\nSpecifies whether or not to ignore upper/lower case differences when making the comparison.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Result\n\nBoolean\n\nReturns a true/false value indicating whether or not $String2 was found at the beginning of $String1\n\n\n\n\n\nExample\n\n$Result = StringStartsWith(\"ABCDEF\",\"ABC\",true);\n\n\n\n\n\nStringSub\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS StringSub": {
  "prefix": "StringSub",
  "body": [
   "$$returnString=StringSub($$inputString,$$StartingPosition,$$Length);"
  ],
  "description": "\n\nReturns a substring of the InputString parameter, starting with the position specified by the $StartingPosition argument, up to the number of characters specified in the $Length argument. In the event that the input string length is less than the $Length argument, all of the remaining string will be returned.\n\nExample:\n\n$inputString = \"Every Good Boy Does Fine.\";\n\n$a = StringSub($inputString,3,5)\n\nAfter this operation, the return string $a will contain \"ry Go\".\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$InputString\n\nString\n\nThe String parameter to be searched.\n\n\n\n$StartingPosition\n\nInteger\n\nThe zero based position to begin the start of the substring.\n\n\n\n$Length\n\nInteger\n\nThe number of characters to be placed in the substring.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$returnString\n\nString\n\nThe resulting substring returned.\n\n\n\n\n\nStringToLower\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS StringToLower": {
  "prefix": "StringToLower",
  "body": [
   "$$output=StringToLower($$Input);"
  ],
  "description": "\n\nConverts all Alpha characters in a string to lower case. Function Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Input\n\nString\n\nThe String which is to be lower-cased.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Output\n\nString\n\nThe resultant lower-case string is returned.\n\n\n\n\n\nStringToTitle\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS StringToTitle": {
  "prefix": "StringToTitle",
  "body": [
   "$$newString=StringToTitle($$oldString);"
  ],
  "description": "\n\nThis function will convert the supplied string into Title Case (the first letter of every word will be capitalized).\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$oldString\n\nString\n\nThe string to change the case of.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$newString\n\nString\n\nThe string changed into Title Case.\n\n\n\n\n\nExample:\n\n// Change this string to Title Case.\n\n$oldString = \"this is the string to change the case of\";\n\n$newString = StringToTitle($$oldString);\n\n\n\n// This will return: \"This Is The String To Change The Case Of\"\n\n\n\n\n\nStringToUpper\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS StringToUpper": {
  "prefix": "StringToUpper",
  "body": [
   "$$output=StringToUpper($$Input);"
  ],
  "description": "\n\nConverts all Alpha characters in a string to upper case. Function Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Input\n\nString\n\nThe String which is to be uppercased.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Output\n\nString\n\nThe resultant upper-case string is returned.\n\n\n\n\n\nStringTrim\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS StringTrim": {
  "prefix": "StringTrim",
  "body": [
   "$$TrimmedString=StringTrim($$StringToTrim);"
  ],
  "description": "\n\nThe StringTrim function removes all the whitespace located at the front and end of a string.\n\nExample\n\n$TrimmedString = StringTrim(\" MY STRING \");\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$StringToTrim\n\nString\n\nThe string which contains white space to be removed\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$TrimmedString\n\nString\n\nThe returned string with the whitespace removed.\n\n\n\n\n\nStringTrimEnd\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS StringTrimEnd": {
  "prefix": "StringTrimEnd",
  "body": [
   "$$TrimmedString=StringTrimEnd($$StringToTrim);"
  ],
  "description": "\n\nThe StringTrimEnd function removes all the whitespace located at the end of a string.\n\nExample\n\n$TrimmedString = StringTrimEnd(\" MY STRING \");\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$StringToTrim\n\nString\n\nThe string which contains white space to be removed\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$TrimmedString\n\nString\n\nThe returned string with the whitespace removed.\n\n\n\n\n\nStringTrimStart\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS StringTrimStart": {
  "prefix": "StringTrimStart",
  "body": [
   "$$TrimmedString=StringTrimStart($$StringToTrim);"
  ],
  "description": "\n\nThe StringTrimStart function removes all the whitespace located at the front of a string.\n\nExample\n\n$TrimmedString = StringTrimStart(\" MY STRING \");\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$StringToTrim\n\nString\n\nThe string which contains white space to be removed\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$TrimmedString\n\nString\n\nThe returned string with the whitespace removed.\n\n\n\n\n\nClipboard_GetText\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Clipboard_GetText": {
  "prefix": "Clipboard_GetText",
  "body": [
   "$$cbText=Clipboard_GetText();"
  ],
  "description": "\n\nThis function will return text that is on the Windows System clipboard.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$cbText\n\nString\n\nThe string data that was on the Windows System clipboard.\n\n\n\n\n\nExample:\n\n// Get the text data\n\n$cbText = Clipboard_GetText();\n\n\n\n\n\nClipboard_SetText\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS Clipboard_SetText": {
  "prefix": "Clipboard_SetText",
  "body": [
   "Clipboard_SetText($$textToCopy);"
  ],
  "description": "\n\nThis function will place text on the Windows System clipboard.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$textToCopy\n\nString\n\nThe text to copy onto the Windows System clipboard.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n// Copy the text data\n\n$textToCopy = \"This goes on the clipboard\";\n\nClipboard_SetText($textToCopy);\n\n\n\n\n\nCMD_Close\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS CMD_Close": {
  "prefix": "CMD_Close",
  "body": [
   "CMD_Close($$cmdHandle);"
  ],
  "description": "\n\nThis function will close the command line window that was opened with CMD_OpenCMDProcess.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$cmdHandle\n\nObject\n\nA handle to the command line process that was opened with CMD_OpenCMDProcess.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n// Open a Window and Name it.\n\n$winName = \"Test Window\";\n\n$cmdHandle = CMD_OpenCMDProcess($winName);\n\n\n\n\n\n// Now close the window.\n\nCMD_Close($cmdHandle);\n\n\n\n\n\nCMD_OpenCMDProcess\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS CMD_OpenCMDProcess": {
  "prefix": "CMD_OpenCMDProcess",
  "body": [
   "$$cmdHandle=CMD_OpenCMDProcess($$windowName,$$showWindow);"
  ],
  "description": "\n\nThis function will open a command line process in a shown or hidden window and apply a name to that window (even if not visible, the window still needs a unique name).\n\n\n\n\n\nNote:\n\nCMD_OpenCMDProcess works differently from the CreateProcess function in that this function will open the command window and allow for reading Standard In and Standard Error without closing the process first. This is an asynchronous operation.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$windowName\n\nString\n\nA name to attach to the process window that opens.\n\n\n\n$showWindow\n\nBoolean\n\nWhether to show the command window. This parameter is optional. If omitted, the default will be FALSE.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$cmdHandle\n\nObject\n\nA handle to the command line process that is used to send text to this process or retrieve text from the process.\n\n\n\n\n\nExample:\n\n// Open a Process and Name it.\n\n$winName = \"Test Window\";\n\n$showWin = false;\n\n$cmdHandle = CMD_OpenCMDProcess($winName, $showWin);\n\n\n\n\n\nCMD_ReadStdErr\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS CMD_ReadStdErr": {
  "prefix": "CMD_ReadStdErr",
  "body": [
   "$$errText=CMD_ReadStdErr($$cmdHandle);"
  ],
  "description": "\n\nThis function will return all of the error text that was generated since the last time this function was called. This is the text that a command line process would normally send to StdErr.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$cmdHandle\n\nObject\n\nA handle to the command line process that was opened with CMD_OpenCMDProcess.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$errText\n\nString\n\nThe error text that was generated by this process since the last time this function was called.\n\n\n\n\n\nExample:\n\n// Open a Window and Name it.\n\n$winName = \"Test Window\";\n\n$cmdHandle = CMD_OpenCMDProcess($winName);\n\n\n\n\n\n$errText = CMD_ReadStdErr($cmdHandle);\n\n\n\n\n\nCMD_ReadStdOut\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS CMD_ReadStdOut": {
  "prefix": "CMD_ReadStdOut",
  "body": [
   "$$newText=CMD_ReadStdOut($$cmdHandle);"
  ],
  "description": "\n\nThis function will return all of the new text that was generated since the last time this function was called. This is the text that a command line process would normally send to StdOut.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$cmdHandle\n\nObject\n\nA handle to the command line process that was opened with CMD_OpenCMDProcess.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$newText\n\nString\n\nThe new text that was generated by this process since the last time this function was called.\n\n\n\n\n\nExample:\n\n// Open a Window and Name it.\n\n$winName = \"Test Window\";\n\n$cmdHandle = CMD_OpenCMDProcess($winName);\n\n\n\n\n\n$newText = CMD_ReadStdOut($cmdHandle);\n\n\n\n\n\nCMD_Write\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS CMD_Write": {
  "prefix": "CMD_Write",
  "body": [
   "CMD_Write($$cmdHandle,$$text);"
  ],
  "description": "\n\nThis function will write text to the command line process without appending an end-of-line. The text is sent to StdIn.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$cmdHandle\n\nObject\n\nA handle to the command line process that was opened with CMD_OpenCMDProcess.\n\n\n\n$text\n\nString\n\nText that will be sent to the command line process. No end-of-line will be appended.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n// Open a Window and Name it.\n\n$winName = \"Test Window\";\n\n$cmdHandle = CMD_OpenCMDProcess($winName);\n\n\n\n\n\n// Send the ping local command but don't press return yet.\n\n$text = \"ping 127.0.0.1\";\n\nCMD_Write($cmdHandle, $text);\n\n\n\n\n\nCMD_WriteLine\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS CMD_WriteLine": {
  "prefix": "CMD_WriteLine",
  "body": [
   "CMD_WriteLine($$cmdHandle,$$text);"
  ],
  "description": "\n\nThis function will write text to the command line process and append an end-of-line. The text is sent to StdIn.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$cmdHandle\n\nObject\n\nA handle to the command line process that was opened with CMD_OpenCMDProcess.\n\n\n\n$text\n\nString\n\nText that will be sent to the command line process. An end-of-line will be appended.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n// Open a Window and Name it.\n\n$winName = \"Test Window\";\n\n$cmdHandle = CMD_OpenCMDProcess($winName);\n\n\n\n\n\n// Send the ping local command and press return.\n\n$text = \"ping 127.0.0.1\";\n\nCMD_WriteLine($cmdHandle, $text);\n\n\n\n\n\nLPT_Port_Read\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS LPT_Port_Read": {
  "prefix": "LPT_Port_Read",
  "body": [
   "$$returnValue=LPT_Port_Read($$portNumber);"
  ],
  "description": "\n\nThis function returns a byte value representing an 8 bit value from the port specified in the function parameters.\n\nNote:\n\nThe original DriverLINX Port I/O Driver developed by Scientific Software Tools, Inc. has been replaced with InpOut32.DLL (renamed back to DLPORTIO.dll) which is compatible with 64-bit systems.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$portNumber\n\nInteger\n\nThe Port number to read from.\n\nValid ports:\n\n\u00b7 0 = address 0x378\n\n\u00b7 1 = address 0x3F8\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$returnValue\n\nInteger\n\nA value of the pattern read from the port specified in the function parameters.\n\n\n\n\n\nExample:\n\n$returnValue = LPT_Port_Read(0);\n\n\n\n\n\nLPT_Port_Set_Baseaddress\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS LPT_Port_Set_Baseaddress": {
  "prefix": "LPT_Port_Set_Baseaddress",
  "body": [
   "LPT_Port_Set_Baseaddress($$portBaseAddress,$$portData);"
  ],
  "description": "\n\nThis function writes one byte value to the port specified in the function parameters.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$portBaseAddress\n\nString\n\nThe Address of the port to write to, specified as a hexadecimal value, eg. \"FF\" for 255. Valid port ranges are 0x100 to 0x3FF.\n\n\n\n$portData\n\nString\n\nThe Data to be written to the port, specified as a hexadecimal byte, eg. \"FF\" for 255.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\nLPT_Port_Set_Baseaddress(\"1F\", \"1F\");\n\n\n\n\n\nLPT_Port_Write\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS LPT_Port_Write": {
  "prefix": "LPT_Port_Write",
  "body": [
   "LPT_Port_Write($$portNumber,$$portData);"
  ],
  "description": "\n\nThis function writes one byte value to the port specified in the function parameters.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$portNumber\n\nInteger\n\nThe Port number to read from.\n\nValid ports:\n\n\u00b7 0 = address 0x378\n\n\u00b7 1 = address 0x3F8\n\n\n\n$portData\n\nString\n\nThe Data to be written to the port, specified as a hexadecimal byte, eg. \"FF\" for 255.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$returnValue\n\nInteger\n\nA value of the pattern read from the status byte of port specified in the function parameters.\n\n\n\n\n\nExample:\n\nLPT_Port_Write(0, \"FE\", \"10\"); // Bit 0 is cleared & bit 4 is set\n\n\n\n\n\nLPT_Status_Read\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS LPT_Status_Read": {
  "prefix": "LPT_Status_Read",
  "body": [
   "$$returnValue=LPT_Status_Read($$portNumber);"
  ],
  "description": "\n\nThis function returns a byte value representing an 8 bit status value from the port specified in the function parameters.\n\nNote:\n\nThe original DriverLINX Port I/O Driver developed by Scientific Software Tools, Inc. has been replaced with InpOut32.DLL (renamed back to DLPORTIO.dll) which is compatible with 64-bit systems.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$portNumber\n\nInteger\n\nThe Port number to read from.\n\nValid ports:\n\n\u00b7 0 = address 0x379\n\n\u00b7 1 = address 0x3F9\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$returnValue\n\nInteger\n\nA value of the pattern read from the status byte of port specified in the function parameters.\n\n\n\n\n\nExample:\n\n$returnValue = LPT_Status_Read(0);\n\n\n\n\n\nCheckProcessIsRunning\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS CheckProcessIsRunning": {
  "prefix": "CheckProcessIsRunning",
  "body": [
   "$$Result=CheckProcessIsRunning($$Process);"
  ],
  "description": "\n\nThe CheckProcessIsRunning function checks to see if the supplied process name is currently executing on the PC.\n\nExample:\n\n$Result = CheckProcessIsRunning(\"iexplore\"); // Will Return True if Internet Explorer is Running.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Process\n\nString\n\nThe name of the process to check for it's running status\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Result\n\nBoolean\n\nReturns 'TRUE' if the process is running, returns 'FALSE' otherwise.\n\n\n\n\n\nCheckProcessIsRunningByHandle\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS CheckProcessIsRunningHandle": {
  "prefix": "CheckProcessIsRunningHandle",
  "body": [
   "$$Result=CheckProcessIsRunningHandle($$ProcessHandle);"
  ],
  "description": "\n\nThe CheckProcessIsRunningByHandle function checks to see if the supplied process handle is currently executing on the PC.\n\nExample:\n\n$Result = CheckProcessIsRunning($MyProcess); // Will Return True if the supplied process handle hasn't exited.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Process\n\nObject\n\nThe process handle to check to see if the given process has exited.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Result\n\nBoolean\n\nReturns 'TRUE' if the process is running, returns 'FALSE' otherwise.\n\n\n\n\n\nCreateProcess\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS CreateProcess": {
  "prefix": "CreateProcess",
  "body": [
   "$$Process=CreateProcess($$workingDirectory,$$program,$$programArguments,$$showWindow);"
  ],
  "description": "\n\nThe CreateProcesss function prepares a process for start, and returns a handle to the System.Process structure.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$workingDirectory\n\nString\n\nThe working directory for the executable you wish to run.\n\n\n\n$program\n\nString\n\nThe path and name of the executable to run.\n\n\n\n$programArguments\n\nString\n\nThe command line arguments to be passed to the external executable.\n\n\n\n$showWindow\n\nBoolean\n\nWhether the external process should be displayed in a shell window, or allowed to open another window on the desktop.\n\nValues:\n\n\u00b7 true - Shows the external process window\n\n\u00b7 false - Prevents any window from opening on the display\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Process\n\nObject\n\nThe handle to the Process Created\n\n\n\n\n\nExample:\n\n$Process = CreateProcess(\"c:\\\\directory\", \"c:\\\\directory\\\\myprogram.exe\", \"-v -p\", false);\n\n\n\n\n\n// The following script automates the windows diskpart.exe command line utility program\n\n$Process = CreateProcess(\"c:\\\\windows\\\\system32\", \"c:\\\\windows\\\\system32\\\\diskpart.exe\", \"\", true);\n\nRedirectProcessStdIn($Process);\n\nRedirectProcessStdOut($Process);\n\n$ExitCode = StartProcess($Process, false);\n\nSleep(3);\n\nWriteLineToProcessStdIn($Process, \"dir\\n\");\n\nSleep(1);\n\nWriteLineToProcessStdIn($Process, \"exit\\n\");\n\n$Output = ReadAllLinesFromProcessStdOut($Process);\n\nUpdateStatus($Output);\n\nEnd;\n\n\n\n\n\nKillProcess\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS KillProcess": {
  "prefix": "KillProcess",
  "body": [
   "KillProcess($$Process);"
  ],
  "description": "\n\nThe KillProcess functions kills an executing process that has been created with the CreateProcess function.\n\nExample:\n\nKillProcess($Process);\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Process\n\nObject\n\nThe handle of a process that has been created previously with the CreateProcess function.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nKillProcessByName\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS KillProcessByName": {
  "prefix": "KillProcessByName",
  "body": [
   "$$ProcessesKilled=KillProcessByName($$ProcessName);"
  ],
  "description": "\n\nThe KillProcessByName function will kill all the executing processes which match the current name. If more than one instance of a process exists, all the processes will be killed.\n\nExample:\n\n$ProcessCount = KillProcessByName($ProcessName);\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ProcessName\n\nString\n\nThe name of the process that you wish to kill.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ProcessesKilled\n\nInteger\n\nThe number of processes that were killed as a result of running this command.\n\n\n\n\n\nProcessWindowControlByHandle\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ProcessWindowControlByHandle": {
  "prefix": "ProcessWindowControlByHandle",
  "body": [
   "ProcessWindowControlByHandle($$ProcessHandle,$$windowControl);"
  ],
  "description": "\n\n\n\n\n\nThis function allows setting the state of the window for other processes or applications running on the same computer as Jabil Test. This is useful for minimizing or maximizing other GUI's that may be running as part of your test process.\n\n\n\n\n\nNotes:\n\nUses \u201cuser32.dll\u201d ShowWindow() function to control process windows.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ProcessHandle\n\nString\n\nProcess handled returned by the CreateProcess() function.\n\n\n\n$WindowControl\n\nInteger\n\nInteger representing WindowShowStyle enumeration:\n\n\n\n\n\n0. Hide - Hides the window and activates another window [SW_HIDE]\n\n1. ShowNormal - Activates and displays a window. If the window is minimized or maximized, the system restores it to its original size and position. An application should specify this flag when displaying the window for the first time [SW_SHOWNORMAL]\n\n2. ShowMinimized - Activates the window and displays it as a minimized window [SW_SHOWMINIMIZED]\n\n3. ShowMaximized - Activates the window and displays it as a maximized window [SW_SHOWMAXIMIZED]\n\n3. Maximize - Maximizes the specified window (same as ShowMaximized above) [SW_MAXIMIZE]\n\n4. ShowNormalNoActivate - Displays a window in its most recent size and position. This value is similar to \"ShowNormal\", except the window is not activated. [SW_SHOWNOACTIVATE]\n\n5. Show - Activates the window and displays it in its current size and position [SW_SHOW]\n\n6. Minimize - Minimizes the specified window and activates the next top-level window in the Z order. Also trims working set [SW_MINIMIZE]\n\n7. ShowMinNoActivate - Displays the window as a minimized window. This value is similar to \"ShowMinimized\", except the window is not activated [SW_SHOWMINNOACTIVE]\n\n8. ShowNoActivate - Displays the window in its current size and position. This value is similar to \"Show\", except the window is not activated [SW_SHOWNA]\n\n9. Restore - Activates and displays the window. If the window is minimized or maximized, the system restores it to its original size and position. An application should specify this flag when restoring a minimized window [SW_RESTORE]\n\n10. ShowDefault - Sets the show state based on the SW_ value specified in the STARTUPINFO structure passed to the CreateProcess function by the program that started the application [SW_SHOWDEFAULT]\n\n11. ForceMinimized - Windows 2000/XP: Minimizes a window, even if the thread that owns the window is hung. This flag should only be used when mimizing windows from a different thread [SW_FORCEMINIMIZE]\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nProcessWindowControlByName\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ProcessWindowControlByName": {
  "prefix": "ProcessWindowControlByName",
  "body": [
   "ProcessWindowControlByName($$processName,$$windowControl);"
  ],
  "description": "\n\n\n\n\n\nThis function allows setting the state of the window for other processes or applications running on the same computer as Jabil Test. This is useful for minimizing or maximizing other GUI's that may be running as part of your test process.\n\n\n\n\n\nNotes:\n\nUses \u201cuser32.dll\u201d ShowWindow() function to control process windows.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ProcessName\n\nString\n\nThe name of the process (as shown in the task manager window)\n\n\n\n$WindowControl\n\nInteger\n\nInteger representing WindowShowStyle enumeration:\n\n\n\n\n\n0. Hide - Hides the window and activates another window [SW_HIDE]\n\n1. ShowNormal - Activates and displays a window. If the window is minimized or maximized, the system restores it to its original size and position. An application should specify this flag when displaying the window for the first time [SW_SHOWNORMAL]\n\n2. ShowMinimized - Activates the window and displays it as a minimized window [SW_SHOWMINIMIZED]\n\n3. ShowMaximized - Activates the window and displays it as a maximized window [SW_SHOWMAXIMIZED]\n\n3. Maximize - Maximizes the specified window (same as ShowMaximized above) [SW_MAXIMIZE]\n\n4. ShowNormalNoActivate - Displays a window in its most recent size and position. This value is similar to \"ShowNormal\", except the window is not activated. [SW_SHOWNOACTIVATE]\n\n5. Show - Activates the window and displays it in its current size and position [SW_SHOW]\n\n6. Minimize - Minimizes the specified window and activates the next top-level window in the Z order. Also trims working set [SW_MINIMIZE]\n\n7. ShowMinNoActivate - Displays the window as a minimized window. This value is similar to \"ShowMinimized\", except the window is not activated [SW_SHOWMINNOACTIVE]\n\n8. ShowNoActivate - Displays the window in its current size and position. This value is similar to \"Show\", except the window is not activated [SW_SHOWNA]\n\n9. Restore - Activates and displays the window. If the window is minimized or maximized, the system restores it to its original size and position. An application should specify this flag when restoring a minimized window [SW_RESTORE]\n\n10. ShowDefault - Sets the show state based on the SW_ value specified in the STARTUPINFO structure passed to the CreateProcess function by the program that started the application [SW_SHOWDEFAULT]\n\n11. ForceMinimized - Windows 2000/XP: Minimizes a window, even if the thread that owns the window is hung. This flag should only be used when mimizing windows from a different thread [SW_FORCEMINIMIZE]\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nReadAllLinesFromProcessStdError\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ReadAllLinesFromProcessStdError": {
  "prefix": "ReadAllLinesFromProcessStdError",
  "body": [
   "$$Result=ReadAllLinesFromProcessStdError($$Process);"
  ],
  "description": "\n\nReads the entire contents of the process's standard error buffer.\n\nNote:\n\nBefore using this function, the standard output of the process must first be redirected using the RedirectProcessStdErr script function.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Process\n\nObject\n\nThe handle of a process that has been created previously with the CreateProcess function.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Result\n\nString\n\nReturns all lines of text from process' standard error.\n\n\n\n\n\nUsage Example:\n\n\n\n\n\n// The following script automates the windows diskpart.exe command line utility program\n\n\n\n\n\n$Process = CreateProcess(\"c:\\\\windows\\\\system32\", \"c:\\\\windows\\\\system32\\\\diskpart.exe\", \"\", true);\n\nRedirectProcessStdIn($Process);\n\nRedirectProcessStdErr($Process);\n\n$ExitCode = StartProcess($Process, false);\n\nSleep(3);\n\nWriteLineToProcessStdIn($Process, \"dir\\n\");\n\nSleep(1);\n\nWriteLineToProcessStdIn($Process, \"exit\\n\");\n\n$Output = ReadAllLinesFromProcessStdError($Process);\n\nUpdateStatus($Output);\n\nEnd;\n\n\n\n\n\nReadAllLinesFromProcessStdOut\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ReadAllLinesFromProcessStdOut": {
  "prefix": "ReadAllLinesFromProcessStdOut",
  "body": [
   "$$Result=ReadAllLinesFromProcessStdOut($$Process);"
  ],
  "description": "\n\nReads the entire contents of the process's standard output buffer.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Process\n\nObject\n\nThe handle of a process that has been created previously with the CreateProcess function.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Result\n\nString\n\nReturns all lines of text from process's standard output.\n\n\n\n\n\nUsage Example:\n\n\n\n\n\n// The following script automates the windows diskpart.exe command line utility program\n\n\n\n\n\n$Process = CreateProcess(\"c:\\\\windows\\\\system32\",\"diskpart.exe\",\"\",true);\n\nRedirectProcessStdIn($Process);\n\nRedirectProcessStdOut($Process);\n\n$ExitCode = StartProcess($Process, false);\n\nSleep(3);\n\nWriteLineToProcessStdIn($Process,\"dir\\n\");\n\nSleep(1);\n\nWriteLineToProcessStdIn($Process,\"exit\\n\");\n\n$Output = ReadAllLinesFromProcessStdOut($Process);\n\nUpdateStatus($Output);\n\nEnd;\n\n\n\n\n\nReadLineFromProcessStdError\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ReadLineFromProcessStdError": {
  "prefix": "ReadLineFromProcessStdError",
  "body": [
   "$$Result=ReadLineFromProcessStdError($$Process);"
  ],
  "description": "\n\nReads a line from the process's standard error buffer.\n\n\n\n\n\nRemarks:\n\nThe process must already have been created using the CreateProcess function.\n\nBefore using this function, the standard error of the process must first be redirected using the RedirectProcessStdErr function.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Process\n\nObject\n\nThe handle of a process that was created previously.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Result\n\nString\n\nOne text line from the process's standard error output.\n\n\n\n\n\nExample:\n\n\n\n\n\n// The following script automates the windows diskpart.exe command line utility program.\n\n$working = \"c:\\\\windows\\\\system32\";\n\n$prog = \"c:\\\\windows\\\\system32\\\\diskpart.exe\";\n\n$args = \"\";\n\n$show = false;\n\n$wait = false;\n\n$dirCom = \"dir\\n\";\n\n$exitCom = \"exit\\n\";\n\n\n\n$process = CreateProcess($working, $prog, $args, $show);\n\nRedirectProcessStdIn($process);\n\nRedirectProcessStdErr($process);\n\n\n\n$exitCode = StartProcess($process, $wait);\n\nSleep(3)\n\nWriteLineToProcessStdIn($process, $dirCom);\n\nSleep(1)\n\nWriteLineToProcessStdIn($process, $exitCom);\n\n\n\n// Get the first line from the stderr of the process.\n\n$errString = ReadLineFromProcessStdError($process);\n\nUpdateStatus($errString);\n\n\n\n\n\nReadLineFromProcessStdOut\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ReadLineFromProcessStdOut": {
  "prefix": "ReadLineFromProcessStdOut",
  "body": [
   "$$Result=ReadLineFromProcessStdOut($$Process);"
  ],
  "description": "\n\nReads a line from the process's standard output buffer.\n\n\n\n\n\nRemarks:\n\nThe process must already have been created using the CreateProcess function.\n\nBefore using this function, the standard output of the process must first be redirected using the RedirectProcessStdOut function.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Process\n\nObject\n\nThe handle of a process that was created previously.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Result\n\nString\n\nOne text line from the process's standard output.\n\n\n\n\n\nExample:\n\n\n\n\n\n// The following script automates the windows diskpart.exe command line utility program.\n\n$working = \"c:\\\\windows\\\\system32\";\n\n$prog = \"c:\\\\windows\\\\system32\\\\diskpart.exe\";\n\n$args = \"\";\n\n$show = false;\n\n$wait = false;\n\n$dirCom = \"dir\\n\";\n\n$exitCom = \"exit\\n\";\n\n\n\n$process = CreateProcess($working, $prog, $args, $show);\n\nRedirectProcessStdIn($process);\n\nRedirectProcessStdErr($process);\n\n\n\n$exitCode = StartProcess($process, $wait);\n\nSleep(3)\n\nWriteLineToProcessStdIn($process, $dirCom);\n\nSleep(1)\n\nWriteLineToProcessStdIn($process, $exitCom);\n\n\n\n// Get the first line from the stdout of the process.\n\n$outString = ReadLineFromProcessStdOut($process);\n\nUpdateStatus($outString);\n\n\n\n\n\nRedirectProcessStdErr\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS RedirectProcessStdErr": {
  "prefix": "RedirectProcessStdErr",
  "body": [
   "RedirectProcessStdErr($$Process);"
  ],
  "description": "\n\nRedirects the process standard error to a buffer in the Process object.\n\nExample:\n\nRedirectProcessStdErr($Process);\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Process\n\nObject\n\nThe handle of a process that has been created previously with the CreateProcess function.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nUsage Example:\n\n\n\n\n\n// The following script automates the windows diskpart.exe command line utility program\n\n\n\n\n\n$Process = CreateProcess(\"c:\\\\windows\\\\system32\",\"diskpart.exe\",\"\", true);\n\nRedirectProcessStdIn($Process);\n\nRedirectProcessStdOut($Process);\n\n$ExitCode = StartProcess($Process, false);\n\nSleep(3);\n\nWriteLineToProcessStdIn($Process,\"dir\\n\");\n\nSleep(1);\n\nWriteLineToProcessStdIn($Process,\"exit\\n\");\n\n$Output = ReadAllLinesFromProcessStdOut($Process);\n\nUpdateStatus($Output);\n\nEnd;\n\n\n\n\n\nRedirectProcessStdIn\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS RedirectProcessStdIn": {
  "prefix": "RedirectProcessStdIn",
  "body": [
   "RedirectProcessStdIn($$Process);"
  ],
  "description": "\n\nRedirects the process standard input to a buffer in the Process object.\n\nExample:\n\nRedirectProcessStdIn($Process);\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Process\n\nObject\n\nThe handle of a process that has been created previously with the CreateProcess function.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nUsage Example:\n\n\n\n\n\n// The following script automates the windows diskpart.exe command line utility program\n\n\n\n\n\n$Process = CreateProcess(\"c:\\\\windows\\\\system32\",\"diskpart.exe\",\"\", true);\n\nRedirectProcessStdIn($Process);\n\nRedirectProcessStdOut($Process);\n\n$ExitCode = StartProcess($Process, false);\n\nSleep(3);\n\nWriteLineToProcessStdIn($Process,\"dir\\n\");\n\nSleep(1);\n\nWriteLineToProcessStdIn($Process,\"exit\\n\");\n\n$Output = ReadAllLinesFromProcessStdOut($Process);\n\nUpdateStatus($Output);\n\nEnd;\n\n\n\n\n\nRedirectProcessStdOut\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS RedirectProcessStdOut": {
  "prefix": "RedirectProcessStdOut",
  "body": [
   "RedirectProcessStdOut($$Process);"
  ],
  "description": "\n\nRedirects the process standard output to a buffer in the Process object.\n\nImportant Note: There is a maximum buffer size on the process standard output pipe, and if your program sends large amounts of information out to the standard output, or is a long running process, you will need to periodically read lines from the standard output to prevent the process from dead-locking. As an alternative, you can use the new function StartProcessCaptureStandardOutputUntilExit which automatically polls the process for output while waiting for the external process to complete.\n\nExample:\n\nRedirectProcessStdOut($Process);\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Process\n\nObject\n\nThe handle of a process that has been created previously with the CreateProcess function.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nUsage Example:\n\n\n\n\n\n// The following script automates the windows diskpart.exe command line utility program\n\n\n\n\n\n$Process = CreateProcess(\"c:\\\\windows\\\\system32\",\"diskpart.exe\",\"\", true);\n\nRedirectProcessStdIn($Process);\n\nRedirectProcessStdOut($Process);\n\n$ExitCode = StartProcess($Process, false);\n\nSleep(3);\n\nWriteLineToProcessStdIn($Process,\"dir\\n\");\n\nSleep(1);\n\nWriteLineToProcessStdIn($Process,\"exit\\n\");\n\n$Output = ReadAllLinesFromProcessStdOut($Process);\n\nUpdateStatus($Output);\n\nEnd;\n\n\n\n\n\nSafelyRemoveDriveByLetter\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SafelyRemoveDriveByLetter": {
  "prefix": "SafelyRemoveDriveByLetter",
  "body": [
   "SafelyRemoveDriveByLetter($$DriveLetter,$$WindowsNotification);"
  ],
  "description": "\n\nThis function ejects a removable disk present on your system. The function checks if the drive is a removable disk device.\n\n\n\nRemarks:\n\n\u00b7 This function is tested with a USB memory stick.\n\n\u00b7 The function won't eject the drive when it's not removable.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$DriveLetter\n\nString\n\nThis parameter represents the drive letter to be ejected.\n\n\n\n$WindowsNotification\n\nBoolean\n\nPass true to allow the Windows shell to display any related UI element.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n\n\nExample:\n\nSafelyRemoveDriveByLetter(\"E:\", true);\n\n\n\n\n\nSafelyRemoveDriveByLetter(\"E:\\\\\", true);\n\n\n\n\n\nSafelyRemoveDriveByLetter(\"E:/\", true);\n\n\n\n\n\nSetProcessWindowToForeground\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SetProcessWindowToForeground": {
  "prefix": "SetProcessWindowToForeground",
  "body": [
   "SetProcessWindowToForeground($$processName);"
  ],
  "description": "\n\n\n\n\n\nThis function is used to set the current foreground window on a visual process running on the test computer. Note, that if a window is minimized, that it first must be changed to an visible state using the ProcessWindowControlByName function.\n\n\n\n\n\nIf the named process is not currently running, the function will generate a failure. The process can be started using the StartProcess or SystemCall command if necessary.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ProcessName\n\nString\n\nThe name of the process (as shown in the task manager window)\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nUsage Example:\n\n\n\n\n\n// Toggles back and forth between a running notepad process and Jabil Test\n\n\n\n\n\nSetProcessWindowToForeground(\"notepad\");\n\nSleep(1);\n\nSetProcessWindowToForeground(\"jabiltest\");\n\nSleep(1);\n\nSetProcessWindowToForeground(\"notepad\");\n\nSleep(1);\n\nSetProcessWindowToForeground(\"jabiltest\");\n\nSleep(1);\n\nSetProcessWindowToForeground(\"notepad\");\n\n\n\n\n\nStartProcess\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS StartProcess": {
  "prefix": "StartProcess",
  "body": [
   "$$ExitCode=StartProcess($$Process,$$WaitForExit);"
  ],
  "description": "\n\nThe StartProcess functions starts a process that has been created with the CreateProcess function. The $WaitForExit argument controls whether or not the test execution will block and wait for the process to exit, or to continue on in parallel with the executing process. If the WaitForExit variable has been set to TRUE, then the function also returns the errorcode of the process that has terminated.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Process\n\nObject\n\nThe handle of a process that has been created with the CreateProcess function.\n\n\n\n$WaitForExit\n\nBoolean\n\nSpecifies whether or not the script should continue execution, or should block and wait for the process to finish.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ExitCode\n\nInteger\n\nThe exit code of the terminating process. NOTE: The exit code is only returned if $WaitForExit was set to true. Otherwise, no return value is passed to the script.\n\n\n\n\n\nExample:\n\n$ExitCode = StartProcess($Process, true);\n\n\n\n\n\n// The following script automates the windows diskpart.exe command line utility program\n\n\n\n\n\n$Process = CreateProcess(\"c:\\\\windows\\\\system32\", \"diskpart.exe\", \"\", true);\n\nRedirectProcessStdIn($Process);\n\nRedirectProcessStdOut($Process);\n\n$ExitCode = StartProcess($Process, false);\n\nSleep(3);\n\nWriteLineToProcessStdIn($Process, \"dir\\n\");\n\nSleep(1);\n\nWriteLineToProcessStdIn($Process, \"exit\\n\");\n\n$Output = ReadAllLinesFromProcessStdOut($Process);\n\nUpdateStatus($Output);\n\nEnd;\n\n\n\n\n\nStartProcessCaptureStandardErrorUntilExit\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS StartProcessCaptureAllStandardErrorUntilExit": {
  "prefix": "StartProcessCaptureAllStandardErrorUntilExit",
  "body": [
   "($$ExitCode,$$OutputString)=StartProcessCaptureAllStandardErrorUntilExit($$Process);"
  ],
  "description": "\n\n\n\n\n\nThis function executes the supplied process, and waits for it to exit. During the execution of the process, all standard error is captured and returned as a single string variable.\n\n\n\n\n\nThis function is useful for capturing the output of a long running process which doesn't require any input from the operator or the test executive.\n\n\n\n\n\nNote:\n\nBefore using this function, the standard output of the process must first be redirected using the RedirectProcessStdErr script function.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Process\n\nObject\n\nThe handle of a process that was created previously with the CreateProcess function.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ExitCode\n\nInteger\n\nThe exit code of the process as returned by the execution shell.\n\n\n\n$OutputString\n\nString\n\nThe entire standard error of the process during execution.\n\n\n\n\n\nUsage Example:\n\n\n\n\n\n$Process = CreateProcess(\"c:\\\\\", \"c:\\\\myConsoleApp.exe\", \"\", true);\n\nRedirectProcessStdIn($Process);\n\nRedirectProcessStdErr($Process);\n\n($ExitCode, $BigString) = StartProcessCaptureAllStandardErrorUntilExit($Process);\n\nUpdateStatus($BigString);\n\nEnd;\n\n\n\n\n\nStartProcessCaptureStandardOutputUntilExit\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS StartProcessCaptureAllStandardOutputUntilExit": {
  "prefix": "StartProcessCaptureAllStandardOutputUntilExit",
  "body": [
   "($$ExitCode,$$OutputString)=StartProcessCaptureAllStandardOutputUntilExit($$Process);"
  ],
  "description": "\n\n\n\n\n\nThis function executes the supplied process, and waits for it to exit. During the execution of the process, all standard output is captured and returned as a single string variable.\n\n\n\n\n\nThis function is useful for capturing the output of a long running process which doesn't require any input from the operator or the test executive.\n\n\n\n\n\nNote:\n\nBefore using this function, the standard output of the process must first be redirected using the RedirectProcessStdOut script function.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Process\n\nObject\n\nThe handle of a process that was created previously with the CreateProcess function.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ExitCode\n\nInteger\n\nThe exit code of the process as returned by the execution shell.\n\n\n\n$OutputString\n\nString\n\nThe entire standard output of the process during execution.\n\n\n\n\n\nUsage Example:\n\n\n\n\n\n$Process = CreateProcess(\"c:\\\\\", \"c:\\\\myConsoleApp.exe\", \"\", true);\n\nRedirectProcessStdIn($Process);\n\nRedirectProcessStdOut($Process);\n\n($ExitCode, $BigString) = StartProcessCaptureAllStandardOutputUntilExit($Process);\n\nUpdateStatus($BigString);\n\nEnd;\n\n\n\n\n\nSystemCall\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SystemCall": {
  "prefix": "SystemCall",
  "body": [
   "SystemCall($$workingDirectory,$$program,$$programArguments,$$waitForExit,$$showWindow);"
  ],
  "description": "\n\nThe SystemCall function is used to spawn an external process from the test executive. The function will always return a PASS result, unless the external process to run can't be found.\n\nExample:\n\nSystemCall(\"c:\\\\directory\",\"myprogram.exe\",\"-v -p\",\"TRUE\",\"FALSE\");\n\nThis function will spawn the myprogram.exe executable contained in the c:\\directory passing it the arguments '-v -p'. The test executive will wait for the process to finish before continuing, and no window will be displayed on the GUI.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$workingDirectory\n\nString\n\nThe working directory for the executable you wish to run.\n\n\n\n$program\n\nString\n\nThe name of the executable to run\n\n\n\n$programArguments\n\nString\n\nThe command line arguments to be passed to the external executable.\n\n\n\n$waitFor\n\nString\n\nA boolean string indicating whether the test executive should wait for the external process to exit before continuing on with the script execution, or whether the executive should continue to run in parallel with the external process. Supported values are:\n\n\"TRUE\" - Waits for the process to finish\n\n\"FALSE\" - Continues with the rest of the test without waiting for the external process to finish\n\n\n\n$showWindow\n\nString\n\nA boolean string indicating whether the external process should be displayed in a shell window, or allowed to open another window on the desktop. Supported values are:\n\n\"TRUE\" - Shows the external process window\n\n\"FALSE\" - Prevents any window from opening on the display.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nWriteLineToProcessStdIn\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS WriteLineToProcessStdIn": {
  "prefix": "WriteLineToProcessStdIn",
  "body": [
   "WriteLineToProcessStdIn($$Process,$$Text);"
  ],
  "description": "\n\nWrites a text line to the process's standard input buffer.\n\nExample:\n\nWriteLineToProcessStdIn($Process);\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Process\n\nObject\n\nThe handle of a process that has been created previously with the CreateProcess function.\n\n\n\n$Text\n\nString\n\nText line to write to the process's standard input.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nUsage Example:\n\n\n\n\n\n// The following script automates the windows diskpart.exe command line utility program\n\n\n\n\n\n$Process = CreateProcess(\"c:\\\\windows\\\\system32\",\"diskpart.exe\",\"\", true);\n\nRedirectProcessStdIn($Process);\n\nRedirectProcessStdOut($Process);\n\n$ExitCode = StartProcess($Process, false);\n\nSleep(3);\n\nWriteLineToProcessStdIn($Process,\"dir\\n\");\n\nSleep(1);\n\nWriteLineToProcessStdIn($Process,\"exit\\n\");\n\n$Output = ReadAllLinesFromProcessStdOut($Process);\n\nUpdateStatus($Output);\n\nEnd;\n\n\n\n\n\nRegistryCheckKeyExists\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS RegistryCheckKeyExists": {
  "prefix": "RegistryCheckKeyExists",
  "body": [
   "$$KeyExists=RegistryCheckKeyExists($$RegistryRootKey,$$RegistrySubKey,$$RegistryKeyName);"
  ],
  "description": "\n\n\n\n\n\nThis function checks to see if the specified registry key exists. If the key is present in the registry, the function returns true, otherwise false is returned.\n\n\n\n\n\nIf the registry could be successfully opened, the function will generate a passing result.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$RegistryRootKey\n\nString\n\nThe name of the base registry key. Allowable values are:\n\n\u00b7 \"ClassesRoot\"\n\n\u00b7 \"CurrentConfig\"\n\n\u00b7 \"CurrentUser\"\n\n\u00b7 \"LocalMachine\"\n\n\n\n\n\n$RegistrySubKey\n\nString\n\nThe name of the registry subkey which contains the key to be edited\n\n\n\n$RegistryKeyName\n\nString\n\nThe name of the registry key to be modified\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$KeyExists\n\nBoolean\n\nA boolean indicating whether or not the key was found in the registry,\n\n\n\n\n\nExamples:\n\n$KeyExists = RegistryCheckKeyExists(\"LocalMachine\",\"Software\\\\MySubKey\",\"MyKey\")\n\n\n\n\n\nRegistryCreateSubKey\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS RegistryCreateSubKey": {
  "prefix": "RegistryCreateSubKey",
  "body": [
   "RegistryCreateSubKey($$RegistryRootKey,$$RegistryKeyName);"
  ],
  "description": "\n\n\n\n\n\nThis function creates the registry sub key under the specified Registry Root Key. The user must have sufficient privileges to write to the specified registry location or the function will generate a failure if the key cannot be written.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$RegistryRootKey\n\nString\n\nThe name of the base registry key. Allowable values are:\n\n\u00b7 \"ClassesRoot\"\n\n\u00b7 \"CurrentConfig\"\n\n\u00b7 \"CurrentUser\"\n\n\u00b7 \"LocalMachine\"\n\n\n\n\n\n$RegistryKeyName\n\nString\n\nThe name of the registry subkey to create\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\nRegistryCreateSubKey(\"LocalMachine\",\"Software\\\\MySubKey\\\\\");\n\n\n\n\n\nRegistryDeleteSubKey\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS RegistryDeleteSubKey": {
  "prefix": "RegistryDeleteSubKey",
  "body": [
   "RegistryDeleteSubKey($$Root,$$KeyName);"
  ],
  "description": "\n\nThis function is used to delete the specified item type from the registry. Function Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Root\n\nString\n\nThe Root Key, allowed values are:\n\n\u00b7 \"ClassesRoot\"\n\n\u00b7 \"CurrentConfig\"\n\n\u00b7 \"CurrentUser\"\n\n\u00b7 \"LocalMachine\"\n\n\n\n$KeyName\n\nString\n\nThe element in the registry to be deleted\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nRegistryDeleteSubKeyTree\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS RegistryDeleteSubKeyTree": {
  "prefix": "RegistryDeleteSubKeyTree",
  "body": [
   "RegistryDeleteSubKeyTree($$Root,$$KeyName);"
  ],
  "description": "\n\nThis function is used to delete the specified item type from the registry. Function Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Root\n\nString\n\nThe Root Key, allowed values are:\n\n\u00b7 \"ClassesRoot\"\n\n\u00b7 \"CurrentConfig\"\n\n\u00b7 \"CurrentUser\"\n\n\u00b7 \"LocalMachine\"\n\n\n\n$KeyName\n\nString\n\nThe element in the registry to be deleted\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nRegistryDeleteValue\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS RegistryDeleteValue": {
  "prefix": "RegistryDeleteValue",
  "body": [
   "RegistryDeleteValue($$Root,$$KeyName);"
  ],
  "description": "\n\nThis function is used to delete the specified item type from the registry.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Root\n\nString\n\nThe Root Key, allowed values are:\n\n\u00b7 \"ClassesRoot\"\n\n\u00b7 \"CurrentConfig\"\n\n\u00b7 \"CurrentUser\"\n\n\u00b7 \"LocalMachine\"\n\n\n\n$KeyName\n\nString\n\nThe element in the registry to be deleted\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nRegistryGetKeyValue\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS RegistryGetKeyValue": {
  "prefix": "RegistryGetKeyValue",
  "body": [
   "$$RegistryValue=RegistryGetKeyValue($$RegistryRootKey,$$RegistrySubKey,$$RegistryKeyName);"
  ],
  "description": "\n\n\n\n\n\nThis function retrieves the value of the requested registry key. Regardless of the key value type, the value is always returned as a string which can be parsed to the desired value type.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$RegistryRootKey\n\nString\n\nThe name of the base registry key. Allowable values are:\n\n\u00b7 \"ClassesRoot\"\n\n\u00b7 \"CurrentConfig\"\n\n\u00b7 \"CurrentUser\"\n\n\u00b7 \"LocalMachine\"\n\n\n\n\n\n$RegistrySubKey\n\nString\n\nThe name of the registry subkey which contains the key to be edited\n\n\n\n$RegistryKeyName\n\nString\n\nThe name of the registry key to be modified\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$RegistryValue\n\nString\n\nThe value of the requested registry key\n\n\n\n\n\nExamples:\n\n$RegistryValue = RegistryGetKeyValue(\"LocalMachine\",\"Software\\\\MySubKey\",\"MyKey\")\n\n\n\n\n\nRegistryGetSubKeyNames\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS RegistryGetSubKeyNames": {
  "prefix": "RegistryGetSubKeyNames",
  "body": [
   "$$subKeyNames=RegistryGetSubKeyNames($$rootKey,$$keyName);"
  ],
  "description": "\n\nThis function will return the list of sub-keys included in the specified key or sub-key.\n\n\n\n\n\nRemarks:\n\nThe function returns the list of sub-keys, not the list of values that are in the specified location. For the list of values, use the RegistryGetValueNames function.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$rootKey\n\nString\n\nThe name of the base registry key. Valid values are:\n\n\u00b7 ClassesRoot\n\n\u00b7 CurrentConfig\n\n\u00b7 CurrentUser\n\n\u00b7 LocalMachine\n\n\n\n$keyName\n\nString\n\nThe name of the key or sub-key to return the list of sub-keys from.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$subKeyNames\n\nArray\n\nThe list of all of the sub-keys in the specified location. If there are no sub-keys, this will be empty.\n\n\n\n\n\nExample:\n\n// Get the list of Video subkeys from the HKey_LocalMachine entry.\n\n$rootKey = \"LocalMachine\";\n\n$location = \"SYSTEM\\CurrentControlSet\\Control\\Video\";\n\n\n\n\n\n$subKeyList = RegistryGetSubKeyNames($rootKey, $location);\n\n\n\n\n\n// Print the list of sub-keys.\n\n$numKeys = ArrayGetLength($subKeyList);\n\n\n\n\n\n$loopCount = 0;\n\nwhile ($loopCount < $numKeys)\n\n{\n\n$oneKey = Array1DGetValue($subKeyList, $loopCount);\n\nUpdateStatus($oneKey);\n\n$loopCount = $loopCount + 1;\n\n}\n\n\n\n\n\nRegistryGetValueNames\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS RegistryGetValueNames": {
  "prefix": "RegistryGetValueNames",
  "body": [
   "$$valueNames=RegistryGetValueNames($$rootKey,$$keyName);"
  ],
  "description": "\n\nThis function will return the list of names of values included in the specified key or sub-key.\n\n\n\n\n\nRemarks:\n\nThe function returns the list of value names, not the list of sub-keys that are in the specified location. For the list of sub-keys, use the RegistryGetSubKeyNames function.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$rootKey\n\nString\n\nThe name of the base registry key. Valid values are:\n\n\u00b7 ClassesRoot\n\n\u00b7 CurrentConfig\n\n\u00b7 CurrentUser\n\n\u00b7 LocalMachine\n\n\n\n$keyName\n\nString\n\nThe name of the key or sub-key to return the list of value names from.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$valueNames\n\nArray\n\nThe list of the names of all of the values in the specified location. If there are no values, this will be empty.\n\n\n\n\n\nExample:\n\n// Get the list of Video value names from the HKey_LocalMachine entry.\n\n$rootKey = \"LocalMachine\";\n\n$location = \"SYSTEM\\CurrentControlSet\\Control\\Video\";\n\n\n\n\n\n$valueList = RegistryGetValueNames($rootKey, $location);\n\n\n\n\n\n// Print the list of value names.\n\n$numVals = ArrayGetLength($valueList);\n\n\n\n\n\n$loopCount = 0;\n\nwhile ($loopCount < $numVals)\n\n{\n\n$oneName = Array1DGetValue($valueList, $loopCount);\n\nUpdateStatus($oneName);\n\n$loopCount = $loopCount + 1;\n\n}\n\n\n\n\n\nRegistrySetKeyValue\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS RegistrySetKeyValue": {
  "prefix": "RegistrySetKeyValue",
  "body": [
   "RegistrySetKeyValue($$RegistryRootKey,$$RegistrySubKey,$$RegistryKeyName,$$RegistryKeyValueType,$$KeyValue);"
  ],
  "description": "\n\n\n\n\n\nThis function writes a new value to an existing or new key under the given sub-key. The user must have sufficient privileges to write to the specified registry location or the function will generate a failure if the key cannot be written.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$RegistryRootKey\n\nString\n\nThe name of the base registry key. Allowable values are:\n\n\u00b7 \"ClassesRoot\"\n\n\u00b7 \"CurrentConfig\"\n\n\u00b7 \"CurrentUser\"\n\n\u00b7 \"LocalMachine\"\n\n\n\n\n\n$RegistrySubKey\n\nString\n\nThe name of the registry subkey which contains the key to be edited\n\n\n\n$RegistryKeyName\n\nString\n\nThe name of the registry key to be modified\n\n\n\n$RegistryKeyValueType\n\nString\n\nThe type of registry value to be set. Allowable Values are:\n\n\u00b7 \"BINARY\"\n\n\u00b7 \"DWORD\"\n\n\u00b7 \"EXPANDSTRING\"\n\n\u00b7 \"MULTISTRING\"\n\n\u00b7 \"STRING\"\n\n\n\n$KeyValue\n\nVarious\n\n\u00b7 The desired value for the key. Supported values types are booleans, floats, integers, or strings.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExamples:\n\nRegistrySetKeyValue(\"LocalMachine\",Software\\\\MySubKey\",\"MyKey\",\"String\",\"Hello World\");\n\n\n\n\n\nCheckDriveWriteProtected\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS CheckDriveWriteProtected": {
  "prefix": "CheckDriveWriteProtected",
  "body": [
   "$$BooleanReturnValue=CheckDriveWriteProtected($$DriveLetterString,$$ExpectedProtection,$$FailJabilTest);"
  ],
  "description": "\n\nThis function tests if a given drive ($DriveLetterString) is write protected.\n\n\n\nResult:\n\nThe result $BooleanReturnValuevalue is TRUE if the drive is write protected.\n\nThe result $BooleanReturnValuevalue is FALSE if the drive is NOT write protected.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$DriveLetter\n\nString\n\nThe drive letter string where we want to test the write protection.\n\n\n\n$ExpectedProtection\n\nBoolean\n\nIf we expect the drive to be write protected, place \"TRUE\". If we expect the drive to be NOT write protected place \"FALSE\"\n\n\n\n$FailJabilTest\n\nBoolean\n\nFail Jabil Test if the $ExpectedProtection of the drive is different then the return value.\n\nIf we place \"FALSE\" then the $ExpectedProtection is ignored.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ReturnValue\n\nBoolean\n\nThe result True or False if we can write data to the drive\n\n\n\n\n\nExample:\n\n\n\nVariable 1 : Here we test if the C:\\ drive is write protected or not.\n\nVariable 2 : We expect it is write protected\n\nVariable 3 : Jabil Test will not fail, the previous variable is ignored\n\n$bResult = CheckDriveWriteProtected(\"c:\\\\\",\"TRUE\",\"FALSE\");\n\n\n\n\n\nGetDiskSpace\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS GetDiskSpace": {
  "prefix": "GetDiskSpace",
  "body": [
   "($$TotalSpace,$$FreeSpace)=GetDiskSpace($$DriveLetter);"
  ],
  "description": "\n\nThis function returns the total number of bytes, and the total number of free bytes that are available on the drive specified by $DriveLetter\n\nExample:\n\n($TotalSpace,$FreeSpace) = GetDiskSpace(\"C:\");\n\n\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$DriveLetter\n\nString\n\nA string containing the drive letter\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$TotalSpace\n\nInteger\n\nThe total number of bytes available on the drive specified.\n\n\n\n$FreeSpace\n\nInteger\n\nThe total number of free bytes available on the drive specified.\n\n\n\n\n\nGetDisplayInformation\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS GetDisplayInformation": {
  "prefix": "GetDisplayInformation",
  "body": [
   "($$number,$$names,$$horiz,$$vert,$$BPP)=GetDisplayInformation();"
  ],
  "description": "\n\nThis function gets the number of displays attached to the computer and returns the names, resolutions and bits per pixel for each monitor.\n\n\n\n\n\nRemarks:\n\nThe data is returned in separate arrays, but they all correspond (for example, the first monitor has its data stored in the first element of the $names, $horiz, $vert and $BPP arrays).\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$number\n\nInteger\n\nThe number of displays in the system.\n\n\n\n$names\n\nString Array\n\nThe name of each of the displays.\n\n\n\n$horiz\n\nInteger Array\n\nThe horizontal resolution of each of the displays.\n\n\n\n$vert\n\nInteger Array\n\nThe vertical resolution of each of the displays.\n\n\n\n$BPP\n\nInteger Array\n\nThe bits per pixel of each of the displays.\n\n\n\n\n\nExample:\n\n// Get the list of displays\n\n($num, $dispNames, $dispX, $dispY, $dispBpp) = GetDisplayInformation();\n\n\n\n\n\n// Print out the list of displays.\n\n$outStr = \"\\nNumber of Displays: \" + $num;\n\nUpdateStatus($outStr);\n\n\n\n\n\n$outStr = \"\\nName\\t\\tHoriz\\tVert\\tBPP\";\n\nUpdateStatus($outStr);\n\n\n\n\n\n$loopCount = 0;\n\nwhile ($loopCount < $num)\n\n{\n\n// Get this display's data.\n\n$dName = Array1DGetValue($dispNames, $loopCount);\n\n$dX = Array1DGetValue($dispX, $loopCount);\n\n$dY = Array1DGetValue($dispY, $loopCount);\n\n$dBpp = Array1DGetValue($dispBpp, $loopCount);\n\n\n\n\n\n$outStr = $dName + \"\\t\" + $dX + \"\\t\" + $dY + \"\\t\" + $dBpp;\n\nUpdateStatus($outStr);\n\n\n\n\n\n$loopCount = $loopCount + 1;\n\n}\n\n\n\n\n\nGetDisplaySize\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS GetDisplaySize": {
  "prefix": "GetDisplaySize",
  "body": [
   "($$width,$$height)=GetDisplaySize($$DisplayNumber);"
  ],
  "description": "\n\nReturns the size of the display specified by $DisplayNumber in pixels. The primary display is always display number 0. In the event that a display number is supplied to the function that does not exist on the system, an error is returned to the script interpreter.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$DisplayNumber\n\nInteger\n\nThe ID of the display whose size you wish to retrieve\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$width\n\nInteger\n\nThe number of pixels making up the width of the display.\n\n\n\n$height\n\nInteger\n\nThe number of pixels making up the height of the display.\n\n\n\n\n\nGetDriveLetterByVolumeName\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS GetDriveLetterByVolumeName": {
  "prefix": "GetDriveLetterByVolumeName",
  "body": [
   "$$DriveLetter=GetDriveLetterByVolumeName($$DriveVolumeName,$$TimeOut,$$FailTest);"
  ],
  "description": "\n\nThis function returns the drive letter for the corresponding drive volume name.\n\n\n\nResult:\n\nThe corresponding drive letter.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$DriveVolumeName\n\nString\n\nThe volume name where we want the corresponding drive letter of.\n\n\n\n$TimeOut\n\nFloat\n\nThe timeout in milliseconds of the function.\n\nIf we enter 0 there is no timeout.\n\n\n\n$FailTest\n\nBoolean\n\nChoose if the script must fail if the corresponding drive letter is not found or a timeout occured.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$DriveLetter\n\nString\n\nThe drive letter for the specified volume name.\n\n\n\n\n\nExample:\n\n$DriveLetter = GetDriveLetterByVolumeName(\"Local Drive\",\"0\",\"FALSE\");\n\n$DriveLetter will have as content \"C:\\\"\n\n\n\n\n\nGetListOfDrives\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS GetListOfDrives": {
  "prefix": "GetListOfDrives",
  "body": [
   "$$driveArray=GetListOfDrives();"
  ],
  "description": "\n\nThis function gets a list of the drives connected to the computer and returns them in an array of strings.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$driveArray\n\nString Array\n\nThe list of drives connected to the computer.\n\n\n\n\n\nExample:\n\n// Get the list of drives\n\n$driveArray = GetListOfDrives();\n\n\n\n\n\n// Print out the list of drives.\n\n$loopCount = 0;\n\n$numDrives = ArrayGetDimensionSize($driveArray, 0);\n\n\n\n\n\nwhile ($loopCount < $numDrives)\n\n{\n\n$drv = Array1DGetValue($driveArray, $loopCount);\n\nUpdateStatus($drv);\n\n$loopCount = $loopCount + 1;\n\n}\n\n\n\n\n\nGetPciDeviceList\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS GetPciDeviceList": {
  "prefix": "GetPciDeviceList",
  "body": [
   "($$number,$$VIDs,$$PIDs,$$descripts)=GetPciDeviceList();"
  ],
  "description": "\n\nThis function gets the number of PCI devices attached to the computer and returns the Vendor ID, Product ID and description of each device.\n\n\n\n\n\nRemarks:\n\nThe data is returned in separate arrays, but they all correspond (for example, the first PCI device has its data stored in the first element of the $VIDs, $PIDs and $descripts arrays).\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$number\n\nInteger\n\nThe number of PCI devices in the system.\n\n\n\n$VIDs\n\nString Array\n\nThe Vendor IDs of each of the PCI devices.\n\n\n\n$PIDs\n\nString Array\n\nThe Product IDs of each of the PCI devices.\n\n\n\n$descripts\n\nString Array\n\nThe description of each of the PCI devices.\n\n\n\n\n\nExample:\n\n// Get the list of PCI devices\n\n($num, $VIDs, $PIDs, $descripts) = GetPciDeviceList();\n\n\n\n\n\n// Print out the list of PCI devices.\n\n$outStr = \"\\nNumber of Devices: \" + $num;\n\nUpdateStatus($outStr);\n\n\n\n\n\n// Print column header.\n\n$outStr = \"\\nVID\\tPID\\tDescription\";\n\nUpdateStatus($outStr);\n\n\n\n\n\n$loopCount = 0;\n\nwhile ($loopCount < $num)\n\n{\n\n// Get this device's data.\n\n$dVID = Array1DGetValue($VIDs, $loopCount);\n\n$dPID = Array1DGetValue($PIDs, $loopCount);\n\n$dDesc = Array1DGetValue($descripts, $loopCount);\n\n\n\n\n\n$outStr = $dVID + \"\\t\" + $dPID + \"\\t\" + $dDesc;\n\nUpdateStatus($outStr);\n\n\n\n\n\n$loopCount = $loopCount + 1;\n\n}\n\n\n\n\n\nGetSystemName\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS GetSystemName": {
  "prefix": "GetSystemName",
  "body": [
   "$$Name=GetSystemName();"
  ],
  "description": "\n\nReturns the DNS name of the current computer.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Name\n\nString\n\nThe network name of the current computer running Jabil Test.\n\n\n\n\n\nGetUserName\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS GetUserName": {
  "prefix": "GetUserName",
  "body": [
   "$$Name=GetUserName();"
  ],
  "description": "\n\nReturns the current Windows user name of the account logged into the system.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Name\n\nString\n\nThe current windows user name of the account logged into the system, including the domain prefix (e.g. \"JABIL/framed\")\n\n\n\n\n\nGetVolumeLabel\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS GetVolumeLabel": {
  "prefix": "GetVolumeLabel",
  "body": [
   "$$volumeLabel=GetVolumeLabel($$driveLetter);"
  ],
  "description": "\n\nReturns the volume label for the corresponding drive letter/drive name.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$driveLetter\n\nString\n\nDrive name (see DriveInfo.VolumeLabel property of System.IO namespace for details.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$volumeLabel\n\nString\n\nVolume label name of selected drive.\n\n\n\n\n\nExample:\n\n\n\n\n\n$volumeLabel = GetVolumeLabel(\u201cC\u201d);\n\nUpdateStatus($volumeLabel);\n\n\n\n\n\nOutput:\n\nLocal Drive\n\n\n\n\n\nGetWirelessNetworks\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS System.GetWirelessNetworks": {
  "prefix": "System.GetWirelessNetworks",
  "body": [
   "$$ReturnString=System.GetWirelessNetworks();"
  ],
  "description": "\n\nThis function returns a string containing the names and signal strength of all publicly available 802.11a/b/g wireless networks in the range of the test station that are broadcasting their SSID's. In the event that the test computer is not equipped with an 802.11 network adapter, and error is returned to the test script interpreter.\n\nThe return string is formatted as follows:\n\nNetwork1Name:SignalStrength;Network2Name:SignalStrength\n\nThe Signal Strength is the RSSI as reported by WMI. If no wireless networks are available, an empty string is returned.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ReturnString\n\nString\n\nThe names and signal strengths of each available wireless access point.\n\n\n\n\n\nSaveScreenCaptureToFile\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SaveScreenCaptureToFile": {
  "prefix": "SaveScreenCaptureToFile",
  "body": [
   "SaveScreenCaptureToFile($$FileName);"
  ],
  "description": "\n\nThis function captures the screen and saves it to an image file with the specified file name.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$FileName\n\nString\n\nThe file name to save the screen capture image as.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample: \n\n\n\nSaveScreenCaptureToFile(\"C:\\\\screenCapture.bmp\");\n\n\n\n\n\nClearExtendedPanelControls\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS ClearExtendedPanelControls": {
  "prefix": "ClearExtendedPanelControls",
  "body": [
   "ClearExtendedPanelControls();"
  ],
  "description": "\n\n\n\n\n\nThis function removes any extended panel controls that have been added to the extended cell panel.\n\n\n\n\n\nNote: these controls are not automatically disposed, they are only removed from the extended display panel.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nUsage Example:\n\n\n\n\n\nClearExtendedPanelControls();\n\n\n\n\n\nGetExtendedPanelMode\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS GetExtendedPanelMode": {
  "prefix": "GetExtendedPanelMode",
  "body": [
   "$$PanelMode=GetExtendedPanelMode();"
  ],
  "description": "\n\n\n\n\n\nThis function returns the current extended panel of the test cell. The panel mode is returned as a string.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$PanelMode\n\nString\n\nReturns the current panel mode of the test cell. Current possible values include:\n\n\u00b7 None\n\n\u00b7 Charting\n\n\u00b7 Empty\n\n\n\n\n\nUsage Example:\n\n\n\n\n\n$PanelMode = GetExtendedPanelMode();\n\nUpdateStatus($PanelMode);\n\n\n\n\n\nSetExtendedPanelMode\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SetExtendedPanelMode": {
  "prefix": "SetExtendedPanelMode",
  "body": [
   "SetExtendedPanelMode($$PanelMode);"
  ],
  "description": "\n\n\n\n\n\nThis function sets the current extended panel mode of the test cell.\n\n\n\n\n\nNote: The panel mode is set for the current script execution only and has no effect on the persistent configuration settings of the test cell.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$PanelMode\n\nString\n\nSets the current panel mode of the test cell. Current possible values include:\n\n\u00b7 \"NONE\"\n\n\u00b7 \"CHARTING\"\n\n\u00b7 \"EMPTY\"\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nUsage Example:\n\n\n\n\n\nSetExtendedPanelMode(\"CHARTING\");\n\n\n\n\n\nSetExtendedPanelSliderPosition\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SetExtendedPanelSliderPosition": {
  "prefix": "SetExtendedPanelSliderPosition",
  "body": [
   "SetExtendedPanelSliderPosition($$SliderPosition);"
  ],
  "description": "\n\n\n\n\n\nThis function moves the vertical slider control between the standard test cell display and the extended panel display for the given test cell. The $SliderPosition is specified in number of pixels from the left side of the test cell window.\n\n\n\n\n\nWhen the Extended Panel Slider Position is modified both the standard test cell\n\n\n\n\n\nImportant Note: In order to use the SetExtendedPanelSliderPosition you must be running Jabil Test in an extended panel mode such as \"Empty\" or \"None\"\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$SliderPosition\n\nInteger\n\nThe number of pixels from the left side of the test cell to set the slider position.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nUsage Example:\n\n\n\n\n\nSetExtendedPanelSliderPosition(500);\n\n\n\n\n\nCastVariable\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS CastVariable": {
  "prefix": "CastVariable",
  "body": [
   "$$NewVariable=CastVariable($$CastType,$$Variable);"
  ],
  "description": "\n\n\n\n\n\nThis function will cast the supplied variable to the type specified by the $CastType parameter. If the variable can't be successfully cast to the type specified, an error will be thrown by the function.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$CastType\n\nString\n\nA string specifying the desired variable cast target. Allowable values are:\n\n\u00b7 \"String\"\n\n\u00b7 \"Bool\"\n\n\u00b7 \"Integer\"\n\n\u00b7 \"Float\"\n\n\n\n$Variable\n\nObject\n\nThe variable to be cast to the desired value type.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$NewVariable\n\nBool,Float,Integer,String\n\nThe returned value type.\n\n\n\n\n\nExample:\n\n\n\n\n\n$MyString = \"3.0\";\n\n$MyInt = 3.0000;\n\n$MyFloat = 3.14159;\n\n$MyBool =\"true\";\n\n\n\n\n\n$VariableType = GetVariableType($MyBool);\n\n$OutputVariable = CastVariable(\"String\",$MyString);\n\n$VariableType = GetVariableType($OutputVariable);\n\n$OutputVariable = CastVariable(\"Integer\",$MyInt);\n\n$VariableType = GetVariableType($OutputVariable);\n\nUpdateStatus($MyInt);\n\n$VariableType = GetVariableType($MyInt);\n\nUpdateStatus($OutputVariable);\n\n$OutputVariable = CastVariable(\"Float\",$MyFloat);\n\n$VariableType = GetVariableType($OutputVariable);\n\n\n\n\n\nCheckPersistentVariableExists\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS CheckPersistentVariableExists": {
  "prefix": "CheckPersistentVariableExists",
  "body": [
   "$$Exists=CheckPersistentVariableExists($$VariableScope,$$VariableName);"
  ],
  "description": "\n\n\n\n\n\nThis function checks to see if a given variable name exists in the specified scope. The Persistent Variable functions save Jabil Test variables values into the built-in Jabil Test database so that they can be retrieved by subsequent test executions.\n\n\n\n\n\nNote:\n\n\n\n\n\nThe persistent variables are stored inside of the Jabil Test SQL Compact database (JabilTest.sdf) inside of the table named 'persistentVariables'.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$VariableScope\n\nString\n\nThe Scope of the variable that you would like to check for presence in the Persistent Variable Space. It is possible for a CELL-scoped variable and a GLOBAL-scoped variable to have the same name, but contain different values.\n\nValid values for variable scope are:\n\n\"CELL\" = A variable that can only be accessed from the cell that created it.\n\n\"GLOBAL\" = A variable that can be accessed from all cell\n\n\n\n$VariableName\n\nString\n\nThe name of the variable that you would like to check for presence in the Persistent Variable Space\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Exists\n\nBoolean\n\nReturns a boolean variable specifying whether or not the given variable was found to exist inside of the persistent variable space.\n\n\n\n\n\nCheckVariableExists\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS CheckVariableExists": {
  "prefix": "CheckVariableExists",
  "body": [
   "$$Exists=CheckVariableExists($$VariableName);"
  ],
  "description": "\n\n\n\n\n\nThis function checks to see if a present variable exists within the variable space in the currently executing script. Returns true if the value is found in the variable space, or otherwise returns false.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$VariableName\n\nString\n\nThe name of the variable that you would like to check to see if it's present in memory.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Exists\n\nBoolean\n\nReturns a boolean variable specifying whether or not the given variable was found to exist in memory.\n\n\n\n\n\nExample:\n\n\n\n\n\n$Exists = CheckVariableExists(\"MyVariable\");\n\nUpdateStatus($Exists);\n\n$MyVariable = \"Some Important Value\";\n\n$Exists = CheckVariableExists(\"MyVariable\");\n\nUpdateStatus($Exists);\n\n\n\n\n\nOutput Example:\n\n\n\n\n\nCheckVariableExists: Variable [MyVariable] Exists = [False]\n\nFalse\n\n$MyVariable = \"Some Important Value\";\n\nCheckVariableExists: Variable [MyVariable] Exists = [True]\n\nTrue\n\n\n\n\n\nCopyVariable\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS CopyVariable": {
  "prefix": "CopyVariable",
  "body": [
   "$$NewVariable=CopyVariable($$ObjectVariable);"
  ],
  "description": "\n\nThis function is used to copy the variable contents to a new variable.\n\nFunction Arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ObjectVariable\n\nVarious\n\nThe variable for which you wish to make a copy. The variable type can be any string, number, boolean, or object variable.\n\n\n\n\n\nReturn Parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$ReturnVariable\n\nVarious\n\nThe returned variable is a \"Copy Of Reference\" copy of the argument variable. The two variables actually refer to the same script variable, but can be accessed by the two different names.\n\n\n\n\n\nDeletePersistentVariable\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS DeletePersistentVariable": {
  "prefix": "DeletePersistentVariable",
  "body": [
   "DeletePersistentVariable($$VariableScope,$$VariableName);"
  ],
  "description": "\n\n\n\n\n\nThis function deletes the named variable from the persistent variable space, if it exists. If the variable doesn't exist, the function returns a passing result as well.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$VariableScope\n\nString\n\nThe scope of the variable to delete. Variables with the same name are allowed to exist at different scopes. In other words, a cell scoped variable may have the same name as a global scoped variable. Allowable values are:\n\n\u00b7 \"CELL\"\n\n\u00b7 \"GLOBAL\"\n\n\n\n$VariableName\n\nString\n\nThe name of the variable that you would like to delete from persistent variable storage.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n\n\n\n\nDeletePersistentVariable(\"GLOBAL\",\"CalibrationTime\");\n\n\n\n\n\nGetPersistentVariable\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS GetPersistentVariable": {
  "prefix": "GetPersistentVariable",
  "body": [
   "$$returnValue=GetPersistentVariable($$variableScope,$$variableName);"
  ],
  "description": "\n\nThis function is used to pull a permanent script variable into the test script for usage.\n\n\n\n\n\nRemarks:\n\nThe permanent variable must first have been created using the SetPersistentVariable function.\n\nPersistent Variables in Jabil Test are non-volatile and continue to exist between different test runs.\n\nThe scope of a persistent variable can be set \"CELL\" meaning that the variable is only visible to the test cell that created it, or \"GLOBAL\" which means that all test cells can access the variable for reading and writing.\n\nIt is possible for a CELL-scoped variable and a GLOBAL-scoped variable to have the same name.\n\nAll persistent variables are permanently stored in an encrypted file.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$variableScope\n\nString\n\nThe Scope of the variable to retrieve.\n\nValid values for scope are: \"CELL\" = Can only be accessed from the cell that created it.\n\n\"GLOBAL\" = Can be accessed by all cells.\n\n\n\n\n\n$variableName\n\nString\n\nThe name of the variable to retrieve.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$returnValue\n\nBoolean, Float, Integer, or String\n\nThe value of the variable retrieved. Type will match the type when the variable was created.\n\n\n\n\n\nExample:\n\n\n\n\n\n// Retrieve the last serial number used in this cell.\n\n$varScope = \"CELL\";\n\n$varName = \"LastSN\";\n\n\n\n$varValue = GetPersistentVariable($varScope, $varName);\n\n\n\n\n\nGetVariableType\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS GetVariableType": {
  "prefix": "GetVariableType",
  "body": [
   "$$VariableType=GetVariableType($$Variable);"
  ],
  "description": "\n\n\n\n\n\nThis function returns the variable type of the variable that has been passed in as the argument to the function. This can be helpful for debugging scripts which use variables returned from dynamic statement evaluation.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Variable\n\nVarious\n\nThe variable to be analyzed for it's type.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$VariableType\n\nString\n\nReturns a string specifying the type of the variable supplied to the function. Possible Variable Types include:\n\n\u00b7 Integer\n\n\u00b7 String\n\n\u00b7 Float\n\n\u00b7 Boolean\n\n\u00b7 Object\n\n\u00b7 Array\n\n\n\n\n\nExamples:\n\n\n\n\n\n$VarType = GetVariableType($MyString);\n\nUpdateStatus($VartType); // returns 'String'\n\n\n\n\n\nGetVariableType(12);\n\nGetVariableType(\"DAN\");\n\nGetVariableType(12.22);\n\nGetVariableType(true);\n\n// Output\n\nGetVariableType: Variable Is Of Type [Integer]\n\nGetVariableType: Variable Is Of Type [String]\n\nGetVariableType: Variable Is Of Type [Float]\n\nGetVariableType: Variable Is Of Type [Boolean]\n\n\n\n\n\nIsEqual\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS IsEqual": {
  "prefix": "IsEqual",
  "body": [
   "$$equal=IsEqual($$Variable1,$$Variable2);"
  ],
  "description": "\n\n\n\n\n\nThis function compares two variables and determines their equality. It is useful for comparing object type variables, which is currently unsupported by the '==' operator in scripts.\n\n\n\n\n\nFor value type variables (integers, floats, string, booleans) the value of the variables is compared, and true is returned if the values are the same.\n\n\n\n\n\nFor arrays and other object type variables, true is only returned if the two variables reference the same object in memory.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$Variable1\n\nObject\n\nThe first variable to be compared. Can be of any type (integer, float, boolean, string, array, object).\n\n\n\n$Variable2\n\nObject\n\nThe second variable to be compared. Can be of any type (integer, float, boolean, string, array, object).\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$equal\n\nBoolean\n\nTrue if the variables are equal, false otherwise. The conditions for equality vary by the type of the input arguments.\n\n\n\n\n\nExample:\n\n\n\n\n\n$StringObject1 = \"Hello world!\";\n\n$StringObject2 = New(\"String\", \"Hello world!\");\n\n$equal = IsEqual($StringObject1 ,$StringObject2 ); //returns true\n\n\n\n\n\n$ArrayObject1 = Array1DCreate(\"INTEGER\", 1);\n\n$ArrayObject2 = Array1DCreate(\"INTEGER\", 1); //different object\n\n$ArrayObject3 = CopyVariable($ArrayObject1); //copy by reference\n\n$ArrayObject4 = $ArrayObject1; //doesn't work, assigns string equal to type name\n\n$equal = IsEqual($Object1, $Object2); //returns false\n\n$equal = IsEqual($Object1, $Object3); //returns true\n\n$equal = IsEqual($Object1, $Object4); //returns false\n\n\n\n\n\nNew\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS New": {
  "prefix": "New",
  "body": [
   "$$newVariable=New($$variableType,$$variableValue);"
  ],
  "description": "\n\nThis function will create and return an instance of a new variable of the specified type with the specified initial value.\n\n\n\n\n\nRemarks:\n\nWhen setting a boolean, the initial value must be in string format and either \"TRUE\" or \"FALSE\".\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$variableType\n\nString\n\nThe type of variable to create. Valid values are:\n\nBoolean\n\nInteger\n\nFloat\n\nString\n\n\n\n$variableValue\n\nBoolean, Float, Integer or String\n\nThe initial value to set the variable to.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$newVariable\n\nBoolean, Float, Integer or String\n\nThe variable that has been created.\n\n\n\n\n\nExample:\n\n\n\n\n\n// Create an explicit float variable.\n\n$varType = \"Float\";\n\n$varVal = 3.0; // Without New, this would set as an integer.\n\n\n\n$floatVar = New($varType, $varVal);\n\n\n\n\n\nSetPersistentVariable\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS SetPersistentVariable": {
  "prefix": "SetPersistentVariable",
  "body": [
   "SetPersistentVariable($$VariableScope,$$VariableName,$$VariableType,$$VariableValue);"
  ],
  "description": "\n\nThe SetPersistentVariable function is used to store a permanent script variable into the Persistent Variable Space. The permanent variable may be retrieved using the GetPersistentVariable function.\n\nPersistent Variables in Jabil Test are non-volatile and continue to exist between different test runs. The scope of a persistent variable can be set \"CELL\" meaning that the variable is only visible to the test cell that created it, or \"GLOBAL\" which means that all test cells can access the variable for reading and writing. All persistent variables are permanently stored in the Jabil Test database file.\n\nNote:\n\nThe persistent variables are stored inside of the Jabil Test SQL Compact database (JabilTest.sdf) inside of the table named 'persistentVariables'.\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$VariableScope\n\nString\n\nThe Scope of the variable that will be stored in the Persistent Variable Space. It is possible for a CELL-scoped variable and a GLOBAL-scoped variable to have the same name.\n\nValues:\n\n\u00b7 \"CELL\" = A variable that can only be accessed from the cell that created it.\n\n\u00b7 \"GLOBAL\" = A variable that can be accessed from all cells.\n\n\n\n$VariableName\n\nString\n\nThe name of the variable that you would like to store in the Persistent Variable Space.\n\n\n\n$VariableType\n\nString\n\nThe type of variable to store.\n\nValues:\n\n\u00b7 \"BOOLEAN\"\n\n\u00b7 \"INTEGER\"\n\n\u00b7 \"FLOAT\"\n\n\u00b7 \"STRING\"\n\n\n\n$VariableValue\n\nBoolean, Integer, Float or String\n\nThe value of the variable to store.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n$VariableScope = \"CELL\";\n\n$VariableName = \"SavedVariable\";\n\n$VariableType = \"STRING\";\n\nSetPersistentVariable($VariableScope, $VariableName, $VariableType, \"Saved Data\");\n\n\n\n\n\nWMI_ClassMethod\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS WMI_ClassMethod": {
  "prefix": "WMI_ClassMethod",
  "body": [
   "$$methodResultsTable=WMI_ClassMethod($$machinePath,$$username,$$password,$$className,$$methodName,$$inParams,$$outParams);"
  ],
  "description": "\n\nExecutes the named function of a given WMI (Windows Management Instrumentation) class \u2013 does not require an instance of the class as returned by a WQL query. The results of the method are returned in a DataTable object with (# of output parameters) columns and (# of objects) rows.\n\n\n\n\n\nSee Microsoft\u2019s WMI Reference page for a list of classes, methods, parameters, and return value tables.\n\n\n\n\n\nNote:\n\nDCOM must be enabled and WMI installed on both the host and target machines.\n\n\n\n\n\nThe account used must have WMI permissions set. Check \"Computer Management > Services and Applications > WMI Control\" and right-click Properties. Navigate to the Security tab and select Root, then click the Security button to check permissions.\n\n\n\n\n\nFirewalls must be setup to allow RPC (Remote Procedure Call) and remote computer management.\n\n\n\n\n\nRemote connections may require changes to the local security policy on the target machine. Use \"Administrative Tools > Local Security Policy\" or \"Run > secpol.msc\" to access the security settings.\n\n\n\n\n\nFor remote logins, navigate to \"Security Settings > Local Policies > Security Options\" and ensure \"Network access: Sharing and security model for local accounts\" is set to \"Classic - local users authenticate as themselves\".\n\n\n\n\n\nFor remote logins with no password, ensure \"Accounts: Limit local account use of blank passwords to console logon only\" is disabled. For security reasons, Microsoft does NOT recommend disabling this setting - use an account with a password if possible.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$machinePath\n\nString\n\nServer and computer name of machine to connect to.\n\n\n\n$username\n\nString\n\nUsername of account on machine. Use null string (\u201cnull\u201d) for local host logins.\n\n\n\n$password\n\nString\n\nPassword for account. Use null string (\u201cnull\u201d) for local host logins, and empty string (\"\") for remote logins with no password (see examples in WMI_Query() help).\n\n\n\n$className\n\nString\n\nWMI class that contains the method.\n\n\n\n$methodName\n\nString\n\nName of method to execute.\n\n\n\n$inParams\n\nObject\n\nList of input parameter names and values given in as a Dictionary<object,object> type. See the Dictionary_Create() method for details.\n\n\n\n$outParams\n\nString\n\nSemicolon-separated list of output parameter names. Only parameters listed will be recorded in the results table. The \u2018ReturnValue\u2019 of the method is automatically returned as the first column, even if this field is blank.\n\n\n\n\n\nReturn variables\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$methodResultsTable\n\nObject\n\nDataTable object containing the results of the method. Each row represents a matching object, and each column is a matching parameter from the $outParams list. The first column will always be \u2018ReturnValue\u2019, the return value of the method itself (0 usually means no errors).\n\n\n\n\n\nExamples:\n\n\n\n\n\n//Opens a new instance of notepad\n\n//use NULL username and password for local connections\n\n$machinePath = \"localhost\";\n\n$username = \"null\";\n\n$password = \"null\";\n\n$class = \"Win32_Process\";\n\n$method = \"Create\";\n\n$inParameters = Dictionary_Create();\n\nDictionary_SetValue($inParameters, \"CommandLine\", \"c:\\\\windows\\\\system32\\\\notepad.exe\");\n\n$outParameters = \"ProcessId\";\n\n$resultsTable = WMI_ClassMethod($machinePath, $username, $password, $class, $method, $inParameters, $outParameters);\n\nDataTable_ShowInWindow($resultsTable);\n\n\n\n\n\nWMI_InstanceMethod\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS WMI_InstanceMethod": {
  "prefix": "WMI_InstanceMethod",
  "body": [
   "$$methodResultsTable=WMI_InstanceMethod($$machinePath,$$username,$$password,$$WQL_query,$$methodName,$$inParams,$$outParams);"
  ],
  "description": "\n\nExecutes the named function on all object instances of a given WMI (Windows Management Instrumentation) class returned by the query. The results of the method are returned in a DataTable object with (# of output parameters) columns and (# of objects) rows.\n\n\n\n\n\nSee Microsoft\u2019s WMI Reference page for a list of classes, methods, parameters, and return value tables.\n\n\n\n\n\nNote:\n\nDCOM must be enabled and WMI installed on both the host and target machines.\n\n\n\n\n\nThe account used must have WMI permissions set. Check \"Computer Management > Services and Applications > WMI Control\" and right-click Properties. Navigate to the Security tab and select Root, then click the Security button to check permissions.\n\n\n\n\n\nFirewalls must be setup to allow RPC (Remote Procedure Call) and remote computer management.\n\n\n\n\n\nRemote connections may require changes to the local security policy on the target machine. Use \"Administrative Tools > Local Security Policy\" or \"Run > secpol.msc\" to access the security settings.\n\n\n\n\n\nFor remote logins, navigate to \"Security Settings > Local Policies > Security Options\" and ensure \"Network access: Sharing and security model for local accounts\" is set to \"Classic - local users authenticate as themselves\".\n\n\n\n\n\nFor remote logins with no password, ensure \"Accounts: Limit local account use of blank passwords to console logon only\" is disabled. For security reasons, Microsoft does NOT recommend disabling this setting - use an account with a password if possible.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$machinePath\n\nString\n\nServer and computer name of machine to connect to.\n\n\n\n$username\n\nString\n\nUsername of account on machine. Use null string (\u201cnull\u201d) for local host logins.\n\n\n\n$password\n\nString\n\nPassword for account. Use null string (\u201cnull\u201d) for local host logins, and empty string (\"\") for remote logins with no password (see examples in WMI_Query() help).\n\n\n\n$WQL_query\n\nString\n\nWQL formatted query string.\n\n\n\n$methodName\n\nString\n\nName of method to execute.\n\n\n\n$inParams\n\nObject\n\nList of input parameter names and values given in as a Dictionary<object,object> type. See the Dictionary_Create() method for details.\n\n\n\n$outParams\n\nString\n\nSemicolon-separated list of output parameter names. Only parameters listed will be recorded in the results table. The \u2018ReturnValue\u2019 of the method is automatically returned as the first column, even if this field is blank.\n\n\n\n\n\nReturn variables\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$methodResultsTable\n\nObject\n\nDataTable object containing the results of the method. Each row represents a matching object, and each column is a matching parameter from the $outParams list. The first column will always be \u2018ReturnValue\u2019, the return value of the method itself (0 usually means no errors).\n\n\n\n\n\nExamples:\n\n\n\n\n\n//Terminates all instances of notepad\n\n//use NULL username and password for local connections\n\n$machinePath = \"localhost\";\n\n$username = \"null\";\n\n$password = \"null\";\n\n$WQL_query = \"SELECT "
 }
,
 "JTS WMI_Query": {
  "prefix": "WMI_Query",
  "body": [
   "$$queryResultsTable=WMI_Query($$machinePath,$$username,$$password,$$WQL_query);"
  ],
  "description": "\n\nExecutes a WMI (Windows Management Instrumentation) query using a given WQL string. The results of the query are returned in a DataTable object with (# of properties) columns and (# of objects) rows.\n\n\n\n\n\nNote:\n\nDCOM must be enabled and WMI installed on both the host and target machines.\n\n\n\nThe account used must have WMI permissions set. Check \"Computer Management > Services and Applications > WMI Control\" and right-click Properties. Navigate to the Security tab and select Root, then click the Security button to check permissions.\n\n\n\nFirewalls must be setup to allow RPC (Remote Procedure Call) and remote computer management.\n\n\n\nRemote connections may require changes to the local security policy on the target machine. Use \"Administrative Tools > Local Security Policy\" or \"Run > secpol.msc\" to access the security settings.\n\n\n\nFor remote logins, navigate to \"Security Settings > Local Policies > Security Options\" and ensure \"Network access: Sharing and security model for local accounts\" is set to \"Classic - local users authenticate as themselves\".\n\n\n\nFor remote logins with no password, ensure \"Accounts: Limit local account use of blank passwords to console logon only\" is disabled. For security reasons, Microsoft does NOT recommend disabling this setting - use an account with a password if possible.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$machinePath\n\nString\n\nServer and computer name of machine to connect to.\n\n\n\n$username\n\nString\n\nUsername of account on machine. Use null string (\u201cnull\u201d) for local host logins.\n\n\n\n$password\n\nString\n\nPassword for account. Use null string (\u201cnull\u201d) for local host logins, and empty string (\"\") for remote logins with no password (see example below).\n\n\n\n$WQL_query\n\nString\n\nWQL formatted query string.\n\n\n\n\n\nReturn variables\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$queryResultsTable\n\nObject\n\nDataTable object containing all data that matches the WQL query. Each row represents a matching object, and each column is a matching property.\n\n\n\n\n\nExamples:\n\n\n\n//get specific information about active network cards on local PC\n\n//use NULL username and password for local connections\n\n$machinePath = \"localhost\";\n\n$username = \"null\";\n\n$password = \"null\";\n\n$WQL_query = \"SELECT Description, IPAddress, MACAddress FROM Win32_NetworkAdapterConfiguration WHERE IPEnabled = true\";\n\n$queryResultsTable = WMI_Query($machinePath, $username, $password, $WQL_query);\n\n\n\n\n\n//show all information about running processes on a remote computer in pop-up window\n\n$machinePath = \"172.128.12.149\";\n\n$username = \"TEST\";\n\n$password = \"test123\";\n\n$WQL_query = \"SELECT "
 }
,
 "JTS WMI_read": {
  "prefix": "WMI_read",
  "body": [
   "($$ResultString)=WMI_read($$QueryString);"
  ],
  "description": "\n\nThis function reads the PC information using the windows WMI interface which can be queried via a language called WQL, very similar in syntax to SQL. This function allows JabilTest to identify most aspects of the computer using a standard interface rather then needing to become an expert interface operation.\n\nExample:\n\n$ResultString = WMI_read(\"Select "
 }
,
 "JTS AG34401A_Init": {
  "prefix": "AG34401A_Init",
  "body": [
   "$$agHandle=AG34401A_Init($$resourceString);"
  ],
  "description": "\n\nThis function initializes communication with the instrument.\n\n\n\n\n\nRemarks:\n\nThis function uses the Agilent IVI instrument drivers for the AG34401A instrument. You also need to load the Agilent COM components.\n\nThis function does not reset the instrument or change any existing settings.\n\nA fail is generated if this function is unable to open the communication channel.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$resourceString\n\nString\n\nVISA resource string identifying the instrument. See VISA Communications in Jabil Test for more information.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$agHandle\n\nObject\n\nHandle to instrument communication channel.\n\n\n\n\n\nExample:\n\n\n\n\n\n// Open communication on GPIB bus.\n\n$resource = \"GPIB0::11::INSTR\";\n\n\n\n$agHandle = AG34401A_Init($resource);\n\n\n\n\n\nAG34401A_InitWithOptions\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG34401A_InitWithOptions": {
  "prefix": "AG34401A_InitWithOptions",
  "body": [
   "$$agHandle=AG34401A_InitWithOptions($$resourceString$$query$$reset$$options);"
  ],
  "description": "\n\nThis function initializes communication with the instrument and, optionally, queries the instrument for its ID, resets the instrument and sets initialization options.\n\n\n\n\n\nRemarks:\n\nThis function uses the Agilent IVI instrument drivers for the AG34401A instrument. You also need to load the Agilent COM components.\n\nA fail is generated if this function is unable to open the communication channel.\n\nRefer to the instrument documentation for more details on initialization parameters.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$resourceString\n\nString\n\nVISA resource string identifying the instrument. See VISA Communications in Jabil Test for more information.\n\n\n\n$query\n\nBoolean\n\n[Optional] Whether to query the instrument ID on initialization.\n\n\n\n$reset\n\nBoolean\n\n[Optional] Whether to reset the instrument on initialization.\n\n\n\n$options\n\nString\n\n[Optional] List of additional parameters to be supplied when initializing the instrument.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$agHandle\n\nObject\n\nHandle to instrument communication channel.\n\n\n\n\n\nExample:\n\n\n\n\n\n// Open communication on GPIB bus with query and reset.\n\n$resource = \"GPIB0::11::INSTR\";\n\n$query = true;\n\n$reset = true;\n\n\n\n$agHandle = AG34401A_InitWithOptions($resource, $query, $reset);\n\n\n\n\n\nAG34401A_MeasureACCurrent\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG34401A_MeasureACCurrent": {
  "prefix": "AG34401A_MeasureACCurrent",
  "body": [
   "$$measurement=AG34401A_MeasureACCurrent($$agHandle,$$timeout,$$range,$$resolution);"
  ],
  "description": "\n\nThis function performs an AC current measurement and returns the result.\n\n\n\n\n\nRemarks:\n\nThis function uses the Agilent IVI instrument drivers for the AG34401A instrument. You also need to load the Agilent COM components.\n\nCommunication must previously have been opened using the AG34401A_Init or AG34401A_InitWithOptions function.\n\nA fail is generated if the instrument is unable to make a measurement or times out.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$agHandle\n\nObject\n\nHandle to previously opened instrument communication channel.\n\n\n\n$timeout\n\nInteger\n\nNumber of milliseconds to wait for a measurement before returning a fail result.\n\n\n\n$range\n\nFloat\n\nThe range for the measurement.\n\n\n\n$resolution\n\nFloat\n\nThe resolution for the measurement.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$measurement\n\nFloat\n\nThe AC current measurement.\n\n\n\n\n\nExample:\n\n\n\n// Open communication.\n\n$resource = \"GPIB0::11::INSTR\";\n\n\n\n$agHandle = AG34401A_Init($resource);\n\n\n\n// Make an AC Current measurement.\n\n$timeout = 1000;\n\n$range = 1;\n\n$resol = 0.0001;\n\n\n\n$measure = AG34401A_MeasureACCurrent($agHandle, $timeout, $range, $resol);\n\n\n\n\n\nAG34401A_MeasureACVolt\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS AG34401A_MeasureACVolt": {
  "prefix": "AG34401A_MeasureACVolt",
  "body": [
   "$$measurement=AG34401A_MeasureACVolt($$agHandle,$$timeout,$$range,$$resolution);"
  ],
  "description": "\n\nThis function performs an AC voltage measurement and returns the result.\n\n\n\n\n\nRemarks:\n\nThis function uses the Agilent IVI instrument drivers for the AG34401A instrument. You also need to load the Agilent COM components.\n\nCommunication must previously have been opened using the AG34401A_Init or AG34401A_InitWithOptions function.\n\nA fail is generated if the instrument is unable to make a measurement or times out.\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$agHandle\n\nObject\n\nHandle to previously opened instrument communication channel.\n\n\n\n$timeout\n\nInteger\n\nNumber of milliseconds to wait for a measurement before returning a fail result.\n\n\n\n$range\n\nFloat\n\nThe range for the measurement.\n\n\n\n$resolution\n\nFloat\n\nThe resolution for the measurement.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$measurement\n\nFloat\n\nThe AC Voltage measurement.\n\n\n\n\n\nExample:\n\n\n\n// Open communication.\n\n$resource = \"GPIB0::11::INSTR\";\n\n\n\n$agHandle = AG34401A_Init($resource);\n\n\n\n// Make an AC Voltage measurement.\n\n$timeout = 1000;\n\n$range = 5;\n\n$resol = 0.001;\n\n\n\n$measure = AG34401A_MeasureACVolt($agHandle, $timeout, $range, $resol);\n\n\n\n\n\nAG34410A_Init\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS MSP_GANG_CreateGangImage": {
  "prefix": "MSP_GANG_CreateGangImage",
  "body": [
   "MSP_GANG_CreateGangImage($$imageName);"
  ],
  "description": "\n\nThis function will convert the loaded code file into an image that can be programmed into the target by the MSP-GANG programmer.\n\n\n\nRemarks\n\nCommunication with the MSP-GANG Programmer must already have been opened using the MSP_GANG_InitComm function.\n\nThe code file must already have been loaded into memory using the MSP_GANG_ReadCodeFile function.\n\n\n\n\n\nFunction arguments\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\n$imageName\n\nString\n\nThe name of the image.\n\n\n\n\n\nReturn parameters\n\n\n\nParameter\n\nVariable Type\n\nDescription\n\n\n\nNone\n\n\n\n\n\nExample:\n\n\n\n\n\n// Open communication on COM3.\n\n$startBaud = 9600;\n\n$port = \"COM4\";\n\n\n\nMSP_GANG_InitComm($port, $startBaud);\n\n\n\n// Load a code file.\n\n$codeFile = \"C:\\\\CodeFiles\\\\MSP_Code_File.hex\";\n\n\n\nMSP_GANG_ReadCodeFile($codeFile);\n\n\n\n// Create an image to be programmed.\n\n$imageName = \"BurnImage\";\n\n\n\nMSP_GANG_CreateGangImage($imageName);\n\n\n\n\n\n<rootNode>\n\n<PCNAME>LapTop</PCNAME>\n\n<PROJECTNAME>T1FirstProject</PROJECTNAME>\n\n<DIVERSITY>T1P1FirstDiversity</DIVERSITY>\n\n<Key1>T1 P1 D1 Not Used</Key1>\n\n<Key2>T1 P1 D1 Also Not Used</Key2>\n\n<Key3>T1 P1 D1 May Be Used</Key3>\n\n<DIVERSITY>T1P1SecondDiversity</DIVERSITY>\n\n<Key1>T1 P1 D2 Second Not Used</Key1>\n\n<Key2>T1 P1 D2 Second Also Not Used</Key2>\n\n<Key3>T1 P1 D2 Second May Be Used</Key3>\n\n<PROJECTNAME>T1SecondProject</PROJECTNAME>\n\n<DIVERSITY>T1P2FirstDiversity</DIVERSITY>\n\n<Key1>T1 P2 D1 Not Used</Key1>\n\n<Key2>T1 P2 D1 Also Not Used</Key2>\n\n<Key3>T1 P2 D1 May Be Used</Key3>\n\n<DIVERSITY>T1P2SecondDiversity</DIVERSITY>\n\n<Key1>T1 P2 D2 Second Not Used</Key1>\n\n<Key2>T1 P2 D2 Second Also Not Used</Key2>\n\n<Key3>T1 P2 D2 Second May Be Used</Key3>\n\n<PCNAME>DeskTop</PCNAME>\n\n<PROJECTNAME>T2FirstProject</PROJECTNAME>\n\n<DIVERSITY>T2P1FirstDiversity</DIVERSITY>\n\n<Key1>T2 P1 D1 Not Used</Key1>\n\n<Key2>T2 P1 D1 Also Not Used</Key2>\n\n<Key3>T2 P1 D1 May Be Used</Key3>\n\n<DIVERSITY>T2P1SecondDiversity</DIVERSITY>\n\n<Key1>T2 P1 D2 Second Not Used</Key1>\n\n<Key2>T2 P1 D2 Second Also Not Used</Key2>\n\n<Key3>T2 P1 D2 Second May Be Used</Key3>\n\n<PROJECTNAME>T2SecondProject</PROJECTNAME>\n\n<DIVERSITY>T2P2FirstDiversity</DIVERSITY>\n\n<Key1>T2 P2 D1 Not Used</Key1>\n\n<Key2>T2 P2 D1 Also Not Used</Key2>\n\n<Key3>T2 P2 D1 May Be Used</Key3>\n\n<DIVERSITY>T2P2SecondDiversity</DIVERSITY>\n\n<Key1>T2 P2 D2 Second Not Used</Key1>\n\n<Key2>T2 P2 D2 Second Also Not Used</Key2>\n\n<Key3>T2 P2 D2 Second May Be Used</Key3>\n\n</rootNode>\n\n\n\n\n\nOpenCV_AdjustGrayContrastWithROI\n\nPrevious Top Next\n\n\n\n"
 }
,
 "JTS OpenCV_AdjustGrayContrastWithROI": {
  "prefix": "OpenCV_AdjustGrayContrastWithROI",
  "body": [
   "$$adjImage=OpenCV_AdjustGrayContrastWithROI($$image,$$steep,$$midCurve,$$left,$$top,$$width,$$height,$$returnItem);"
  ],
  "description": "\n\nThis function adjusts the histogram curve for an area of a gray scale image upwards. This has the effect of brightening dark pixels more than bright pixels. This will give an increase of contrast for the darker pixels while decreasing contrast for the brighter pixels. The function can return the entire image with the adjusted area, or just the adjusted area.The basic function is:\n\n\n\nf(n) = x + mc "
 }
}